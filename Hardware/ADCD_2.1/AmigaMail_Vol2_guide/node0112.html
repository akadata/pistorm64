<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/34.11 FILE="VIII-31/Amnet.txt" NODE="VIII-31-3" TITLE="Listening for Network and Amiga Events" -->
<head>
<title>Listening for Network and Amiga Events</title>
</head>
<body>
<img src="../images/toc_d.gif" alt="[Contents]">
<img src="../images/index_d.gif" alt="[Index]">
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../AmigaMail_Vol2_guide/node0111.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../AmigaMail_Vol2_guide/node0113.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
Once back in the main() routine, the application is almost ready to
start processing network events.  The only thing remaining is to decide
what kind of events the server needs to hear about.  Most applications
will need to be aware of both network and local Amiga events, which
means separate masks need to be set up for both types of events.  On
the network side, the mask needs to contain information on which
sockets need responses.

    /* First, prepare the various masks for signal processing */
    fd_set sockmask;

    FD_ZERO( &#038;sockmask );
    FD_SET( socket, &#038;sockmask );

The sockmask variable will be used as a template to indicate what
network events the application notices.  Since sockmask came off the
stack and contains garbage, the FD_ZERO() call clears all its network
signal bits.  The FD_SET() call sets the mask to listen for events
relating to the socket that the server created earlier.  Everything is
prepared, so the next step is entering the event loop itself.


    long umask;
    fd_set mask;

    while(1)
    {
        /*
        ** Reset the mask values for another pass
        */

        mask = sockmask;
        umask = SIGBREAKF_CTRL_C;

        /*
        ** selectwait is a combo network and Amiga Wait() rolled into
        ** a single call.  It allows the app to respond to both Amiga
        ** signals (CTRL-C in this case) and to network events.
        **
        ** Here, if the selectwait event is the SIGBREAK signal, we
        ** bail and AppPanic() but otherwise its a network event.
        */

        if (selectwait( 2, &#038;mask, NULL, NULL, NULL, &#038;umask ) == -1 )
        {
            AppPanic(&#034;CTRL-C:\nProgram terminating!&#034;,0);
        }


Before an event occurs, the mask variable tells selectwait() which
network events the server wants to receive.  After an event occurs, the
mask variable indicates which socket triggered the network event.  The
sockmask variable is used to reset mask back to its original mask value
at the top of each pass through the event loop.

In addition to waiting on network events, selectwait() also waits on
Exec signals for the current task.  For this example, the only Amiga
event the server cares about is a Ctrl-C break (SIGBREAKF_CTRL_C).  The
selectwait() function has a simple purpose, but due to the wide scope
of network events, the function has a myriad of parameters and
configurations. This example uses the bare minimum of what's possible
using selectwait(), and many network-friendly applications will be able
to get by using only a small subset of selectwait()'s potential.  In
this case, the network event set is passed in mask, and the Amiga event
mask is passed in umask.

If selectwait() returns with a value of -1, it means the Amiga event
mask was the trigger.  Otherwise, a network event caused the function
to return.  This example is simple enough that a Ctrl-C interrupt can
be handled rather easily.
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
