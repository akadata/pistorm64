<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/34.11 FILE="II-77/ASyncIO.c" NODE="MAIN" TITLE="II-77/ASyncIO.c" -->
<head>
<title>II-77/ASyncIO.c</title>
</head>
<body>
<img src="../images/toc_d.gif" alt="[Contents]">
<img src="../images/index_d.gif" alt="[Index]">
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../AmigaMail_Vol2_guide/node017C.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../AmigaMail_Vol2_guide/node017E.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
;/* ASyncIO.c - Execute me to compile with SAS/C 6.56
sc NMINC STRMERGE NOSTKCHK IGNORE=73 asyncio.c
quit
*/

/*
(c)  Copyright 1992-1999 Amiga, Inc.   All rights reserved.
The information contained herein is subject to change without notice,
and is provided &#034;as is&#034; without warranty of any kind, either expressed
or implied.  The entire risk as to the use of this information is
assumed by the user.
*/

#include &#060;exec/types.h&#062;
#include &#060;exec/exec.h&#062;
#include &#060;dos/dos.h&#062;
#include &#060;dos/dosextens.h&#062;
#include &#060;stdio.h&#062;

#include &#060;clib/exec_protos.h&#062;
#include &#060;clib/dos_protos.h&#062;

#include &#034;asyncio.h&#034;

/*****************************************************************************/

static VOID SendAsync(struct AsyncFile *file, APTR arg2)
{
    /* send out an async packet to the file system. */

    file-&#062;af_Packet.sp_Pkt.dp_Port = &#038;file-&#062;af_PacketPort;
    file-&#062;af_Packet.sp_Pkt.dp_Arg2 = (LONG)arg2;
    PutMsg(file-&#062;af_Handler, &#038;file-&#062;af_Packet.sp_Msg);
    file-&#062;af_PacketPending = TRUE;
}

/*****************************************************************************/


static VOID WaitPacket(struct AsyncFile *file)
{
    /* This enables signalling when a packet comes back to the port */
    file-&#062;af_PacketPort.mp_Flags = PA_SIGNAL;

    /* Wait for the packet to come back, and remove it from the message
     * list. Since we know no other packets can come in to the port, we can
     * safely use Remove() instead of GetMsg(). If other packets could come in,
     * we would have to use GetMsg(), which correctly arbitrates access in such
     * a case
     */
    Remove((struct Node *)WaitPort(&#038;file-&#062;af_PacketPort));

    /* set the port type back to PA_IGNORE so we won't be bothered with
     * spurious signals
     */
    file-&#062;af_PacketPort.mp_Flags = PA_IGNORE;

    /* packet is no longer pending, we got it */
    file-&#062;af_PacketPending = FALSE;
}

/*****************************************************************************/

struct AsyncFile *OpenAsync(STRPTR fileName, UBYTE mode, LONG bufferSize)
{
struct AsyncFile  *file;
struct FileHandle *fh;

    /* The buffer size is rounded to a multiple of 32 bytes. This will make
     * DMA as fast as can be
     */

    bufferSize = (bufferSize + 31) &#038; 0xffffffe0;

    /* now allocate the ASyncFile structure, as well as the read buffer. Add
     * 15 bytes to the total size in order to allow for later quad-longword
     * alignement of the buffers
     */

    if (file = AllocVec(sizeof(struct AsyncFile) + bufferSize + 15,
                        MEMF_ANY|MEMF_CLEAR))
    {
        if (mode == MODE_READ)
        {
            file-&#062;af_File     = Open(fileName,MODE_OLDFILE);
            file-&#062;af_ReadMode = TRUE;
        }
        else if (mode == MODE_WRITE)
        {
            file-&#062;af_File = Open(fileName,MODE_NEWFILE);
        }
        else if (mode == MODE_APPEND)
        {
            /* in append mode, we open for writing, and then seek to the
             * end of the file. That way, the initial write will happen at
             * the end of the file, thus extending it
             */

            if (file-&#062;af_File = Open(fileName,MODE_READWRITE))
            {
                if (Seek(file-&#062;af_File,0,OFFSET_END) &#060; 0)
                {
                    Close(file-&#062;af_File);
                    file-&#062;af_File = NULL;
                }
            }
        }

        if (!file-&#062;af_File)
        {
            /* file didn't open, free stuff and leave */
            FreeVec(file);
            return(NULL);
        }

        /* initialize the ASyncFile structure. We do as much as we can here,
         * in order to avoid doing it in more critical sections
         *
         * Note how the two buffers used are quad-longword aligned. This helps
         * performance on 68040 systems with copyback cache. Aligning the data
         * avoids a nasty side-effect of the 040 caches on DMA. Not aligning
         * the data causes the device driver to have to do some magic to avoid
         * the cache problem. This magic will generally involve flushing the
         * CPU caches. This is very costly on an 040. Aligning things avoids
         * the need for magic, at the cost of at most 15 bytes of ram.
         */

        fh                  = BADDR(file-&#062;af_File);
        file-&#062;af_Handler    = fh-&#062;fh_Type;
        file-&#062;af_BufferSize = bufferSize / 2;
        file-&#062;af_Buffers[0] =
                (APTR)(((ULONG)file + sizeof(struct AsyncFile) + 15) &#038; 0xfffffff0);
        file-&#062;af_Buffers[1] =
                (APTR)((ULONG)file-&#062;af_Buffers[0] + file-&#062;af_BufferSize);
        file-&#062;af_Offset     = file-&#062;af_Buffers[0];

        /* this is the port used to get the packets we send out back.
         * It is initialized to PA_IGNORE, which means that no signal is
         * generated when a message comes in to the port. The signal bit number
         * is initialized to SIGB_SINGLE, which is the special bit that can
         * be used for one-shot signalling. The signal will never be set,
         * since the port is of type PA_IGNORE. We'll change the type of the
         * port later on to PA_SIGNAL whenever we need to wait for a message
         * to come in.
         *
         * The trick used here avoids the need to allocate an extra signal bit
         * for the port. It is quite efficient.
         */

        file-&#062;af_PacketPort.mp_MsgList.lh_Head     =
                (struct Node *)&#038;file-&#062;af_PacketPort.mp_MsgList.lh_Tail;
        file-&#062;af_PacketPort.mp_MsgList.lh_TailPred =
                (struct Node *)&#038;file-&#062;af_PacketPort.mp_MsgList.lh_Head;
        file-&#062;af_PacketPort.mp_Node.ln_Type        = NT_MSGPORT;
        file-&#062;af_PacketPort.mp_Flags               = PA_IGNORE;
        file-&#062;af_PacketPort.mp_SigBit              = SIGB_SINGLE;
        file-&#062;af_PacketPort.mp_SigTask             = FindTask(NULL);

        file-&#062;af_Packet.sp_Pkt.dp_Link          = &#038;file-&#062;af_Packet.sp_Msg;
        file-&#062;af_Packet.sp_Pkt.dp_Arg1          = fh-&#062;fh_Arg1;
        file-&#062;af_Packet.sp_Pkt.dp_Arg3          = file-&#062;af_BufferSize;
        file-&#062;af_Packet.sp_Msg.mn_Node.ln_Name  = (STRPTR)&#038;file-&#062;af_Packet.sp_Pkt;
        file-&#062;af_Packet.sp_Msg.mn_Node.ln_Type  = NT_MESSAGE;
        file-&#062;af_Packet.sp_Msg.mn_Length        = sizeof(struct StandardPacket);

        if (mode == MODE_READ)
        {
            /* if we are in read mode, send out the first read packet to the
             * file system. While the application is getting ready to read
             * data, the file system will happily fill in this buffer with
             * DMA transfer, so that by the time the application needs the data,
             * it will be in the buffer waiting
             */

            file-&#062;af_Packet.sp_Pkt.dp_Type = ACTION_READ;
            if (file-&#062;af_Handler)
                SendAsync(file,file-&#062;af_Buffers[0]);
        }
        else
        {
            file-&#062;af_Packet.sp_Pkt.dp_Type = ACTION_WRITE;
            file-&#062;af_BytesLeft             = file-&#062;af_BufferSize;
        }
    }

    return(file);
}

/*****************************************************************************/

LONG CloseAsync(struct AsyncFile *file)
{
LONG result;
LONG result2;

    result = 0;
    if (file)
    {
        if (file-&#062;af_PacketPending)
            WaitPacket(file);

        result  = file-&#062;af_Packet.sp_Pkt.dp_Res1;
        result2 = file-&#062;af_Packet.sp_Pkt.dp_Res2;
        if (result &#062;= 0)
        {
            if (!file-&#062;af_ReadMode)
            {
                /* this will flush out any pending data in the write buffer */
                result  = Write(file-&#062;af_File,
                          file-&#062;af_Buffers[file-&#062;af_CurrentBuf],
                          file-&#062;af_BufferSize - file-&#062;af_BytesLeft);
                result2 = IoErr();
            }
        }

        Close(file-&#062;af_File);
        FreeVec(file);

        SetIoErr(result2);
    }

    return(result);
}

/*****************************************************************************/

LONG ReadAsync(struct AsyncFile *file, APTR buf, LONG numBytes)
{
LONG totalBytes;
LONG bytesArrived;

    totalBytes = 0;

    /* if we need more bytes than there are in the current buffer, enter the
     * read loop
     */

    while (numBytes &#062; file-&#062;af_BytesLeft)
    {
        /* this takes care of NIL: */
        if (!file-&#062;af_Handler)
            return(0);

        WaitPacket(file);

        bytesArrived = file-&#062;af_Packet.sp_Pkt.dp_Res1;
        if (bytesArrived &#060;= 0)
        {
            /* error, get out of here */
            SetIoErr(file-&#062;af_Packet.sp_Pkt.dp_Res2);
            return(-1);
        }

        /* enable this section of code if you want special processing for
         * reads bigger than the buffer size
         */
#ifdef OPTIMIZE_BIG_READS
        if (numBytes &#062; file-&#062;af_BytesLeft + bytesArrived + file-&#062;af_BufferSize)
        {
            if (file-&#062;af_BytesLeft)
            {
                CopyMem(file-&#062;af_Offset,buf,file-&#062;af_BytesLeft);

                numBytes   -= file-&#062;af_BytesLeft;
                buf         = (APTR)((ULONG)buf + file-&#062;af_BytesLeft);
                totalBytes += file-&#062;af_BytesLeft;
                file-&#062;af_BytesLeft = 0;
            }

            if (bytesArrived)
            {
                CopyMem(file-&#062;af_Buffers[file-&#062;af_CurrentBuf],buf,bytesArrived);

                numBytes   -= bytesArrived;
                buf         = (APTR)((ULONG)buf + bytesArrived);
                totalBytes += bytesArrived;
            }

            bytesArrived = Read(file-&#062;af_File,buf,numBytes);

            if (bytesArrived &#060;= 0)
                return(-1);

            SendAsync(file,file-&#062;af_Buffers[0]);
            file-&#062;af_CurrentBuf = 0;
            file-&#062;af_BytesLeft  = 0;

            return(totalBytes + bytesArrived);
        }
#endif

        if (file-&#062;af_BytesLeft)
        {
            CopyMem(file-&#062;af_Offset,buf,file-&#062;af_BytesLeft);

            numBytes   -= file-&#062;af_BytesLeft;
            buf         = (APTR)((ULONG)buf + file-&#062;af_BytesLeft);
            totalBytes += file-&#062;af_BytesLeft;
        }

        /* ask that the buffer be filled */
        SendAsync(file,file-&#062;af_Buffers[1-file-&#062;af_CurrentBuf]);

        file-&#062;af_Offset     = file-&#062;af_Buffers[file-&#062;af_CurrentBuf];
        file-&#062;af_CurrentBuf = 1 - file-&#062;af_CurrentBuf;
        file-&#062;af_BytesLeft  = bytesArrived;
    }

    if (numBytes)
    {
        CopyMem(file-&#062;af_Offset,buf,numBytes);
        file-&#062;af_BytesLeft -= numBytes;
        file-&#062;af_Offset     = (APTR)((ULONG)file-&#062;af_Offset + numBytes);
    }

    return (totalBytes + numBytes);
}

/*****************************************************************************/

LONG ReadCharAsync(struct AsyncFile *file)
{
char ch;

    if (file-&#062;af_BytesLeft)
    {
        /* if there is at least a byte left in the current buffer, get it
         * directly. Also update all counters
         */

        ch = *(char *)file-&#062;af_Offset;
        file-&#062;af_BytesLeft--;
        file-&#062;af_Offset = (APTR)((ULONG)file-&#062;af_Offset + 1);

        return((LONG)ch);
    }

    /* there were no characters in the current buffer, so call the main read
     * routine. This has the effect of sending a request to the file system to
     * have the current buffer refilled. After that request is done, the
     * character is extracted for the alternate buffer, which at that point
     * becomes the &#034;current&#034; buffer
     */

    if (ReadAsync(file,&#038;ch,1) &#062; 0)
        return((LONG)ch);

    /* We couldn't read above, so fail */

    return(-1);
}

/*****************************************************************************/

LONG WriteAsync(struct AsyncFile *file, APTR buf, LONG numBytes)
{
LONG totalBytes;

    totalBytes = 0;

    while (numBytes &#062; file-&#062;af_BytesLeft)
    {
        /* this takes care of NIL: */
        if (!file-&#062;af_Handler)
        {
            file-&#062;af_Offset    = file-&#062;af_Buffers[file-&#062;af_CurrentBuf];
            file-&#062;af_BytesLeft = file-&#062;af_BufferSize;
            return(numBytes + totalBytes);
        }

        if (file-&#062;af_BytesLeft)
        {
            CopyMem(buf,file-&#062;af_Offset,numBytes);

            numBytes   -= file-&#062;af_BytesLeft;
            buf         = (APTR)((ULONG)buf + file-&#062;af_BytesLeft);
            totalBytes += file-&#062;af_BytesLeft;
        }

        if (file-&#062;af_PacketPending)
        {
            WaitPacket(file);

            if (file-&#062;af_Packet.sp_Pkt.dp_Res1 &#060;= 0)
            {
                /* an error occurred, leave */
                SetIoErr(file-&#062;af_Packet.sp_Pkt.dp_Res2);
                return(-1);
            }
        }

        /* send the current buffer out to disk */
        SendAsync(file,file-&#062;af_Buffers[file-&#062;af_CurrentBuf]);

        file-&#062;af_CurrentBuf   = 1 - file-&#062;af_CurrentBuf;
        file-&#062;af_Offset       = file-&#062;af_Buffers[file-&#062;af_CurrentBuf];
        file-&#062;af_BytesLeft    = file-&#062;af_BufferSize;
    }

    if (numBytes)
    {
        CopyMem(buf,file-&#062;af_Offset,numBytes);
        file-&#062;af_BytesLeft -= numBytes;
        file-&#062;af_Offset     = (APTR)((ULONG)file-&#062;af_Offset + numBytes);
    }

    return (totalBytes + numBytes);
}

/*****************************************************************************/

LONG WriteCharAsync(struct AsyncFile *file, char ch)
{
    if (file-&#062;af_BytesLeft)
    {
        /* if there's any room left in the current buffer, directly write
         * the byte into it, updating counters and stuff.
         */

        *(char *)file-&#062;af_Offset = ch;
        file-&#062;af_BytesLeft--;
        file-&#062;af_Offset = (APTR)((ULONG)file-&#062;af_Offset + 1);

        /* one byte written */
        return(1);
    }

    /* there was no room in the current buffer, so call the main write
     * routine. This will effectively send the current buffer out to disk,
     * wait for the other buffer to come back, and then put the byte into
     * it.
     */

    return(WriteAsync(file,&#038;ch,1));
}
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
