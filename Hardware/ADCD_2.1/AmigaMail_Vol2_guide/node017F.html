<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/34.11 FILE="II-87/LockRecord.c" NODE="MAIN" TITLE="II-87/LockRecord.c" -->
<head>
<title>II-87/LockRecord.c</title>
</head>
<body>
<img src="../images/toc_d.gif" alt="[Contents]">
<img src="../images/index_d.gif" alt="[Index]">
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../AmigaMail_Vol2_guide/node017E.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../AmigaMail_Vol2_guide/node0180.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
; /* LockRecord.c - Execute me to compile me with SAS/C 6.56
sc NMINC STRMERGE NOSTKCHK NODEBUG DATA=FAR IGNORE=73 LockRecord.c
slink FROM LockRecord.o to LockRecord LIB lib:amiga.lib
quit
*
* AmigaMail LockRecord()/UnLockRecord() example.
*/

/*
(c)  Copyright 1992-1999 Amiga, Inc.   All rights reserved.
The information contained herein is subject to change without notice,
and is provided &#034;as is&#034; without warranty of any kind, either expressed
or implied.  The entire risk as to the use of this information is
assumed by the user.
*/

#include &#060;exec/memory.h&#062;
#include &#060;exec/lists.h&#062;
#include &#060;dos/dosextens.h&#062;
#include &#060;dos/rdargs.h&#062;
#include &#060;dos/record.h&#062;
#include &#060;utility/tagitem.h&#062;

#include &#060;clib/alib_protos.h&#062;
#include &#060;clib/dos_protos.h&#062;
#include &#060;clib/exec_protos.h&#062;
#include &#060;clib/utility_protos.h&#062;

void GetCommandLine(BPTR, struct RDArgs *rdargs, UBYTE *cmdbuffer);
void DoLockRecord(BPTR, struct RDArgs *rdargs);
void DoUnLockRecord(BPTR fh, struct RDArgs *rdargs);
void ListRecordLocks(void);
struct LockNode *FindRecordLock(ULONG offset, ULONG length);

/* List and node structures to keep track of record locks */
struct LockNode {
    struct LockNode *ln_Succ;
    struct LockNode *ln_Pred;
    ULONG ln_Counter;
    ULONG ln_Offset;
    ULONG ln_Length;
    ULONG ln_Mode;
};

struct LockList {
    struct LockNode *lh_Head;
    struct LockNode *lh_Tail;
    struct LockNode *lh_TailPred;
    ULONG lh_Counter;
};

/* Pseudo data file */
#define TESTFILE &#034;t:locktest&#034;

#define LOCK_TEMPLATE &#034;OFFSET/K/N,LENGTH/K/N,EXCLUSIVE/S,IMMEDIATE/S,TIMEOUT/K/N&#034;
#define UNLOCK_TEMPLATE &#034;OFFSET/K/N,LENGTH/K/N&#034;

#define OFFSET_POS      0
#define LENGTH_POS      1
#define EXCLUSIVE_POS   2
#define IMMEDIATE_POS   3
#define TIMEOUT_POS     4

struct Library *SysBase;
struct DosLibrary *DOSBase;
struct Library *UtilityBase;

struct LockList *locklist;

LONG main(void)
{
    BPTR fh;
    struct RDArgs *rdargs;
    struct CSource *csource;
    UBYTE *cmdbuffer;
    struct LockNode *lnode, *nnode;
    LONG error = RETURN_OK;

    SysBase = (*((struct Library **) 4));

    /* Fails silently if &#060; 37 */
    if (DOSBase = (struct DosLibrary *)OpenLibrary(&#034;dos.library&#034;, 37))
    {
        UtilityBase = DOSBase-&#062;dl_UtilityBase;

        if (locklist = AllocMem(sizeof(struct LockList), MEMF_CLEAR))
        {
            NewList((struct List *)locklist);

            /* Allocate RDArgs structure to parse command lines */
            if (rdargs = AllocDosObject(DOS_RDARGS, TAG_END))
            {
                csource = &#038;rdargs-&#062;RDA_Source;

                /* Get buffer to read command lines in */
                if (csource-&#062;CS_Buffer = AllocMem(512, MEMF_CLEAR))
                {
                    csource-&#062;CS_Length = 512;
                    csource-&#062;CS_CurChr = 0;

                    /* Buffer to isolate command keyword */
                    if (cmdbuffer = AllocMem(80, MEMF_CLEAR))
                    {

                        /* Open a testfile, create it if necessary */
                        if (fh = Open(TESTFILE, MODE_READWRITE))
                        {

                            /* Process command lines */
                            GetCommandLine(fh, rdargs, cmdbuffer);

                            /* Try to get rid of outstanding record locks */
                            lnode = locklist-&#062;lh_Head;
                            while (nnode = lnode-&#062;ln_Succ)
                            {

                                /* Try to unlock pending locks */
                                if ((UnLockRecord(fh,
                                                  lnode-&#062;ln_Offset,
                                                  lnode-&#062;ln_Length)) == DOSFALSE)
                                {
                   Printf(&#034;Error unlocking record %ld with offset %ld length %ld\n&#034;,
                                        lnode-&#062;ln_Counter,
                                        lnode-&#062;ln_Offset,
                                        lnode-&#062;ln_Length);
                                    if (IoErr())
                                        PrintFault(IoErr(), NULL);
                                }
                                /* Remove node no matter what */
                                FreeMem(lnode, sizeof(struct LockNode));
                                lnode = nnode;
                            };

                            Close(fh);
                        }
                        FreeMem(cmdbuffer, 80);
                    } else
                        SetIoErr(ERROR_NO_FREE_STORE);

                    FreeMem(csource-&#062;CS_Buffer, 512);
                } else
                    SetIoErr(ERROR_NO_FREE_STORE);

                FreeDosObject(DOS_RDARGS, rdargs);
            } else
                SetIoErr(ERROR_NO_FREE_STORE);

            FreeMem(locklist, sizeof(struct LockList));
        } else
            SetIoErr(ERROR_NO_FREE_STORE);


        error = IoErr();
        if (error)
        {
            PrintFault(IoErr(), NULL);
            error = RETURN_FAIL;
        }

        CloseLibrary((struct Library *)DOSBase);
    }
    return(error);
}
void GetCommandLine(BPTR fh, struct RDArgs *rdargs, UBYTE *cmdbuffer)
{
    struct CSource *csource = &#038;rdargs-&#062;RDA_Source;
    UBYTE *cmdlinebuffer = csource-&#062;CS_Buffer;
    LONG error;

    /* Prompt for command line */
    Write(Output(), &#034;Cmd&#062; &#034;, 5);

    /* Loop forever, waiting for commands */
    for (;;)
    {
        /* Get command line */
        if ((FGets(Input(), cmdlinebuffer, 512)) != NULL)
        {

            /* Use ReadItem() to isolate actual command */
            error = ReadItem(cmdbuffer, 80, csource);

            /* Break on error */
            if (error == ITEM_ERROR)
                break;

            /* Make sure I've got something */
            else if (error != ITEM_NOTHING)
            {
                /* cmdbuffer now contains the command:
                 *
                 * KNOWN COMMANDS:
                 * QUIT
                 * LIST
                 * LOCKRECORD
                 * UNLOCKRECORD
                 */

                if ((Stricmp(&#034;QUIT&#034;, cmdbuffer)) == 0)
                    break;
                else if ((Stricmp(&#034;HELP&#034;, cmdbuffer)) == 0)
                {
                    Printf(&#034;Available commands:\n&#034;);
                    Printf(&#034;LOCKRECORD %s\n&#034;, LOCK_TEMPLATE);
                    Printf(&#034;UNLOCKRECORD %s\n&#034;, UNLOCK_TEMPLATE);
                    Printf(&#034;LIST\n&#034;);
                    Printf(&#034;QUIT\n&#034;);
                }
                else if ((Stricmp(&#034;LIST&#034;, cmdbuffer)) == 0)
                    ListRecordLocks();  /* Show all current locks */
                else
                {

                    /* Note that I've already isolated the command
                     * keyword, so I'm using Source-&#062;CS_CurChr to point
                     * after it.
                     */
                    csource-&#062;CS_Buffer += csource-&#062;CS_CurChr;
                    csource-&#062;CS_CurChr = 0;

                    if ((Stricmp(&#034;LOCKRECORD&#034;, cmdbuffer)) == 0)
                        DoLockRecord(fh, rdargs);
                    else if ((Stricmp(&#034;UNLOCKRECORD&#034;, cmdbuffer)) == 0)
                        DoUnLockRecord(fh, rdargs);
                    else
                        PrintFault(ERROR_NOT_IMPLEMENTED, cmdbuffer);

                    /* Reset CSource */
                    csource-&#062;CS_Buffer = cmdlinebuffer;
                }

                /* Output new prompt. Make sure csource is OK. */
                Write(Output(), &#034;Cmd&#062; &#034;, 5);
                csource-&#062;CS_CurChr = 0;
            }
        } else
            break;
    }
}

void DoLockRecord(BPTR fh, struct RDArgs *rdargs)
{
    struct RDArgs *readargs;
    LONG rargs[5];
    ULONG offset, length, timeout, mode;
    ULONG result;
    struct LockNode *lnode;

    offset = length = timeout = mode = 0;
    rargs[0] = rargs[1] = rargs[2] = rargs[3] = rargs[4] = 0;

    if (readargs = ReadArgs(LOCK_TEMPLATE, rargs, rdargs))
    {

        if (rargs[OFFSET_POS])
            offset = *((LONG *)rargs[OFFSET_POS]);
        if (rargs[LENGTH_POS])
            length = *((LONG *)rargs[LENGTH_POS]);
        if (rargs[TIMEOUT_POS])
            timeout = *((LONG *)rargs[TIMEOUT_POS]);

        /* Type of locking */
        if (rargs[EXCLUSIVE_POS])
        {
            if (rargs[IMMEDIATE_POS])
                mode = REC_EXCLUSIVE_IMMED;
            else
                mode = REC_EXCLUSIVE;
        }
        else
        {
            if (rargs[IMMEDIATE_POS])
                mode = REC_SHARED_IMMED;
            else
                mode = REC_SHARED;
        }

        rargs[0] = offset;
        rargs[1] = length;
        switch (mode)
        {
            case REC_EXCLUSIVE_IMMED:
                rargs[2] = (LONG)&#034;REC_EXCLUSIVE_IMMED&#034;;
                break;
            case REC_EXCLUSIVE:
                rargs[2] = (LONG)&#034;REC_EXCLUSIVE&#034;;
                break;
            case REC_SHARED_IMMED:
                rargs[2] = (LONG)&#034;REC_SHARED_IMMED&#034;;
                break;
            case REC_SHARED:
                rargs[2] = (LONG)&#034;REC_SHARED&#034;;
                break;
        }
        rargs[3] = timeout;


        /* Show what I'm going to do */
        VFPrintf(Output(),
            &#034;LockRecord: Offset %ld, Length %ld, Mode %s, Timeout %ld...&#034;,
            rargs);
        Flush(Output());

        /* Lock the record. Parameters are not checked. It is f.e. possible to
         * specify an offset larger than the size of the file. Possible since
         * Record Locks are not related to the file itself, only the means for
         * you to do arbitration.
         *
         * Note that the timeout value is in ticks...
         */
        result = LockRecord(fh, offset, length, mode, timeout);

        if (result == DOSTRUE)
        {
            Write(Output(), &#034;OK\n&#034;, 3);

            /* Add a node to track this record lock */
            if (lnode = AllocMem(sizeof(struct LockNode), MEMF_CLEAR))
            {
                lnode-&#062;ln_Counter = locklist-&#062;lh_Counter++;
                lnode-&#062;ln_Offset = offset;
                lnode-&#062;ln_Length = length;
                lnode-&#062;ln_Mode = mode;

                AddTail((struct List *)locklist, (struct Node *)lnode);
            }
            else
            {
                /* Not enough memory for node. You're on your own... */
                Write(Output(), &#034;Not enough memory to track record lock.\n&#034;, 40);
            }
        }
        else
        {
            Write(Output(), &#034;FAILED\n&#034;, 7);
            if (IoErr())
                PrintFault(IoErr(), NULL);
        }

        /* Release memory associated with readargs */
        FreeArgs(readargs);
    } else
        PrintFault(IoErr(), NULL);
}

void DoUnLockRecord(BPTR fh, struct RDArgs *rdargs)
{
    struct RDArgs *readargs;
    LONG rargs[2];
    ULONG offset, length;
    ULONG result;
    struct LockNode *lnode;

    offset = length = 0;
    rargs[0] = rargs[1] = 0;

    if (readargs = ReadArgs(LOCK_TEMPLATE, rargs, rdargs))
    {

        if (rargs[OFFSET_POS])
            offset = *((LONG *)rargs[OFFSET_POS]);
        if (rargs[LENGTH_POS])
            length = *((LONG *)rargs[LENGTH_POS]);

        rargs[0] = offset;
        rargs[1] = length;

        /* Show what I'm going to do */
        VFPrintf(Output(), &#034;UnLockRecord: Offset %ld, Length %ld...&#034;, rargs);
        Flush(Output());

        /* Unlock indicated record with indicated offset and length.
         * If the same record (same offset/length) is locked multiple times,
         * only one, the first one in the list , will be unlocked.
         */
        result = UnLockRecord(fh, offset, length);

        if (result == DOSTRUE) {
            Write(Output(), &#034;OK\n&#034;, 3);

            /* Remove node associated with this lock */
            if (lnode = FindRecordLock(offset, length))
            {
                Remove((struct Node *)lnode);
                FreeMem(lnode, sizeof(struct LockNode));
            }
        }
        else
        {
            Write(Output(), &#034;FAILED\n&#034;, 7); /* Keep locknode */
            if (IoErr())
                PrintFault(IoErr(), NULL);
        }
        /* Release memory associated with readargs */
        FreeArgs(readargs);
    } else
        PrintFault(IoErr(), NULL);
}

void ListRecordLocks(void)
{
    struct LockNode *lnode;
    LONG rargs[4];

    for (lnode = locklist-&#062;lh_Head; lnode-&#062;ln_Succ; lnode = lnode-&#062;ln_Succ)
    {
        rargs[0] = lnode-&#062;ln_Counter;
        rargs[1] = lnode-&#062;ln_Offset;
        rargs[2] = lnode-&#062;ln_Length;

        switch (lnode-&#062;ln_Mode)
        {
            case REC_EXCLUSIVE_IMMED:
                rargs[3] = (LONG)&#034;REC_EXCLUSIVE_IMMED&#034;;
                break;
            case REC_EXCLUSIVE:
                rargs[3] = (LONG)&#034;REC_EXCLUSIVE&#034;;
                break;
            case REC_SHARED_IMMED:
                rargs[3] = (LONG)&#034;REC_SHARED_IMMED&#034;;
                break;
            case REC_SHARED:
                rargs[3] = (LONG)&#034;REC_SHARED&#034;;
                break;
        }

        VFPrintf(Output(), &#034;RecordLock #%ld: Offset %ld Length %ld Mode %s\n&#034;, rargs);
    }
    Flush(Output());
}

struct LockNode *FindRecordLock(ULONG offset, ULONG length)
{
    struct LockNode *lnode;

    for (lnode = locklist-&#062;lh_Head; lnode-&#062;ln_Succ; lnode = lnode-&#062;ln_Succ)
    {
        if ((lnode-&#062;ln_Offset == offset) &#038;&#038; lnode-&#062;ln_Length == length)
            return(lnode);
    }
    return(NULL);
}
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
