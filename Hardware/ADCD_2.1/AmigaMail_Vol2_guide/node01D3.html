<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/34.11 FILE="VI-1/interplay.c" NODE="MAIN" TITLE="VI-1/interplay.c" -->
<head>
<title>VI-1/interplay.c</title>
</head>
<body>
<img src="../images/toc_d.gif" alt="[Contents]">
<img src="../images/index_d.gif" alt="[Index]">
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../AmigaMail_Vol2_guide/node01D2.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../AmigaMail_Vol2_guide/node01D4.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
;/* interplay.c -- execute me to compile me
sc DATA=NEAR NMINC STRMERGE NOSTKCHK IGNORE=73 interplay.c
slink FROM LIB:c.o + interplay.o TO interplay LIBRARY lib:sc.lib+lib:amiga.lib
quit
*/


/* (c)  Copyright 1993-1999 Amiga, Inc.   All rights reserved. */
/* The information contained herein is subject to change without    */
/* notice, and is provided &#034;as is&#034; without warranty of any kind,    */
/* either expressed or implied.  The entire risk as to the use of   */
/* this information is assumed by the user.                         */


/* Interlay.c - Run from Shell (CLI) only.  Given two file names of IFF
** 8SVX 8-bit sampled audio data, plays the data from both files using just
** one channel.  This demonstrates how virtual audio channels can be
** implemented.
**
** The program supports two different methods for virtual voices.  Method 1
** (the default method) interleaves bytes from each file so that the data words
** fed into the Amiga's audio hardware contain one byte each from the given
** files.  The samples are then played back at twice their normal speed.  Since
** each sample only gets half of the playback bandwidth, the speed sounds
** correct.  To the listener, it sounds as if both samples are playing
** simultaneously even though only one channel is used.
**
** Normally the maximum playback rate with the Amiga's audio hardware is about
** 28K bytes/sec.  Since interleaving requires doubling the nominal sampling
** rate, it will only work with audio data created at a sampling rate of 14K
** bytes/sec or less.
**
** Method 2, takes one byte from each file, sums them and divides by two.
** The resulting byte value is sent to the Amiga's audio hardware.  No speed
** increase is required for this technique, however some noise  is introduced
** by the averaging of the byte values.  To use method 2, inlcude the SUM
** keyword as the last argument typed on the command line.  Examples:
**
**    interplay talk.8svx music.8svx SUM  (Uses method 2, averaging)
**    interplay talk.8svx music.8svx      (Uses method 1, interleaving)
**    interplay talk.8svx                 (Normal single file 8SVX playback)
**
** For an example of conventional IFF 8SVX audio see the &#034;Amiga ROM Kernel
** Reference Manual: Devices&#034;, 3rd edition (ISBN 0-201-56775-X), page 28 and
** page 515.
*/


#include &#060;exec/types.h&#062;
#include &#060;exec/devices.h&#062;
#include &#060;exec/memory.h&#062;
#include &#060;devices/audio.h&#062;
#include &#060;dos/dos.h&#062;

#include &#060;iff/iff.h&#062;
#include &#060;iff/8svx.h&#062;

#include &#060;clib/exec_protos.h&#062;
#include &#060;clib/dos_protos.h&#062;
#include &#060;clib/alib_protos.h&#062;

#include &#060;stdio.h&#062;
#include &#060;string.h&#062;
#include &#060;dos.h&#062;      /* This is the dos.h file from SAS/C not Commodore */

#ifdef SASC
int CXBRK(VOID)    { return(0); };
int chkabort(VOID) { return(0); };
#endif


#define BUF_SIZE 1024


/* Prototypes for functions defined in this program */
struct IOAudio *SiezeChannel( VOID );
VOID            ReleaseChannel( struct IOAudio * );
char           *Parse8svx(char *, struct InterPlay * );
VOID            EndParse( struct InterPlay * );
VOID            FillAudio(struct InterPlay *, struct IOAudio * );



struct InterPlay                       /* This is the main structure used for */
    {                                  /*  storage of playback state info.    */
    ULONG             sample_done;     /* 0=Keep playing, 1=all done playing. */
    UBYTE            *sample_byte;     /* Pointer for going through the data. */
    UBYTE            *sample_loc;      /* Start of 8SVX BODY data in memory.  */
    ULONG             sample_size;     /*  and total size of file for freeing.*/
    struct InterPlay *next_iplay;      /* Link to second data set. NULL means */
                                       /*  no second file name was given.     */
    LONG              offsetBody;      /* Offset into the file of BODY Chunk. */
    UWORD             sample_speed;    /* Value for audio period register.    */
    BOOL              USE_SUMMING;     /* TRUE means use averaging,           */
    };                                 /*  FALSE means use interleaving.      */

/* Version string for AmigaDOS VERSION command. */
UBYTE versiontag[] = &#034;$VER: Interplay 1.0 (2.2.93)&#034;;


/*-----------------------------------------
**
**          main()
**
**-----------------------------------------
*/

VOID main(int argc, char **argv)
{
struct InterPlay  mainplay,otherplay;   /* Two instances of the InterPlay    */
                                        /*  structure, one for each file.    */
struct IOAudio *pIOA_1=NULL,
               *pIOA_2=NULL,            /* Two IOAudio pointers, plus one    */
               *pIOA  =NULL;            /*  for switching back and forth     */
struct MsgPort *mport1=NULL,            /*  during double-buffering.         */
               *mport2=NULL,            /* Two MsgPort pointers, plus one    */
               *mport =NULL;            /*  for switching back and forth.    */

struct Message *msg;                    /* For the GetMsg() call.            */

LONG aswitch = 0L;                      /* Double-buffering logical switch.  */

static BYTE chip playbuffer1[BUF_SIZE]; /* Two buffers, one for each IOAudio */
static BYTE chip playbuffer2[BUF_SIZE]; /*  request.  Play out of one while  */
                                        /*  the other is being set up.       */
char *errormsg;     /* For error returns */
ULONG wakemask=0L;  /* For Wait() call   */


/* Give an AmigaDOS style help message */
if( (argc == 2) &#038;&#038; !strcmp(argv[1],&#034;?\0&#034;) )
    printf(&#034;8SVX-FILES/M,SUM/S\n&#034;);

else if(argc&#062;=2) /* OK got at least one argument. */
    {
    /* Get an audio channel at the highest priority */
    if( pIOA_1=SiezeChannel() )
      {
      mport1 = pIOA_1-&#062;ioa_Request.io_Message.mn_ReplyPort;
      pIOA_1-&#062;ioa_Data = playbuffer1;

      /* Get a 2nd MsgPort and 2nd IOAudio structure for double-buffering */
      pIOA_2 = AllocMem(sizeof(struct IOAudio),MEMF_PUBLIC | MEMF_CLEAR );
      mport2 = CreatePort(0,0);
      if( pIOA_2 &#038;&#038; mport2 )
          {
          /* The 2 IOAudio requests should be initialized the same */
          /* except for the buffer and the reply port they use.    */
          *pIOA_2 = *pIOA_1;
          pIOA_2-&#062;ioa_Request.io_Message.mn_ReplyPort = mport2;
          pIOA_2-&#062;ioa_Data = playbuffer2;

          /* Default is to use interleaving, not averaging */
          mainplay.USE_SUMMING = FALSE;

          /* Parse the 8SVX file and fill in the InterPlay structure */
          errormsg = Parse8svx( argv[1] , &#038;mainplay );

          /* If a second file name was given by the user then this is */
          /* an interleave request, so parse the 2nd 8SVX file.       */
          if( argc&#062;=3 &#038;&#038; !errormsg )
              {
              errormsg = Parse8svx( argv[2] , &#038;otherplay );
              mainplay.next_iplay = &#038;otherplay;

              /* If the SUM keyword was given in the command line, set the */
              /* SUMMING flag so that averaging, not interleaving, is used.*/
              if( (argc == 4) &#038;&#038;
                  ( !strcmp(argv[3],&#034;SUM\0&#034;) || !strcmp(argv[3],&#034;sum\0&#034;) )  )
                  mainplay.USE_SUMMING = TRUE;
              }
          else
              otherplay.sample_done = 1;

          if(!errormsg) /* File names given parsed OK? */
              {
              /* Fill up the buffer for the first request. */
              FillAudio( &#038;mainplay, pIOA_1);

              /* Is there enough data to double-buffer ? */
              if(!mainplay.sample_done || !otherplay.sample_done)
                  {
                  /* OK, enough data to double-buffer; fill up 2nd request */
                  FillAudio( &#038;mainplay, pIOA_2 );
                  BeginIO((struct IORequest *) pIOA_1 );
                  BeginIO((struct IORequest *) pIOA_2 );

                  /* Initial state of double-buffering variables */
                  aswitch=0; pIOA=pIOA_2; mport=mport1;

                  /*---------------------*/
                  /*  M A I N   L O O P  */
                  /*---------------------*/
                  while(!mainplay.sample_done || !otherplay.sample_done)
                      {
                      wakemask=Wait( (1 &#060;&#060; mport-&#062;mp_SigBit) |
                                               SIGBREAKF_CTRL_C  );

                      if( wakemask &#038; SIGBREAKF_CTRL_C )
                          {
                          otherplay.sample_done = 1;
                          mainplay.sample_done = 1;
                          }

                      while((msg=GetMsg(mport))==NULL){}

                      /* Toggle double-buffering variables */
                      if  (aswitch) {aswitch=0;pIOA=pIOA_2;mport=mport1;}
                      else          {aswitch=1;pIOA=pIOA_1;mport=mport2;}

                      FillAudio( &#038;mainplay, pIOA );
                      BeginIO((struct IORequest *) pIOA );
                      }

                  wakemask=Wait( 1 &#060;&#060; mport-&#062;mp_SigBit );
                  while((msg=GetMsg(mport))==NULL){}

                  if  (aswitch) {aswitch=0;pIOA=pIOA_2;mport=mport1;}
                  else          {aswitch=1;pIOA=pIOA_1;mport=mport2;}

                  wakemask=Wait( 1 &#060;&#060; mport-&#062;mp_SigBit );
                  while((msg=GetMsg(mport))==NULL){}
                  }
              else
                  {
                  /* Only enough data to fill up one buffer */
                  BeginIO((struct IORequest *) pIOA_1 );
                  wakemask=Wait( 1 &#060;&#060; mport1-&#062;mp_SigBit );
                  while((msg=GetMsg(mport1))==NULL){}
                  }
              }
          else
              /* One or the other of the files had a problem in Parse8svx() */
              printf(errormsg);

          /* Free the memory used for the 8SVX files in Parse8svx() */
          if(mainplay.next_iplay)
              EndParse( &#038;otherplay );
          EndParse( &#038;mainplay );

          }
      else printf(&#034;Couldn't get memory for a second IOAudio and MsgPort\n&#034;);

      /* Free the ports and memory used by the 2 IOAudio requests */
      if(mport2) DeletePort(mport2);
      if(pIOA_2) FreeMem( pIOA_2, sizeof(struct IOAudio) );

      ReleaseChannel(pIOA_1);
      }
    else printf(&#034;Couldn't get a channel on the audio device\n&#034;);
    }
else printf(&#034;Enter one or two 8SVX filenames.\n&#034;);
}



/*----------------------------------------------------------------------
** struct IOAudio *res = SiezeChannel( VOID )
**
**   Allocates any channel at the highest priority.  Once allocated,
**   the hardware registers of the given channel can be hit directly
**   without interfering with normal audio.device operation.
**
**   Retruns NULL on failure
**   or returns the address of the IOAudio used to get the channel.
**   If the call to this function succeeds, ReleaseChannel() should
**   be called later to free the channel and memory used for the IOAudio.
**-----------------------------------------------------------------------
*/
struct IOAudio *
SiezeChannel( VOID )
{
struct IOAudio *myAIOreq=NULL;
struct MsgPort *myAIOreply=NULL;
UBYTE chans[] = {1,2,4,8};      /* Try to get one channel, any channel */
BYTE dev = -1;

myAIOreq=(struct IOAudio *)AllocMem(sizeof(struct IOAudio),MEMF_PUBLIC );
if(myAIOreq)
    {
    myAIOreply=CreatePort(0,0);
    if(myAIOreply)
        {
        myAIOreq-&#062;ioa_Request.io_Message.mn_ReplyPort   = myAIOreply;
        myAIOreq-&#062;ioa_Request.io_Message.mn_Node.ln_Pri = 127;
        myAIOreq-&#062;ioa_Request.io_Command                = ADCMD_ALLOCATE;
        myAIOreq-&#062;ioa_AllocKey                          = 0;
        myAIOreq-&#062;ioa_Data                              = chans;
        myAIOreq-&#062;ioa_Length                            = sizeof(chans);

        dev=OpenDevice(&#034;audio.device&#034;,0L,(struct IORequest *)myAIOreq,0L);

       if(! dev)
            return( myAIOreq ); /* Successful exit */

        DeletePort( myAIOreply );
        }
    FreeMem( myAIOreq, sizeof(struct IOAudio) );
    }
return( NULL );
}


/*---------------------------------------------------------------
** VOID ReleaseChannel(struct IOAudio *rel );
**
**   Frees the channel and any asociated memory allocated earlier
**   with SiezeChannel().
**---------------------------------------------------------------
*/
VOID
ReleaseChannel(struct IOAudio *rel)
{
if(rel)
    {
    CloseDevice( (struct IORequest *) rel );

    if(rel-&#062;ioa_Request.io_Message.mn_ReplyPort)
        {
        DeletePort(rel-&#062;ioa_Request.io_Message.mn_ReplyPort);
        }
    FreeMem( rel, sizeof(struct IOAudio) );
    }
}




/*--------------------------------------------------------------------
**
** char *Parse8svx( char *filename, struct InterPlay *play_state)
**
**   Pass this function the name of an 8svx file.  It opens the file and
**   finds the VHDR and BODY Chunks.  Playback information is stored
**   in the InterPlay structure.
**
**   A NULL return indicates the parse was completely successful.
**   A non-NULL return means the file cannot be played back for
**   some reason.  In that case the return value is a pointer to
**   an error message explaining what went wrong.
**
**   After calling Parse8svx(), End Parse() should be called
**   to free any memory used.
**
**----------------------------------------------------------------------
*/
char *
Parse8svx(char *fname, struct InterPlay *play)
{
BYTE iobuffer[12];
LONG rdcount=0L;
Chunk *pChunk=NULL;
GroupHeader *pGH=NULL;

Voice8Header *pV8Head = NULL;
char         *error   = NULL;
BPTR         filehandle=NULL;
BOOL         NO_BODY  = TRUE;
BOOL         NO_VHDR  = TRUE;


/* Under normal operation, this function leaves the file positioned */
/* at the BODY Chunk.  However, for some degenerate 8SVX files, one */
/* additional seek is needed at the end.  In that case this field   */
/* (play-&#062;offsetBody) will be changed to the seek offset.           */
play-&#062;offsetBody = 0;
play-&#062;sample_loc = NULL;   /* Set to non-NULL if memory is allocated  */
play-&#062;next_iplay = NULL;   /* Default is no successors, no interleave */
play-&#062;sample_done= 0L;     /* Will be set to 1 when playback is done  */

filehandle= NULL;          /* Set to non-NULL if the file opens       */

NO_BODY=TRUE;
NO_VHDR=TRUE;

/* This section just makes sure that the first 12 bytes of the */
/* file conform to the IFF FORM specification, sub-type 8SVX.  */
filehandle = Open( fname, MODE_OLDFILE );
if(filehandle)
    {
    /* Next, read the first 12 bytes to check the type */
    rdcount =Read( filehandle, iobuffer, 12L );
    if(rdcount==12L)
        {
        /* Make sure it is an IFF FORM type */
        pGH = (GroupHeader *)iobuffer;
        if(pGH-&#062;ckID == FORM)
            {
            /* Make sure it is an 8SVX sub-type */
            if(pGH-&#062;grpSubID != ID_8SVX)
                    error=&#034;Not an 8SVX file\n&#034;;
            }
        else
            error=&#034;Not an IFF FORM\n&#034;;
        }
    else
        error=&#034;Read error or file too short1\n&#034;;
    }
else
    error=&#034;Couldn't open that file. Try another.\n&#034;;


/* Read through all Chunks until BODY and VHDR */
/* Chunks are found or until an error occurs.  */
while( !error &#038;&#038;   (NO_BODY  ||  NO_VHDR) )
    {
    /* Read the first 8 bytes of the Chunk to get the type and size */
    rdcount =Read( filehandle, iobuffer, 8L );
    if(rdcount==8L)
        {
        pChunk=(Chunk *)iobuffer;
        switch(pChunk-&#062;ckID)
            {

            case ID_VHDR:
                /* AllocMem() ckSize rounded up and read */
                /* the VHDR, filling in the InterPlay */
                if(pChunk-&#062;ckSize &#038; 1L)
                    pChunk-&#062;ckSize++;

                pV8Head = AllocMem(pChunk-&#062;ckSize, MEMF_PUBLIC);
                if(pV8Head)
                    {
                    rdcount=Read(filehandle,pV8Head,pChunk-&#062;ckSize);
                    if(rdcount==pChunk-&#062;ckSize )
                        {
                        if(pV8Head-&#062;sCompression==sCmpNone)
                            {
                            /* Set the playback speed */
                            play-&#062;sample_speed = (UWORD)
                                        (3579545L / pV8Head-&#062;samplesPerSec);

                            /* Set up start, end of sample data */
                            play-&#062;sample_size = pV8Head-&#062;oneShotHiSamples
                                                   + pV8Head-&#062;repeatHiSamples;
                            }
                        else error=&#034;Can't read compressed file\n&#034;;
                        }
                    else error=&#034;Read problem in header\n&#034;;

                    FreeMem(pV8Head, pChunk-&#062;ckSize );
                    }
                else error=&#034;Couldn't get header memory\n&#034;;
                NO_VHDR = FALSE;
                break;

            case ID_BODY:
                /* Technically, a VHDR could come after a BODY.*/
                /* This is a pretty unlikely occurence though. */
                if(NO_VHDR)
                    {
                    if(pChunk-&#062;ckSize &#038; 1L)
                        pChunk-&#062;ckSize++;

                    rdcount = Seek(filehandle, pChunk-&#062;ckSize, OFFSET_CURRENT);
                    if(rdcount==-1)
                        error=&#034;Problem during BODY-skipping seek\n&#034;;
                    else
                        play-&#062;offsetBody=rdcount;
                    }
                NO_BODY = FALSE;
                break;

            default:
                /* Ignore other Chunks, skipping over them */
                if(pChunk-&#062;ckSize &#038; 1L)
                    pChunk-&#062;ckSize++;

                rdcount = Seek(filehandle, pChunk-&#062;ckSize, OFFSET_CURRENT);
                if(rdcount==-1)
                    error=&#034;Problem during chunk-skipping seek\n&#034;;
                break;
            }
        }
    else error = &#034;Read error or file too short2\n&#034;;
    }

if(!error)
    {
    /* In case the VHDR came after the BODY, seek back to the BODY */
    if(play-&#062;offsetBody)
        {
        rdcount = Seek(filehandle, play-&#062;offsetBody, OFFSET_BEGINNING);
        if(rdcount==-1)
            error=&#034;Couldn't seek to BODY\n&#034;;
        }

    /* OK now get the BODY data into a memory block */
    play-&#062;sample_loc = AllocMem( play-&#062;sample_size, MEMF_PUBLIC );
    if(play-&#062;sample_loc)
        {
        rdcount = Read(filehandle, play-&#062;sample_loc, play-&#062;sample_size);
        if(rdcount!=play-&#062;sample_size)
            error = &#034;Error during BODY read\n&#034;;
        else
            play-&#062;sample_byte=play-&#062;sample_loc;
        }
    else
        error=&#034;Couldn't get memory for BODY Chunk\n&#034;;
    }

if(filehandle)
    Close(filehandle);

return(error);
}



/*---------------------------------------------------------------
**
** VOID EndParse( struct InterPlay * );
**
**   This function simply frees any memory used by an earlier
**   call to Parse8svx().
**
**---------------------------------------------------------------
*/
VOID
EndParse( struct InterPlay *play )
{
if(play-&#062;sample_loc)
    FreeMem(play-&#062;sample_loc, play-&#062;sample_size );
}



/*-----------------------------------------------------------------------------
**
** VOID FillAudio(struct InterPlay *, struct IOAudio * );
**
**   This function gets 512 bytes each from 2 BODY buffers and interleaves
**   the bytes in the audio playback buffer.
**------------------------------------------------------------------------------
*/
VOID
FillAudio(struct InterPlay *inplay, struct IOAudio *ioa )
{
struct InterPlay *play1,*play2;
ULONG remainder1,remainder2,x;
UWORD speedfac;
WORD value;


if(ioa-&#062;ioa_Request.io_Command != CMD_WRITE) /* For 1st time callers only */
    {
    /* When two files are played at once, their speeds must match.  Use  */
    /* whichever speed is fastest. Interleaved requests also require the */
    /* speed to be doubled (period is halved).  However, the period      */
    /* cannot be lower than 124 or audio DMA bandwidth will be exceeded. */
    speedfac = inplay-&#062;sample_speed;

    if(inplay-&#062;next_iplay)
        {
        if(inplay-&#062;next_iplay-&#062;sample_speed &#060; inplay-&#062;sample_speed)
            speedfac = inplay-&#062;next_iplay-&#062;sample_speed;

        if ( !(inplay-&#062;USE_SUMMING) )
            speedfac /= 2;
        }

    if(speedfac &#060; 124)
        speedfac = 124;

    ioa-&#062;ioa_Request.io_Command = CMD_WRITE;
    ioa-&#062;ioa_Request.io_Flags   = ADIOF_PERVOL;
    ioa-&#062;ioa_Volume             = 63;
    ioa-&#062;ioa_Period             = speedfac;
    ioa-&#062;ioa_Length             = BUF_SIZE;
    ioa-&#062;ioa_Cycles             = 1;
    }

if(inplay-&#062;next_iplay)
    {
    play1=inplay;
    play2=inplay-&#062;next_iplay;

    remainder1 = play1-&#062;sample_size - (play1-&#062;sample_byte - play1-&#062;sample_loc);
    remainder2 = play2-&#062;sample_size - (play2-&#062;sample_byte - play2-&#062;sample_loc);

    if(play1-&#062;USE_SUMMING)
        {
        /*
        ** AVERAGING LOGIC for playing TWO samples on ONE channel
        */
        for(x=0; x&#060;BUF_SIZE ;x++)
            {
            value = 0;

            if( x&#060;remainder1 )
                {
                value += *( (BYTE *)(play1-&#062;sample_byte) );
                play1-&#062;sample_byte++;
                }
            else if( x==remainder1 )
                play1-&#062;sample_done=1;

            if( x&#060;remainder2 )
                {
                value += *( (BYTE *)(play2-&#062;sample_byte) );
                play2-&#062;sample_byte++;
                }
            else if( x==remainder2 )
                play2-&#062;sample_done=1;

            *(ioa-&#062;ioa_Data + x) = (UBYTE) (value/2);
            }
        }
    else
        {
        /*
        ** INTERLEAVE LOGIC for playing TWO samples on ONE channel
        */

        /* If there are more bytes in the 1st sample data file, place them in */
        /* the EVEN positions in the playback buffer of this IOAudio request. */
        for(x=0; (x&#060;BUF_SIZE) &#038;&#038; (x&#060;2*remainder1); x+=2 )
            {
            *(ioa-&#062;ioa_Data + x) = *(play1-&#062;sample_byte);
            play1-&#062;sample_byte++;
            }
        /* If there are no more bytes then mark the 1st sample as done */
        if(x&#060;BUF_SIZE)
            play1-&#062;sample_done=1L;

        while(x&#060;BUF_SIZE)      /* Pad the playback buffer with zeroes. */
            {
            *(ioa-&#062;ioa_Data + x) = 0;
            x+=2;
            }

        /* If there are more bytes in the 2nd sample data file, place them in */
        /* the ODD positions in the playback buffer of this IOAudio request.  */
        for(x=1; (x&#060;BUF_SIZE) &#038;&#038; (x&#060;2*remainder2);x+=2)
            {
            *(ioa-&#062;ioa_Data + x) = *(play2-&#062;sample_byte);
            play2-&#062;sample_byte++;
            }
        /* If there are no more bytes then mark the 2nd sample as done */
        if(x&#060;BUF_SIZE)
            play2-&#062;sample_done=1L;

        while(x&#060;BUF_SIZE)      /* Pad the playback buffer with zeroes. */
            {
            *(ioa-&#062;ioa_Data + x) = 0;
            x+=2;
            }
        }
    }
else
    {
    /*
    ** REGULAR LOGIC for playing a single sample on a single channel.
    */
    remainder1= inplay-&#062;sample_size - (inplay-&#062;sample_byte-inplay-&#062;sample_loc);
    if(remainder1 &#062; BUF_SIZE)
        {
        CopyMem(inplay-&#062;sample_byte,ioa-&#062;ioa_Data,BUF_SIZE);
        inplay-&#062;sample_byte+=BUF_SIZE;
        }
    else
        {
        CopyMem(inplay-&#062;sample_byte,ioa-&#062;ioa_Data,remainder1);
        ioa-&#062;ioa_Length=remainder1;
        inplay-&#062;sample_done=1L;
        }
    }
}
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
