<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/34.11 FILE="II-107/ASyncIO.c" NODE="MAIN" TITLE="II-107/ASyncIO.c" -->
<head>
<title>II-107/ASyncIO.c</title>
</head>
<body>
<img src="../images/toc_d.gif" alt="[Contents]">
<img src="../images/index_d.gif" alt="[Index]">
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../AmigaMail_Vol2_guide/node0185.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../AmigaMail_Vol2_guide/node0187.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
;/* ASyncIO.c - Execute me to compile with SAS/C 6.56
sc data=near nominc strmer streq nostkchk saveds ign=73 AsyncIO.c
quit
*/

/* (c)  Copyright 1993-1999 Amiga, Inc.   All rights reserved. */
/* The information contained herein is subject to change without    */
/* notice, and is provided &#034;as is&#034; without warranty of any kind,    */
/* either expressed or implied.  The entire risk as to the use of   */
/* this information is assumed by the user.                         */

#include &#060;exec/types.h&#062;
#include &#060;exec/memory.h&#062;
#include &#060;dos/dos.h&#062;
#include &#060;dos/dosextens.h&#062;

#include &#060;clib/exec_protos.h&#062;
#include &#060;clib/dos_protos.h&#062;

#include &#060;pragmas/exec_pragmas.h&#062;
#include &#060;pragmas/dos_pragmas.h&#062;

#include &#034;asyncio.h&#034;


/*****************************************************************************/


extern struct Library *DOSBase;
extern struct Library *SysBase;


/*****************************************************************************/


/* this macro lets us long-align structures on the stack */
#define D_S(type,name) char a_##name[sizeof(type)+3]; \
                       type *name = (type *)((LONG)(a_##name+3) &#038; ~3);


/*****************************************************************************/


/* send out an async packet to the file system. */
static VOID SendPacket(struct AsyncFile *file, APTR arg2)
{
    file-&#062;af_Packet.sp_Pkt.dp_Port = &#038;file-&#062;af_PacketPort;
    file-&#062;af_Packet.sp_Pkt.dp_Arg2 = (LONG)arg2;
    PutMsg(file-&#062;af_Handler, &#038;file-&#062;af_Packet.sp_Msg);
    file-&#062;af_PacketPending = TRUE;
}


/*****************************************************************************/


/* this function waits for a packet to come back from the file system. If no
 * packet is pending, state from the previous packet is returned. This ensures
 * that once an error occurs, it state is maintained for the rest of the life
 * of the file handle.
 *
 * This function also deals with IO errors, bringing up the needed DOS
 * requesters to let the user retry an operation or cancel it.
 */
static LONG WaitPacket(struct AsyncFile *file)
{
LONG bytes;

    if (file-&#062;af_PacketPending)
    {
        /* mark packet as no longer pending since we are going to get it */
        file-&#062;af_PacketPending = FALSE;

        while (TRUE)
        {
            /* This enables signalling when a packet comes back to the port */
            file-&#062;af_PacketPort.mp_Flags = PA_SIGNAL;

            /* Wait for the packet to come back, and remove it from the message
             * list. Since we know no other packets can come in to the port, we can
             * safely use Remove() instead of GetMsg(). If other packets could come in,
             * we would have to use GetMsg(), which correctly arbitrates access in such
             * a case
             */
            Remove((struct Node *)WaitPort(&#038;file-&#062;af_PacketPort));

            /* set the port type back to PA_IGNORE so we won't be bothered with
             * spurious signals
             */
            file-&#062;af_PacketPort.mp_Flags = PA_IGNORE;

            bytes = file-&#062;af_Packet.sp_Pkt.dp_Res1;
            if (bytes &#062;= 0)
            {
                /* packet didn't report an error, so bye... */
                return(bytes);
            }

            /* see if the user wants to try again... */
            if (ErrorReport(file-&#062;af_Packet.sp_Pkt.dp_Res2,
                            REPORT_STREAM,
                            file-&#062;af_File,NULL))
                return(-1);

            /* user wants to try again, resend the packet */
            SendPacket(file,file-&#062;af_Buffers[file-&#062;af_CurrentBuf]);
        }
    }

    /* last packet's error code, or 0 if packet was never sent */
    SetIoErr(file-&#062;af_Packet.sp_Pkt.dp_Res2);

    return(file-&#062;af_Packet.sp_Pkt.dp_Res1);
}


/*****************************************************************************/


/* this function puts the packet back on the message list of our
 * message port.
 */
static VOID RequeuePacket(struct AsyncFile *file)
{
    AddHead(&#038;file-&#062;af_PacketPort.mp_MsgList,&#038;file-&#062;af_Packet.sp_Msg.mn_Node);
    file-&#062;af_PacketPending = TRUE;
}


/*****************************************************************************/


/* this function records a failure from a synchronous DOS call into the
 * packet so that it gets picked up by the other IO routines in this module
 */
VOID RecordSyncFailure(struct AsyncFile *file)
{
    file-&#062;af_Packet.sp_Pkt.dp_Res1 = -1;
    file-&#062;af_Packet.sp_Pkt.dp_Res2 = IoErr();
}


/*****************************************************************************/


struct AsyncFile *OpenAsync(const STRPTR fileName, UBYTE accessMode, LONG bufferSize)
{
struct AsyncFile  *file;
struct FileHandle *fh;
BPTR               handle;
BPTR               lock;
LONG               blockSize;
D_S(struct InfoData,infoData);

    handle = NULL;
    file   = NULL;
    lock   = NULL;

    if (accessMode == MODE_READ)
    {
        if (handle = Open(fileName,MODE_OLDFILE))
            lock = DupLockFromFH(handle);
    }
    else
    {
        if (accessMode == MODE_WRITE)
        {
            handle = Open(fileName,MODE_NEWFILE);
        }
        else if (accessMode == MODE_APPEND)
        {
            /* in append mode, we open for writing, and then seek to the
             * end of the file. That way, the initial write will happen at
             * the end of the file, thus extending it
             */

            if (handle = Open(fileName,MODE_READWRITE))
            {
                if (Seek(handle,0,OFFSET_END) &#060; 0)
                {
                    Close(handle);
                    handle = NULL;
                }
            }
        }

        /* we want a lock on the same device as where the file is. We can't
         * use DupLockFromFH() for a write-mode file though. So we get sneaky
         * and get a lock on the parent of the file
         */
        if (handle)
            lock = ParentOfFH(handle);
    }

    if (handle)
    {
        /* if it was possible to obtain a lock on the same device as the
         * file we're working on, get the block size of that device and
         * round up our buffer size to be a multiple of the block size.
         * This maximizes DMA efficiency.
         */

        blockSize = 512;
        if (lock)
        {
            if (Info(lock,infoData))
            {
                blockSize = infoData-&#062;id_BytesPerBlock;
                bufferSize =
                    (((bufferSize + blockSize - 1) / blockSize) * blockSize) * 2;
            }
            UnLock(lock);
        }

        /* now allocate the ASyncFile structure, as well as the read buffers.
         * Add 15 bytes to the total size in order to allow for later
         * quad-longword alignement of the buffers
         */

        if (file = AllocVec(sizeof(struct AsyncFile) + bufferSize + 15,MEMF_ANY))
        {
            file-&#062;af_File      = handle;
            file-&#062;af_ReadMode  = (accessMode == MODE_READ);
            file-&#062;af_BlockSize = blockSize;

            /* initialize the ASyncFile structure. We do as much as we can here,
             * in order to avoid doing it in more critical sections
             *
             * Note how the two buffers used are quad-longword aligned. This
             * helps performance on 68040 systems with copyback cache. Aligning
             * the data avoids a nasty side-effect of the 040 caches on DMA.
             * Not aligning the data causes the device driver to have to do
             * some magic to avoid the cache problem. This magic will generally
             * involve flushing the CPU caches. This is very costly on an 040.
             * Aligning things avoids the need for magic, at the cost of at
             * most 15 bytes of ram.
             */

            fh                     = BADDR(file-&#062;af_File);
            file-&#062;af_Handler       = fh-&#062;fh_Type;
            file-&#062;af_BufferSize    = bufferSize / 2;
            file-&#062;af_Buffers[0]
                = (APTR)(((ULONG)file + sizeof(struct AsyncFile) + 15) &#038; 0xfffffff0);
            file-&#062;af_Buffers[1]
                = (APTR)((ULONG)file-&#062;af_Buffers[0] + file-&#062;af_BufferSize);
            file-&#062;af_Offset        = file-&#062;af_Buffers[0];
            file-&#062;af_CurrentBuf    = 0;
            file-&#062;af_SeekOffset    = 0;
            file-&#062;af_PacketPending = FALSE;

            /* this is the port used to get the packets we send out back.
             * It is initialized to PA_IGNORE, which means that no signal is
             * generated when a message comes in to the port. The signal bit
             * number is initialized to SIGB_SINGLE, which is the special bit
             * that can be used for one-shot signalling. The signal will never
             * be set, since the port is of type PA_IGNORE. We'll change the
             * type of the port later on to PA_SIGNAL whenever we need to wait
             * for a message to come in.
             *
             * The trick used here avoids the need to allocate an extra signal
             * bit for the port. It is quite efficient.
             */

            file-&#062;af_PacketPort.mp_MsgList.lh_Head
                = (struct Node *)&#038;file-&#062;af_PacketPort.mp_MsgList.lh_Tail;
            file-&#062;af_PacketPort.mp_MsgList.lh_Tail     = NULL;
            file-&#062;af_PacketPort.mp_MsgList.lh_TailPred
                = (struct Node *)&#038;file-&#062;af_PacketPort.mp_MsgList.lh_Head;
            file-&#062;af_PacketPort.mp_Node.ln_Type        = NT_MSGPORT;
            file-&#062;af_PacketPort.mp_Flags               = PA_IGNORE;
            file-&#062;af_PacketPort.mp_SigBit              = SIGB_SINGLE;
            file-&#062;af_PacketPort.mp_SigTask             = FindTask(NULL);

            file-&#062;af_Packet.sp_Pkt.dp_Link          = &#038;file-&#062;af_Packet.sp_Msg;
            file-&#062;af_Packet.sp_Pkt.dp_Arg1          = fh-&#062;fh_Arg1;
            file-&#062;af_Packet.sp_Pkt.dp_Arg3          = file-&#062;af_BufferSize;
            file-&#062;af_Packet.sp_Pkt.dp_Res1          = 0;
            file-&#062;af_Packet.sp_Pkt.dp_Res2          = 0;
            file-&#062;af_Packet.sp_Msg.mn_Node.ln_Name  = (STRPTR)&#038;file-&#062;af_Packet.sp_Pkt;
            file-&#062;af_Packet.sp_Msg.mn_Node.ln_Type  = NT_MESSAGE;
            file-&#062;af_Packet.sp_Msg.mn_Length        = sizeof(struct StandardPacket);

            if (accessMode == MODE_READ)
            {
                /* if we are in read mode, send out the first read packet to
                 * the file system. While the application is getting ready to
                 * read data, the file system will happily fill in this buffer
                 * with DMA transfers, so that by the time the application
                 * needs the data, it will be in the buffer waiting
                 */

                file-&#062;af_Packet.sp_Pkt.dp_Type = ACTION_READ;
                file-&#062;af_BytesLeft             = 0;
                if (file-&#062;af_Handler)
                    SendPacket(file,file-&#062;af_Buffers[0]);
            }
            else
            {
                file-&#062;af_Packet.sp_Pkt.dp_Type = ACTION_WRITE;
                file-&#062;af_BytesLeft             = file-&#062;af_BufferSize;
            }
        }
        else
        {
            Close(handle);
        }
    }

    return(file);
}


/*****************************************************************************/


LONG CloseAsync(struct AsyncFile *file)
{
LONG result;

    if (file)
    {
        result = WaitPacket(file);
        if (result &#062;= 0)
        {
            if (!file-&#062;af_ReadMode)
            {
                /* this will flush out any pending data in the write buffer */
                result = Write(file-&#062;af_File,
                               file-&#062;af_Buffers[file-&#062;af_CurrentBuf],
                               file-&#062;af_BufferSize - file-&#062;af_BytesLeft);
            }
        }

        Close(file-&#062;af_File);
        FreeVec(file);
    }
    else
    {
        SetIoErr(ERROR_INVALID_LOCK);
        result = -1;
    }

    return(result);
}


/*****************************************************************************/


LONG ReadAsync(struct AsyncFile *file, APTR buffer, LONG numBytes)
{
LONG totalBytes;
LONG bytesArrived;

    totalBytes = 0;

    /* if we need more bytes than there are in the current buffer, enter the
     * read loop
     */

    while (numBytes &#062; file-&#062;af_BytesLeft)
    {
        /* drain buffer */
        CopyMem(file-&#062;af_Offset,buffer,file-&#062;af_BytesLeft);

        numBytes           -= file-&#062;af_BytesLeft;
        buffer              = (APTR)((ULONG)buffer + file-&#062;af_BytesLeft);
        totalBytes         += file-&#062;af_BytesLeft;
        file-&#062;af_BytesLeft  = 0;

        bytesArrived = WaitPacket(file);
        if (bytesArrived &#060;= 0)
        {
            if (bytesArrived == 0)
                return(totalBytes);

            return(-1);
        }

        /* ask that the buffer be filled */
        SendPacket(file,file-&#062;af_Buffers[1-file-&#062;af_CurrentBuf]);

        if (file-&#062;af_SeekOffset &#062; bytesArrived)
            file-&#062;af_SeekOffset = bytesArrived;

        file-&#062;af_Offset      = (APTR)((ULONG)file-&#062;af_Buffers[file-&#062;af_CurrentBuf]
                                   + file-&#062;af_SeekOffset);
        file-&#062;af_CurrentBuf  = 1 - file-&#062;af_CurrentBuf;
        file-&#062;af_BytesLeft   = bytesArrived - file-&#062;af_SeekOffset;
        file-&#062;af_SeekOffset  = 0;
    }

    CopyMem(file-&#062;af_Offset,buffer,numBytes);
    file-&#062;af_BytesLeft -= numBytes;
    file-&#062;af_Offset     = (APTR)((ULONG)file-&#062;af_Offset + numBytes);

    return (totalBytes + numBytes);
}


/*****************************************************************************/


LONG ReadCharAsync(struct AsyncFile *file)
{
unsigned char ch;

    if (file-&#062;af_BytesLeft)
    {
        /* if there is at least a byte left in the current buffer, get it
         * directly. Also update all counters
         */

        ch = *(char *)file-&#062;af_Offset;
        file-&#062;af_BytesLeft--;
        file-&#062;af_Offset = (APTR)((ULONG)file-&#062;af_Offset + 1);

        return((LONG)ch);
    }

    /* there were no characters in the current buffer, so call the main read
     * routine. This has the effect of sending a request to the file system to
     * have the current buffer refilled. After that request is done, the
     * character is extracted for the alternate buffer, which at that point
     * becomes the &#034;current&#034; buffer
     */

    if (ReadAsync(file,&#038;ch,1) &#062; 0)
        return((LONG)ch);

    /* We couldn't read above, so fail */

    return(-1);
}


/*****************************************************************************/


LONG WriteAsync(struct AsyncFile *file, APTR buffer, LONG numBytes)
{
LONG totalBytes;

    totalBytes = 0;

    while (numBytes &#062; file-&#062;af_BytesLeft)
    {
        /* this takes care of NIL: */
        if (!file-&#062;af_Handler)
        {
            file-&#062;af_Offset    = file-&#062;af_Buffers[0];
            file-&#062;af_BytesLeft = file-&#062;af_BufferSize;
            return(numBytes);
        }

        if (file-&#062;af_BytesLeft)
        {
            CopyMem(buffer,file-&#062;af_Offset,file-&#062;af_BytesLeft);

            numBytes   -= file-&#062;af_BytesLeft;
            buffer      = (APTR)((ULONG)buffer + file-&#062;af_BytesLeft);
            totalBytes += file-&#062;af_BytesLeft;
        }

        if (WaitPacket(file) &#060; 0)
            return(-1);

        /* send the current buffer out to disk */
        SendPacket(file,file-&#062;af_Buffers[file-&#062;af_CurrentBuf]);

        file-&#062;af_CurrentBuf = 1 - file-&#062;af_CurrentBuf;
        file-&#062;af_Offset     = file-&#062;af_Buffers[file-&#062;af_CurrentBuf];
        file-&#062;af_BytesLeft  = file-&#062;af_BufferSize;
    }

    CopyMem(buffer,file-&#062;af_Offset,numBytes);
    file-&#062;af_BytesLeft -= numBytes;
    file-&#062;af_Offset     = (APTR)((ULONG)file-&#062;af_Offset + numBytes);

    return (totalBytes + numBytes);
}


/*****************************************************************************/


LONG WriteCharAsync(struct AsyncFile *file, UBYTE ch)
{
    if (file-&#062;af_BytesLeft)
    {
        /* if there's any room left in the current buffer, directly write
         * the byte into it, updating counters and stuff.
         */

        *(UBYTE *)file-&#062;af_Offset = ch;
        file-&#062;af_BytesLeft--;
        file-&#062;af_Offset = (APTR)((ULONG)file-&#062;af_Offset + 1);

        /* one byte written */
        return(1);
    }

    /* there was no room in the current buffer, so call the main write
     * routine. This will effectively send the current buffer out to disk,
     * wait for the other buffer to come back, and then put the byte into
     * it.
     */

    return(WriteAsync(file,&#038;ch,1));
}


/*****************************************************************************/


LONG SeekAsync(struct AsyncFile *file, LONG position, BYTE mode)
{
LONG  current, target;
LONG  minBuf, maxBuf;
LONG  bytesArrived;
LONG  diff;
LONG  filePos;
LONG  roundTarget;
D_S(struct FileInfoBlock,fib);

    bytesArrived = WaitPacket(file);

    if (bytesArrived &#060; 0)
        return(-1);

    if (file-&#062;af_ReadMode)
    {
        /* figure out what the actual file position is */
        filePos = Seek(file-&#062;af_File,OFFSET_CURRENT,0);
        if (filePos &#060; 0)
        {
            RecordSyncFailure(file);
            return(-1);
        }

        /* figure out what the caller's file position is */
        current = filePos - (file-&#062;af_BytesLeft+bytesArrived);

        /* figure out the absolute offset within the file where we must seek to */
        if (mode == MODE_CURRENT)
        {
            target = current + position;
        }
        else if (mode == MODE_START)
        {
            target = position;
        }
        else /* if (mode == MODE_END) */
        {
            if (!ExamineFH(file-&#062;af_File,fib))
            {
                RecordSyncFailure(file);
                return(-1);
            }

            target = fib-&#062;fib_Size + position;
        }

        /* figure out what range of the file is currently in our buffers */
        minBuf = current - (LONG)((ULONG)file-&#062;af_Offset -
                     (ULONG)file-&#062;af_Buffers[1 - file-&#062;af_CurrentBuf]);
        maxBuf = current + file-&#062;af_BytesLeft
                     + bytesArrived;  /* WARNING: this is one too big */

        diff = target - current;

        if ((target &#060; minBuf) || (target &#062;= maxBuf))
        {
            /* the target seek location isn't currently in our buffers, so
             * move the actual file pointer to the desired location, and then
             * restart the async read thing...
             */

            /* this is to keep our file reading block-aligned on the device.
             * block-aligned reads are generally quite a bit faster, so it is
             * worth the trouble to keep things aligned
             */
            roundTarget = (target / file-&#062;af_BlockSize) * file-&#062;af_BlockSize;

            if (Seek(file-&#062;af_File,roundTarget-filePos,OFFSET_CURRENT) &#060; 0)
            {
                RecordSyncFailure(file);
                return(-1);
            }

            SendPacket(file,file-&#062;af_Buffers[0]);

            file-&#062;af_SeekOffset = target-roundTarget;
            file-&#062;af_BytesLeft  = 0;
            file-&#062;af_CurrentBuf = 0;
        }
        else if ((target &#060; current) || (diff &#060;= file-&#062;af_BytesLeft))
        {
            /* one of the two following things is true:
             *
             * 1. The target seek location is within the current read buffer,
             * but before the current location within the buffer. Move back
             * within the buffer and pretend we never got the pending packet,
             * just to make life easier, and faster, in the read routine.
             *
             * 2. The target seek location is ahead within the current
             * read buffer. Advance to that location. As above, pretend to
             * have never received the pending packet.
             */

            RequeuePacket(file);

            file-&#062;af_BytesLeft -= diff;
            file-&#062;af_Offset     = (APTR)((ULONG)file-&#062;af_Offset + diff);
        }
        else
        {
            /* at this point, we know the target seek location is within
             * the buffer filled in by the packet that we just received
             * at the start of this function. Throw away all the bytes in the
             * current buffer, send a packet out to get the async thing going
             * again, readjust buffer pointers to the seek location, and return
             * with a grin on your face... :-)
             */

            diff -= file-&#062;af_BytesLeft;

            SendPacket(file,file-&#062;af_Buffers[1-file-&#062;af_CurrentBuf]);

            file-&#062;af_Offset
                = (APTR)((ULONG)file-&#062;af_Buffers[file-&#062;af_CurrentBuf] + diff);
            file-&#062;af_CurrentBuf = 1 - file-&#062;af_CurrentBuf;
            file-&#062;af_BytesLeft  = bytesArrived - diff;
        }
    }
    else
    {
        if (Write(file-&#062;af_File,
                  file-&#062;af_Buffers[file-&#062;af_CurrentBuf],
                  file-&#062;af_BufferSize - file-&#062;af_BytesLeft) &#060; 0)
        {
            RecordSyncFailure(file);
            return(-1);
        }

        /* this will unfortunately generally result in non block-aligned file
         * access. We could be sneaky and try to resync our file pos at a
         * later time, but we won't bother. Seeking in write-only files is
         * relatively rare (except when writing IFF files with unknown chunk
         * sizes, where the chunk size has to be written after the chunk data)
         */

        current = Seek(file-&#062;af_File,position,mode);

        if (current &#060; 0)
        {
            RecordSyncFailure(file);
            return(-1);
        }

        file-&#062;af_BytesLeft  = file-&#062;af_BufferSize;
        file-&#062;af_CurrentBuf = 0;
    }

    return(current);
}
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
