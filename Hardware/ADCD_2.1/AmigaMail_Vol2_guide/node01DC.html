<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/34.11 FILE="VIII-31/SendNote.c" NODE="MAIN" TITLE="VIII-31/SendNote.c" -->
<head>
<title>VIII-31/SendNote.c</title>
</head>
<body>
<img src="../images/toc_d.gif" alt="[Contents]">
<img src="../images/index_d.gif" alt="[Index]">
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../AmigaMail_Vol2_guide/node01DB.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../AmigaMail_Vol2_guide/node01DD.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
;/* sendnote.c - Execute to compile with SAS/C 6.56
sc DATA=FAR NMINC STRMERGE STREQ NOSTKCHK SAVEDS IGNORE=73 sendnote.c
slink FROM LIB:c.o sendnote.o TO sendnote LIBRARY LIB:sc.lib LIB:amiga.lib
quit
*/

/* (c)  Copyright 1992-1999 Amiga, Inc.   All rights reserved. */
/* The information contained herein is subject to change without    */
/* notice, and is provided &#034;as is&#034; without warranty of any kind,    */
/* either expressed or implied.  The entire risk as to the use of   */
/* this information is assumed by the user.                         */

/*
** Our Application Prototypes (specific to notes.c file)
*/

void    main( int, char ** );
void    FinalExit( int );

/*
** Application-specific defines and globals
*/

char Version[] = &#034;\0$VER: SendNote 1.2 (1.12.91)&#034;;

#define TEMPLATE    &#034;Host/A,Text,Button&#034;
#define OPT_HOST    0
#define OPT_TEXT    1
#define OPT_BUTTON  2
#define OPT_COUNT   3

/*
** The library bases...we need em later...
*/

struct Library *IntuitionBase, *SockBase;

/*
** All other includes and protos are indexed off our catch-all file
** note.h which both the client (sendnote.c) and server (shownote.c)
** include.
*/

#include    &#034;note.h&#034;


void    main(int argc, char **argv)
{
    struct RDArgs *rdargs;      /* ReadArgs() return information */

    struct sockaddr_in serv;    /* Server's Internet Address */

    struct hostent *host;       /* The located host info */

    struct NetNote out;         /* Message packet for send/recv */

    long opts[OPT_COUNT] =  {
                            0L,
                            (long)&#034;== PING! ==&#034;,
                            (long)&#034;OK&#034;
                            };

    int sock;                   /* The working socket */

    char *hostnam,                  /* Arg of hostname */
         *text,                 /* Arg of text to be sent */
         *button;               /* Arg of button text */

    /*
    ** Process arguments using new (2.0) dos calls.
    */

    rdargs = (struct RDArgs *)ReadArgs( (UBYTE *)TEMPLATE, opts, NULL );
    if(rdargs == NULL)
    {
        puts(&#034;Command line not accepted!&#034;);
        FinalExit( RETURN_ERROR );
    }

    hostnam = (char *)opts[OPT_HOST];
    text = (char *)opts[OPT_TEXT];
    button  = (char *)opts[OPT_BUTTON];

    /*
    **  Open socket.library and intialize socket space
    */

    if (SockBase = OpenLibrary(&#034;inet:libs/socket.library&#034;, 0L))
    {
        setup_sockets( 1, &#038;errno );
    }
    else
    {
        puts(&#034;Can't open socket.library!&#034;);
        FinalExit( RETURN_ERROR );
    }

    /*
    ** First we need to try and resolve the host machine as a
    ** normal IP/Internet address.  If that fails, fall back to seaching
    ** the hosts file for it.  Before anything, we need to clear out
    ** the buffer (serv) where the information will be placed, using
    ** the bzero() call (actually a macro in sys/types.h).
    */

    bzero( &#038;serv, sizeof(struct sockaddr_in) );
    if ( (serv.sin_addr.s_addr = inet_addr(hostnam)) == INADDR_NONE )
    {
        /*
        ** Okay, the program wasnt handed a dotted decimal address,
        ** so we check and see if it was handed a machine name.
        **
        ** NOTE:  Grab the information you need before you use the
        **        gethostbyname() call again.  Subsequent calls
        **        will overwrite the buffer it hands back.
        */

        if ( (host = gethostbyname(hostnam)) == NULL )
        {
            printf(&#034;Host not found: %s\n&#034;,host);
            FinalExit( RETURN_ERROR );
        }

        /*
        ** It does indeed have a name, so copy the addr field from the
        ** hostent structure into the sockaddr structure.
        */

        bcopy( host-&#062;h_addr, (char *)&#038;serv.sin_addr, host-&#062;h_length );
    }

/*
**  Following is commented out for ease of testing purposes!  Normally, apps
**  should obtain server numbers using this type of code and a matching entry
**  in the inet:db/services file.
**
**  {
**      struct servent *servptr;
**      char *servnam = APPNAME;
**
**      *
**      ** Open the INET:DB/SERVICES file and locate the server info
**      ** by matching the name and service.
**      *
**
**      if ((servptr = getservbyname( servnam, &#034;tcp&#034; )) == NULL)
**      {
**          printf(&#034;%s not in inet:db/services list!&#034;,servnam);
**          FinalExit( RETURN_ERROR );
**      }
**      serv.sin_port = servptr-&#062;s_port;
**  }
**
*/

    /*
    ** If you used the above code, you would remove this line:
    */

    serv.sin_port = 8769;

    /*
    ** This tells the system the socket in question is an Internet socket
    */

    serv.sin_family = AF_INET;

    /*
    ** Initialize the socket
    */

    if ( (sock = socket( AF_INET, SOCK_STREAM, 0 )) &#060; 0 )
    {
        printf(&#034;socket gen: %s\n&#034;, strerror(errno));
        FinalExit( RETURN_ERROR );
    }

    /*
    ** Connect the socket to the remote socket, which belongs to the
    ** server, and which will &#034;wake up&#034; the server.
    */

    if ( connect( sock,
                  (struct sockaddr *)&#038;serv,
                  sizeof(struct sockaddr) ) &#060; 0 )
    {
        printf(&#034;connect: %s\n&#034;, strerror(errno));
        s_close( sock );
        FinalExit( RETURN_ERROR );
    }

    /*
    ** Compose the message packet for transmission
    */

    out.nn_Code = NN_MSG;
    strcpy( (char *)&#038;out.nn_Text, text );
    strcpy( (char *)&#038;out.nn_Button, button );

    /*
    ** Send the packet to the remote system
    */

    send( sock, (char *)&#038;out, sizeof(struct NetNote), 0 );

    printf(&#034;\nMessage sent to %s...waiting for answer...\n&#034;, hostnam );

    /*
    ** Wait for either acknowledge or error.  This is a potential hang
    ** location if the server is mortally wounded.
    */

    recv( sock, (char *)&#038;out, sizeof(struct NetNote), 0 );

    /*
    ** Evaluate the packet returned to us
    */

    if (out.nn_Code == NN_ACK)
    {
        printf(&#034;Response:  Button %ld pressed.\n\n&#034;, out.nn_Retval );
    }
    else
    {
        puts(&#034;Error during message send...please try again later!&#034;);
        FinalExit( RETURN_ERROR );
    }

    /*
    ** Since ReadArgs() was called inside the main() function, the pointer
    ** to the buffer it created needs to be deallocated inside main().
    */

    if (rdargs)
    {
        FreeArgs( rdargs );
    }

    FinalExit( RETURN_OK );

}

/*
**  FinalExit() - Non-returning routine which handles exits and cleanups.
**
**
*/

void    FinalExit( int retcode )
{

	/*
	** If SockBase is non-null, it means that socket.library was opened,
	** and a socket environment was initialized.  Remove the environment
	** and close the library.
	*/

    if (SockBase)
    {
        cleanup_sockets();
        CloseLibrary(SockBase);
    }

	/*
	** Terminate program, handing return code out to the shell handler
	*/

    exit( retcode );
}
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
