<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/34.11 FILE="I-47/EnfMung.txt" NODE="I-47-6" TITLE="More Remote Debugging Tips" -->
<head>
<title>More Remote Debugging Tips</title>
</head>
<body>
<img src="../images/toc_d.gif" alt="[Contents]">
<img src="../images/index_d.gif" alt="[Index]">
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../AmigaMail_Vol2_guide/node0058.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../AmigaMail_Vol2_guide/node005A.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
Debugging with Enforcer and Mungwall is even more effective when an
application sends other debugging information to the serial or parallel
port.  The linker library debug.lib contains a printf()-like function,
kprintf(), to print information to the serial port.  The linker library
ddebug.lib contains a similar function called dprintf() that prints
debugging information to the parallel port.  The output from these
functions intermix with the output from Enforcer and Mungwall, making
it easy to pinpoint which part of the code is causing Enforcer or
Mungwall hits.

Functions like kprintf() and dprintf() are useful, but adding and
removing them from programs can be tedious.  One easy way to deal with
this problem is to include them only when a special label is defined:

    /**********    debug macros     ***********/
    #define MYDEBUG  1
    void kprintf(UBYTE *fmt,...);
    void dprintf(UBYTE *fmt,...);
    #define DEBTIME 0
    #define bug printf
    #if MYDEBUG
    #define D(x) (x); if(DEBTIME&#062;0) Delay(DEBTIME);
    #else
    #define D(x) ;
    #endif /* MYDEBUG */
    /********** end of debug macros **********/

Set MYDEBUG to 1 to turn on debugging.  Set ``bug'' to:
    ``printf'' to send debugging information to the default console,
    ``kprintf'' to send debugging information to the serial port
            (link with debug.lib), and
    ``dprintf'' to send debugging information to the parallel port
            (link with ddebug.lib).

When using this macro, make sure there two close parentheses before the
semicolon at the end of each D(bug()) statement.

Example macro usage:

        win = OpenWindow(&#038;mynewwin);
        D(bug(&#034;Opened window at $%lx\n&#034;, win));

A different low-level method of figuring out which instructions caused
an Enforcer hit is to disassemble program memory where the hit
occurred.  First, match the disassembly with your own code.  Assembly
programmers could just compare the disassembly to their source.  Others
could take the hex values of a sequence of position-independent 68000
instructions near the hit (i.e.  no addresses except for offsets and
branches) and do a search for this pattern in your object modules.  If
you find the pattern, do a mixed source and object disassembly of that
object module and then look in the output for instructions matching
those where the hit occurred.   For example, with SAS's OMD you could
compile your code with the flag -d1, then do the following:

    1.Ram Disk:&#062; OMD &#062;ram:dump mymodule.o mymodule.c
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
