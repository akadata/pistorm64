<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/34.11 FILE="IX-1/4play.c" NODE="MAIN" TITLE="IX-1/4play.c" -->
<head>
<title>IX-1/4play.c</title>
</head>
<body>
<img src="../images/toc_d.gif" alt="[Contents]">
<img src="../images/index_d.gif" alt="[Index]">
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../AmigaMail_Vol2_guide/node01FD.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../AmigaMail_Vol2_guide/node01FF.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
/*
 * 4play.c
 */

#include    &#060;exec/types.h&#062;
#include    &#060;libraries/dos.h&#062;

#include    &#060;stdlib.h&#062;
#include    &#060;stdio.h&#062;

#include    &#060;clib/exec_protos.h&#062;

UBYTE portdata;
UBYTE *portptr = &#038;portdata;

UBYTE firedata;
UBYTE *fireptr = &#038;firedata;

extern int getport(void);
extern void read34(void);
extern void freeport(void);


/*
 * Lattice control-c stop...
 */
int CXBRK(void) { return(0); }      /* Disable Lattice CTRL/C handling */
int chkabort(void) { return(0); }   /* really */


void Quit(char whytext[], LONG return_code)
{
    if(return_code==0) freeport();  /* Assembly routine to
                                       de-allocate parallel port */

    printf(&#034;%s\n&#034;,whytext);

    exit(return_code);              /* returning non-zero
                                       terminates the program */
}


void main(void)
{
    BOOL done=FALSE;
    UBYTE error;

    /* getport() is an assembly routine that allocates the parallel port
     * and makes all the lines we're interested in &#034;read&#034; lines.
     */
    if(error=getport()) Quit(&#034;Parallel port in use&#034;,25);
    /* WARNING:
     * This example continuously reads the ports and checks for CTRL_C,
     * thereby eating a lot of CPU time.  Actual applications that expect
     * to be even more system friendly might want to set up some interrupts
     * on the fire button lines, such that the game can read the ports less
     * often, but never miss a &#034;fire&#034; press.
     */

    while(!done)
    {
        read34();       /* read34() is the assembly routine that copies the
                         * relavent data from the port into our variables.
                         */

        /* We'll just print the raw bytes from the read, and leave it as an
         * exercise for the reader to mask out the relevant bits.
         * (Check the pinouts to find which bits the switches appear at.)
         */
        printf(&#034;portdata = %u, firedata = %u\n&#034;,portdata,firedata);

        /* Check CTRL_C */
        if(SetSignal(0L,0L) &#038; SIGBREAKF_CTRL_C) /* Hit since last check? */
        {
            SetSignal(0L,SIGBREAKF_CTRL_C); /* Clear old status */
            done=TRUE;
        }
    }
    Quit(&#034;Ctrl-C was pressed.&#034;,0);
}
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
