<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/34.11 FILE="Lib_examples/mousetest.c" NODE="MAIN" TITLE="Lib_examples/mousetest.c" -->
<head>
<title>Lib_examples/mousetest.c</title>
</head>
<body>
<img src="../images/toc_d.gif" alt="[Contents]">
<img src="../images/index_d.gif" alt="[Index]">
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../Libraries_Manual_guide/node05A8.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../Libraries_Manual_guide/node05AA.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
;/* mousetest.c - Execute me to compile me with SAS C 5.10
LC -b1 -cfistq -v -y -j73 mousetest.c
Blink FROM LIB:c.o,mousetest.o TO mousetest LIBRARY LIB:LC.lib,LIB:Amiga.lib
quit

** mousetest.c - Read position and button events from the mouse.
*/
#define INTUI_V36_NAMES_ONLY

#include &#060;exec/types.h&#062;
#include &#060;intuition/intuition.h&#062;
#include &#060;graphics/gfxbase.h&#062;
#include &#060;devices/inputevent.h&#062;

#include &#060;clib/exec_protos.h&#062;
#include &#060;clib/graphics_protos.h&#062;
#include &#060;clib/intuition_protos.h&#062;

#include &#060;stdio.h&#062;

#ifdef LATTICE
int CXBRK(void)    { return(0); }  /* Disable Lattice CTRL/C handling */
int chkabort(void) { return(0); }  /* really */
#endif

#define BUFSIZE 16

/* something to use to track the time between messages
** to test for double-clicks.
*/
typedef struct myTimeVal
    {
    ULONG LeftSeconds;
    ULONG LeftMicros;
    ULONG RightSeconds;
    ULONG RightMicros;
    } MYTIMEVAL;


/* our function prototypes */
VOID doButtons(struct IntuiMessage *msg, MYTIMEVAL *tv);
VOID process_window(struct Window *win);

struct Library *IntuitionBase;
struct GfxBase       *GfxBase;	/* we need GfxBase-&#062;DefaultFont */


/*
** main() -- set-up everything.
*/
VOID main(int argc, char **argv)
{
struct Window *win;
struct Screen *scr;
struct DrawInfo *dr_info;
ULONG width;

/* Open the libraries we will use.  Requires Release 2 (KS V2.04, V37) */
if (IntuitionBase = OpenLibrary(&#034;intuition.library&#034;,37))
    {
    if (GfxBase = (struct GfxBase *)OpenLibrary(&#034;graphics.library&#034;, 37))
        {
        /* Lock the default public screen in order to read its DrawInfo data */
        if (scr = LockPubScreen(NULL))
            {
            if (dr_info = GetScreenDrawInfo(scr))
                {
                /* use wider of space needed for output (18 chars and spaces)
                 * or titlebar text plus room for titlebar gads (approx 18 each)
                 */
                width = max((GfxBase-&#062;DefaultFont-&#062;tf_XSize * 18),
                            (18 * 2) + TextLength(&#038;scr-&#062;RastPort,&#034;MouseTest&#034;,9));

                if (win = OpenWindowTags(NULL,
                            WA_Top,    20,
                            WA_Left,   100,
                            WA_InnerWidth,  width,
                            WA_Height, (2 * GfxBase-&#062;DefaultFont-&#062;tf_YSize) +
                                       scr-&#062;WBorTop + scr-&#062;Font-&#062;ta_YSize + 1 +
                                       scr-&#062;WBorBottom,
                            WA_Flags, WFLG_DEPTHGADGET | WFLG_CLOSEGADGET |
                                      WFLG_ACTIVATE    | WFLG_REPORTMOUSE |
                                      WFLG_RMBTRAP     | WFLG_DRAGBAR,
                            WA_IDCMP, IDCMP_CLOSEWINDOW | IDCMP_RAWKEY |
                                      IDCMP_MOUSEMOVE   | IDCMP_MOUSEBUTTONS,
                            WA_Title, &#034;MouseTest&#034;,
                            WA_PubScreen, scr,
                            TAG_END))
                    {
                    printf(&#034;Monitors the Mouse:\n&#034;);
                    printf(&#034;    Move Mouse, Click and DoubleClick in Window\n&#034;);

                    SetAPen(win-&#062;RPort,dr_info-&#062;dri_Pens[TEXTPEN]);
                    SetBPen(win-&#062;RPort,dr_info-&#062;dri_Pens[BACKGROUNDPEN]);
                    SetDrMd(win-&#062;RPort,JAM2);

                    process_window(win);

                    CloseWindow(win);
                    }
                FreeScreenDrawInfo(scr, dr_info);
                }
            UnlockPubScreen(NULL,scr);
            }
        CloseLibrary((struct Library *)GfxBase);
        }
    CloseLibrary(IntuitionBase);
    }
}

/*
** process_window() - simple message loop for processing IntuiMessages
*/
VOID process_window(struct Window *win)
{
USHORT done;
struct IntuiMessage *msg;
MYTIMEVAL tv;
UBYTE prt_buff[14];
LONG xText, yText;  /* places to position text in window. */

done = FALSE;
tv.LeftSeconds = 0; /* initial values for testing double-click */
tv.LeftMicros  = 0;
tv.RightSeconds = 0;
tv.RightMicros  = 0;
xText = win-&#062;BorderLeft + (win-&#062;IFont-&#062;tf_XSize * 2);
yText = win-&#062;BorderTop + 3 + win-&#062;IFont-&#062;tf_Baseline;

while (!done)
    {
    Wait((1L&#060;&#060;win-&#062;UserPort-&#062;mp_SigBit));

    while ((!done) &#038;&#038;
           (msg = (struct IntuiMessage *)GetMsg(win-&#062;UserPort)))
        {
        switch (msg-&#062;Class)
            {
            case IDCMP_CLOSEWINDOW:
                done = TRUE;
                break;
            /* NOTE NOTE NOTE:  If the mouse queue backs up a lot, Intuition
            ** will start dropping MOUSEMOVE messages off the end until the
            ** queue is serviced.  This may cause the program to lose some
            ** of the MOUSEMOVE events at the end of the stream.
            **
            ** Look in the window structure if you need the true position
            ** of the mouse pointer at any given time.  Look in the
            ** MOUSEBUTTONS message if you need position when it clicked.
            ** An alternate to this processing would be to set a flag that
            ** a mousemove event arrived, then print the position of the
            ** mouse outside of the &#034;while (GetMsg())&#034; loop.  This allows
            ** a single processing call for many mouse events, which speeds
            ** up processing A LOT!  Something like:
            **
            ** while (GetMsg())
            **    {
            **    if (class == IDCMP_MOUSEMOVE)
            **        mouse_flag = TRUE;
            **    ReplyMsg();   NOTE: copy out all needed fields first !
            **    }
            ** if (mouse_flag)
            **    {
            **    process_mouse_event();
            **    mouse_flag = FALSE;
            **    }
            **
            ** You can also use IDCMP_INTUITICKS for slower paced messages
            ** (all messages have mouse coordinates.)
            */
            case IDCMP_MOUSEMOVE:
                /* Show the current position of the mouse relative to the
                ** upper left hand corner of our window
                */
                Move(win-&#062;RPort,xText,yText);
                sprintf(prt_buff, &#034;X%5d Y%5d&#034;, msg-&#062;MouseX, msg-&#062;MouseY);
                Text(win-&#062;RPort,prt_buff,13);
                break;
            case IDCMP_MOUSEBUTTONS:
                doButtons(msg,&#038;tv);
                break;
            }
        ReplyMsg((struct Message *)msg);
        }
    }
}

/*
** Show what mouse buttons where pushed
*/
VOID doButtons(struct IntuiMessage *msg, MYTIMEVAL *tv)
{
/* Yes, qualifiers can apply to the mouse also.  That is how
** we get the shift select on the Workbench.  This shows how
** to see if a specific bit is set within the qualifier
*/
if (msg-&#062;Qualifier &#038; (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT))
    printf(&#034;Shift &#034;);

switch (msg-&#062;Code)
    {
    case SELECTDOWN:
        printf(&#034;Left Button Down at X%ld Y%ld&#034;, msg-&#062;MouseX, msg-&#062;MouseY);
        if(DoubleClick(tv-&#062;LeftSeconds, tv-&#062;LeftMicros, msg-&#062;Seconds, msg-&#062;Micros))
            printf(&#034; DoubleClick!&#034;);
        else
            {
            tv-&#062;LeftSeconds = msg-&#062;Seconds;
            tv-&#062;LeftMicros  = msg-&#062;Micros;
            tv-&#062;RightSeconds = 0;
            tv-&#062;RightMicros  = 0;
            }
        break;
    case SELECTUP:
        printf(&#034;Left Button Up   at X%ld Y%ld&#034;, msg-&#062;MouseX, msg-&#062;MouseY);
        break;
    case MENUDOWN:
        printf(&#034;Right Button down at X%ld Y%ld&#034;, msg-&#062;MouseX, msg-&#062;MouseY);
        if(DoubleClick(tv-&#062;RightSeconds, tv-&#062;RightMicros, msg-&#062;Seconds, msg-&#062;Micros))
            printf(&#034; DoubleClick!&#034;);
        else
            {
            tv-&#062;LeftSeconds = 0;
            tv-&#062;LeftMicros  = 0;
            tv-&#062;RightSeconds = msg-&#062;Seconds;
            tv-&#062;RightMicros  = msg-&#062;Micros;
            }
        break;
    case MENUUP:
        printf(&#034;Right Button Up   at X%ld Y%ld&#034;, msg-&#062;MouseX, msg-&#062;MouseY);
        break;
    }
printf(&#034;\n&#034;);
}
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
