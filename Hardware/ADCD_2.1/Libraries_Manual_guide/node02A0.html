<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/34.11 FILE="Libraries/Lib_19" NODE="19-3-1" TITLE="19 / Using A Device / Synchronous Vs. Asynchronous Requests" INDEX="Libraries/Lib_Index/MAIN" -->
<head>
<title>19 / Using A Device / Synchronous Vs. Asynchronous Requests</title>
</head>
<body>
<img src="../images/toc_d.gif" alt="[Contents]">
<a href="../Libraries_Manual_guide/node002C.html"><img src="../images/index.gif" alt="[Index]" border=0></a>
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../Libraries_Manual_guide/node029F.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../Libraries_Manual_guide/node02A1.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
As stated above, you can send I/O requests to a device synchronously or
asynchronously.  The choice of which to use is largely a function of your
<a name="line4">application.</a>

Synchronous requests use the <a href="../Libraries_Manual_guide/node029F.html#line8">DoIO()</a> function.  DoIO() will not return
control to your application until the I/O request has been satisfied by
the device.  The advantage of this is that you don't have to monitor the
message port for the device reply because DoIO() takes care of all the
message handling.  The disadvantage is that your application will be tied
up while the I/O request is being processed, and should the request not
complete for some reason, DoIO() will not return and your application will
<a name="line13">hang.</a>

Asynchronous requests use the <a href="../Libraries_Manual_guide/node029F.html#line13">SendIO()</a> and <a href="../Libraries_Manual_guide/node029F.html#line21">BeginIO()</a> functions.  Both
return to your application almost immediately after you call them.  This
allows you to do other operations, including sending more I/O requests to
the device.  Note that any additional I/O requests you send must use
separate I/O request structures. Outstanding I/O requests are not
available for re-use until the device is finished with them.

    Do Not Touch!
    -------------
    When you use <a href="../Libraries_Manual_guide/node029F.html#line13">SendIO()</a> or <a href="../Libraries_Manual_guide/node029F.html#line21">BeginIO()</a>, the I/O request you pass to
    the device and any associated data buffers should be considered
    read-only.  Once you send it to the device, you must not modify it
    in any way until you receive the reply message from the device or
<a name="line28">    abort the request.</a>

Sending multiple asynchronous I/O requests to a device can be tricky
because devices require them to be unique and initialized.  This means you
can't use an I/O request that's still in the queue, but you need the
fields which were initialized in it when you opened the device.  The
solution is to copy the initialized I/O request to another I/O request(s)
before sending anything to the device.

Regardless of what you do while you are waiting for an asynchronous I/O
request to return, you need to have some mechanism for knowing when the
request has been done.  There are two basic methods for doing this.

The first involves putting your application into a wait state until the
device returns the I/O request to the message port of your application.
You can use the <a href="../Includes_and_Autodocs_2._guide/node038B.html">WaitIO()</a>, <a href="../Libraries_Manual_guide/node02D4.html">Wait()</a> or <a href="../Libraries_Manual_guide/node02F1.html#line9">WaitPort()</a> function to wait for the
return of the I/O request. It is important to note that all of the above
functions and also <a href="../Libraries_Manual_guide/node029F.html#line8">DoIO()</a> may Wait() on the message reply port's
<a href="../Includes_and_Autodocs_2._guide/node0099.html#line29">mp_SigBit</a>.  For this reason, the task that created the port must be the
same task the waits for completion of the I/O.  There are three ways to
<a name="line48">wait:</a>

      * <a href="../Includes_and_Autodocs_2._guide/node038B.html">WaitIO()</a> not only waits for the return of the I/O request, it
        also takes care of all the message handling functions.  This is
        very convenient, but you can pay for this convenience: your
<a name="line53">        application will hang if the I/O request does not return.</a>

      * <a href="../Libraries_Manual_guide/node02D4.html">Wait()</a> waits for a signal to be sent to the message port.  It
        will awaken your task when the signal arrives, but you are
<a name="line57">        responsible for all of the message handling.</a>

      * <a href="../Libraries_Manual_guide/node02F1.html#line9">WaitPort()</a> waits for the message port to be non-empty.  It
        returns a pointer to the message in the port, but you are
<a name="line61">        responsible for all of the message handling.</a>

The second method to detect when the request is complete involves using
the <a href="../Includes_and_Autodocs_2._guide/node033E.html">CheckIO()</a> function.  CheckIO() takes an I/O request as its argument
and returns an indication of whether or not it has been completed.  When
CheckIO() returns the completed indication, you will still have to remove
the I/O request from the message port.
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
