<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/34.11 FILE="Lib_examples/Sift.c" NODE="MAIN" TITLE="Lib_examples/Sift.c" -->
<head>
<title>Lib_examples/Sift.c</title>
</head>
<body>
<img src="../images/toc_d.gif" alt="[Contents]">
<img src="../images/index_d.gif" alt="[Index]">
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../Libraries_Manual_guide/node059F.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../Libraries_Manual_guide/node05A1.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
;/* sift.c - Execute me to compile me with SAS C 5.10
LC -b1 -cfistq -v -j73 sift.c
Blink FROM LIB:c.o,sift.o TO sift LIBRARY LIB:LC.lib,LIB:Amiga.lib
quit
*
* Sift.c lists the type and size of every chunk in an IFF file and
* checks the IFF file for correct syntax.  You should use Sift to
* check IFF files created by your programs.
*
* sift.c:	Takes any IFF file and tells you what's in it.  Verifies syntax and all that cool stuff.
*
* Usage: sift -c		; For clipboard scanning
*    or  sift &#060;file&#062;		; For DOS file scanning
*
* Reads the specified stream and prints an IFFCheck-like listing of the contents of the IFF file, if any.
* Stream is a DOS file for &#060;file&#062; argument, or is the clipboard's primary clip for -c.
* This program must be run from a CLI.
*
*/

#include &#060;exec/types.h&#062;
#include &#060;exec/memory.h&#062;
#include &#060;libraries/dos.h&#062;
#include &#060;libraries/iffparse.h&#062;
#include &#060;clib/exec_protos.h&#062;
#include &#060;clib/dos_protos.h&#062;
#include &#060;clib/iffparse_protos.h&#062;
#include &#060;stdlib.h&#062;
#include &#060;stdio.h&#062;
#include &#060;string.h&#062;

#ifdef LATTICE
int CXBRK(void) { return(0); }     /* Disable Lattice CTRL/C handling */
int chkabort(void) { return(0); }  /* really */
#endif

#define MINARGS 2

UBYTE vers[] = &#034;\0$VER: sift 37.1&#034;;       /* 2.0 Version string for c:Version to find */
UBYTE usage[] = &#034;Usage: sift IFFfilename (or -c for clipboard)&#034;;

void PrintTopChunk (struct IFFHandle *);  /* proto for our function */

/*
 * Text error messages for possible IFFERR_#? returns from various IFF routines.  To get the index into
 * this array, take your IFFERR code, negate it, and subtract one.
 *  idx = -error - 1;
 */
char	*errormsgs[] = {
	&#034;End of file (not an error).&#034;, &#034;End of context (not an error).&#034;, &#034;No lexical scope.&#034;,
	&#034;Insufficient memory.&#034;, &#034;Stream read error.&#034;, &#034;Stream write error.&#034;,
	&#034;Stream seek error.&#034;, &#034;File is corrupt.&#034;, &#034;IFF syntax error.&#034;,
	&#034;Not an IFF file.&#034;, &#034;Required call-back hook missing.&#034;, &#034;Return to client.  You should never see this.&#034;
};

struct Library *IFFParseBase;

void main(int argc, char **argv)
{
    struct IFFHandle	*iff = NULL;
    long		error;
    short		cbio;

    	/* if not enough args or '?', print usage */
    	if(((argc)&#038;&#038;(argc&#060;MINARGS))||(argv[argc-1][0]=='?'))
		{
	    	printf(&#034;%s\n&#034;,usage);
	    	goto bye;
	    	}

	/* Check to see if we are doing I/O to the Clipboard. */
	cbio = (argv[1][0] == '-'  &#038;&#038;  argv[1][1] == 'c');

	if (!(IFFParseBase = OpenLibrary (&#034;iffparse.library&#034;, 0L)))
		{
		puts(&#034;Can't open iff parsing library.&#034;);
		goto bye;
		}

	/* Allocate IFF_File structure. */
	if (!(iff = AllocIFF ()))
		{
		puts (&#034;AllocIFF() failed.&#034;);
		goto bye;
		}

	/*
	 * Internal support is provided for both AmigaDOS files, and the clipboard.device.  This bizarre
	 * 'if' statement performs the appropriate machinations for each case.
	 */
	if (cbio)
		{
		/*
		 * Set up IFF_File for Clipboard I/O.
		 */
		if (!(iff-&#062;iff_Stream =
				(ULONG) OpenClipboard (PRIMARY_CLIP)))
			{
			puts (&#034;Clipboard open failed.&#034;);
			goto bye;
			}
		InitIFFasClip (iff);
		}
	else
		{
		/* Set up IFF_File for AmigaDOS I/O.  */
		if (!(iff-&#062;iff_Stream = Open (argv[1], MODE_OLDFILE)))
			{
			puts (&#034;File open failed.&#034;);
			goto bye;
			}
		InitIFFasDOS (iff);
		}

	/* Start the IFF transaction. */
	if (error = OpenIFF (iff, IFFF_READ))
		{
		puts (&#034;OpenIFF failed.&#034;);
		goto bye;
		}

	while (1)
		{
		/*
		 * The interesting bit.  IFFPARSE_RAWSTEP permits us to have precision monitoring of the
		 * parsing process, which is necessary if we wish to print the structure of an IFF file.
		 * ParseIFF() with _RAWSTEP will return the following things for the following reasons:
		 *
		 * Return code:			Reason:
		 * 0				Entered new context.
		 * IFFERR_EOC			About to leave a context.
		 * IFFERR_EOF			Encountered end-of-file.
		 * &#060;anything else&#062;		A parsing error.
		 */
		error = ParseIFF (iff, IFFPARSE_RAWSTEP);

		/*
		 * Since we're only interested in when we enter a context, we &#034;discard&#034; end-of-context
		 * (_EOC) events.
		 */
		if (error == IFFERR_EOC)
			continue;
		else if (error)
			/*
			 * Leave the loop if there is any other error.
			 */
			break;


		/* If we get here, error was zero. Print out the current state of affairs. */
		PrintTopChunk (iff);
		}

	/*
	 * If error was IFFERR_EOF, then the parser encountered the end of
	 * the file without problems.  Otherwise, we print a diagnostic.
	 */
	if (error == IFFERR_EOF)
		puts (&#034;File scan complete.&#034;);
	else
		printf (&#034;File scan aborted, error %ld: %s\n&#034;,
			error, errormsgs[-error - 1]);

bye:
	if (iff) {
		/* Terminate the IFF transaction with the stream.  Free all associated structures. */
		CloseIFF (iff);

		/*
		 * Close the stream itself.
		 */
		if (iff-&#062;iff_Stream)
			if (cbio)
				CloseClipboard ((struct ClipboardHandle *)
						iff-&#062;iff_Stream);
			else
				Close (iff-&#062;iff_Stream);

		/* Free the IFF_File structure itself. */
		FreeIFF (iff);
		}
	if (IFFParseBase)	CloseLibrary (IFFParseBase);

	exit (RETURN_OK);
}

void
PrintTopChunk (iff)
struct IFFHandle *iff;
{
	struct ContextNode	*top;
	short			i;
	char			idbuf[5];

	/* Get a pointer to the context node describing the current context. */
	if (!(top = CurrentChunk (iff)))
		return;

	/*
	 * Print a series of dots equivalent to the current nesting depth of chunks processed so far.
	 * This will cause nested chunks to be printed out indented.
	 */
	for (i = iff-&#062;iff_Depth;  i--; )
		printf (&#034;. &#034;);

	/* Print out the current chunk's ID and size. */
	printf (&#034;%s %ld &#034;, IDtoStr (top-&#062;cn_ID, idbuf), top-&#062;cn_Size);

	/* Print the current chunk's type, with a newline. */
	puts (IDtoStr (top-&#062;cn_Type, idbuf));
}
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
