<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/34.11 FILE="Libraries/Lib_27" NODE="27-2-6" TITLE="27 / Display Routines and Structures / Viewport Display Memory" INDEX="Libraries/Lib_Index/MAIN" -->
<head>
<title>27 / Display Routines and Structures / Viewport Display Memory</title>
</head>
<body>
<img src="../images/toc_d.gif" alt="[Contents]">
<a href="../Libraries_Manual_guide/node002C.html"><img src="../images/index.gif" alt="[Index]" border=0></a>
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../Libraries_Manual_guide/node032A.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../Libraries_Manual_guide/node032C.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
The picture you create in memory can be larger than the screen image that
can be displayed within your ViewPort.  This big picture (called a raster
and represented by the BitMap structure) can have a maximum size dependent
upon the version of the Agnus chip in the Amiga.  The ECS Agnus can handle
rasters up to 16,384 by 16,384 pixels.  Older Agnus chips are limited to
rasters up to 1,024 by 1,024 pixels.  The section earlier in this chapter
on &#034;<a href="../Libraries_Manual_guide/node031D.html">Determining Chip Versions</a>&#034; explains how to find out which Agnus is
<a name="line9">installed.</a>

The example in the following figure introduces terms that tell the system
how to find the display data and how to display it in the ViewPort. These
terms are RHeight, RWidth, <a href="../Includes_and_Autodocs_2._guide/node00B8.html#line106">RyOffset,</a> <a href="../Includes_and_Autodocs_2._guide/node00B8.html#line106">RxOffset,</a> <a href="../Libraries_Manual_guide/node0324.html">DHeight</a>, <a href="../Libraries_Manual_guide/node0325.html">DWidth</a>, <a href="../Includes_and_Autodocs_2._guide/node00B8.html#line40">DyOffset</a>
and <a href="../Includes_and_Autodocs_2._guide/node00B8.html#line40">DxOffset</a>.

<a name="line16">     <a href="../Libraries_Manual_guide/node05F1.html">Figure 27-16: ViewPort Data Area Parameters</a></a>

The terms RHeight and RWidth do not appear in actual system data
structures.  They refer to the dimensions of the raster and are used here
to relate the size of the raster to the size of the display area. RHeight
is the number of rows in the raster and RWidth is the number of bytes per
row times 8.  The raster shown in the figure is too big to fit entirely in
the display area, so you tell the system which pixel of the raster should
appear in the upper left corner of the display segment specified by your
ViewPort.  The variables that control that placement are <a href="../Includes_and_Autodocs_2._guide/node00B8.html#line106">RyOffset</a> and
<a name="line26"><a href="../Includes_and_Autodocs_2._guide/node00B8.html#line106">RxOffset</a>.</a>

To compute <a href="../Includes_and_Autodocs_2._guide/node00B8.html#line106">RyOffset</a> and <a href="../Includes_and_Autodocs_2._guide/node00B8.html#line106">RxOffset</a>, you need RHeight, RWidth, <a href="../Libraries_Manual_guide/node0324.html">DHeight</a>, and
<a href="../Libraries_Manual_guide/node0325.html">DWidth</a>.  The DHeight and DWidth variables define the height and width in
pixels of the portion of the display that you want to appear in the
ViewPort.  The example shows a full-screen, low-resolution mode
(320-pixel), non-interlaced (200-line) display formed from the larger
overall picture.

Normal values for <a href="../Includes_and_Autodocs_2._guide/node00B8.html#line106">RyOffset</a> and <a href="../Includes_and_Autodocs_2._guide/node00B8.html#line106">RxOffset</a> are defined by the formulas:

    0 &#060; = RyOffset &#060; = (RHeight - DHeight)
<a name="line38">    0 &#060; = RxOffset &#060; = (RWidth - DWidth)</a>

Once you have defined the size of the raster and the section of that
raster that you wish to display, you need only specify where to put this
ViewPort on the screen.  This is controlled by the ViewPort variables
<a href="../Includes_and_Autodocs_2._guide/node00B8.html#line40">DyOffset</a> and <a href="../Includes_and_Autodocs_2._guide/node00B8.html#line40">DxOffset</a>.  These are offsets relative to the <a href="../Includes_and_Autodocs_2._guide/node00B8.html#line57">View.DxOffset</a>
and <a href="../Includes_and_Autodocs_2._guide/node00B8.html#line57">DyOffset</a>. Possible NTSC values for DyOffset range from -23 to +217
(-46 to +434 if the ViewPort is interlaced), PAL values range from -15 to
+267 (-30 to +534 for interlaced ViewPorts).  Possible values for DxOffset
range from -18 to +362 (-36 to +724 if the ViewPort is Hires, -72 to +1448
if SuperHires), when the View is in its default, initialized position.

The parameters shown in the figure above are distributed in the following
<a name="line51">data structures:</a>

  * <a href="../Includes_and_Autodocs_2._guide/node00B8.html#line57">View</a> (information about the whole display) includes the variables
    that you use to position the whole display on the screen.  The View
    structure contains a Modes field used to determine if the whole
    display is to be interlaced or non-interlaced.  It also contains
    pointers to its list of ViewPorts and pointers to the Copper
    instructions produced by the system to create the display you have
<a name="line59">    defined.</a>

  * <a href="../Includes_and_Autodocs_2._guide/node00B8.html#line40">ViewPort</a> (information about this segment of the display) includes the
    values <a href="../Includes_and_Autodocs_2._guide/node00B8.html#line40">DxOffset</a> and <a href="../Includes_and_Autodocs_2._guide/node00B8.html#line40">DyOffset</a> that are used to position this portion
    relative to the overall View.  The ViewPort also contains the
    variables <a href="../Libraries_Manual_guide/node0324.html">DHeight</a> and <a href="../Libraries_Manual_guide/node0325.html">DWidth</a>, which define the size of this display
    segment; a <a href="../Libraries_Manual_guide/node0327.html">Modes</a> variable; and a pointer to the local <a href="../Libraries_Manual_guide/node00F1.html#line4">ColorMap</a>.
    Under Release 2, the <a href="../Libraries_Manual_guide/node0339.html#line15">VideoControl()</a> function and its various tags are
    used to manipulate the ColorMap and ViewPort.Modes.  Each ViewPort
    also contains a pointer to the next ViewPort.  You create a linked
<a name="line69">    list of ViewPorts to define the complete display.</a>

  * <a href="../Includes_and_Autodocs_2._guide/node00B8.html#line106">RasInfo</a> (information about the raster) contains the variables
    <a href="../Includes_and_Autodocs_2._guide/node00B8.html#line106">RxOffset</a> and <a href="../Includes_and_Autodocs_2._guide/node00B8.html#line106">RyOffset</a>. It also contains pointers to the BitMap
    structure and to a companion RasInfo structure if this is a dual
<a name="line74">    playfield.</a>

  * <a href="../Includes_and_Autodocs_2._guide/node00A6.html#line47">BitMap</a> (information about memory usage) tells the system where to
    find the display and drawing area memory and shows how this memory
    space is organized, including the display's depth.

You must allocate enough memory for the display you define. The memory you
use for the display may be shared with the area control structures used
for drawing.  This allows you to draw into the same areas that you are
currently displaying on the screen.

As an alternative, you can define two BitMaps.  One of them can be the
active structure (that being displayed) and the other can be the inactive
structure.  If you draw into one BitMap while displaying another, the user
cannot see the drawing taking place. This is called double-buffering of
the display.  See &#034;<a href="../Libraries_Manual_guide/node0346.html">Advanced Topics</a>&#034; below for an explanation of the steps
required for double-buffering.  Double-buffering takes twice as much
<a name="line91">memory as single-buffering because two full displays are produced.</a>

To determine the amount of required memory for each ViewPort for
single-buffering, you can use the following formula.

    #include &#060;graphics/gfx.h&#062;

    /* Depth, Width, and Height get set to something reasonable. */
    UBYTE Depth, Width, Height;

    /* Calculate resulting VP size. */
<a name="line102">    bytes_per_ViewPort = Depth * RASSIZE(Width, Height);</a>

RASSIZE() is a system macro attuned to the current design of the system
memory allocation for display rasters.  See the &#060;graphics/<a href="../Includes_and_Autodocs_2._guide/node00A6.html#line57">gfx.h</a>&#062; include
file for the formula with which RASSIZE() is calculated.

For example, a 32-color ViewPort (depth = 5), 320 pixels wide by 200 lines
high currently uses 40,000 bytes.  A 16-color ViewPort (depth = 4), 640
pixels wide by 400 lines high currently uses 128,000 bytes.
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
