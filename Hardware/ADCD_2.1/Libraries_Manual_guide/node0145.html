<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/34.11 FILE="Libraries/Lib_5" NODE="5-6-2-1" TITLE="5 / / Gadget Refreshing by the Program / Updating a Gadget's Imagery" INDEX="Libraries/Lib_Index/MAIN" -->
<head>
<title>5 / / Gadget Refreshing by the Program / Updating a Gadget's Imagery</title>
</head>
<body>
<img src="../images/toc_d.gif" alt="[Contents]">
<a href="../Libraries_Manual_guide/node002C.html"><img src="../images/index.gif" alt="[Index]" border=0></a>
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../Libraries_Manual_guide/node0144.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../Libraries_Manual_guide/node0146.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
The <a href="../Libraries_Manual_guide/node0146.html">RefreshGList()</a> function was designed to draw gadgets from scratch, and
assumes that the underlying area is blank.  This function cannot be used
blindly to update gadget imagery.  The typical problem that arises is that
the application cannot change a gadget from selected to unselected state
(or from disabled to enabled state) and have the imagery appear correct.
However, with a little care, the desired results can be obtained.

Depending on the imagery you select for your gadget, the rendering of one
state may not completely overwrite the rendering of a previous one.  For
example, consider a button which consists of a complement-highlighted
<a href="../Libraries_Manual_guide/node014C.html">boolean</a> gadget, whose imagery is a surrounding <a href="../Libraries_Manual_guide/node01C1.html">Border</a> and whose label is
an <a href="../Libraries_Manual_guide/node01C7.html">IntuiText</a>.  Attempting to visually unselect such a gadget by clearing
its <a href="../Libraries_Manual_guide/node014A.html#line63">GFLG_SELECTED</a> flag and refreshing it will leave incorrect imagery
because <a href="../Libraries_Manual_guide/node0146.html">RefreshGList()</a> just redraws the border and text, and never knows
to erase the field area around the text and inside the gadget.  That area
will remain complemented from before.

One solution is to use a gadget whose imagery is certain to overwrite any
imagery left over from a different state.  Disabling a gadget or
highlighting it with complement mode affects the imagery in the entire
select box.  To overwrite this successfully, the gadget's imagery
(<a href="../Libraries_Manual_guide/node0149.html#line91">GadgetRender</a>) should be an <a href="../Libraries_Manual_guide/node01BA.html">Image</a> structure which fully covers the select
box.  Such a gadget may be highlighted with color complementing
(<a href="../Libraries_Manual_guide/node014A.html#line8">GFLG_GADGHCOMP</a>), or with an alternate image (<a href="../Libraries_Manual_guide/node014A.html#line16">GFLG_GADGHIMAGE</a>) for its
<a href="../Libraries_Manual_guide/node0149.html#line102">SelectRender</a>.  Or, for a gadget which will never be disabled but needs to
be deselected programmatically, you may also use a <a href="../Libraries_Manual_guide/node01C1.html">Border</a> structure for
its GadgetRender, and an identically-shaped (but differently colored)
Border for its SelectRender.

The other technique is to pre-clear the underlying area before
re-rendering the gadget.  To do this, remove the gadget, erase the
rectangle of the gadget's select area, change the <a href="../Libraries_Manual_guide/node014A.html#line63">GFLG_SELECTED</a> or the
<a href="../Libraries_Manual_guide/node014A.html#line73">GFLG_DISABLED</a> flag, add the gadget back, and refresh it.

If the gadget has a relative size and/or position (i.e., if of the
GFLG_RELxxx flags are used), then the application will need to compute the
rectangle of the gadget's select area based on the window's current width
and/or height.  Since the window size is involved in the calculation, it
is important that the window not change size between the call to
<a href="../Libraries_Manual_guide/node0133.html#line27">RemoveGList()</a> and the call to <a href="../Libraries_Manual_guide/node035F.html">RectFill()</a>.  To ensure this, the application
should set <a href="../Libraries_Manual_guide/node01E0.html#line28">IDCMP_SIZEVERIFY</a> so that Intuition will first notify you before
beginning a sizing operation.  (Note that applications using any of the
IDCMP verify events such as IDCMP_SIZEVERIFY should not delay long in
processing such events, since that holds up the user, and also Intuition
may give up and stop waiting for you).
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
