<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/34.11 FILE="Lib_examples/eventloop.c" NODE="MAIN" TITLE="Lib_examples/eventloop.c" -->
<head>
<title>Lib_examples/eventloop.c</title>
</head>
<body>
<img src="../images/toc_d.gif" alt="[Contents]">
<img src="../images/index_d.gif" alt="[Index]">
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../Libraries_Manual_guide/node0589.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../Libraries_Manual_guide/node058B.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
;/* eventloop.c - Execute me to compile me with SAS C 5.10
LC -b1 -cfistq -v -y -j73 eventloop.c
Blink FROM LIB:c.o,eventloop.o TO eventloop LIBRARY LIB:LC.lib,LIB:Amiga.lib
quit
**
** This example shows how to receive Intuition events.  It reports on a
** variety of events: close window, keyboard, disk insertion and removal,
** select button up and down and menu button up and down.  Note that the
** menu button events will only be received by the program if the
** WA_RMBTrap attribute is set for the window.
**
** eventloop.c - standard technique to handle IntuiMessages from an IDCMP.
*/
#define INTUI_V36_NAMES_ONLY

#include &#060;exec/types.h&#062;
#include &#060;intuition/intuition.h&#062;

#include &#060;clib/exec_protos.h&#062;
#include &#060;clib/intuition_protos.h&#062;

#include &#060;stdio.h&#062;

#ifdef LATTICE
int CXBRK(void)    { return(0); }  /* Disable Lattice CTRL/C handling */
int chkabort(void) { return(0); }  /* really */
#endif

/* our function prototypes */
BOOL handleIDCMP(struct Window *win, BOOL done);

struct Library *IntuitionBase = NULL;


/*
** main routine.
** Open required library and window, then process the events from the
** window.  Free all resources when done.
*/
VOID main(int argc, char **argv)
{
ULONG signals;
UBYTE done;
struct Window *win;

IntuitionBase = (struct IntuitionBase *)OpenLibrary(&#034;intuition.library&#034;,37);
if (IntuitionBase != NULL)
    {
    if (win = OpenWindowTags(NULL,
                        WA_Title,       &#034;Press Keys and Mouse in this Window&#034;,
                        WA_Width,       500,
                        WA_Height,      50,
                        WA_Activate,    TRUE,
                        WA_CloseGadget, TRUE,
                        WA_RMBTrap,     TRUE,
                        WA_IDCMP, IDCMP_CLOSEWINDOW | IDCMP_VANILLAKEY |
                            IDCMP_RAWKEY | IDCMP_DISKINSERTED |
                            IDCMP_DISKREMOVED | IDCMP_MOUSEBUTTONS,
                        TAG_END))
        {
        done = FALSE;

        /* perform this loop until the message handling routine signals
        ** that we are done.
        **
        ** When the Wait() returns, check which signal hit and process
        ** the correct port.  There is only one port here, so the test
        ** could be eliminated.  If multiple ports were being watched,
        ** the test would become:
        **
        **    signals = Wait( (1L &#060;&#060; win1-&#062;UserPort-&#062;mp_SigBit) |
        **                    (1L &#060;&#060; win2-&#062;UserPort-&#062;mp_SigBit) |
        **                    (1L &#060;&#060; win3-&#062;UserPort-&#062;mp_SigBit))
        **    if (signals &#038; (1L &#060;&#060; win1-&#062;UserPort-&#062;mp_SigBit))
        **        done = handleWin1IDCMP(win1,done);
        **    else if (signals &#038; (1L &#060;&#060; win2-&#062;UserPort-&#062;mp_SigBit))
        **        done = handleWin2IDCMP(win2,done);
        **    else if (signals &#038; (1L &#060;&#060; win3-&#062;UserPort-&#062;mp_SigBit))
        **        done = handleWin3IDCMP(win3,done);
        **
        ** Note that these could all call the same routine with different
        ** window pointers (if the handling was identical).
        **
        ** handleIDCMP() should remove all of the messages from the port.
        */
        while (!done)
            {
            signals = Wait(1L &#060;&#060; win-&#062;UserPort-&#062;mp_SigBit);
            if (signals &#038; (1L &#060;&#060; win-&#062;UserPort-&#062;mp_SigBit))
                done = handleIDCMP(win,done);
            };
        CloseWindow(win);
        }
    CloseLibrary(IntuitionBase);
    }
}


/*
** handleIDCMP() - handle all of the messages from an IDCMP.
*/
BOOL handleIDCMP(struct Window *win, BOOL done)
{
struct IntuiMessage *message;
USHORT code;
SHORT mousex, mousey;
ULONG class;

/* Remove all of the messages from the port by calling GetMsg()
** until it returns NULL.
**
** The code should be able to handle three cases:
**
** 1.  No messages waiting at the port, and the first call to GetMsg()
** returns NULL.  In this case the code should do nothing.
**
** 2.  A single message waiting.  The code should remove the message,
** processes it, and finish.
**
** 3.  Multiple messages waiting.  The code should process each waiting
** message, and finish.
*/
while (NULL != (message = (struct IntuiMessage *)GetMsg(win-&#062;UserPort)))
    {
    /* It is often convenient to copy the data out of the message.
    ** In many cases, this lets the application reply to the message
    ** quickly.  Copying the data is not required, if the code does
    ** not reply to the message until the end of the loop, then
    ** it may directly reference the message information anywhere
    ** before the reply.
    */
    class  = message-&#062;Class;
    code   = message-&#062;Code;
    mousex = message-&#062;MouseX;
    mousey = message-&#062;MouseY;

    /* The loop should reply as soon as possible.  Note that the code
    ** may not reference data in the message after replying to the
    ** message.  Thus, the application should not reply to the message
    ** until it is done referencing information in it.
    **
    ** Be sure to reply to every message received with GetMsg().
    */
    ReplyMsg((struct Message *)message);

    /* The class contains the IDCMP type of the message. */
    switch (class)
        {
        case IDCMP_CLOSEWINDOW:
            done = TRUE;
            break;
        case IDCMP_VANILLAKEY:
            printf(&#034;IDCMP_VANILLAKEY (%lc)\n&#034;,code);
            break;
        case IDCMP_RAWKEY:
            printf(&#034;IDCMP_RAWKEY\n&#034;);
            break;
        case IDCMP_DISKINSERTED:
            printf(&#034;IDCMP_DISKINSERTED\n&#034;);
            break;
        case IDCMP_DISKREMOVED:
            printf(&#034;IDCMP_DISKREMOVED\n&#034;);
            break;
        case IDCMP_MOUSEBUTTONS:
            /* the code often contains useful data, such as the ASCII
            ** value (for IDCMP_VANILLAKEY), or the type of button
            ** event here.
            */
            switch (code)
                {
                case SELECTUP:
                    printf(&#034;SELECTUP at %d,%d\n&#034;,mousex,mousey);
                    break;
                case SELECTDOWN:
                    printf(&#034;SELECTDOWN at %d,%d\n&#034;,mousex,mousey);
                    break;
                case MENUUP:
                    printf(&#034;MENUUP\n&#034;);
                    break;
                case MENUDOWN:
                    printf(&#034;MENUDOWN\n&#034;);
                    break;
                default:
                    printf(&#034;UNKNOWN CODE\n&#034;);
                    break;
                }
            break;
        default:
            printf(&#034;Unknown IDCMP message\n&#034;);
            break;
        }
    }
return(done);
}
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
