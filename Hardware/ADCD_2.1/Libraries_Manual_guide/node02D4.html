<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/34.11 FILE="Libraries/Lib_22" NODE="22-1-2" TITLE="22 / The Signal System / Waiting for a Signal" INDEX="Libraries/Lib_Index/MAIN" -->
<head>
<title>22 / The Signal System / Waiting for a Signal</title>
</head>
<body>
<img src="../images/toc_d.gif" alt="[Contents]">
<a href="../Libraries_Manual_guide/node002C.html"><img src="../images/index.gif" alt="[Index]" border=0></a>
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../Libraries_Manual_guide/node02D3.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../Libraries_Manual_guide/node02D5.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
Signals are most often used to wake up a task upon the occurrence of some
external event.  Applications call the Exec <a href="../Includes_and_Autodocs_2._guide/node038A.html">Wait()</a> function, directly or
indirectly, in order to enter a wait state until some external event
triggers a signal which awakens the task.

Though signals are usually not used to interrupt an executing task, they
can be used this way.  Task exceptions, described in the &#034;<a href="../Libraries_Manual_guide/node02C5.html">Exec Tasks</a>&#034;
chapter, allow signals to act as a task-local interrupt.

The <a href="../Includes_and_Autodocs_2._guide/node038A.html">Wait()</a> function specifies the set of signals that will wake up the
task and then puts the task to sleep (into the waiting state).

    ULONG Wait( ULONG signalSet );

Any one signal or any combination of signals from this set are sufficient
to awaken the task.  <a href="../Includes_and_Autodocs_2._guide/node038A.html">Wait()</a> returns a mask indicating which signals
satisfied the Wait() call.  Note that when signals are used in conjunction
with a message port, a set signal bit does not necessarily mean that there
is a message at the message port.  See the &#034;<a href="../Libraries_Manual_guide/node02F1.html">Exec Messages and Ports</a>&#034;
chapter for details about proper handling of messages.

Because tasks (and interrupts) normally execute asynchronously, it is
often possible to receive a particular signal before a task actually
<a href="../Includes_and_Autodocs_2._guide/node038A.html">Wait()s</a> for it.  In such cases the Wait() will be immediately satisfied,
and the task will not be put to sleep.

The <a href="../Includes_and_Autodocs_2._guide/node038A.html">Wait()</a> function implicitly clears those signal bits that satisfied the
wait condition.  This effectively resets those signals for reuse.
However, keep in mind that a task might get more signals while it is still
processing the previous signal.  If the same signal is received multiple
times and the signal bit is not cleared between them, some signals will go
unnoticed.

Be aware that using <a href="../Includes_and_Autodocs_2._guide/node038A.html">Wait()</a> will break a <a href="../Libraries_Manual_guide/node02C2.html#line9">Forbid()</a> or <a href="../Libraries_Manual_guide/node02C3.html#line6">Disable()</a> state.
Wait() cannot be used in supervisor mode or within interrupts.

A task may <a href="../Includes_and_Autodocs_2._guide/node038A.html">Wait()</a> for a combination of signal bits and will wake up when
any of the signals occur.  Wait() returns a signal mask specifying which
signal or signals were received.  Usually the program must check the
returned mask for each signal it was waiting on and take the appropriate
action for each that occurred.  The order in which these bits are checked
is often important.

Here is a hypothetical example of a process that is using the console and
timer devices, and is waiting for a message from either device and a
possible break character issued by the user:

    consoleSignal = 1L &#060;&#060; ConsolePort-&#062;mp_SigBit;
    timerSignal   = 1L &#060;&#060; TimerPort-&#062;mp_SigBit;
    userSignal    = SIGBREAKF_CTRL_C;         /* Defined in &#060;dos/dos.h&#062; */

    signals = Wait(consoleSignal | timerSignal | userSignal);

    if (signals &#038; consoleSignal)
        printf(&#034;new character\n&#034;);

    if (signals &#038; timeOutSignal)
        printf(&#034;timeout\n&#034;);

    if (signals &#038; userSignal)
        printf(&#034;User Ctrl-C Abort\n&#034;);

This code will put the task to sleep waiting for a new character, or the
expiration of a time period, or a Ctrl-C break character issued by the
user.  Notice that this code checks for an incoming character signal
before checking for a timeout.  Although a program can check for the
occurrence of a particular event by checking whether its signal has
occurred, this may lead to busy wait polling.  Such polling is wasteful of
the processor and is usually harmful to the proper function of the Amiga
system.  However, if a program needs to do constant processing and also
check signals (a compiler for example) <a href="../Includes_and_Autodocs_2._guide/node037E.html">SetSignal</a>(0,0) can be used to get a
copy of your task's current signals.

<a name="line75">    ULONG SetSignal( ULONG newSignals, ULONG signalSet );</a>

<a href="../Includes_and_Autodocs_2._guide/node037E.html">SetSignal()</a> can also be used to set or clear the state of the signals.
Implementing this can be dangerous and should generally not be done. The
following fragment illustrates a possible use of SetSignal().

    signals = SetSignal(0,0);           /* Get current state of signals */

    if (signals &#038; SIGBREAKF_CTRL_C)     /* Check for Ctrl-C.           */
        {
        printf(&#034;Break\n&#034;);              /* Ctrl-C signal has been set. */
        SetSignal(0, SIGBREAKF_CTRL_C)  /* Clear Ctrl-C signal.        */
        }
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
