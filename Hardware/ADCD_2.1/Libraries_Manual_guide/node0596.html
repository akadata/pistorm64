<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/34.11 FILE="Lib_examples/strhooks.c" NODE="MAIN" TITLE="Lib_examples/strhooks.c" -->
<head>
<title>Lib_examples/strhooks.c</title>
</head>
<body>
<img src="../images/toc_d.gif" alt="[Contents]">
<img src="../images/index_d.gif" alt="[Index]">
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../Libraries_Manual_guide/node0595.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../Libraries_Manual_guide/node0597.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
;/* strhooks.c - Execute me to compile me with SAS C 5.10
LC -b1 -cfistq -v -y -j73 strhooks.c
Blink FROM LIB:c.o,strhooks.o TO strhooks LIBRARY LIB:LC.lib,LIB:Amiga.lib
quit
**   strhooks.c - string gadget hooks demo
**
** WARNING: This file contains &#034;callback&#034; functions.
** You must disable stack checking (SAS -v flag) for them to work.
*/
#define INTUI_V36_NAMES_ONLY

#include &#060;exec/types.h&#062;
#include &#060;exec/memory.h&#062;
#include &#060;utility/hooks.h&#062;
#include &#060;devices/inputevent.h&#062;
#include &#060;intuition/intuition.h&#062;
#include &#060;intuition/sghooks.h&#062;
#include &#060;graphics/displayinfo.h&#062;

#include &#060;clib/intuition_protos.h&#062;
#include &#060;clib/utility_protos.h&#062;
#include &#060;clib/exec_protos.h&#062;

#ifdef LATTICE
int CXBRK(void)    { return(0); }  /* Disable Lattice CTRL/C handling */
int chkabort(void) { return(0); }  /* really */
#endif

/* our function prototypes */
BOOL IsHexDigit(UBYTE test_char);
ULONG str_hookRoutine(struct Hook *hook, struct SGWork *sgw, ULONG *msg);
void initHook(struct Hook *hook, ULONG (*ccode)());
VOID handleWindow(struct Vars *vars);

struct Library    *IntuitionBase;
struct Library    *UtilityBase;

#define SG_STRLEN     (44)
#define MYSTRGADWIDTH (200)
#define INIT_LATER	0

/* A border for the string gadget */
UWORD strBorderData[] =	/* init elements 5 and 7 later (height adjust) */
    {
    0,0,  MYSTRGADWIDTH + 3,0,  MYSTRGADWIDTH + 3,INIT_LATER,
    0,INIT_LATER,   0,0,
    };
struct Border strBorder =
    {
    -2,-2, 1, 0,JAM1,5,strBorderData,NULL,
    };

/* We'll dynamically allocate/clear most structures, buffers */
struct Vars
    {
    struct Window      *sgg_Window;
    struct Gadget       sgg_Gadget;
    struct StringInfo   sgg_StrInfo;
    struct StringExtend sgg_Extend;
    struct Hook         sgg_Hook;
    UBYTE               sgg_Buff[SG_STRLEN];
    UBYTE               sgg_WBuff[SG_STRLEN];
    UBYTE               sgg_UBuff[SG_STRLEN];
    };

/*   Main entry point.
**
** Open all required libraries, set-up the string gadget.
** Prepare the hook, open the sgg_Window and go...
*/
VOID main(int argc, char **argv)
{
struct Vars   *vars;
struct Screen   *screen;
struct DrawInfo *drawinfo;

if (IntuitionBase = OpenLibrary(&#034;intuition.library&#034;, 37L))
    {
    if (UtilityBase = OpenLibrary(&#034;utility.library&#034;, 37L))
        {
        /* get the correct pens for the screen. */
        if (screen = LockPubScreen(NULL))
            {
            if (drawinfo = GetScreenDrawInfo(screen))
                {
                vars = (struct Vars *)AllocMem(sizeof(struct Vars),MEMF_CLEAR);
                if (vars != NULL)
                    {
                    vars-&#062;sgg_Extend.Pens[0] = drawinfo-&#062;dri_Pens[FILLTEXTPEN];
                    vars-&#062;sgg_Extend.Pens[1] = drawinfo-&#062;dri_Pens[FILLPEN];
                    vars-&#062;sgg_Extend.ActivePens[0] = drawinfo-&#062;dri_Pens[FILLTEXTPEN];
                    vars-&#062;sgg_Extend.ActivePens[1] = drawinfo-&#062;dri_Pens[FILLPEN];
                    vars-&#062;sgg_Extend.EditHook = &#038;(vars-&#062;sgg_Hook);
                    vars-&#062;sgg_Extend.WorkBuffer = vars-&#062;sgg_WBuff;

                    vars-&#062;sgg_StrInfo.Buffer = vars-&#062;sgg_Buff;
                    vars-&#062;sgg_StrInfo.UndoBuffer = vars-&#062;sgg_UBuff;
                    vars-&#062;sgg_StrInfo.MaxChars = SG_STRLEN;
                    vars-&#062;sgg_StrInfo.Extension = &#038;(vars-&#062;sgg_Extend);

                    /* There should probably be a border around the string gadget.
                    ** As is, it is hard to locate when disabled.
                    */
                    vars-&#062;sgg_Gadget.LeftEdge = 20;
                    vars-&#062;sgg_Gadget.TopEdge = 30;
                    vars-&#062;sgg_Gadget.Width = MYSTRGADWIDTH;
                    vars-&#062;sgg_Gadget.Height = screen-&#062;RastPort.TxHeight;
                    vars-&#062;sgg_Gadget.Flags = GFLG_GADGHCOMP | GFLG_STRINGEXTEND;
                    vars-&#062;sgg_Gadget.Activation = GACT_RELVERIFY;
                    vars-&#062;sgg_Gadget.GadgetType = GTYP_STRGADGET;
                    vars-&#062;sgg_Gadget.SpecialInfo = &#038;(vars-&#062;sgg_StrInfo);
                    vars-&#062;sgg_Gadget.GadgetRender = (APTR)&#038;strBorder;
                    strBorderData[5] = strBorderData[7] =
                          screen-&#062;RastPort.TxHeight + 3;

                    initHook(&#038;(vars-&#062;sgg_Hook), str_hookRoutine);

                    if (vars-&#062;sgg_Window = OpenWindowTags(NULL,
                            WA_PubScreen,       screen,
                            WA_Left,      21,   WA_Top,       20,
                            WA_Width,    500,   WA_Height,   150,
                            WA_MinWidth,  50,   WA_MaxWidth,  ~0,
                            WA_MinHeight, 30,   WA_MaxHeight, ~0,
                            WA_SimpleRefresh, TRUE,
                            WA_NoCareRefresh, TRUE,
                            WA_RMBTrap,       TRUE,
                            WA_IDCMP,         IDCMP_GADGETUP | IDCMP_CLOSEWINDOW,
                            WA_Flags,         WFLG_CLOSEGADGET | WFLG_NOCAREREFRESH |
                                              WFLG_DRAGBAR | WFLG_DEPTHGADGET |
                                              WFLG_SIMPLE_REFRESH,
                            WA_Title,         &#034;String Hook Accepts HEX Digits Only&#034;,
                            WA_Gadgets,       &#038;(vars-&#062;sgg_Gadget),
                            TAG_DONE))
                        {
                        handleWindow(vars);

                        CloseWindow(vars-&#062;sgg_Window);
                        }
                    FreeMem(vars,sizeof(struct Vars));
                    }
                FreeScreenDrawInfo(screen, drawinfo);
                }
            UnlockPubScreen(NULL, screen);
            }
        CloseLibrary(UtilityBase);
        }
    CloseLibrary(IntuitionBase);
    }
}


/*
** This is an example string editing hook, which shows the basics of
** creating a string editing function.  This hook restricts entry to
** hexadecimal digits (0-9, A-F, a-f) and converts them to upper case.
** To demonstrate processing of mouse-clicks, this hook also detects
** clicking on a character, and converts it to a zero.
**
** NOTE: String editing hooks are called on Intuition's task context,
** so the hook may not use DOS and may not cause Wait() to be called.
*/

ULONG str_hookRoutine(struct Hook *hook, struct SGWork *sgw, ULONG *msg)
{
UBYTE *work_ptr;
ULONG return_code;

/* Hook must return non-zero if command is supported.
** This will be changed to zero if the command is unsupported.
*/
return_code = ~0L;

if (*msg == SGH_KEY)
    {
    /* key hit -- could be any key (Shift, repeat, character, etc.) */

    /* allow only upper case characters to be entered.
    ** act only on modes that add or update characters in the buffer.
    */
    if ((sgw-&#062;EditOp == EO_REPLACECHAR) ||
        (sgw-&#062;EditOp == EO_INSERTCHAR))
        {
        /* Code contains the ASCII representation of the character
        ** entered, if it maps to a single byte.  We could also look
        ** into the work buffer to find the new character.
        **
        **     sgw-&#062;Code == sgw-&#062;WorkBuffer[sgw-&#062;BufferPos - 1]
        **
        ** If the character is not a legal hex digit, don't use
        ** the work buffer and beep the screen.
        */
        if (!IsHexDigit(sgw-&#062;Code))
            {
            sgw-&#062;Actions |= SGA_BEEP;
            sgw-&#062;Actions &#038;= ~SGA_USE;
            }
        else
            {
            /* And make it upper-case, for nicety */
            sgw-&#062;WorkBuffer[sgw-&#062;BufferPos - 1] = ToUpper(sgw-&#062;Code);
            }
        }
    }
else if (*msg == SGH_CLICK)
    {
    /* mouse click
    ** zero the digit clicked on
    */
    if (sgw-&#062;BufferPos &#060; sgw-&#062;NumChars)
        {
        work_ptr = sgw-&#062;WorkBuffer + sgw-&#062;BufferPos;
        *work_ptr = '0';
        }
    }
else
    {
    /* UNKNOWN COMMAND
    ** hook should return zero if the command is not supported.
    */
    return_code = 0;
    }

return(return_code);
}



/*
** This is a function which converts register-parameter
** hook calling convention into standard C conventions.
** It only works with SAS C 5.0+
**
** Without the fancy __asm stuff, you'd probably need to
** write this in assembler.
**
** You could conceivably declare all your C hook functions
** this way, and eliminate the middleman (you'd initialize
** the h_Entry field to your C function's address, and not
** bother with the h_SubEntry field).
**
** This is nice and easy, though, and since we're using the
** small data model, using a single interface routine like this
** (which does the necessary __saveds), it might
** actually turn out to be smaller to use a single entry point
** like this rather than declaring each of many hooks __saveds.
*/
ULONG __saveds __asm hookEntry(register __a0 struct Hook *hookptr,
    register __a2 void  *object,
    register __a1 void  *message)
{
return((*hookptr-&#062;h_SubEntry)(hookptr, object, message));
}


/*
** Initialize the hook to use the hookEntry() routine above.
*/
void initHook(struct Hook *hook, ULONG (*ccode)())
{
hook-&#062;h_Entry    = hookEntry;
hook-&#062;h_SubEntry = ccode;
hook-&#062;h_Data     = 0;   /* this program does not use this */
}

/*
** Process messages received by the sgg_Window.  Quit when the close gadget
** is selected.
*/
VOID handleWindow(struct Vars *vars)
{
struct IntuiMessage *msg;
ULONG  class;
USHORT code;

for (;;)
    {
    Wait(1L &#060;&#060; vars-&#062;sgg_Window-&#062;UserPort-&#062;mp_SigBit);
    while (msg =
            (struct IntuiMessage *)GetMsg(vars-&#062;sgg_Window-&#062;UserPort))
        {
        /* Stash message contents and reply, important when message
        ** triggers some lengthy processing
        */
        class = msg-&#062;Class;
        code  = msg-&#062;Code;
        ReplyMsg((struct Message *)msg);

        switch (class)
            {
            case IDCMP_GADGETUP:
                /* if a code is set in the hook after an SGH_KEY
                ** command, where SGA_END is set on return from
                ** the hook, the code will be returned in the Code
                ** field of the IDCMP_GADGETUP message.
                */
                break;
            case IDCMP_CLOSEWINDOW:
                return;
                break;
            }
        }
    }
}


/*
** IsHexDigit()
**
** Return TRUE if the character is a hex digit (0-9, A-F, a-f)
*/
BOOL IsHexDigit(UBYTE test_char)
{
test_char = ToUpper(test_char);
if (((test_char &#062;= '0') &#038;&#038; (test_char &#060;= '9')) ||
    ((test_char &#062;= 'A') &#038;&#038; (test_char &#060;= 'F')))
    return(TRUE);
else
    return(FALSE);
}
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
