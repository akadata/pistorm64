<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/34.11 FILE="lib_examples/rbf.c" NODE="MAIN" TITLE="lib_examples/rbf.c" -->
<head>
<title>lib_examples/rbf.c</title>
</head>
<body>
<img src="../images/toc_d.gif" alt="[Contents]">
<img src="../images/index_d.gif" alt="[Index]">
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../Libraries_Manual_guide/node05E8.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../Libraries_Manual_guide/node05EA.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
;/* rbf.c - Execute me to compile me with SAS C 5.10
LC -d0 -b1 -cfistq -v -y -j73 rbf.c
Blink FROM LIB:c.o,rbf.o,rbfhandler.o TO rbf LIBRARY LIB:LC.lib,LIB:Amiga.lib
quit

** rbf.c - serial receive buffer full interrupt handler example.
** Must be linked with assembler handler rbfhandler.o
**
** To receive characters, this example requires ASCII serial input
** at your Amiga's current serial hardware baud rate (ie. 9600 after
** reboot, else last baud rate used)
*/

#include &#060;exec/execbase.h&#062;
#include &#060;exec/memory.h&#062;
#include &#060;exec/interrupts.h&#062;
#include &#060;resources/misc.h&#062;
#include &#060;hardware/custom.h&#062;
#include &#060;hardware/intbits.h&#062;
#include &#060;dos/dos.h&#062;

#include &#060;clib/exec_protos.h&#062;
#include &#060;clib/misc_protos.h&#062;

#include &#060;stdio.h&#062;
#include &#060;string.h&#062;

#ifdef LATTICE
int CXBRK(void)  { return(0); }  /* Disable Lattice CTRL/C handling */
void chkabort(void) { return; }  /* really */
#endif

#define BUFFERSIZE 256

extern void RBFHandler();   /* proto for asm interrupt handler */
void main(void);

struct MiscResource *MiscBase;
extern struct ExecBase *SysBase;
extern struct Custom far custom;    /* defined in amiga.lib */

static UBYTE *allocname = &#034;rbf-example&#034;;

struct RBFData {
    struct Task *rd_Task;
    ULONG rd_Signal;
    ULONG rd_BufferCount;
    UBYTE rd_CharBuffer[BUFFERSIZE + 2];
    UBYTE rd_FlagBuffer[BUFFERSIZE + 2];
    UBYTE rd_Name[32];
};

void main(void)
{
    struct RBFData *rbfdata;
    UBYTE *currentuser;
    BYTE signr;
    struct Device *serdevice;
    struct Interrupt *rbfint, *priorint;
    BOOL priorenable;
    ULONG signal;

    if (MiscBase = OpenResource(&#034;misc.resource&#034;))
    {
        currentuser = AllocMiscResource(MR_SERIALPORT, allocname);        /* Allocate the serial */
        if (currentuser)                                                  /* port registers.     */
        {
            printf(&#034;serial hardware allocated by %s. Trying to remove it\n&#034;,
                   currentuser);                                         /* Hey! someone got it! */
            Forbid();
            if (serdevice = (struct Device *)FindName(&#038;SysBase-&#062;DeviceList, currentuser))
                RemDevice(serdevice);
            Permit();

            currentuser = AllocMiscResource(MR_SERIALPORT, allocname);          /* and try again */
        }
        if (currentuser == NULL)
        {                                                                      /* Get the serial */
            currentuser = AllocMiscResource(MR_SERIALBITS, allocname);         /* control bits.  */
            if (currentuser)
            {
                printf(&#034;serial control allocated by %s\n&#034;, currentuser);            /* Give up. */
                FreeMiscResource(MR_SERIALPORT);
            }
            else
            {                                                                  /* Got them both. */
                printf(&#034;serial hardware allocated\n&#034;);
                if ((signr = AllocSignal(-1)) != -1)          /* Allocate a signal bit for the   */
                {                                             /* interrupt handler to signal us. */
                    if (rbfint = AllocMem(sizeof(struct Interrupt), MEMF_PUBLIC|MEMF_CLEAR))
                    {
                        if (rbfdata = AllocMem(sizeof(struct RBFData), MEMF_PUBLIC|MEMF_CLEAR))
                        {
                            rbfdata-&#062;rd_Task = FindTask(NULL);        /* Init rfbdata structure. */
                            rbfdata-&#062;rd_Signal = 1L &#060;&#060; signr;

                            rbfint-&#062;is_Node.ln_Type = NT_INTERRUPT;      /* Init interrupt node. */
                            strcpy(rbfdata-&#062;rd_Name, allocname);
                            rbfint-&#062;is_Node.ln_Name = rbfdata-&#062;rd_Name;
                            rbfint-&#062;is_Data = (APTR)rbfdata;
                            rbfint-&#062;is_Code = RBFHandler;
                                                                        /* Save state of RBF and */
                            priorenable = custom.intenar &#038; INTF_RBF ? TRUE : FALSE; /* interrupt */
                            custom.intena = INTF_RBF;                             /* disable it. */
                            priorint = SetIntVector(INTB_RBF, rbfint);

                            if (priorint) printf(&#034;replaced the %s RBF interrupt handler\n&#034;,
                                                 priorint-&#062;is_Node.ln_Name);
                            printf(&#034;enabling RBF interrupt\n&#034;);
                            custom.intena = INTF_SETCLR | INTF_RBF;

                            printf(&#034;waiting for buffer to fill up. Use CTRL-C to break\n&#034;);
                            signal = Wait(1L &#060;&#060; signr | SIGBREAKF_CTRL_C);

                            if (signal &#038; SIGBREAKF_CTRL_C) printf(&#034;&#062;break&#060;\n&#034;);
                            printf(&#034;Character buffer contains:\n%s\n&#034;, rbfdata-&#062;rd_CharBuffer);

                            custom.intena = INTF_RBF;               /* Restore previous handler. */
                            SetIntVector(INTB_RBF, priorint);
                                                                  /* Enable it if it was enabled */
                            if (priorenable) custom.intena = INTF_SETCLR|INTF_RBF;    /* before. */

                            FreeMem(rbfdata, sizeof(struct RBFData));
                        }
                        else  printf(&#034;can't allocate memory for rbf data\n&#034;);
                        FreeMem(rbfint, sizeof(struct Interrupt));
                    }
                    else printf(&#034;can't allocate memory for interrupt structure\n&#034;);
                    FreeSignal(signr);
                }
                else printf(&#034;can't allocate signal\n&#034;);

                FreeMiscResource(MR_SERIALBITS);   /* release serial hardware */
                FreeMiscResource(MR_SERIALPORT);
            }
        }
    } /* There is no 'CloseResource()' function */
}
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
