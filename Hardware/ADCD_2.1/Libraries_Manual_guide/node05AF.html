<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/34.11 FILE="Lib_examples/menulayout.c" NODE="MAIN" TITLE="Lib_examples/menulayout.c" -->
<head>
<title>Lib_examples/menulayout.c</title>
</head>
<body>
<img src="../images/toc_d.gif" alt="[Contents]">
<img src="../images/index_d.gif" alt="[Index]">
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../Libraries_Manual_guide/node05AE.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../Libraries_Manual_guide/node05B0.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
;/* menulayout.c - Execute me to compile me with SAS C 5.10
LC -b1 -cfistq -v -y -j73 menulayout.c
Blink FROM LIB:c.o,menulayout.o TO menulayout LIBRARY LIB:LC.lib,LIB:Amiga.lib
quit
** menulayout.c - Example showing how to do menu layout in general.  This example
** also illustrates handling menu events, including IDCMP_MENUHELP events.
**
** Note that handling arbitrary fonts is fairly complex.  Applications that require V37
** should use the simpler menu layout routines found in the GadTools library.
*/
#define INTUI_V36_NAMES_ONLY

#include &#060;exec/types.h&#062;
#include &#060;intuition/intuition.h&#062;
#include &#060;intuition/intuitionbase.h&#062;
#include &#060;graphics/gfxbase.h&#062;
#include &#060;dos/dos.h&#062;
#include &#060;clib/exec_protos.h&#062;
#include &#060;clib/graphics_protos.h&#062;
#include &#060;clib/intuition_protos.h&#062;
#include &#060;stdlib.h&#062;
#include &#060;stdio.h&#062;
#include &#060;string.h&#062;

#ifdef LATTICE
int CXBRK(void)    { return(0); }  /* Disable Lattice CTRL/C handling */
int chkabort(void) { return(0); }  /* really */
#endif
/* Our function prototypes */
BOOL processMenus(USHORT selection, BOOL done);
BOOL handleIDCMP(struct Window *win);
USHORT MaxLength(struct RastPort *textRPort, struct MenuItem *first_item, USHORT char_size);
VOID setITextAttr(struct IntuiText *first_IText, struct TextAttr *textAttr);
VOID adjustItems(struct RastPort *textRPort, struct MenuItem *first_item, struct TextAttr *textAttr,
                 USHORT char_size, USHORT height, USHORT level, USHORT left_edge);
BOOL adjustMenus(struct Menu *first_menu, struct TextAttr *textAttr);
LONG doWindow(void);

/* Settings Item IntuiText */
struct IntuiText SettText[] = {
        {0,1,JAM2,2,         1, NULL, &#034;Sound...&#034;,        NULL },
        {0,1,JAM2,CHECKWIDTH,1, NULL, &#034; Auto Save&#034;,      NULL },
        {0,1,JAM2,CHECKWIDTH,1, NULL, &#034; Have Your Cake&#034;, NULL },
        {0,1,JAM2,CHECKWIDTH,1, NULL, &#034; Eat It Too&#034;,     NULL }
    };

struct MenuItem SettItem[] = {
	{ /* &#034;Sound...&#034; */
	    &#038;SettItem[1], 0, 0, 0, 0, ITEMTEXT|ITEMENABLED|HIGHCOMP, 0,
	    (APTR)&#038;SettText[0], NULL, NULL, NULL, MENUNULL },
        { /* &#034;Auto Save&#034; (toggle-select, initially selected) */
	    &#038;SettItem[2], 0, 0, 0, 0, ITEMTEXT|ITEMENABLED|HIGHCOMP|CHECKIT|MENUTOGGLE|CHECKED, 0,
	    (APTR)&#038;SettText[1], NULL, NULL, NULL, MENUNULL },
	{ /* &#034;Have Your Cake&#034; (initially selected, excludes &#034;Eat It Too&#034;) */
	    &#038;SettItem[3], 0, 0, 0, 0, ITEMTEXT|ITEMENABLED|HIGHCOMP|CHECKIT|CHECKED, 8,
	    (APTR)&#038;SettText[2], NULL, NULL, NULL, MENUNULL },
        { /* &#034;Eat It Too&#034; (excludes &#034;Have Your Cake&#034;) */
	    NULL, 0, 0, 0, 0, ITEMTEXT|ITEMENABLED|HIGHCOMP|CHECKIT, 4,
	    (APTR)&#038;SettText[3], NULL, NULL, NULL, MENUNULL }
    };

/* Edit Menu Item IntuiText */
struct IntuiText EditText[] = {
        {0,1,JAM2,2,1, NULL, &#034;Cut&#034;,       NULL },
        {0,1,JAM2,2,1, NULL, &#034;Copy&#034;,      NULL },
        {0,1,JAM2,2,1, NULL, &#034;Paste&#034;,     NULL },
        {0,1,JAM2,2,1, NULL, &#034;Erase&#034;,     NULL },
        {0,1,JAM2,2,1, NULL, &#034;Undo&#034;,      NULL }
    };

/* Edit Menu Items */
struct MenuItem EditItem[] = {
        { /* &#034;Cut&#034; (key-equivalent: 'X') */
	    &#038;EditItem[1], 0, 0, 0, 0, ITEMTEXT|COMMSEQ|ITEMENABLED|HIGHCOMP, 0,
	    (APTR)&#038;EditText[0], NULL, 'X', NULL, MENUNULL },
        { /* &#034;Copy&#034; (key-equivalent: 'C') */
	    &#038;EditItem[2], 0, 0, 0, 0, ITEMTEXT|COMMSEQ|ITEMENABLED|HIGHCOMP, 0,
	    (APTR)&#038;EditText[1], NULL, 'C', NULL, MENUNULL },
        { /* &#034;Paste&#034; (key-equivalent: 'V') */
	    &#038;EditItem[3], 0, 0, 0, 0, ITEMTEXT|COMMSEQ|ITEMENABLED|HIGHCOMP, 0,
	    (APTR)&#038;EditText[2], NULL, 'V', NULL, MENUNULL },
        { /* &#034;Erase&#034; (disabled) */
	    &#038;EditItem[4], 0, 0, 0, 0, ITEMTEXT|HIGHCOMP, 0,
	    (APTR)&#038;EditText[3], NULL, NULL, NULL, MENUNULL },
        { /* &#034;Undo&#034; MenuItem (key-equivalent: 'Z') */
	    NULL, 0, 0, 0, 0, ITEMTEXT|COMMSEQ|ITEMENABLED|HIGHCOMP, 0,
	    (APTR)&#038;EditText[4], NULL, 'Z', NULL, MENUNULL }
    };

/* IntuiText for the Print Sub-Items */
struct IntuiText PrtText[] = {
        {0,1, JAM2,2,1, NULL, &#034;NLQ&#034;,   NULL },
        {0,1, JAM2,2,1, NULL, &#034;Draft&#034;, NULL }
    };

/* Print Sub-Items */
struct MenuItem PrtItem[] = {
        { /* &#034;NLQ&#034; */
	    &#038;PrtItem[1], 0, 0, 0, 0, ITEMTEXT|ITEMENABLED|HIGHCOMP, 0,
	    (APTR)&#038;PrtText[0], NULL, NULL, NULL, MENUNULL },
        { /* &#034;Draft&#034; */
	    NULL, 0, 0, 0, 0, ITEMTEXT|ITEMENABLED|HIGHCOMP, 0,
	    (APTR)&#038;PrtText[1], NULL, NULL, NULL, MENUNULL }
    };
/* Uses the &#062;&#062; character to indicate a sub-menu item.
** This is \273 Octal, 0xBB Hex or Alt-0 from the Keyboard.
**
** NOTE that standard menus place this character at the right margin of the menu box.
** This may be done by using a second IntuiText structure for the single character,
** linking this IntuiText to the first one, and positioning the IntuiText so that the
** character appears at the right margin.  GadTools library will provide the correct behavior.
*/

/* Project Menu Item IntuiText */
struct IntuiText ProjText[] = {
        {0,1, JAM2,2,1, NULL, &#034;New&#034;,         NULL },
        {0,1, JAM2,2,1, NULL, &#034;Open...&#034;,     NULL },
        {0,1, JAM2,2,1, NULL, &#034;Save&#034;,        NULL },
        {0,1, JAM2,2,1, NULL, &#034;Save As...&#034;,  NULL },
        {0,1, JAM2,2,1, NULL, &#034;Print     \273&#034;, NULL },
        {0,1, JAM2,2,1, NULL, &#034;About...&#034;,    NULL },
        {0,1, JAM2,2,1, NULL, &#034;Quit&#034;,        NULL }
    };


/* Project Menu Items */
struct MenuItem ProjItem[] = {
        { /* &#034;New&#034; (key-equivalent: 'N' */
	    &#038;ProjItem[1],0, 0, 0, 0, ITEMTEXT|COMMSEQ|ITEMENABLED|HIGHCOMP, 0,
	    (APTR)&#038;ProjText[0], NULL, 'N', NULL, MENUNULL },
        { /* &#034;Open...&#034; (key-equivalent: 'O') */
	    &#038;ProjItem[2],0, 0, 0, 0, ITEMTEXT|COMMSEQ|ITEMENABLED|HIGHCOMP, 0,
	    (APTR)&#038;ProjText[1], NULL, 'O', NULL, MENUNULL },
        { /* &#034;Save&#034; (key-equivalent: 'S') */
	    &#038;ProjItem[3],0, 0, 0, 0, ITEMTEXT|COMMSEQ|ITEMENABLED|HIGHCOMP, 0,
	    (APTR)&#038;ProjText[2], NULL, 'S', NULL, MENUNULL },
        { /* &#034;Save As...&#034; (key-equivalent: 'A') */
	    &#038;ProjItem[4],0, 0, 0, 0, ITEMTEXT|COMMSEQ|ITEMENABLED|HIGHCOMP, 0,
	    (APTR)&#038;ProjText[3], NULL, 'A', NULL, MENUNULL },
        { /* &#034;Print&#034; (has sub-menu) */
	    &#038;ProjItem[5],0, 0, 0, 0, ITEMTEXT|ITEMENABLED|HIGHCOMP, 0,
	    (APTR)&#038;ProjText[4], NULL, NULL, &#038;PrtItem[0], MENUNULL },
        { /* &#034;About...&#034; */
	    &#038;ProjItem[6],0, 0, 0, 0, ITEMTEXT|ITEMENABLED|HIGHCOMP, 0,
	    (APTR)&#038;ProjText[5], NULL, NULL, NULL, MENUNULL },
        { /* &#034;Quit&#034; (key-equivalent: 'Q' */
	    NULL, 0, 0, 0, 0, ITEMTEXT|COMMSEQ|ITEMENABLED|HIGHCOMP, 0,
	    (APTR)&#038;ProjText[6], NULL, 'Q', NULL, MENUNULL }
    };

/* Menu Titles */
struct Menu Menus[] = {
        {&#038;Menus[1],  0, 0, 63, 0, MENUENABLED, &#034;Project&#034;,    &#038;ProjItem[0]},
        {&#038;Menus[2], 70, 0, 39, 0, MENUENABLED, &#034;Edit&#034;,       &#038;EditItem[0]},
        {NULL,     120, 0, 88, 0, MENUENABLED, &#034;Settings&#034;,   &#038;SettItem[0]},
    };

/* A pointer to the first menu for easy reference */
struct Menu *FirstMenu = &#038;Menus[0];

/* Window Text for Explanation of Program */
struct IntuiText WinText[] = {
        {0, 0, JAM2, 0, 0, NULL, &#034;How to do a Menu&#034;, NULL},
        {0, 0, JAM2, 0, 0, NULL, &#034;(with Style)&#034;, &#038;WinText[0]}
    };

/* Globals */
struct Library  *IntuitionBase = NULL;
struct Library  *GfxBase = NULL;

/* open all of the required libraries.  Note that we require
** Intuition V37, as the routine uses OpenWindowTags().
*/
VOID main(int argc, char **argv)
{
LONG returnValue;

/* This gets set to RETURN_OK if everything goes well. */
returnValue = RETURN_FAIL;

/* Open the Intuition Library */
IntuitionBase = OpenLibrary(&#034;intuition.library&#034;, 37);
if (IntuitionBase)
    {
    /* Open the Graphics Library */
    GfxBase = (struct GfxBase *)OpenLibrary(&#034;graphics.library&#034;, 33);
    if (GfxBase)
        {
        returnValue = doWindow();

        CloseLibrary(GfxBase);
        }
    CloseLibrary(IntuitionBase);
    }
exit(returnValue);
}

/* Open a window with some properly positioned text.  Layout and set
** the menus, then process any events received.  Cleanup when done.
*/

LONG doWindow()
{
struct Window *window;
struct Screen *screen;
struct DrawInfo *drawinfo;
ULONG  signalmask, signals;
ULONG  win_width, alt_width, win_height;
LONG   returnValue = RETURN_FAIL;
BOOL   done = FALSE;

if (screen = LockPubScreen(NULL))
    {
    if (drawinfo = GetScreenDrawInfo(screen))
        {
        /* get the colors for the window text */
        WinText[0].FrontPen = WinText[1].FrontPen = drawinfo-&#062;dri_Pens[TEXTPEN];
        WinText[0].BackPen  = WinText[1].BackPen  = drawinfo-&#062;dri_Pens[BACKGROUNDPEN];

        /* use the screen's font for the text */
        WinText[0].ITextFont = WinText[1].ITextFont = screen-&#062;Font;

        /* calculate window size */
        win_width  = 100 + IntuiTextLength(&#038;(WinText[0]));
        alt_width  = 100 + IntuiTextLength(&#038;(WinText[1]));
        if (win_width &#060; alt_width)
            win_width  = alt_width;
        win_height = 1 + screen-&#062;WBorTop + screen-&#062;WBorBottom +
                     (screen-&#062;Font-&#062;ta_YSize * 5);

        /* calculate the correct positions for the text in the window */
        WinText[0].LeftEdge = (win_width - IntuiTextLength(&#038;(WinText[0]))) &#062;&#062; 1;
        WinText[0].TopEdge  = 1 + screen-&#062;WBorTop + (2 * screen-&#062;Font-&#062;ta_YSize);
        WinText[1].LeftEdge = (win_width - IntuiTextLength(&#038;(WinText[1]))) &#062;&#062; 1;
        WinText[1].TopEdge  = WinText[0].TopEdge + screen-&#062;Font-&#062;ta_YSize;

        /* Open the window */
        window = OpenWindowTags(NULL,
            WA_PubScreen, screen,
            WA_IDCMP,     IDCMP_MENUPICK | IDCMP_CLOSEWINDOW | IDCMP_MENUHELP,
            WA_Flags,     WFLG_DRAGBAR | WFLG_DEPTHGADGET | WFLG_CLOSEGADGET |
                              WFLG_ACTIVATE | WFLG_NOCAREREFRESH,
            WA_Left,      10,             WA_Top,       screen-&#062;BarHeight + 1,
            WA_Width,     win_width,      WA_Height,    win_height,
            WA_Title,     &#034;Menu Example&#034;, WA_MenuHelp,  TRUE,
            TAG_END);



        if (window)
            {
            returnValue = RETURN_OK;  /* program initialized ok */

            /* Give a brief explanation of the program */
            PrintIText(window-&#062;RPort,&#038;WinText[1],0,0);

            /* Adjust the menu to conform to the font (TextAttr) */
            adjustMenus(FirstMenu, window-&#062;WScreen-&#062;Font);

            /* attach the menu to the window */
            SetMenuStrip(window, FirstMenu);

            /* Set up the signals that you want to hear about ... */
            signalmask = 1L &#060;&#060; window-&#062;UserPort-&#062;mp_SigBit;

            /* And wait to hear from your signals */
            while (!done)
                {
                signals = Wait(signalmask);
                if (signals &#038; signalmask) done = handleIDCMP(window);
                };

            /* clean up everything used here */
            ClearMenuStrip(window);
            CloseWindow(window);
            }
        FreeScreenDrawInfo(screen,drawinfo);
        }
    UnlockPubScreen(NULL,screen);
    }
return(returnValue);
}

/* print out what menu was selected.  Properly handle the IDCMP_MENUHELP
** events.  Set done to TRUE if quit is selected.
*/
BOOL processMenus(USHORT selection, BOOL done)
{
USHORT flags;
USHORT menuNum, itemNum, subNum;

menuNum = MENUNUM(selection);
itemNum = ITEMNUM(selection);
subNum  = SUBNUM(selection);

/* when processing IDCMP_MENUHELP, you are not guaranteed
** to get a menu item.
*/
if (itemNum != NOITEM)
    {
    flags = ((struct MenuItem *)ItemAddress(FirstMenu,(LONG)selection))-&#062;Flags;
    if (flags &#038; CHECKED)
        printf(&#034;(Checked) &#034;);
    }

switch (menuNum)
    {
    case 0:      /* Project Menu */
        switch (itemNum)
            {
            case NOITEM: printf(&#034;Project Menu\n&#034;);        break;
            case 0:      printf(&#034;New\n&#034;);                 break;
            case 1:      printf(&#034;Open\n&#034;);                break;
            case 2:      printf(&#034;Save\n&#034;);                break;
            case 3:      printf(&#034;Save As\n&#034;);             break;
            case 4:      printf(&#034;Print &#034;);
                switch (subNum)
                    {
                    case NOSUB: printf(&#034;Item\n&#034;);  break;
                    case 0:     printf(&#034;NLQ\n&#034;);   break;
                    case 1:     printf(&#034;Draft\n&#034;); break;
                    }
                break;
            case 5:      printf(&#034;About\n&#034;);               break;
            case 6:      printf(&#034;Quit\n&#034;);   done = TRUE; break;
            }
        break;





    case 1:      /* Edit Menu */
        switch (itemNum) {
            case NOITEM: printf(&#034;Edit Menu\n&#034;); break;
            case 0:      printf(&#034;Cut\n&#034;);       break;
            case 1:      printf(&#034;Copy\n&#034;);      break;
            case 2:      printf(&#034;Paste\n&#034;);     break;
            case 3:      printf(&#034;Erase\n&#034;);     break;
            case 4:      printf(&#034;Undo\n&#034;);      break;
            }
        break;
    case 2:      /* Settings Menu */
        switch (itemNum) {
            case NOITEM: printf(&#034;Settings Menu\n&#034;); break;
            case 0:      printf(&#034;Sound\n&#034;);            break;
            case 1:      printf(&#034;Auto Save\n&#034;);        break;
            case 2:      printf(&#034;Have Your Cake\n&#034;);   break;
            case 3:      printf(&#034;Eat It Too\n&#034;);       break;
            }
        break;
    case NOMENU: /* No menu selected, can happen with IDCMP_MENUHELP */
        printf(&#034;no menu\n&#034;);
        break;
    }
return(done);
}

/* Handle the IDCMP messages.  Set done to TRUE if quit or closewindow is selected. */
BOOL handleIDCMP(struct Window *win)
{
BOOL done;
USHORT code, selection;
struct IntuiMessage *message = NULL;
ULONG  class;

done = FALSE;

/* Examine pending messages */
while (message = (struct IntuiMessage *)GetMsg(win-&#062;UserPort)) {
    class = message-&#062;Class;
    code = message-&#062;Code;

    /* When we're through with a message, reply */
    ReplyMsg((struct Message *)message);

    /* See what events occurred */
    switch (class) {
        case IDCMP_CLOSEWINDOW:
            done = TRUE;
            break;
        case IDCMP_MENUHELP:
            /*
	    ** The routine that handles the menus for IDCMP_MENUHELP must be very careful
	    ** it can receive menu information that is impossible under IDCMP_MENUPICK.
	    ** For instance, the code value on a IDCMP_MENUHELP may have a valid number
	    ** for the menu, then NOITEM and NOSUB. IDCMP_MENUPICK would get MENUNULL
	    ** in this case.  IDCMP_MENUHELP never come as multi-select items, and the
	    ** event terminates the menu processing session.
            **
            ** Note that I do not keep the return value from the processMenus() routine here--the
	    ** application should not quit if the user selects &#034;help&#034; over the quit menu item.
            */
            printf(&#034;IDCMP_MENUHELP: Help on &#034;);
            processMenus(code,done);
            break;
        case IDCMP_MENUPICK:
            for ( selection = code; selection != MENUNULL;
                  selection = (ItemAddress(FirstMenu,(LONG)selection))-&#062;NextSelect)
                {
                printf(&#034;IDCMP_MENUPICK: Selected &#034;);
                done = processMenus(selection,done);
                }
            break;
        }
    }
return(done);
}
/* Steps thru each item to determine the maximum width of the strip */
USHORT MaxLength(struct RastPort *textRPort, struct MenuItem *first_item, USHORT char_size)
{
USHORT maxLength;
USHORT total_textlen;
struct MenuItem  *cur_item;
struct IntuiText *itext;
USHORT extra_width;
USHORT maxCommCharWidth;
USHORT commCharWidth;

extra_width = char_size;  /* used as padding for each item. */

/* Find the maximum length of a command character, if any.
** If found, it will be added to the extra_width field.
*/
maxCommCharWidth = 0;
for (cur_item = first_item; cur_item != NULL; cur_item = cur_item-&#062;NextItem)
    {
    if (cur_item-&#062;Flags &#038; COMMSEQ)
        {
        commCharWidth = TextLength(textRPort,&#038;(cur_item-&#062;Command),1);
        if (commCharWidth &#062; maxCommCharWidth)
            maxCommCharWidth = commCharWidth;
        }
    }

/* if we found a command sequence, add it to the extra required space.  Add
** space for the Amiga key glyph plus space for the command character.  Note
** this only works for HIRES screens, for LORES, use LOWCOMMWIDTH.
*/
if (maxCommCharWidth &#062; 0)
    extra_width += maxCommCharWidth + COMMWIDTH;

/* Find the maximum length of the menu items, given the extra width calculated above. */
maxLength = 0;
for (cur_item = first_item; cur_item != NULL; cur_item = cur_item-&#062;NextItem)
    {
    itext = (struct IntuiText *)cur_item-&#062;ItemFill;
    total_textlen = extra_width + itext-&#062;LeftEdge +
          TextLength(textRPort, itext-&#062;IText, strlen(itext-&#062;IText));

    /* returns the greater of the two */
    if (total_textlen &#062; maxLength)
        maxLength = total_textlen;
    }
return(maxLength);
}

/* Set all IntuiText in a chain (they are linked through the NextText ** field) to the same font. */
VOID setITextAttr(struct IntuiText *first_IText, struct TextAttr *textAttr)
{
struct IntuiText *cur_IText;

for (cur_IText = first_IText; cur_IText != NULL; cur_IText = cur_IText-&#062;NextText)
    cur_IText-&#062;ITextFont = textAttr;
}


/* Adjust the MenuItems and SubItems */
VOID adjustItems(struct RastPort *textRPort, struct MenuItem *first_item,
                 struct TextAttr *textAttr, USHORT char_size, USHORT height,
                 USHORT level, USHORT left_edge)
{
register USHORT item_num;
struct   MenuItem *cur_item;
USHORT   strip_width, subitem_edge;

if (first_item == NULL)
    return;

/* The width of this strip is the maximum length of its members. */
strip_width = MaxLength(textRPort, first_item, char_size);



/* Position the items. */
for (cur_item = first_item, item_num = 0; cur_item != NULL; cur_item = cur_item-&#062;NextItem, item_num++)
    {
    cur_item-&#062;TopEdge  = (item_num * height) - level;
    cur_item-&#062;LeftEdge = left_edge;
    cur_item-&#062;Width    = strip_width;
    cur_item-&#062;Height   = height;

    /* place the sub_item 3/4 of the way over on the item. */
    subitem_edge = strip_width - (strip_width &#062;&#062; 2);

    setITextAttr((struct IntuiText *)cur_item-&#062;ItemFill, textAttr);
    adjustItems(textRPort,cur_item-&#062;SubItem,textAttr,char_size,height,1,subitem_edge);
    }
}


/* The following routines adjust an entire menu system to conform to the specified fonts' width and
** height.  Allows for Proportional Fonts. This is necessary for a clean look regardless of what the
** users preference in Fonts may be.  Using these routines, you don't need to specify TopEdge,
** LeftEdge, Width or Height in the MenuItem structures.
**
** NOTE that this routine does not work for menus with images, but assumes that all menu items are
** rendered with IntuiText.
**
** This set of routines does NOT check/correct if the menu runs off
** the screen due to large fonts, too many items, lo-res screen.
*/
BOOL adjustMenus(struct Menu *first_menu, struct TextAttr *textAttr)
{
struct RastPort   textrp = {0};             /* Temporary RastPort */
struct Menu      *cur_menu;
struct TextFont  *font;                     /* Font to use */
USHORT            start, char_size, height;
BOOL              returnValue = FALSE;

/* open the font */
if (font = OpenFont(textAttr))
    {
    SetFont(&#038;textrp, font);       /* Put font into temporary RastPort */

    char_size = TextLength(&#038;textrp, &#034;n&#034;, 1);    /* Get the Width of the Font */

    /* To prevent crowding of the Amiga key when using COMMSEQ, don't allow the items to be less
    ** than 8 pixels high.  Also, add an extra pixel for inter-line spacing.
    */
    if (font-&#062;tf_YSize &#062; 8)
        height = 1 + font-&#062;tf_YSize;
    else
        height = 1 + 8;

    start = 2;      /* Set Starting Pixel */

    /* Step thru the menu structure and adjust it */
    for (cur_menu = first_menu; cur_menu != NULL; cur_menu = cur_menu-&#062;NextMenu)
        {
        cur_menu-&#062;LeftEdge = start;
        cur_menu-&#062;Width = char_size +
            TextLength(&#038;textrp, cur_menu-&#062;MenuName, strlen(cur_menu-&#062;MenuName));
        adjustItems(&#038;textrp, cur_menu-&#062;FirstItem, textAttr, char_size, height, 0, 0);
        start += cur_menu-&#062;Width + char_size + char_size;
        }
    CloseFont(font);              /* Close the Font */
    returnValue = TRUE;
    }
return(returnValue);
}
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
