<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/34.11 FILE="Lib_examples/AvailFonts.c" NODE="MAIN" TITLE="Lib_examples/AvailFonts.c" -->
<head>
<title>Lib_examples/AvailFonts.c</title>
</head>
<body>
<img src="../images/toc_d.gif" alt="[Contents]">
<img src="../images/index_d.gif" alt="[Index]">
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../Libraries_Manual_guide/node05B6.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../Libraries_Manual_guide/node05B8.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
;/* AvailFonts.c - Execute me to compile me with Lattice 5.10a
LC -cfistq -v -y -j73 AvailFonts.c
Blink FROM LIB:c.o,AvailFonts.o TO AvailFonts LIBRARY LIB:LC.lib,LIB:Amiga.lib
quit ;*/

#include &#060;exec/types.h&#062;
#include &#060;dos/rdargs.h&#062;
#include &#060;dos/dosextens.h&#062;
#include &#060;intuition/intuition.h&#062;
#include &#060;intuition/screens.h&#062;
#include &#060;graphics/text.h&#062;
#include &#060;graphics/displayinfo.h&#062;
#include &#060;graphics/regions.h&#062;
#include &#060;graphics/gfx.h&#062;
#include &#060;libraries/diskfont.h&#062;
#include &#060;utility/tagitem.h&#062;
#include &#060;clib/exec_protos.h&#062;
#include &#060;clib/dos_protos.h&#062;
#include &#060;clib/layers_protos.h&#062;
#include &#060;clib/alib_stdio_protos.h&#062;
#include &#060;clib/intuition_protos.h&#062;
#include &#060;clib/graphics_protos.h&#062;
#include &#060;clib/diskfont_protos.h&#062;
#include &#060;clib/utility_protos.h&#062;

#ifdef LATTICE
int CXBRK(void) { return(0); }  /* Disable Lattice CTRL/C handling */
int chkabort(void) { return(0); }
#endif

UBYTE *vers = &#034;\0$VER: AvailFonts 36.3&#034;;

void MainLoop(void);
ULONG StrLen(UBYTE *);

struct stringstruct {
        UBYTE *string;
        LONG charcount;
        WORD stringwidth;
};

UBYTE *alphabetstring = &#034;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&#034;;
struct stringstruct fname, fheight, XDPI, YDPI, entrynum;
struct Library *DiskfontBase, *IntuitionBase, *LayersBase, *GfxBase, *UtilityBase;
struct Window *mywin;
struct RastPort *mycliprp, myrp;
struct Rectangle myrect;
struct Region *new_region, *old_region;
struct DrawInfo *mydrawinfo;
struct AvailFontsHeader *afh;
LONG fontheight, alphabetcharcount;
WORD stringwidth;

void main(int argc, char **argv)
{
  struct TextFont *defaultfont = NULL;
  struct TextAttr defaultfontattr = { &#034;topaz.font&#034;, 9, 0, 0 };

  LONG afsize, afshortage, cliprectside;

  fname.string = &#034;Font Name:  &#034;;
  fheight.string = &#034;Font Height:  &#034;;
  XDPI.string = &#034;X DPI:  &#034;;
  YDPI.string = &#034;Y DPI:  &#034;;
  entrynum.string = &#034;Entry #:  &#034;;

  if (DiskfontBase = OpenLibrary(&#034;diskfont.library&#034;, 37L))              /* Open the libraries. */
  {
    if (IntuitionBase = OpenLibrary(&#034;intuition.library&#034;, 37L))
    {
      if (GfxBase = OpenLibrary(&#034;graphics.library&#034;, 37L))
      {
        if (LayersBase = OpenLibrary(&#034;layers.library&#034;, 37L))
        {
          if (UtilityBase = OpenLibrary(&#034;utility.library&#034;, 37L))
          {
            if (mywin = OpenWindowTags(NULL,                              /* Open that window. */
                                    WA_SmartRefresh,TRUE,
                                    WA_SizeGadget,  FALSE,
                                    WA_CloseGadget, TRUE,
                                    WA_IDCMP,       IDCMP_CLOSEWINDOW,
                                    WA_DragBar,     TRUE,
                                    WA_DepthGadget, TRUE,
                                    WA_Title,       (ULONG)&#034;AvailFonts() example&#034;,
                                    TAG_END))
            {
              myrp = *(mywin-&#062;RPort);       /* A structure assign: clone my window's Rastport. */
                                            /* RastPort.  This RastPort will be used to render */
                                            /* the font specs, not the actual font sample.     */
              if (mydrawinfo = GetScreenDrawInfo(mywin-&#062;WScreen))
              {
                SetFont(&#038;myrp, mydrawinfo-&#062;dri_Font);

                myrect.MinX = mywin-&#062;BorderLeft;                          /* LAYOUT THE WINDOW */
                myrect.MinY = mywin-&#062;BorderTop;
                myrect.MaxX = mywin-&#062;Width - (mywin-&#062;BorderRight + 1);
                myrect.MaxY = mywin-&#062;Height - (mywin-&#062;BorderBottom + 1);

                cliprectside = (myrect.MaxX - myrect.MinX) / 20;

                fname.charcount    = StrLen(fname.string);
                fheight.charcount  = StrLen(fheight.string);
                XDPI.charcount     = StrLen(XDPI.string);
                YDPI.charcount     = StrLen(YDPI.string);
                entrynum.charcount = StrLen(entrynum.string);
                alphabetcharcount  = StrLen(alphabetstring);

                fontheight = (myrp.Font-&#062;tf_YSize) + 2;

                if (fontheight &#062; ((myrect.MaxY - myrect.MinY) / 6))  /* If the default screen  */
                {                                                    /* font is more than one- */
                  defaultfont = OpenFont(&#038;defaultfontattr);          /* sixth the size of the  */
                  SetFont(&#038;myrp, defaultfont);                       /* window, use topaz-9.   */
                  fontheight = (myrp.Font-&#062;tf_YSize) + 2;
                }

                fname.stringwidth   = TextLength(&#038;myrp, (STRPTR)fname.string, fname.charcount);
                fheight.stringwidth = TextLength(&#038;myrp, (STRPTR)fheight.string, fheight.charcount);
                XDPI.stringwidth    = TextLength(&#038;myrp, (STRPTR)XDPI.string, XDPI.charcount);
                YDPI.stringwidth    = TextLength(&#038;myrp, (STRPTR)YDPI.string, YDPI.charcount);
                entrynum.stringwidth =
                    TextLength(&#038;myrp, (STRPTR)entrynum.string, entrynum.charcount);

                stringwidth = fname.stringwidth;         /* What is the largest string length? */
                stringwidth =
                    (fheight.stringwidth &#062; stringwidth) ? fheight.stringwidth : stringwidth;
                stringwidth = (XDPI.stringwidth &#062; stringwidth) ? XDPI.stringwidth : stringwidth;
                stringwidth = (YDPI.stringwidth &#062; stringwidth) ? YDPI.stringwidth : stringwidth;
                stringwidth =
                    (entrynum.stringwidth &#062; stringwidth) ? entrynum.stringwidth : stringwidth;
                stringwidth += mywin-&#062;BorderLeft;

                if (stringwidth &#060; ((myrect.MaxX - myrect.MinX) &#062;&#062; 1)) /* If the stringwidth is */
                {                                                 /* more than half the viewing*/
                  SetAPen(&#038;myrp, mydrawinfo-&#062;dri_Pens[TEXTPEN]);  /* area, quit because the    */
                  SetDrMd(&#038;myrp, JAM2);                           /* font is just too big.     */

                  Move(&#038;myrp, myrect.MinX + 8 + stringwidth - fname.stringwidth,
                               myrect.MinY + 4 + (myrp.Font-&#062;tf_Baseline));
                  Text(&#038;myrp, fname.string, fname.charcount);

                  Move(&#038;myrp, myrect.MinX + 8 + stringwidth - fheight.stringwidth,
                              myrp.cp_y + fontheight);
                  Text(&#038;myrp, fheight.string, fheight.charcount);

                  Move(&#038;myrp, myrect.MinX + 8 + stringwidth - XDPI.stringwidth,
                              myrp.cp_y + fontheight);
                  Text(&#038;myrp, XDPI.string, XDPI.charcount);

                  Move(&#038;myrp, myrect.MinX + 8 + stringwidth - YDPI.stringwidth,
                              myrp.cp_y + fontheight);
                  Text(&#038;myrp, YDPI.string, YDPI.charcount);

                  Move(&#038;myrp, myrect.MinX + 8 + stringwidth - entrynum.stringwidth,
                              myrp.cp_y + fontheight);
                  Text(&#038;myrp, entrynum.string, entrynum.charcount);

                  myrect.MinX = myrect.MinX + cliprectside;
                  myrect.MaxX = myrect.MaxX - cliprectside;
                  myrect.MinY = myrect.MinY + (5 * fontheight) + 8;
                  myrect.MaxY = myrect.MaxY - 8;

                  SetAPen(&#038;myrp, mydrawinfo-&#062;dri_Pens[SHINEPEN]);         /* Draw a box around */
                  Move(&#038;myrp, myrect.MinX - 1, myrect.MaxY + 1);          /* the cliprect.     */
                  Draw(&#038;myrp, myrect.MaxX + 1, myrect.MaxY + 1);
                  Draw(&#038;myrp, myrect.MaxX + 1, myrect.MinY - 1);

                  SetAPen(&#038;myrp, mydrawinfo-&#062;dri_Pens[SHADOWPEN]);
                  Draw(&#038;myrp, myrect.MinX - 1, myrect.MinY - 1);
                  Draw(&#038;myrp, myrect.MinX - 1, myrect.MaxY);

                  SetAPen(&#038;myrp, mydrawinfo-&#062;dri_Pens[TEXTPEN]);
                                          /* Fill up a buffer with a list of the available fonts */
                  afsize = AvailFonts((STRPTR)afh, 0L, AFF_MEMORY|AFF_DISK|AFF_SCALED|AFF_TAGGED);
                  do
                  {
                    afh = (struct AvailFontsHeader *) AllocMem(afsize, 0);
                    if (afh)
                    {
                      afshortage = AvailFonts((STRPTR)afh, afsize,
                                              AFF_MEMORY|AFF_DISK|AFF_SCALED|AFF_TAGGED);
                      if (afshortage)
                      {
                        FreeMem(afh, afsize);
                        afsize += afshortage;
                        afh = (struct AvailFontsHeader *)(-1L);
                      }
                    }
                  } while (afshortage &#038;&#038; afh);

                  if (afh)
                  {
                    /* This is for the layers.library clipping region that gets attached to */
                    /* the window.  This prevents the application from unnecessarily        */
                    /* rendering beyond the bounds of the inner part of the window. For     */
                    /* more information on clipping, see the Layers chapter of this manual. */

                    if (new_region = NewRegion())                 /* More layers stuff */
                    {
                      if (OrRectRegion(new_region, &#038;myrect));/* Even more layers stuff */
                      {
                         /* Obtain a pointer to the window's rastport and set up some of    */
                         /* the rastport attributes.  This example obtains the text pen     */
                         /* for the window's screen using the GetScreenDrawInfo() function. */
                         mycliprp = mywin-&#062;RPort;
                         SetAPen(mycliprp, mydrawinfo-&#062;dri_Pens[TEXTPEN]);

                         MainLoop();
                      }
                      DisposeRegion(new_region);
                    }
                    FreeMem(afh, afsize);
                  }
                }
                FreeScreenDrawInfo(mywin-&#062;WScreen, mydrawinfo);
              }
              CloseWindow(mywin);
            }
            CloseLibrary(UtilityBase);
          }
          CloseLibrary(LayersBase);
        }
        CloseLibrary(GfxBase);
      }
      CloseLibrary(IntuitionBase);
    }
    CloseLibrary(DiskfontBase);
  }
}



void MainLoop(void)
{
  UWORD x;
  struct Task *mytask;
  struct IntuiMessage *mymsg;
  BOOL aok = TRUE;
  struct TAvailFonts *afont;
  struct TextFont *myfont;
  UBYTE buf[8];
  ULONG dpi;

  mytask = FindTask(NULL);
  afont = (struct TAvailFonts *)&#038;(afh[1]);

  for (x = 0; (x &#060; afh-&#062;afh_NumEntries); x++)
  {
    if (aok)
    {
      if (myfont = OpenDiskFont(&#038;(afont-&#062;taf_Attr)))
      {
        SetAPen(&#038;myrp, mydrawinfo-&#062;dri_Pens[BACKGROUNDPEN]);   /* Print the TextFont attributes. */
        RectFill( &#038;myrp, stringwidth, mywin-&#062;BorderTop + 4,
                  mywin-&#062;Width - (mywin-&#062;BorderRight + 1), myrect.MinY - 2 );

        SetAPen(&#038;myrp, mydrawinfo-&#062;dri_Pens[TEXTPEN]);
        Move( &#038;myrp, stringwidth + mywin-&#062;BorderLeft,
              mywin-&#062;BorderTop + 4 + (myrp.Font-&#062;tf_Baseline) );
        Text( &#038;myrp, (UBYTE *)myfont-&#062;tf_Message.mn_Node.ln_Name,
              StrLen((UBYTE *)myfont-&#062;tf_Message.mn_Node.ln_Name) );

        Move(&#038;myrp, stringwidth + mywin-&#062;BorderLeft, myrp.cp_y + fontheight); /* Print the      */
        sprintf(buf, &#034;%d\0&#034;, myfont-&#062;tf_YSize);                               /* font's Y Size. */
        Text(&#038;myrp, buf, StrLen(buf));

        Move(&#038;myrp, stringwidth + mywin-&#062;BorderLeft, myrp.cp_y + fontheight); /* Print the X DPI */
        dpi = GetTagData( TA_DeviceDPI, 0L,
                          ((struct TextFontExtension *)(myfont-&#062;tf_Extension))-&#062;tfe_Tags);
        if (dpi)
        {
            sprintf(buf, &#034;%d\0&#034;, ((dpi &#038; 0xFFFF0000)&#062;&#062;16));
            Text(&#038;myrp, buf, StrLen(buf));
        }
        else Text(&#038;myrp, &#034;nil&#034;, 3L);

        Move(&#038;myrp, stringwidth + mywin-&#062;BorderLeft, myrp.cp_y + fontheight); /* Print the Y DPI */
        if (dpi)
        {
            sprintf(buf, &#034;%d\0&#034;, (dpi &#038; 0x0000FFFF));
            Text(&#038;myrp, buf, StrLen(buf));
        }
        else Text(&#038;myrp, &#034;nil&#034;, 3L);

        Move(&#038;myrp, stringwidth + mywin-&#062;BorderLeft, myrp.cp_y + fontheight);     /* Print the */
        sprintf(buf, &#034;%d\0&#034;, x);                                                   /* entrynum. */
        Text(&#038;myrp, buf, StrLen(buf));

        SetFont(mycliprp, myfont);
        old_region = InstallClipRegion(mywin-&#062;WLayer, new_region); /* Install clipping rectangle */

        SetRast(mycliprp, mydrawinfo-&#062;dri_Pens[BACKGROUNDPEN]);
        Move( mycliprp, myrect.MinX, myrect.MaxY - (myfont-&#062;tf_YSize - myfont-&#062;tf_Baseline) );
        Text(mycliprp, alphabetstring, alphabetcharcount);

        Delay(100);

        new_region = InstallClipRegion(mywin-&#062;WLayer, old_region);  /* Remove clipping rectangle */

        while (mymsg = (struct IntuiMessage *)GetMsg(mywin-&#062;UserPort))
        {
            aok = FALSE;
            x = afh-&#062;afh_NumEntries;
            ReplyMsg((struct Message *)mymsg);
        }



        if (mytask-&#062;tc_SigRecvd &#038; SIGBREAKF_CTRL_C)        /* Did the user hit CTRL-C (the shell */
        {                                                  /* window has to receive the CTRL-C)? */
            aok = FALSE;
            x = afh-&#062;afh_NumEntries;
            VPrintf(&#034;Ctrl-C Break\n&#034;, NULL);
        }
        CloseFont(myfont);
      }
    }
    afont++;
  }
}


ULONG StrLen(UBYTE *string)
{
    ULONG x = 0L;

    while (string[x++]);
    return(--x);
}
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
