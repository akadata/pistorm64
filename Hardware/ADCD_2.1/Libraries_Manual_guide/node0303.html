<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/34.11 FILE="Libraries/Lib_26" NODE="26-1-1" TITLE="26 / Introduction / Sequence of Events During an Interrupt" INDEX="Libraries/Lib_Index/MAIN" -->
<head>
<title>26 / Introduction / Sequence of Events During an Interrupt</title>
</head>
<body>
<img src="../images/toc_d.gif" alt="[Contents]">
<a href="../Libraries_Manual_guide/node002C.html"><img src="../images/index.gif" alt="[Index]" border=0></a>
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../Libraries_Manual_guide/node0302.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../Libraries_Manual_guide/node0304.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
Before useful interrupt handling code can be executed, a considerable
amount of hardware and software activity must occur.  Each interrupt must
propagate through several hardware and software interfaces before
<a name="line5">application code is finally dispatched:</a>

  * A hardware device decides to cause an interrupt and sends a signal to
<a name="line8">    the interrupt control portions of the 4703 (Paula) custom chip.</a>

  * The 4703 interrupt control logic notices this new signal and performs
    two primary operations.  First, it records that the interrupt has
    been requested by setting a flag bit in the <a href="../Hardware_Manual_guide/node0164.html#line11">INTREQ</a> register.  Second,
    it examines the <a href="../Hardware_Manual_guide/node0164.html#line4">INTENA</a> register to determine whether the
    corresponding interrupt and the interrupt master are enabled.  If
    both are enabled, the 4703 generates an interrupt request by placing
    the priority level of the request onto the three 68000 interrupt
<a name="line17">    control input lines (IPL0, IPL1, IPL2).</a>

  * These three signals correspond to seven interrupt priority levels in
    the 68000.  If the priority of the new interrupt is greater than the
    current processor priority, an interrupt sequence is initiated. The
    priority level of the new interrupt is used to index into the top
    seven words of the processor address space.  The odd byte (a vector
    number) of the indexed word is fetched and then shifted left by two
    to create an offset into the processor's auto-vector interrupt table.
    The vector offsets used are in the range of $064 to $07C.  These are
    labeled as interrupt autovectors in the 68000 manual.  The
    auto-vector table appears in low memory on a 68000 system, but its
    location for other 68000 family processors is determined by the
    processor's CPU Vector Base Register (VBR).  VBR can be accessed from
<a name="line31">    <a href="../Libraries_Manual_guide/node02CA.html">supervisor mode</a> with the MOVEC instruction.</a>

  * The processor then switches into <a href="../Libraries_Manual_guide/node02CA.html">supervisor mode</a> (if it is not
    already in that mode), and saves copies of the status register and
    program counter (PC) onto the top of the system stack (additional
    information may be saved by processors other than the 68000).  The
    processor priority is then raised to the level of the active
<a name="line38">    interrupt.</a>

  * From the low memory vector address (calculated in step three above),
    a 32-bit autovector address is fetched and loaded into the program
<a name="line42">    counter.  This is an entry point into Exec's interrupt dispatcher.</a>

  * Exec must now further decode the interrupt by examining the <a href="../Hardware_Manual_guide/node0164.html#line11">INTREQ</a>
    and <a href="../Hardware_Manual_guide/node0164.html#line4">INTENA</a> 4703 chip registers.  Once the active interrupt has been
    determined, Exec indexes into an <a href="../Includes_and_Autodocs_2._guide/node009E.html#line31">ExecBase</a> array to fetch the
    interrupt's handler entry point and handler data pointer addresses.

  * Exec now turns control over to the interrupt handler by calling it as
    if it were a subroutine.  This handler may deal with the interrupt
    directly or may propagate control further by invoking interrupt
<a name="line52">    server chain processing.</a>

You can see from the above discussion that the interrupt autovectors
should never be altered by the user.  If you wish to provide your own
system interrupt handler, you must use the Exec <a href="../Libraries_Manual_guide/node030A.html#line23">SetIntVector()</a> function.
You should not change the contents of any autovector location.

Task multiplexing usually occurs as the result of an interrupt.  When an
interrupt has finished and the processor is about to return to user mode,
Exec determines whether task-scheduling attention is required.  If a task
was signaled during interrupt processing, the task scheduler will be
invoked.  Because Exec uses preemptive task scheduling, it can be said
that the interrupt subsystem is the heart of task multiplexing.  If, for
some reason, interrupts do not occur, a task might execute forever because
it cannot be forced to relinquish the CPU.
<a name="line67"></a>

                    Table 26-1: Interrupts by Priority

                  Exec
    Hardware    Pseodo-
    Priority    Priority   Description                Label   Type
    --------    --------   -----------                -----   ----
              ____
             |     1    Serial transmit buffer empty  TBE      H
             |
       1 ----|     2    disk block complete           DSKBLK   H
<a name="line79">             |</a>
             |     3    software interrupt            SOFTINT  H
<a name="line81">             |----</a>
       2 ----|     4    external INT2 &#038; CIAA          PORTS    S
             |----
             |     5    graphics coprocessor          COPER    S
             |
       3 ----|     6    vertical blank interval       VERTB    S
             |
             |     7    blitter finished              BLIT     H
             |----
             |     8    audio channel 2               AUD2     H
             |
             |     9    audio channel 0               AUD0     H
       4 ----|
             |     10   audio channel 3               AUD3     H
             |
             |     11   audio channel 1               AUD1     H
             |----
             |     12   Serial receive buffer full    RBF      H
<a name="line99">       5 ----|</a>
             |     13   disk sync pattern found       DSKSYNC  H
             |----
             |     14   external INT6 &#038; CIAB          EXTER    S
<a name="line103">       6 ----|</a>
             |     15   special (master enable)       INTEN    -
             |----
       7 ----|____ --   non-maskable interrupt        <a href="../Libraries_Manual_guide/node0305.html">NMI</a>      S
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
