<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/34.11 FILE="Libraries/Lib_B" NODE="B-2-1" TITLE="B / rootclass / New Methods: OM_NEW" INDEX="Libraries/Lib_Index/MAIN" -->
<head>
<title>B / rootclass / New Methods: OM_NEW</title>
</head>
<body>
<img src="../images/toc_d.gif" alt="[Contents]">
<a href="../Libraries_Manual_guide/node002C.html"><img src="../images/index.gif" alt="[Index]" border=0></a>
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../Libraries_Manual_guide/node04BB.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../Libraries_Manual_guide/node04BD.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
This method tells a class to create a new instance of itself.  If OM_NEW
is successful, it returns a pointer to the new object, otherwise it
returns NULL.

For programmers who are only creating Boopsi objects rather than creating
custom classes, use the intuition.library function <a href="../Libraries_Manual_guide/node0203.html#line25">NewObject()</a>:

    APTR NewObject(struct IClass  *privateclass,
                   UBYTE          *publicclassname,
                   ULONG          firsttag,
                   ...)

The OM_NEW method receives the following arguments (defined in
&#060;intuition/<a href="../Includes_and_Autodocs_2._guide/node00E2.html#line76">classusr.h</a>&#062;):

    struct opSet /* The OM_NEW method uses the same structure as OM_SET */
    {
        ULONG             MethodID;      /* OM_NEW */
        struct TagItem    *ops_AttrList; /* tag attributes to initialize */
        struct GadgetInfo *ops_GInfo;    /* Always NULL for OM_NEW */
    };

The ops_AttrList field contains a pointer to a tag list of attribute/value
pairs.  Each pair contains an attribute ID and the initial value of the
corresponding attribute.

The ops_GInfo field is always NULL for the OM_NEW method.

Unlike other methods, when the dispatcher gets an OM_NEW message, the
object pointer (newobject from the <a href="../Libraries_Manual_guide/node0211.html">dispatchRKMModel()</a> prototype above)
does not point to an object, since the idea is to create a new object.
The pointer normally used to pass a Boopsi object is instead used to pass
the address of the object's &#034;true class&#034; (the class of which the object
is an instance).

The first thing the dispatcher does when it processes an OM_NEW message is
pass the OM_NEW message on to its superclass's dispatcher.  It does this
using the amiga.lib function <a href="../Libraries_Manual_guide/node0212.html#line27">DoSuperMethodA()</a>:

    ULONG DoSuperMethodA(Class *cl, Object *trueclass, Msg msg);

Each superclass's dispatcher does this until the message gets to the
rootclass dispatcher.

Each class keeps a record of how much memory its local instance data
requires.  The <a href="../Libraries_Manual_guide/node04BB.html">rootclass</a> dispatcher's OM_NEW method looks at the object's
true class (newobject from the prototype) to find out how much memory to
allocate for the object's instance data.  The rootclass dispatcher
allocates enough memory for the true class's local instance data, plus
enough memory for the local instance data of each of the true class's
superclasses.  If all goes well, the rootclass dispatcher increments the
true class's internal count of instances of true class, and returns a
pointer to the newly created object.  it passes control back to the
subclass dispatcher that called it.  If there was a problem, the rootclass
dispatcher passes back a NULL.

When the <a href="../Libraries_Manual_guide/node04BB.html">rootclass</a> dispatcher returns, the subclass dispatcher regains
control from <a href="../Libraries_Manual_guide/node0212.html#line27">DoSuperMethodA()</a>.  DoSuperMethodA() will return either a
pointer to the new object or NULL if there was an error.  Although the
rootclass dispatcher allocated all the memory the object needs, it did not
set up any of that memory.  Now its the the subclass dispatcher's turn to
do some work.  It has to initialize the instance data that is local to its
class.  A dispatcher finds its local instance data by using the
INST_DATA() macro (defined in &#060;intuition/<a href="../Includes_and_Autodocs_2._guide/node00DA.html#line46">classes.h</a>&#062;).

After initializing its local instance data, the subclass dispatcher passes
control down to its subclass dispatcher, which in turn, initializes its
local instance data.  Control passes down from class to subclass until the
true class dispatcher regains control.

Now the true class dispatcher has to initialize its local instance data.
It has to scan through the tag list of attribute/value pairs passed in the
OM_NEW message (opSet.ops_AttrList).  If the dispatcher finds any
attributes that the true class recognizes, it has to initialize them to
the value passed in the attribute/value pair.

At this point, the new object can allocate other resources it needs that
it did not allocate as part of its instance data.  For example, the new
Boopsi object might need a frame image around itself, so it can create a
new one using a Boopsi frame image.  If the object allocates any resources
in this step, it must deallocate these resources later when it is disposed
in the <a href="../Libraries_Manual_guide/node04BD.html">OM_DISPOSE</a> method.

Finally, the dispatcher can return.  When the dispatcher returns from an
OM_NEW method, it returns a pointer to the new object.
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
