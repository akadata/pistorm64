<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/39.2 FILE="graphics" NODE="BltBitMap()" TITLE="graphics.library/BltBitMap" -->
<head>
<title>graphics.library/BltBitMap</title>
</head>
<body text="#000000" bgcolor="#AAAAAA">
<img src="../images/toc_d.gif" alt="[Contents]">
<img src="../images/index_d.gif" alt="[Index]">
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../Includes_and_Autodocs_3._guide/node02B1.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../Includes_and_Autodocs_3._guide/node02B3.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->

<b>   NAME</b>
	BltBitMap -- <a href="../Includes_and_Autodocs_3._guide/node0301.html">Move</a> a rectangular region of bits in a <a href="../Includes_and_Autodocs_3._guide/node05DC.html#line45">BitMap</a>.

<b>   SYNOPSIS</b>
	planecnt = BltBitMap(SrcBitMap, SrcX, SrcY, DstBitMap,
	D0                   A0         D0:16 D1:16 A1
	    DstX, DstY, SizeX, SizeY, Minterm, Mask [, TempA])
	    D2:16 D3:16 D4:16  D5:16  D6:8     D7:8   [A2]

	ULONG BltBitMap(struct <a href="../Includes_and_Autodocs_3._guide/node05DC.html#line45">BitMap</a> *, WORD, WORD, struct <a href="../Includes_and_Autodocs_3._guide/node05DC.html#line45">BitMap</a> *,
	    WORD, WORD, WORD, WORD, <a href="../Includes_and_Autodocs_3._guide/node0654.html#line50">UBYTE</a>, <a href="../Includes_and_Autodocs_3._guide/node0654.html#line50">UBYTE</a>, <a href="../Includes_and_Autodocs_3._guide/node0654.html#line43">UWORD</a> *);

<b>   FUNCTION</b>
	Perform non-destructive blits to move a rectangle from one
	area in a <a href="../Includes_and_Autodocs_3._guide/node05DC.html#line45">BitMap</a> to another area, which can be on a different
	<a href="../Includes_and_Autodocs_3._guide/node05DC.html#line45">BitMap</a>.
	This blit is assumed to be friendly: no error conditions (e.g.
	a rectangle outside the <a href="../Includes_and_Autodocs_3._guide/node05DC.html#line45">BitMap</a> bounds) are tested or reported.

<b>   INPUTS</b>
	SrcBitMap, DstBitMap - the BitMap(s) containing the
	      rectangles
	    - the planes copied from the source to the destination are
	      only those whose plane numbers are identical and less
	      than the minimum Depth of either <a href="../Includes_and_Autodocs_3._guide/node05DC.html#line45">BitMap</a> and whose Mask
	      bit for that plane is non-zero.
	    - as a special case, if a plane pointer in the SrcBitMap
	      is zero, it acts as a pointer to a plane of all zeros, and
	      if the plane pointer is 0xffffffff, it acts as a pointer
	      to a plane of all ones.  (Note: new for V36)
	    - SrcBitMap and DstBitMap can be identical if they point
	      to actual planes.
	SrcX, SrcY - the x and y coordinates of the upper left corner
	    of the source rectangle.  Valid range is positive
	    signed integer such that the raster word's offset
	    0..(32767-Size)
	DstX, DstY - the x and y coordinates of the upper left
	    corner of the destination for the rectangle.  Valid
	    range is as for Src.
	SizeX, SizeY - the size of the rectangle to be moved.  Valid
	    range is (X: 1..976; Y: 1..1023 such that final raster
	    word's offset is 0..32767)
	Minterm - the logic function to apply to the rectangle when
	    A is non-zero (i.e. within the rectangle).  B is the
	    source rectangle and C, D is the destination for the
	    rectangle.
	    - $0C0 is a vanilla copy
	    - $030 inverts the source before the copy
	    - $050 ignores the source and inverts the destination
	    - see the hardware reference manual for other combinations
	Mask - the write mask to apply to this operation.  Bits set
	    indicate the corresponding planes (if not greater than
	    the minimum plane count) are to participate in the
	    operation.  Typically this is set to 0xff.
	TempA - If the copy overlaps exactly to the left or right
	    (i.e. the scan line addresses overlap), and TempA is
	    non-zero, it points to enough chip accessible memory
	    to hold a line of A source for the blit (ie CHIP RAM).
	    BltBitMap will allocate (and free) the needed TempA if
	    none is provided and one is needed.  Blit overlap is
	    determined from the relation of the first non-masked
	    planes in the source and destination bit maps.

<b>   RESULTS</b>
	planecnt - the number of planes actually involved in the blit.

<b>   NOTES</b>
	o   This function may use the blitter.

<b>   SEE ALSO</b>
	<a href="../Includes_and_Autodocs_3._guide/node02C3.html">ClipBlit()</a>  <a href="../Includes_and_Autodocs_3._guide/node05DC.html">graphics/gfx.h</a>  <a href="../Includes_and_Autodocs_3._guide/node05DF.html">hardware/blit.h</a>
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
