<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/39.2 FILE="include/intuition/classusr.h" NODE="MAIN" TITLE="include/intuition/classusr.h" -->
<head>
<title>include/intuition/classusr.h</title>
</head>
<body text="#000000" bgcolor="#AAAAAA">
<img src="../images/toc_d.gif" alt="[Contents]">
<img src="../images/index_d.gif" alt="[Index]">
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../Includes_and_Autodocs_3._guide/node0635.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../Includes_and_Autodocs_3._guide/node0637.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
#ifndef	INTUITION_CLASSUSR_H
#define INTUITION_CLASSUSR_H	1
/*
**  $VER: classusr.h 38.2 (14.4.1992)
**  Includes Release 44.1
**
**  For application users of Intuition object classes
**
**  (C) Copyright 1989-1999 Amiga, Inc.
**	    All Rights Reserved
*/


#ifndef UTILITY_HOOKS_H
#include &#060;utility/hooks.h&#062;
#endif

<a name="line18">/*** User visible handles on objects, classes, messages ***/</a>
typedef ULONG	Object;		/* abstract handle */
<a name="line20"></a>
typedef	UBYTE	*ClassID;

/* you can use this type to point to a &#034;generic&#034; message,
 * in the object-oriented programming parlance.  Based on
 * the value of 'MethodID', you dispatch to processing
 * for the various message types.  The meaningful parameter
 * packet structure definitions are defined below.
<a name="line28"> */</a>
typedef struct {
    ULONG MethodID;
    /* method-specific data follows, some examples below */
}		*Msg;

/*
 * Class id strings for Intuition classes.
 * There's no real reason to use the uppercase constants
 * over the lowercase strings, but this makes a good place
 * to list the names of the built-in classes.
 */
#define ROOTCLASS	&#034;rootclass&#034;		/* classusr.h	  */
#define IMAGECLASS	&#034;imageclass&#034;		/* imageclass.h   */
#define FRAMEICLASS	&#034;frameiclass&#034;
#define SYSICLASS	&#034;sysiclass&#034;
#define FILLRECTCLASS	&#034;fillrectclass&#034;
#define GADGETCLASS	&#034;gadgetclass&#034;		/* gadgetclass.h  */
#define PROPGCLASS	&#034;propgclass&#034;
#define STRGCLASS	&#034;strgclass&#034;
#define BUTTONGCLASS	&#034;buttongclass&#034;
#define FRBUTTONCLASS	&#034;frbuttonclass&#034;
#define GROUPGCLASS	&#034;groupgclass&#034;
#define ICCLASS		&#034;icclass&#034;		/* icclass.h	  */
#define MODELCLASS	&#034;modelclass&#034;
#define ITEXTICLASS	&#034;itexticlass&#034;
#define POINTERCLASS	&#034;pointerclass&#034;		/* pointerclass.h */

/* Dispatched method ID's
 * NOTE: Applications should use Intuition entry points, not direct
 * DoMethod() calls, for NewObject, DisposeObject, SetAttrs,
 * SetGadgetAttrs, and GetAttr.
 */

#define OM_Dummy	(0x100)
#define OM_NEW		(0x101)	/* 'object' parameter is &#034;true class&#034;	*/
#define OM_DISPOSE	(0x102)	/* delete self (no parameters)		*/
#define OM_SET		(0x103)	/* set attributes (in tag list)		*/
#define OM_GET		(0x104)	/* return single attribute value	*/
#define OM_ADDTAIL	(0x105)	/* add self to a List (let root do it)	*/
#define OM_REMOVE	(0x106)	/* remove self from list		*/
#define OM_NOTIFY	(0x107)	/* send to self: notify dependents	*/
#define OM_UPDATE	(0x108)	/* notification message from somebody	*/
#define OM_ADDMEMBER	(0x109)	/* used by various classes with lists	*/
#define OM_REMMEMBER	(0x10A)	/* used by various classes with lists	*/

/* Parameter &#034;Messages&#034; passed to methods	*/

<a name="line76">/* OM_NEW and OM_SET	*/</a>
struct opSet {
    ULONG		MethodID;
    struct TagItem	*ops_AttrList;	/* new attributes	*/
    struct GadgetInfo	*ops_GInfo;	/* always there for gadgets,
					 * when SetGadgetAttrs() is used,
					 * but will be NULL for OM_NEW
					 */
};

<a name="line86">/* OM_NOTIFY, and OM_UPDATE	*/</a>
struct opUpdate {
    ULONG		MethodID;
    struct TagItem	*opu_AttrList;	/* new attributes	*/
    struct GadgetInfo	*opu_GInfo;	/* non-NULL when SetGadgetAttrs or
					 * notification resulting from gadget
					 * input occurs.
					 */
    ULONG		opu_Flags;	/* defined below	*/
};

/* this flag means that the update message is being issued from
 * something like an active gadget, a la GACT_FOLLOWMOUSE.  When
 * the gadget goes inactive, it will issue a final update
 * message with this bit cleared.  Examples of use are for
 * GACT_FOLLOWMOUSE equivalents for propgadclass, and repeat strobes
 * for buttons.
 */
#define OPUF_INTERIM	(1&#060;&#060;0)

<a name="line106">/* OM_GET	*/</a>
struct opGet {
    ULONG		MethodID;
    ULONG		opg_AttrID;
    ULONG		*opg_Storage;	/* may be other types, but &#034;int&#034;
					 * types are all ULONG
					 */
};

<a name="line115">/* OM_ADDTAIL	*/</a>
struct opAddTail {
    ULONG		MethodID;
    struct List		*opat_List;
};

/* OM_ADDMEMBER, OM_REMMEMBER	*/
<a name="line122">#define  opAddMember opMember</a>
struct opMember {
    ULONG		MethodID;
    Object		*opam_Object;
};


#endif
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
