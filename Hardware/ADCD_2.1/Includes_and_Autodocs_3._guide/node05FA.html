<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/39.2 FILE="include/libraries/hdwrench.h" NODE="MAIN" TITLE="include/libraries/hdwrench.h" -->
<head>
<title>include/libraries/hdwrench.h</title>
</head>
<body text="#000000" bgcolor="#AAAAAA">
<img src="../images/toc_d.gif" alt="[Contents]">
<img src="../images/index_d.gif" alt="[Index]">
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../Includes_and_Autodocs_3._guide/node05F9.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../Includes_and_Autodocs_3._guide/node05FB.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
#ifndef LIBRARIES_HDWRENCH_H
#define LIBRARIES_HDWRENCH_H

/*
**	$VER: hdwrench.h 44.3 (29.7.1999)
**	Includes Release 44.1
**
**	Disk Prep Support Library API includes
**
**	(C) Copyright 1999 Joanne B. Dow, Wizardess Designs,
**	    for license to Amiga, Inc.
**
**	    All Rights Reserved
*/

/*****************************************************************************/

#ifndef EXEC_LIBRARIES_H
#include &#060;exec/libraries.h&#062;
#endif

#ifndef DEVICES_HARDBLOCKS_H
#include &#060;devices/hardblocks.h&#062;
#endif

/*****************************************************************************/
<a name="line27"></a>
struct HDWLibrary
{
        struct Library       ml_Lib;
        ULONG                ml_SegList;
        ULONG                ml_Flags;
        APTR                 ml_ExecBase; /* pointer to exec base  */
        long                *ml_relocs;   /* pointer to relocs.    */
        struct HDWLibrary   *ml_origbase; /* pointer to original library base  */
        long                 ml_numjmps;
};

#define  HDWBaseName    &#034;hdwrench.library&#034;

/* === General Constant Defines === */

/* Artificial unassigned value for the RDB structures. */
#define UNASSIGNED  (ULONG) -131L

/* End block number link within RDB structures */
#define RDBEND      (ULONG) -1L

#define DEFAULT_RDBBLOCKSHI 63

/* === Structure &#038; Typedefs === */

typedef struct
{
    USHORT  ready [ 16 ];   /* Tests ready and first block read */
    USHORT  there [ 16 ];   /* Tests as &#034;there&#034; but fails other tests */
} ValidIDstruct;


/* Actual disk read write return structure: */
struct rw_return                /* Should fit within a ULONG */
{
    USHORT  success;            /* Error code */
    USHORT  failed_word;        /* 0 on reads. */
    USHORT  block_written;      /* 0 on reads. */
};

enum rw_success_val             /* Return values for rw_return.success field. */
{
    success = 0,                /* 0 */
    success_on_retry_write,     /* 1 */
    success_on_retry_read,      /* 2 */
    failed_on_write,            /* 3 */
    failed_on_reread,           /* 4 */
    illegal_command,            /* 5 */
    io_command_failure,         /* 6 */
    scsi_command_failure,       /* 7 */
    out_of_memory,              /* 8 */
    no_more_disk_blocks,        /* 9 */
    rdsk_not_located,           /* 10 */
    io_device_not_open,         /* 11 */
    invalid_blocksize_found,    /* 12 */
    no_callback_hook,           /* 13 */
    user_aborted,               /* 14 */
    operation_not_permitted     /* 15 */
};

/* Internal bootblock structure. Create dummy structures to pass to read
 * and write functions as necessary. Be sure that bb_BlockNum is filled in
 * and that the actual size of the data area pointed to by the union is
 * sufficiently large to contain one disk block.
 */
typedef struct bootblock
{
    struct MinNode   bb_Node;
    LONG             allocsize;
    LONG             bb_BlockNum;
    WORD             bb_Changed;
    LONG             unit;              /* Unit number for THIS set of RDBs. */
    char             DeviceName [32];   /* Device name */
    struct rw_return bb_RWErrors;
    BOOL             wflag;             /* Written out flag. */
    BYTE             spares[4-sizeof(BOOL)];/* Fill out short word */

    union
    {
        struct       RigidDiskBlock bd_RDB;
        struct       PartitionBlock bd_PB;
        struct       FileSysHeaderBlock bd_FHB;
        struct       LoadSegBlock bd_LSB;
        struct       BadBlockBlock bd_BB;
        UBYTE        bd_Bytes[512];     /* NB: This is the MINIMUM size we */
        UWORD        bd_Words[256];     /* can have here. It MAY be extended */
        ULONG        bd_Longs[128];     /* if actual block size is larger. */
    } bb_Data;
} BootBlock;

/*  ==== Error report values for other functions ==== */
#define E_NOERROR           0

#define E_ILLEGAL_SLASH     200
#define E_EOF_IN_COMMENT    201
#define E_ILLEGAL_STAR      202
#define E_TOKEN_TO_LONG     203
#define E_MEMORY_PANIC      204
#define E_PREMATURE_EOF     205
#define E_MISSING_EQUALS    206
#define E_ILLEGAL_T_F       207
#define E_ILLEGAL_TOKEN     208
#define E_DUPLICATE_DISK    209
#define E_NOT_LEGAL_NAME    210
#define E_EXCEEDED_SIZE_LIM 211
#define E_FILE_WRITE_ERROR  212
#define E_TOOMANY_FS        213
#define E_FSAVE_CONFUSION   214
#define E_FS_CANNOT_OPEN    215
#define E_LOST_IN_RDB_SPACE 216
#define E_FS_WRITE_ERROR    217
#define E_MULTIPLE_RDSKS    218
#define E_RDSK_NOT_1ST      219
#define E_NO_RDBS_LOADED    220
#define E_RDBS_ALREADY_IN   221     /* RDBs already loaded. */
#define E_FAILED_FILEOPEN   222
#define E_FILE_READ_FAILED  223
#define E_FILE_NOT_RDBS     224
#define E_NO_BLOCKSIZE_SPEC 225
#define E_FILE_WRITE_FAILED 226
#define E_MEMORYP_NULL      227     /* prospective &#034;memp&#034; is null */
#define E_ILLEGAL_BLOCKSIZE 228
#define E_INSUFFICIENT_MEM  229
#define E_RENUMBER_FAILED   230
#define E_BLOCKS_EXCEEDED   231     /* Too many RDB blocks */
#define E_INCOMPLETE_FSDESC 232
#define E_FS_NOT_FOUND      233
#define E_LIST_SCREWEDUP    234
#define E_NO_SUCH_DIR       235
#define E_EXALL_ERROR       236
#define E_UNIT_DIFFERS      237

#define T_RENUMBER_LEFT     300

#define W_DUPLICATE_FS      100
#define W_FS_NO_WRITE       101

/* Definitions for type field in FileSave */
#define DRIVEINIT   0
#define FILESYSTEM  1
<a name="line168"></a>
struct DefaultsArray
{
    ULONG   TotalBlocks;
    UWORD   BytesPerBlock;
    UWORD   BlocksPerSurface;
    UWORD   Surfaces;
    UWORD   Cylinders;          /* note: MaxCyl = Cylinders - 1; */
    UWORD   UnusedBlocks;
};

/* Defaults Array filling error bit array */
#define DA_NOERRORS             0
#define DA_NO_CAPACITY_REPORT   1
#define DA_NO_OPTIMIZE          2
#define DA_BAD_MODESENSE_4      4
#define DA_BAD_MODESENSE_3      8
#define DA_FAILED               256
#define DA_NO_DRIVE_OPEN        DA_FAILED
#define DA_RIDICULOUS_VALUES    ( DA_FAILED &#060;&#060; 1 )

/* Defaults Array filling &#034;Optimize&#034; Flags */
#define DA_OPTIMIZE             1   /* Optimize storage if possible */
#define DA_HUGE                 2   /* Allow partitioning huge disks */
#define DA_HF_WAY               4   /* Use the old HardFrame algorithm */
/* Note: DA_HF_WAY is forces DA_OPTIMIZE and DA_HUGE off. */
/*       DA_BAD_MODESENSE_3 and DA_BAD_MODESENSE_4 only happen with DA_HF_WAY */
/*       Errors below DA_FAILED are informational. */

/*  ==== Mountfile Recognized Strings ==== */
#ifdef DONT_EVER_COMPILE_ME /* This stuff is for reference only, thank you. */

#ifdef FORREAL
#define EXTERN
#else
#define EXTERN  extern
#endif

EXTERN const char   *_Tokens[]
#ifdef FORREAL
= {
    &#034;/&#034;,                    /*0 */
    &#034;#&#034;,
    &#034;=&#034;,
    &#034;device&#034;,
    &#034;surfaces&#034;,
    &#034;blockspertrack&#034;,
    &#034;reserved&#034;,
    &#034;prealloc&#034;,
    &#034;interleave&#034;,
    &#034;lowcyl&#034;,
    &#034;highcyl&#034;,              /* 10 */
    &#034;buffers&#034;,
    &#034;bufmemtype&#034;,
    &#034;maxtransfer&#034;,
    &#034;mask&#034;,
    &#034;bootpri&#034;,
    &#034;dostype&#034;,
    &#034;unit&#034;,
    &#034;flags&#034;,
    &#034;stacksize&#034;,
    &#034;priority&#034;,             /* 20 */
    &#034;globvec&#034;,
    &#034;filesystem&#034;,
    &#034;mount&#034;,
    &#034;heads&#034;,
    &#034;bytesperblock&#034;,
    &#034;disk&#034;,
    &#034;rdblow&#034;,
    &#034;rdbhi&#034;,
    &#034;reselect&#034;,
    &#034;hilun&#034;,                /* 30 */
    &#034;hiid&#034;,
    &#034;hidrive&#034;,
    &#034;cylinders&#034;,
    &#034;cylinderblocks&#034;,
    &#034;mincyl&#034;,
    &#034;maxcyl&#034;,
    &#034;hicard&#034;,
    &#034;blocksize&#034;,
    &#034;bootable&#034;,
    &#034;readonly&#034;,             /* 40 */
    &#034;driveinit&#034;,
    &#034;baud&#034;,
    &#034;control&#034;,
    &#034;bootblocks&#034;,
    &#034;synch&#034;,
    &#034;sectorsperblock&#034;,
    &#034;\xff&#034;
}
#endif
;

#define TSLASH          0
#define THACK           1
#define TEQUALS         2
#define TDEVICE         3
#define TSURFACES       4
#define TBLOCKSPERTRACK 5
#define TRESERVED       6
#define TPREALLOC       7
#define TINTERLEAVE     8
#define TLOWCYL         9
#define THICYL          10
#define TBUFFERS        11
#define TBUFMEMTYPE     12
#define TMAXTRANSFER    13
#define TMASK           14
#define TBOOTPRI        15
#define TDOSTYPE        16
#define TUNIT           17
#define TFLAGS          18
#define TSTACKSIZE      19
#define TPRIORITY       20
#define TGLOBVEC        21
#define TFILESYSTEM     22
#define TMOUNT          23
#define THEADS          24
#define TBYTESPERBLOCK  25
#define TDISK           26
#define TRDBLOW         27
#define TRDBHI          28
#define TRESELECT       29
#define THILUN          30
#define THIID           31
#define TLASTDRIVE      32
#define TCYLINDERS      33
#define TCYLINDERBLOCKS 34
#define TMINCYL         35
#define TMAXCYL         36
#define THICARD         37
#define TBLOCKSIZE      38
#define TBOOTABLE       39
#define TREADONLY       40
#define TDRIVEINIT      41
#define TBAUD           42
#define TCONTROL        43
#define TBOOTBLOCKS     44
#define TSYNCH          45
#define TSECSPERBLOCK   46

#define TokenCount      46
#define TNOMATCH        TokenCount + 1

#endif /* COMPILEME */



typedef struct
{
    STRPTR  devicename;
    LONG    board;
    LONG    address;
    LONG    lun;
    STRPTR  messagestring;
    LONG    extra;
    LONG    param1;
    LONG    param2;
    LONG    param3;
} HDWCallbackMsg;

#define EXTRA_BEFORE_TEST       0
#define EXTRA_AFTER_TEST        1
#define EXTRA_BEFORE_FORMAT     2       /* with no way to stop once you start.*/
#define EXTRA_BEFORE_VERIFY     3       /* Setup the verify requester and
                                           return &#034;go ahead&#034; */
#define EXTRA_UPDATE_VERIFY     4       /* New string for requester - return
                                           any Abort received */
#define EXTRA_VERIFY_REASSIGN   5       /* New string - return &#034;Yes&#034; or &#034;No&#034; */
#define EXTRA_VERIFY_FINISHED   6       /* Notify user, accept OK, close */

#define INQBUFSIZE  36  /* Standard size of Inquiry buffer */

/****************************************************************************/

/*
 *	Callback messages for the hdwrench.library tester program.
 *	These strings are &#034;suggested&#034; English strings for use with
 *	the hdwrench.library callback hook.
 */

#ifdef USE_SUGGESTED_MESSAGES
    /* MESSAGE */                                   /* .extra usages */
char *callback_messages[] =
{
    /* A) FINDVALID_SCANNING_STRING */              /* 0 and 1 */
    &#034;Scanning: %s: %d%d%d&#034;,         /* from message: devicename, board, lun, addr */

    /* B) LONGTIME_NOABORT_WARNING */               /* 2 */
    &#034;You are about to format LUN %d on\n&#034;
    &#034;drive %d attached to board %d\n\n&#034;
    &#034;***WARNING WARNING WARNING***\n&#034;
    &#034;It can take up to several hours\n&#034;
    &#034;to format a hard disk. And there\n&#034;
    &#034;is no safe way to abort.\n\n&#034;
    &#034;Are you VERY sure you want to do this?\n&#034;,
    /* C) LONGTIME_VERIFY_WARNING */                /* 3 */
    &#034;LUN %d on drive %d on board %d\n&#034;
    &#034;            Note\n&#034;
    &#034;It can take up to several hours\n&#034;
    &#034;to verify a hard disk. However,\n&#034;
    &#034;you can abort during verify.\n\n&#034;
    &#034;No data will be changed on the\n&#034;
    &#034;drive.\n\n&#034;
    &#034;Do you wish to continue?\n&#034;,

    /* D) FORMAT_USER_ABORTED_STRING */             /* 6 */
    &#034;User Aborted. Your drive is safe!\n&#034;,

    /* E) FORMAT_MOUNTED_DRIVE */                   /* 4 */
    &#034;%s\nShould we format a mounted drive?\n&#034;,

    /* F) FORMAT_NOT_PERMITTED */                   /* 6 */
    &#034;%s\nFormatting the system disk\nis not permitted. Aborting...\n&#034;,

    /* G) FORMAT_UNRECOGNIZED_STATUS */             /* 6 */
    &#034;Unrecognized SCSI status byte 0x%2.2x returned.\n&#034;,

    /* H) FORMAT_RESERVATION_CONFLICT */            /* 6 */
    &#034;Device is reserved by another initiator.\n&#034;,

    /* I) FORMAT_DRIVE_BUSY */                      /* 6 */
    &#034;Drive is busy.\n&#034;,

    /* J) FORMAT_COMMAND_PROBLEM */                 /* 6 */
    &#034;Unknown problem issuing SCSI Direct command!\n&#034;,

    /* K) FORMAT_SUCCESS_STRING */                  /* 6 */
    &#034;Format completed with no errors.&#034;,

    /* L) FORMAT_FAILED_STRING */                   /* 6 maybe */
    &#034;Format failed! Your drive may be dead.\n&#034;,

    /* M) VERIFY_USER_ABORTED_STRING */             /* 6 */
    &#034;User Aborted.\n&#034;,

    /* N) VERIFY_READCAPACITY_FAILED */             /* 6 */
    &#034;ReadCapacity failed! Verify impossible.\n&#034;,

    /* O) VERIFY_PROGRESS */                        /* 4 */
    &#034;Verifying blocks %d to %d of %d.\r&#034;,

    /* P) VERIFY_REASSIGN_Q */                      /* 5 */
    &#034;Block %d is bad.\n&#034;
    &#034;Reassign this bad block?&#034;,

    /* Q) VERIFY_COMPLETED_STRING */                /* 6 */
    &#034;Verify completed:\n&#034;
    &#034;    %d errors,\n&#034;
    &#034;    %d successful reassignments,\n&#034;
    &#034;and %d failed reassignments\n&#034;,

    /* R) VERIFY_ERROR_UNKNOWN_LOC */               /* 4 */
    &#034;Medium error at unknown location!\n&#034;
    &#034;You should back up the drive and low-level format\n&#034;,

    /* S) VERIFY_HARDWARE_ERROR */                  /* 4 */
    &#034;Hardware error %ld!\n&#034;,

    /* T) VERIFY_RECOVERED_ERROR */                 /* 4 */
    &#034;Recovered read error at block %ld\n&#034;,

    /* U) VERIFY_RECOVERED_UNKNOWN_LOC */           /* 4 */
    &#034;Recovered error at unknown location!\n&#034;
    &#034;You should consider backing up the\n&#034;
    &#034;drive and reformatting\n&#034;,

    /* V) VERIFY_ILLEGAL_REQUEST */                 /* 4 */
    &#034;Drive returned an Illegal Request Error (%ld)\n&#034;,

    /* W) VERIFY_UNKNOWN_ERROR */
    &#034;Unknown error: sense key %ld (more)\n&#034;
    &#034;Device returned sense code %ld (more)\n&#034;
    &#034;Consult drive documentation\n&#034;,

    /* X) VERIFY_CONTINUE */                        /* 4 */
    &#034;Continuing verify at block %d...\n&#034;,

    /* Y) VERIFY_SEEK_ERROR */                      /* 4 */
    &#034;seek eror!\n&#034;,

    /* Z) VERIFY_MEDIUM_ERROR */                    /* 4 */
    &#034;Medium error at unknown location!\n&#034;
    &#034;You should back up the drive and low-level format\n&#034;,

    /* [) VERIFY_ILLEGAL_COMMAND */                 /* 4 */
    &#034;Illegal command!\n&#034;,

    /* \) VERIFY_ILLEGAL_ADDRESS */                 /* 4 */
    &#034;Illegal address %ld!&#034;,

    /* ]) VERIFY_BAD_ARGUEMENT */                   /* 4 */
    &#034;Bad command arguement!\n&#034;,

    /* ^) VERIFY_CARTRIDGE_CHANGED */               /* 4 */
    &#034;Cartridge changed&#034;,

    /* _) VERIFY_ILLEGAL_LUN */                     /* 4 */
    &#034;Invalid LUN addressed!&#034;,

    /* `) VERIFY_UNFORMATTED_DRIVE */               /* 4 */
    &#034;Unformatted drive!&#034;,

    /* a) VERIFY_NONEXTENDED_SENSE */               /* 4 */
    &#034;Non-extended sense error is 0x%x&#034;,

    /* b) VERIFY_NO_SCSI_ERROR_RETURNED */          /* 4 */
    &#034;Device didn't return good sense data!&#034;,

    /* other */
    &#034;Illegal callback message %x&#034;                   /* any */
};

#define MIN_MESSAGE 'A'
#define MAX_MESSAGE 'b'

#endif /* USE_SUGGESTED_MESSAGES */

#endif	/* LIBRARIES_HDWRENCH_H */
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
