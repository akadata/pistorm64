Hardware_Manual_guide/node003F.html.txt:1:A Register Summary / SPRxCTL, SPRxPOS ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- SPRxCTL 142 W A D( E ) Sprite x vert stop position and control data SPRxPOS 140 W A D Sprite x vert-horiz start position data These two registers work together as position, size and feature sprite-control registers. They are usually loaded by the sprite DMA channel during horizontal blank; however, they may be loaded by either processor at any time. SPRxPOS register: BIT# SYM FUNCTION ---- ---- ----------------------------- 15-08 SV7-SV0 Start vertical value. High bit(SV8) is in SPRxCTL register below. 07-00 SH8-SH1 Start horizontal value. Low bit(SH0) is in SPRxCTL register below. SPRxCTL register (writing this address disables sprite horizontal comparator circuit): BIT# SYM FUNCTION ---- -------- ----------------------------- 15-08 EV7-EV0 End (stop) vertical value low 8 bits 07 ATT Sprite attach control bit (odd sprites) 06-04 X Not used 02 SV8 Start vertical value high bit 01 EV8 End (stop) vertical value high bit 00 SH0 Start horizontal value low bit [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0060.html.txt:1:Amiga® Hardware Reference Manual: B Register Summary Address Order ]" border=0> This appendix contains information about the register set in address order. The following codes and abbreviations are used in this appendix: & Register used by DMA channel only. % Register used by DMA channel usually, processors sometimes. + Address register pair. Must be an even address pointing to chip memory. * Address not writable by the Copper. ~ Address not writable by the Copper unless the "copper danger bit", COPCON is set true. A,D,P A=Agnus chip, D=Denise chip, P=Paula chip. W,R W=write-only; R=read-only, ER Early read. This is a DMA data transfer to RAM, from either the disk or the blitter. RAM timing requires data to be on the bus earlier than microprocessor read cycles. These transfers are therefore initiated by Agnus timing, rather than a read address on the destination address bus. S Strobe (write address with no register bits). Writing the register causes the effect. PTL,PTH Chip memory pointer that addresses DMA data. Must be reloaded by a processor before use (vertical blank for bitplane and sprite pointers, and prior to starting the blitter for blitter pointers). LCL,LCH Chip memory location (starting address) of DMA data. Used to automatically restart pointers, such as the Copper program counter (during vertical blank) and the audio sample counter (whenever the audio length count is finished). MOD 15-bit modulo. A number that is automatically added to the memory address at the end of each line to generate the address for the beginning of the next line. This allows the blitter (or the display window) to operate on (or display) a window of data that is smaller than the actual picture in memory (memory map). Uses 15 bits, plus sign extend. About the ECS registers. ------------------------ Registers denoted with an "(E)" in the chip column means that those registers have been changed in the Enhanced Chip Set (ECS). The ECS is found in the A3000, and is installable in the A500 and A2000. Certain ECS registers are completely new, others have been extended in their functionality. See the register map in Appendix C for information on which ECS registers are new and which have been modified. ---------------------------------------------------------------------- NAME ADD R/W CHIP FUNCTION ---------------------------------------------------------------------- BLTDDAT & *000 ER A Blitter destination early read (dummy address) DMACONR *002 R AP DMA control (and blitter status) read VPOSR *004 R A( E ) Read vert most signif. bit (and frame flop) VHPOSR *006 R A Read vert and horiz. position of beam DSKDATR & *008 ER P Disk data early read (dummy address) JOY0DAT *00A R D Joystick-mouse 0 data (vert,horiz) JOY1DAT *00C R D Joystick-mouse 1 data (vert,horiz) CLXDAT *00E R D Collision data register (read and clear) ADKCONR *010 R P Audio, disk control register read POT0DAT *012 R P( E ) Pot counter pair 0 data (vert,horiz) POT1DAT *014 R P( E ) Pot counter pair 1 data (vert,horiz) POTGOR *016 R P Pot port data read (formerly POTINP) SERDATR *018 R P Serial port data and status read DSKBYTR *01A R P Disk data byte and status read INTENAR *01C R P Interrupt enable bits read INTREQR *01E R P Interrupt request bits read DSKPTH + *020 W A( E ) Disk pointer (high 3 bits, 5 bits if ECS) DSKPTL + *022 W A Disk pointer (low 15 bits) DSKLEN *024 W P Disk length DSKDAT & *026 W P Disk DMA data write REFPTR & *028 W A Refresh pointer VPOSW *02A W A Write vert most signif. bit (and frame flop) VHPOSW *02C W A Write vert and horiz position of beam COPCON *02E W A( E ) Coprocessor control register (CDANG) SERDAT *030 W P Serial port data and stop bits write SERPER *032 W P Serial port period and control POTGO *034 W P Pot port data write and start JOYTEST *036 W D Write to all four joystick-mouse counters at once STREQU & *038 S D Strobe for horiz sync with VB and EQU STRVBL & *03A S D Strobe for horiz sync with VB (vert. blank) STRHOR & *03C S DP Strobe for horiz sync STRLONG & *03E S D( E ) Strobe for identification of long horiz. line. BLTCON0 ~040 W A Blitter control register 0 BLTCON1 ~042 W A( E ) Blitter control register 1 BLTAFWM ~044 W A Blitter first word mask for source A BLTALWM ~046 W A Blitter last word mask for source A BLTCPTH + ~048 W A Blitter pointer to source C (high 3 bits) BLTCPTL + ~04A W A Blitter pointer to source C (low 15 bits) BLTBPTH + ~04C W A Blitter pointer to source B (high 3 bits) BLTBPTL + ~04E W A Blitter pointer to source B (low 15 bits) BLTAPTH + ~050 W A( E ) Blitter pointer to source A (high 3 bits) BLTAPTL + ~052 W A Blitter pointer to source A (low 15 bits) BLTDPTH + ~054 W A Blitter pointer to destination D (high 3 bits) BLTDPTL + ~056 W A Blitter pointer to destination D (low 15 bits) BLTSIZE ~058 W A Blitter start and size (window width,height) BLTCON0L ~05A W A( E ) Blitter control 0, lower 8 bits (minterms) BLTSIZV ~05C W A( E ) Blitter V size (for 15 bit vertical size) BLTSIZH ~05E W A( E ) Blitter H size and start (for 11 bit H size) BLTCMOD ~060 W A Blitter modulo for source C BLTBMOD ~062 W A Blitter modulo for source B BLTAMOD ~064 W A Blitter modulo for source A BLTDMOD ~066 W A Blitter modulo for destination D ~068 ~06A ~06C ~06E BLTCDAT % ~070 W A Blitter source C data register BLTBDAT % ~072 W A Blitter source B data register BLTADAT % ~074 W A Blitter source A data register ~076 SPRHDAT ~078 W A( E ) Ext. logic UHRES sprite pointer and data id ~07A DENISEID ~07C R D( E ) Chip revision level for Denise (video out chip) DSKSYNC ~07E W P Disk sync pattern register for disk read COP1LCH + 080 W A( E ) Coprocessor first location register (high 3 bits, high 5 bits if ECS) COP1LCL + 082 W A Coprocessor first location register (low 15 bits) COP2LCH + 084 W A( E ) Coprocessor second location register (high 3 bits, high 5 bits if ECS) COP2LCL + 086 W A Coprocessor second location register (low 15 bits) COPJMP1 088 S A Coprocessor restart at first location COPJMP2 08A S A Coprocessor restart at second location COPINS 08C W A Coprocessor instruction fetch identify DIWSTRT 08E W A Display window start (upper left vert-horiz position) DIWSTOP 090 W A Display window stop (lower right vert.-horiz. position) DDFSTRT 092 W A Display bitplane data fetch start (horiz. position) DDFSTOP 094 W A Display bitplane data fetch stop (horiz. position) DMACON 096 W ADP DMA control write (clear or set) CLXCON 098 W D Collision control INTENA 09A W P Interrupt enable bits (clear or set bits) INTREQ 09C W P Interrupt request bits (clear or set bits) ADKCON 09E W P Audio, disk, UART control AUD0LCH + 0A0 W A( E ) Audio channel 0 location (high 3 bits, 5 if ECS) AUD0LCL + 0A2 W A Audio channel 0 location (low 15 bits) AUD0LEN 0A4 W P Audio channel 0 length AUD0PER 0A6 W P( E ) Audio channel 0 period AUD0VOL 0A8 W P Audio channel 0 volume AUD0DAT & 0AA W P Audio channel 0 data 0AC 0AE AUD1LCH + 0B0 W A Audio channel 1 location (high 3 bits) AUD1LCL + 0B2 W A Audio channel 1 location (low 15 bits) AUD1LEN 0B4 W P Audio channel 1 length AUD1PER 0B6 W P Audio channel 1 period AUD1VOL 0B8 W P Audio channel 1 volume AUD1DAT & 0BA W P Audio channel 1 data 0BC 0BE AUD2LCH + 0C0 W A Audio channel 2 location (high 3 bits) AUD2LCL + 0C2 W A Audio channel 2 location (low 15 bits) AUD2LEN 0C4 W P Audio channel 2 length AUD2PER 0C6 W P Audio channel 2 period AUD2VOL 0C8 W P Audio channel 2 volume AUD2DAT & 0CA W P Audio channel 2 data 0CC 0CE AUD3LCH + 0D0 W A Audio channel 3 location (high 3 bits) AUD3LCL + 0D2 W A Audio channel 3 location (low 15 bits) AUD3LEN 0D4 W P Audio channel 3 length AUD3PER 0D6 W P Audio channel 3 period AUD3VOL 0D8 W P Audio channel 3 volume AUD3DAT & 0DA W P Audio channel 3 data 0DC 0DE BPL1PTH + 0E0 W A Bitplane 1 pointer (high 3 bits) BPL1PTL + 0E2 W A Bitplane 1 pointer (low 15 bits) BPL2PTH + 0E4 W A Bitplane 2 pointer (high 3 bits) BPL2PTL + 0E6 W A Bitplane 2 pointer (low 15 bits) BPL3PTH + 0E8 W A Bitplane 3 pointer (high 3 bits) BPL3PTL + 0EA W A Bitplane 3 pointer (low 15 bits) BPL4PTH + 0EC W A Bitplane 4 pointer (high 3 bits) BPL4PTL + 0EE W A Bitplane 4 pointer (low 15 bits) BPL5PTH + 0F0 W A Bitplane 5 pointer (high 3 bits) BPL5PTL + 0F2 W A Bitplane 5 pointer (low 15 bits) BPL6PTH + 0F4 W A Bitplane 6 pointer (high 3 bits) BPL6PTL + 0F6 W A Bitplane 6 pointer (low 15 bits) 0F8 0FA 0FC 0FE BPLCON0 100 W AD( E ) Bitplane control register (misc. control bits) BPLCON1 102 W D Bitplane control reg. (scroll value PF1, PF2) BPLCON2 104 W D( E ) Bitplane control reg. (priority control) BPLCON3 106 W D( E ) Bitplane control (enhanced features) BPL1MOD 108 W A Bitplane modulo (odd planes) BPL2MOD 10A W A Bitplane modulo (even planes) 10C 10E BPL1DAT & 110 W D Bitplane 1 data (parallel-to-serial convert) BPL2DAT & 112 W D Bitplane 2 data (parallel-to-serial convert) BPL3DAT & 114 W D Bitplane 3 data (parallel-to-serial convert) BPL4DAT & 116 W D Bitplane 4 data (parallel-to-serial convert) BPL5DAT & 118 W D Bitplane 5 data (parallel-to-serial convert) BPL6DAT & 11A W D Bitplane 6 data (parallel-to-serial convert) 11C 11E SPR0PTH + 120 W A Sprite 0 pointer (high 3 bits) SPR0PTL + 122 W A Sprite 0 pointer (low 15 bits) SPR1PTH + 124 W A Sprite 1 pointer (high 3 bits) SPR1PTL + 126 W A Sprite 1 pointer (low 15 bits) SPR2PTH + 128 W A Sprite 2 pointer (high 3 bits) SPR2PTL + 12A W A Sprite 2 pointer (low 15 bits) SPR3PTH + 12C W A Sprite 3 pointer (high 3 bits) SPR3PTL + 12E W A Sprite 3 pointer (low 15 bits) SPR4PTH + 130 W A Sprite 4 pointer (high 3 bits) SPR4PTL + 132 W A Sprite 4 pointer (low 15 bits) SPR5PTH + 134 W A Sprite 5 pointer (high 3 bits) SPR5PTL + 136 W A Sprite 5 pointer (low 15 bits) SPR6PTH + 138 W A Sprite 6 pointer (high 3 bits) SPR6PTL + 13A W A Sprite 6 pointer (low 15 bits) SPR7PTH + 13C W A Sprite 7 pointer (high 3 bits) SPR7PTL + 13E W A Sprite 7 pointer (low 15 bits) SPR0POS % 140 W AD Sprite 0 vert-horiz start position data SPR0CTL % 142 W AD( E ) Sprite 0 vert stop position and control data SPR0DATA % 144 W D Sprite 0 image data register A SPR0DATB % 146 W D Sprite 0 image data register B SPR1POS % 148 W AD Sprite 1 vert-horiz start position data SPR1CTL % 14A W AD Sprite 1 vert stop position and control data SPR1DATA % 14C W D Sprite 1 image data register A SPR1DATB % 14E W D Sprite 1 image data register B SPR2POS % 150 W AD Sprite 2 vert-horiz start position data SPR2CTL % 152 W AD Sprite 2 vert stop position and control data SPR2DATA % 154 W D Sprite 2 image data register A SPR2DATB % 156 W D Sprite 2 image data register B SPR3POS % 158 W AD Sprite 3 vert-horiz start position data SPR3CTL % 15A W AD Sprite 3 vert stop position and control data SPR3DATA % 15C W D Sprite 3 image data register A SPR3DATB % 15E W D Sprite 3 image data register B SPR4POS % 160 W AD Sprite 4 vert-horiz start position data SPR4CTL % 162 W AD Sprite 4 vert stop position and control data SPR4DATA % 164 W D Sprite 4 image data register A SPR4DATB % 166 W D Sprite 4 image data register B SPR5POS % 168 W AD Sprite 5 vert-horiz start position data SPR5CTL % 16A W AD Sprite 5 vert stop position and control data SPR5DATA % 16C W D Sprite 5 image data register A SPR5DATB % 16E W D Sprite 5 image data register B SPR6POS % 170 W AD Sprite 6 vert-horiz start position data SPR6CTL % 172 W AD Sprite 6 vert stop position and control data SPR6DATA % 174 W D Sprite 6 image data register A SPR6DATB % 176 W D Sprite 6 image data register B SPR7POS % 178 W AD Sprite 7 vert-horiz start position data SPR7CTL % 17A W AD Sprite 7 vert stop position and control data SPR7DATA % 17C W D Sprite 7 image data register A SPR7DATB % 17E W D Sprite 7 image data register B COLOR00 180 W D Color table 00 COLOR01 182 W D Color table 01 COLOR02 184 W D Color table 02 COLOR03 186 W D Color table 03 COLOR04 188 W D Color table 04 COLOR05 18A W D Color table 05 COLOR06 18C W D Color table 06 COLOR07 18E W D Color table 07 COLOR08 190 W D Color table 08 COLOR09 192 W D Color table 09 COLOR10 194 W D Color table 10 COLOR11 196 W D Color table 11 COLOR12 198 W D Color table 12 COLOR13 19A W D Color table 13 COLOR14 19C W D Color table 14 COLOR15 19E W D Color table 15 COLOR16 1A0 W D Color table 16 COLOR17 1A2 W D Color table 17 COLOR18 1A4 W D Color table 18 COLOR19 1A6 W D Color table 19 COLOR20 1A8 W D Color table 20 COLOR21 1AA W D Color table 21 COLOR22 1AC W D Color table 22 COLOR23 1AE W D Color table 23 COLOR24 1B0 W D Color table 24 COLOR25 1B2 W D Color table 25 COLOR26 1B4 W D Color table 26 COLOR27 1B6 W D Color table 27 COLOR28 1B8 W D Color table 28 COLOR29 1BA W D Color table 29 COLOR30 1BC W D Color table 30 COLOR31 1BE W D Color table 31 HTOTAL 1C0 W A( E ) Highest number count, horiz line (VARBEAMEN=1) HSSTOP 1C2 W A( E ) Horizontal line position for HSYNC stop HBSTRT 1C4 W A( E ) Horizontal line position for HBLANK start HBSTOP 1C6 W A( E ) Horizontal line position for HBLANK stop VTOTAL 1C8 W A( E ) Highest numbered vertical line (VARBEAMEN=1) VSSTOP 1CA W A( E ) Vertical line position for VSYNC stop VBSTRT 1CC W A( E ) Vertical line for VBLANK start VBSTOP 1CE W A( E ) Vertical line for VBLANK stop 1D0 Reserved 1D2 Reserved 1D4 Reserved 1D6 Reserved 1D8 Reserved 1DA Reserved BEAMCON0 1DC W A( E ) Beam counter control register (SHRES,PAL) HSSTRT 1DE W A( E ) Horizontal sync start (VARHSY) VSSTRT 1E0 W A( E ) Vertical sync start (VARVSY) HCENTER 1E2 W A( E ) Horizontal position for Vsync on interlace DIWHIGH 1E4 W AD( E ) Display window - upper bits for start, stop RESERVED 1110X RESERVED 1111X NO-OP(NULL) 1FE [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node00E2.html.txt:1:5 / Forming and Playing a Sound / Audio Summary ]" border=0> These are the steps necessary to produce a steady tone: 1. Define the waveform. 2. Create the data set containing the pairs of data samples (data words). Normally, a data set contains the definition of one waveform. 3. Set the location registers: AUDxLCH (high three bits) AUDxLCL (low fifteen bits) 4. Set the length register, AUDxLEN , to the number of data words to be retrieved before starting at the address currently in AUDxLC . 5. Set the volume register, AUDxVOL . 6. Set the period register, AUDxPER 7. Start the audio DMA by writing a 1 into bit 9, DMAEN , along with a 1 in the SET/CLR bit and a 1 in the position of the AUDxEN bit of the channel or channels you want to start. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0263.html.txt:1:DMA Index ]" border=0> DMA, 4 , 207 audio, 137 , 138 , 141 , 144 , 145 , 147 , 148 , 157 , 164-165 , 194 , 220 bitplanes, 62 blitter, 50 , 170-173 , 174 , 176 , 179-181 , 183-184 , 187 , 189 , 191 , 193 , 194 , 196-198 control, 222 control register, 218 , 222 copper, 19-20 , 30 disk, 4 , 194 , 220 , 241 , 246 , 247 , 250 display, 20 , 194 , 300 playfield, 62 sprites, 4 , 27 , 97 , 102 , 108 , 109 , 110 , 115 , 116-117 , 118 , 120-121 , 123 , 126 , 127 , 128 , 194 [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0056.html.txt:1:2 / Starting and Stopping the Copper / Starting the Copper After Reset ]" border=0> At power-on or reset time, you must initialize one of the Copper location registers (COP1LC or COP2LC) and write to its strobe address before Copper DMA is turned on. This ensures a known start address and known state. Usually, COP1LC is used because this particular register is reused during each vertical blanking time. The following sequence of instructions shows how to initialize a location register . It is assumed that the user has already created the correct Copper instruction list at location "mycoplist." ; ; Install the copper list ; LEA CUSTOM,a1 ; a1 = address of custom chips LEA MYCOPLIST(pc),a0 ; Address of our copper list MOVE.L a0, COP1LC (a1) ; Write whole longword address MOVE.W COPJMP1 (a1),d0 ; Causes copper to load PC from COP1LC ; ; Then enable copper and raster dma ; MOVE.W #(DMAF_SETCLR!DMAF_COPPER!DMAF_RASTER!DMAF_MASTER), DMACON (a1) ; Now, if the contents of COP1LC are not changed, every time vertical blanking occurs the Copper will restart at the same location for each subsequent video screen. This forms a repeatable loop which, if the list is correctly formulated, will cause the displayed screen to be stable. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node01F0.html.txt:1:Glossary / frequency modulation ]" border=0> In audio applications, a means of producing complex sounds by using one audio channel to affect the period of the waveform produced by another channel. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node001F.html.txt:1:A Register Summary / BLTxMOD ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- BLTxMOD 064 W A Blitter modulo x This register contains the modulo for blitter source (x=A,B,C) or destination (x=D). A modulo is a number that is automatically added to the address at the end of each line, to make the address point to the start of the next line. Each source or destination has its own modulo, allowing each to be a different size, while an identical area of each is used in the blitter operation. LINE DRAW BLTAMOD and BLTBMOD are used as slope LINE DRAW storage registers and must be preloaded LINE DRAW with the values (4Y-4X) and (4Y) LINE DRAW respectively. Y/X= line slope. LINE DRAW BLTCMOD and BLTDMOD must both be LINE DRAW preloaded with the width (in bytes) LINE DRAW of the image into which the line is LINE DRAW being drawn (normally two times the LINE DRAW screen width in words). [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node001B.html.txt:1:A Register Summary / BLTCON0L ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- BLTCON0L 05A W A( E ) Blitter control 0, lower 8 bits (minterms) [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node00E6.html.txt:1:5 / Producing Complex Sounds / Playing Multiple Tones at the Same Time ]" border=0> You can play multiple tones either by using several channels independently or by summing the samples in several data sets, playing the summed data sets through a single channel. Since all four audio channels are independently programmable, each channel has its own data set; thus a different tone or musical note can be played on each channel. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node018E.html.txt:1:8 / Floppy Disk Controller / Disk Subsystem Timing ]" border=0> Figures 8-7, 8-8 and 8-9 show the timing parameters of the Amiga's floppy disk subsystem with a Chinon drive. Keep in mind that this information can change with floppy drives from other vendors. To ensure compatibility with future versions of the system, you should avoid using this information in applications. 500ms min | | __ | MOTOR | | ON |___________________________________________________________ __ | ________ DRIVE | | | SELECT |__________________________________________________| | | 1.2ms min | | | | | _____ ___________________________________ ______________ STEP | | | | | |__| | | |__| | | | | -->| | | | | ______________ __________________________ WRITE | | GATE |____________________| 1.2ms min -->| | | ___________ | (see text) | _____________ SIDE | | | | SELECT |____________________________________| 8us max-->| | | | Figure 8-7: Chinon Write Timing Diagram ____ _______ DRIVE | | SELECT |_________________________________________________| | | | | 3ms | | | | t | 18 ms min | | min | 18 ms min | | | | | | | | | | | | ->| | | | ___________ | _________________ DIRECTION | | | | SELECT _____| | |__________________________| | 4ms | max | | | | | ->| | Figure 8-8: Chinon Access Timing Diagram __ DRIVE | SELECT |___________________________________________________________ -->| | | | | 1us min | | | ________________________ _____________________________ WRITE | | GATE | | |_______| | | 1000us min | 1.2ms min | | (see text)->| | | ______________________ | | ______________ SIDE | | | SELECT | -->| | | 1.2ms max-->| | | | CIAAPRA/CIABPRB - Disk selection, control and sensing Disk DMA Channel Control DSKPTH - Pointer to Data DSKLEN - Length, Direction, DMA Enable DSKBYTR - Disk Data Byte and Status Read (read-only) ADKCON and ADKCONR - Audio and Disk Control Register DSKSYNC - Disk Input Synchronizer [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node025F.html.txt:1:D Index ]" border=0> Data-fetch, --> DBLPF, 87 , 90 DDFSTOP, 60-61 , 80 , 82 , 91 , 99 DDFSTRT, 60 , 80 , 82 , 91 , 99 Decibel values, 163 Denise, 2 , 297 DENISEID, 298 Descending Mode - blitter, 182 DEST, 170 Digital Joystick - connection, 329 ,fire buttons, 329 Disk, --> Disk Port, 320 Display - size of, 57 Display DMA, 20 Display field, 40 Display memory, 57 Display modes, 41 Display window, --> DIWHIGH, 298 , 306 DIWSTOP, 59 , 78 , 91 , 99 , 219 , 306 DIWSTRT, 58 , 59 , 76 , 91 , 99 , 219 , 306 DMA, --> DMA Contention, 193 DMA Priority, 194 DMAB_BLTDONE, 186 DMACON, --> DMACONR, 222 DMAEN, 144 , 222 , 247 DMAF_BLITHOG, 198 DMAF_BLTNZERO, 187 DSK, 244 DSKBLK, 220 DSKBYTR, 241 , 248 DSKCHANGE, 244 DSKDIREC, 244 DSKEN, 222 DSKINDEX, 244 DSKLEN, 241 , 246-247 DSKMOTOR, 244 DSKPROT, 244 DSKPTH, 241 , 246 , 298 DSKRDY, 244 DSKSELx, 244 DSKSIDE, 244 DSKSTEP, 244 DSKSYN, 220 DSKSYNC, 241 , 247 , 250 DSKTRACK0, 244 Dual Playfield, --> [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node003C.html.txt:1:A Register Summary / REFPTR ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- REFPTR 028 W A Refresh pointer This register is used as a dynamic RAM refresh address generator. It is writeable for test purposes only, and should never be written by the microprocessor. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0248.html.txt:1:ADKCON Index ]" border=0> ADKCON, 241 , 250 , 256 disk control bits, 249 in audio, 149-150 [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node01A3.html.txt:1:8 / Serial I/O Interface / Contents Of The Receive Data Register ]" border=0> The serial input data-receive register is 16 bits wide. It contains the 8 or 9 bit input data and status bits. The data is received, one bit at a time, into an internal serial-to-parallel shift register . When the proper number of bit times have elapsed, the contents of this register are transferred to the serial data read register (SERDATR) shown in Table 8-10, and you are signaled that there is data ready for you. Immediately after the transfer of data takes place, the receive shift register again becomes ready to accept new data. After receiving the receiver-full interrupt, you will have up to one full character-receive time (8 to 10 bit times) to accept the data and clear the interrupt. If the interrupt is not cleared in time, the OVERRUN bit is set. Table 8-9 shows the definitions of the various bit positions within SERDATR. Table 8-9: SERDATR / ADKCON Registers SERDATR ------- Bit Number Name Function ------ ---- -------- 15 OVRUN OVERRUN (Mirror -- also appears in the interrupt request register.) Indicates that another byte of data was received before the previous byte was picked up by the processor. To prevent this condition, it is necessary to reset INTF_RBF (bit 11, receive-buffer-full) in INTREQ . 14 RBF READ BUFFER FULL (Mirror -- also appears in the interrupt request register.) When this bit is 1, there is data ready to be picked up by the processor. After reading the contents of this data register, you must reset the INTF_RBF bit in INTREQ to prevent an overrun. 13 TBE TRANSMIT BUFFER EMPTY (Not a mirror -- interrupt occurs when the buffer becomes empty.) When bit 14 is a 1, the data in the output data register ( SERDAT ) has been transferred to the serial output shift register , so SERDAT is ready to accept another output word. This is also true when the buffer is empty. This bit is normally used for full-duplex operation. 12 TSRE TRANSMIT SHIFT REGISTER EMPTY When this bit is a 1, the output shift register has completed its task, all data has been transmitted, and the register is now idle. If you stop writing data into the output register ( SERDAT ), then this bit will become a 1 after both the word currently in the shift register and the word placed into SERDAT have been transmitted. This bit is normally used for half-duplex operation. 11 RXD Direct read of RXD pin on Paula chip. 10 Not used at this time. 9 STP Stop bit if 9 data bits are specified for receive. 8 STP Stop bit if 8 data bits are specified for receive. OR DB8 9th data bit if 9 bits are specified for receive. 7-0 DB7-DB0 Low 8 data bits of received data. Data is TRUE (data you read is the same polarity as the data expected). ADKCON -------- Bit Number Name Function ------ ---- -------- 15 SET/CLR Allows setting or clearing individual bits. If bit 15 is a 1 specified bits are set. If bit 15 is a 0 specified bits are cleared. 11 UARTBRK Force the transmit pin to zero. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node01A0.html.txt:1:8 / Serial I/O Interface / Introduction To Serial Circuitry ]" border=0> The Paula custom chip contains a Universal Asynchronous Receiver/Transmitter, or UART. This UART is programmable for any rate from 110 to over 1,000,000 bits per second. It can receive or send data with a programmable length of eight or nine bits. The UART implementation provides a high degree of software control. The UART is capable of detecting overrun errors, which occur when some other system sends in data faster than you remove it from the data-receive register. There are also status bits and interrupts for the conditions of receive buffer full and transmit buffer empty. An additional status bit is provided that indicates "all bits have been shifted out". All of these topics are discussed in folowing sections. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node01EF.html.txt:1:Glossary / frequency ]" border=0> In audio applications, the number of times per second a waveform repeats. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0075.html.txt:1:3 / Basic Playfield / Displaying and Redisplaying the Playfield ]" border=0> You start playfield display by making certain that the bitplane pointers are set and bitplane DMA is turned on. You turn on bitplane DMA by writing a 1 to bit BPLEN in the DMACON (for DMA control) register. See Chapter 7, System Control Hardware, for instructions on setting this register. Each time the playfield is redisplayed, you have to reset the bitplane pointers. Resetting is necessary because the pointers have been incremented to point to each successive word in memory and must be repointed to the first word for the next display. You write Copper instructions to handle the redisplay or perform this operation as part of a vertical blanking task. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node00DA.html.txt:1:5 / Forming and Playing a Sound / Creating the Waveform Data ]" border=0> The waveform used as an example in this section is a simple sine wave, which produces a pure tone. To conserve memory, you normally define only one full cycle of a waveform in memory. For a steady, unchanging sound, the values at the waveform's beginning and ending points and the trend or slope of the data at the beginning and end should be closely related. This ensures that a continuous repetition of the waveform sounds like a continuous stream of sound. Sound data is organized as a set of eight-bit data items; each item is a sample from the waveform. Each data word retrieved for the audio channel consists of two samples. Sample values can range from -128 to +127. As an example, the data set shown below produces a close approximation to a sine wave. About the sample data. ---------------------- The data is stored in byte address order with the first digitized amplitude value at the lowest byte address, the second at the next byte address, and so on. Also, note that the first byte of data must start at a word-address boundary. This is because the audio DMA retrieves one word (16 bits) at a time and uses the sample it reads as two bytes of data. To use audio channel 0, write the address of "audiodata" into AUD0LC, where the audio data is organized as shown below. For simplicity, "AUDxLC" in the table below stands for the combination of the two actual location registers ( AUDxLCH and AUDxLCL ). For the audio DMA channels to be able to retrieve the data, the data address to which AUD0LC points must be somewhere in chip RAM. Table 5-1: Sample Audio Data Set for Channel 0 audiodata ---> AUD0LC * 100 98 AUD0LC + 2 ** 92 83 AUD0LC + 4 71 56 AUD0LC + 6 38 20 AUD0LC + 8 0 -20 AUD0LC + 10 -38 -56 AUD0LC + 12 -71 -83 AUD0LC + 14 -92 -83 AUD0LC + 16 -100 -98 AUD0LC + 18 -92 -83 AUD0LC + 20 -71 -56 AUD0LC + 22 -38 -20 AUD0LC + 24 0 20 AUD0LC + 26 38 56 AUD0LC + 28 71 83 AUD0LC + 30 92 98 Notes: ------ * Audio data is located on a word-address boundary. ** AUD0LC stands for AUD0LCL and AUD0LCH . [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node016F.html.txt:1:7 / / Setting and Clearing Bits / Figure 7-4: Interrupt Priorities ]" border=0> Exec Hardware Software Priority Priority Description Name -------- -------- ----------- ---- ____ | 1 transmitter buffer empty TBE | 1 -----| 2 disk block complete DSKBLK | | 3 software interrupt SOFTINT |---- 2 -----| 4 external INT2 & CIAA PORTS |---- | 5 graphics coprocessor COPER | 3 -----| 6 vertical blank interval VERTB | | 7 blitter finished BLIT |---- | 8 audio channel 2 AUD2 | | 9 audio channel 0 AUD0 4 -----| | 10 audio channel 3 AUD3 | | 11 audio channel 1 AUD1 |---- | 12 receiver buffer full RBF 5 -----| | 13 disk sync pattern found DSKSYNC |---- | 14 external INT6 & CIAB EXTER 6 -----| | 15 special (master enable) INTEN |---- 7 -----|____ -- non-maskable interrupt NMI [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node006B.html.txt:1:3 / / Allocating Memory for Bitplanes / NTSC Example of Bitplane Size ]" border=0> For example, using a normal, NTSC, low resolution, non-interlaced display with 320 pixels across each display line and a total of 200 display lines, each line of the bitplane requires 40 bytes (320 bits divided by 8 bits per byte = 40). Multiply the 200 lines times 40 bytes per line to get 8,000 bytes per bitplane as given above. A low resolution, non-interlaced playfield made up of two bitplanes requires 16,000 bytes of memory area. The memory for each bitplane must be continuous, so you need to have two 8,000-byte blocks of available memory. Figure 3-7 shows an 8,000-byte memory area organized as 200 lines of 40 bytes each, providing 1 bit for each pixel position in the display plane. _______________________________ _______________________________ |_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_| ----> |_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_| Memory Location N Memory Location N+38 _______________________________ _______________________________ |_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_| ----> |_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_| Memory Location N+40 | Memory Location N+78 | | \|/ _______________________________ _______________________________ |_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_| ----> |_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_| Memory Location N+7960 Memory Location N+7998 Figure 3-7: Memory Organization for a Basic Bitplane Access to bitplanes in memory is provided by two address registers, BPLxPTH and BPLxPTL , for each bitplane (12 registers in all). The "x" position in the name holds the bitplane number; for example BPL1PTH and BPL1PTL hold the starting address of PLANE 1. Pairs of registers with names ending in PTH and PTL contain 19-bit addresses. 68000 programmers may treat these as one 32-bit address and write to them as one long word. You write to the high order word, which is the register whose name ends in "PTH." The example below shows how to set the bitplane pointers. Assuming two bitplanes, one at $21000 and the other at $25000, the processor sets BPL1PT to $21000 and BPL2PT to $25000. Note that this is usually the Copper's task. ; ; Since the bitplane pointer registers are mapped as full 680x0 long-word ; data, we can store the addresses with a 32-bit move... ; LEA CUSTOM,a0 ; Get base address of custom hardware... MOVE.L $21000,BPL1PTH(a0) ; Write bitplane 1 pointer MOVE.L $25000,BPL2PTH(a0) ; Write bitplane 2 pointer Note that the memory requirements given here are for the playfield only. You may need to allocate additional memory for other parts of the display -- sprites , audio , animation -- and for your application programs. Memory allocation for other parts of the display is discussed in the chapters describing those topics. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node02DF.html.txt:1:Hard_examples/simpleline.asm ]" border=0> ; ; simpleline.asm ; ; This example uses the line draw mode of the blitter ; to draw a line. The line is drawn with no pattern ; and a simple `or' blit into a single bitplane. ; (Link with amiga.lib) ; ; Input: d0=x1 d1=y1 d2=x2 d3=y2 d4=width a0=aptr ; include 'exec/types.i' include 'hardware/custom.i' include 'hardware/blit.i' include 'hardware/dmabits.i' include 'hardware/hw_examples.i' ; xref _custom ; xdef simpleline ; ; Our entry point. ; simpleline: lea _custom,a1 ; snarf up the custom address register sub.w d0,d2 ; calculate dx bmi xneg ; if negative, octant is one of [3,4,5,6] sub.w d1,d3 ; calculate dy '' is one of [1,2,7,8] bmi yneg ; if negative, octant is one of [7,8] cmp.w d3,d2 ; cmp |dx|,|dy| '' is one of [1,2] bmi ygtx ; if y>x, octant is 2 moveq.l #OCTANT1+LINEMODE,d5 ; otherwise octant is 1 bra lineagain ; go to the common section ygtx: exg d2,d3 ; X must be greater than Y moveq.l #OCTANT2+LINEMODE,d5 ; we are in octant 2 bra lineagain ; and common again. yneg: neg.w d3 ; calculate abs(dy) cmp.w d3,d2 ; cmp |dx|,|dy|, octant is [7,8] bmi ynygtx ; if y>x, octant is 7 moveq.l #OCTANT8+LINEMODE,d5 ; otherwise octant is 8 bra lineagain ynygtx: exg d2,d3 ; X must be greater than Y moveq.l #OCTANT7+LINEMODE,d5 ; we are in octant 7 bra lineagain xneg: neg.w d2 ; dx was negative! octant is [3,4,5,6] sub.w d1,d3 ; we calculate dy bmi xyneg ; if negative, octant is one of [5,6] cmp.w d3,d2 ; otherwise it's one of [3,4] bmi xnygtx ; if y>x, octant is 3 moveq.l #OCTANT4+LINEMODE,d5 ; otherwise it's 4 bra lineagain xnygtx: exg d2,d3 ; X must be greater than Y moveq.l #OCTANT3+LINEMODE,d5 ; we are in octant 3 bra lineagain xyneg: neg.w d3 ; y was negative, in one of [5,6] cmp.w d3,d2 ; is y>x? bmi xynygtx ; if so, octant is 6 moveq.l #OCTANT5+LINEMODE,d5 ; otherwise, octant is 5 bra lineagain xynygtx: exg d2,d3 ; X must be greater than Y moveq.l #OCTANT6+LINEMODE,d5 ; we are in octant 6 lineagain: mulu.w d4,d1 ; Calculate y1 * width ror.l #4,d0 ; move upper four bits into hi word add.w d0,d0 ; multiply by 2 add.l d1,a0 ; ptr += (x1 >> 3) add.w d0,a0 ; ptr += y1 * width swap d0 ; get the four bits of x1 or.w #$BFA,d0 ; or with USEA, USEC, USED, F=A+C lsl.w #2,d3 ; Y = 4 * Y add.w d2,d2 ; X = 2 * X move.w d2,d1 ; set up size word lsl.w #5,d1 ; shift five left add.w #$42,d1 ; and add 1 to height, 2 to width btst #DMAB_BLTDONE-8,DMACONR(a1) ; safety check waitblit: btst #DMAB_BLTDONE-8,DMACONR(a1) ; wait for blitter bne waitblit move.w d3,BLTBMOD(a1) ; B mod = 4 * Y sub.w d2,d3 ext.l d3 move.l d3,BLTAPT(a1) ; A ptr = 4 * Y - 2 * X bpl lineover ; if negative, or.w #SIGNFLAG,d5 ; set sign bit in con1 lineover: move.w d0,BLTCON0(a1) ; write control registers move.w d5,BLTCON1(a1) move.w d4,BLTCMOD(a1) ; C mod = bitplane width move.w d4,BLTDMOD(a1) ; D mod = bitplane width sub.w d2,d3 move.w d3,BLTAMOD(a1) ; A mod = 4 * Y - 4 * X move.w #$8000,BLTADAT(a1) ; A data = 0x8000 moveq.l #-1,d5 ; Set masks to all ones move.l d5,BLTAFWM(a1) ; we can hit both masks at once move.l a0,BLTCPT(a1) ; Pointer to first pixel to set move.l a0,BLTDPT(a1) move.w d1,BLTSIZE(a1) ; Start blit rts ; and return, blit still in progress. end [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0068.html.txt:1:3 / / Bitplanes and Color / Selecting the Number of Bitplanes ]" border=0> After deciding how many colors you want and how many bitplanes are required to give you those colors, you tell the system how many bitplanes to use. You select the number of bitplanes by writing the number into the register BPLCON0 (for Bitplane Control Register 0) The relevant bits are bits 14, 13, and 12, named BPU2, BPU1, and BPU0 (for "Bitplanes Used"). Table 3-5 shows the values to write to these bits and how the system assigns bitplane numbers. Table 3-5: Setting the Number of Bitplanes Number of Name(s) of Value Bitplanes Bitplanes ----- --------- ---------- 000 None * 001 1 PLANE 1 010 2 PLANES 1 and 2 011 3 PLANES 1 - 3 100 4 PLANES 1 - 4 101 5 PLANES 1 - 5 110 6 PLANES 1 - 6 ** 111 Value not used. * Shows only a background color; no playfield is visible. ** Sixth bitplane is used only in dual-playfield mode and in hold-and-modify mode (described in the section called Advanced Topics. About the BPLCON0 register. ---------------------------- The bits in the BPLCON0 register cannot be set independently. To set any one bit, you must reload them all. The following example shows how to tell the system to use two low resolution bitplanes. MOVE.W #$2200, BPLCON0 +CUSTOM ; Write to it Because register BPLCON0 is used for setting other characteristics of the display and the bits are not independently settable, the example above also sets other parameters (all of these parameters are described later in the chapter). * Hold-and-modify mode is turned off. * Single-playfield mode is set. * Composite video color is enabled. (Not applicable in all models.) * Genlock audio is disabled. * Light pen is disabled. * Interlaced mode is disabled. * External resynchronization is disabled. (genlock) [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0264.html.txt:1:DMACON Index ]" border=0> DMACON, 222 , 247 blitter done, 186 DMAF_BLITHOG bit, 198 in audio, 144 in playfields, 62 stopping the Copper, 30 zero detection, 187 [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node02CC.html.txt:1:Hard_examples/lores_playfield.asm ]" border=0> ; ; lores_playfield.asm ; ; This example sets up a 320 x 200 playfield with one bitplane, which ; is located at $21000. Also, a Copper list is set up at $20000. ; ; This example relies on the include file hw_examples.i. ; LEA CUSTOM,a0 ; a0 points at custom chips MOVE.W #$1200,BPLCON0(a0) ; One bitplane, enable composite color MOVE.W #0,BPLCON1(a0) ; Set horizontal scroll value to 0 MOVE.W #0,BPL1MOD(a0) ; Set modulo to 0 for all odd bitplanes MOVE.W #$0038,DDFSTRT(a0) ; Set data-fetch start to $38 MOVE.W #$00D0,DDFSTOP(a0) ; Set data-fetch stop to $D0 MOVE.W #$2C81,DIWSTRT(a0) ; Set DIWSTRT to $2C81 MOVE.W #$F4C1,DIWSTOP(a0) ; Set DIWSTOP to $F4C1 MOVE.W #$0F00,COLOR00(a0) ; Set background color to red MOVE.W #$0FF0,COLOR01(a0) ; Set color register 1 to yellow ; ; Fill bitplane with $FF00FF00 to produce stripes ; MOVE.L #$21000,a1 ; Point at beginning of bitplane MOVE.L #$FF00FF00,d0 ; We will write $FF00FF00 long words MOVE.W #2000,d1 ; 2000 long words = 8000 bytes ; LOOP: MOVE.L d0,(a1)+ ; Write a long word DBRA d1,LOOP ; Decrement counter and loop until done... ; ; Set up Copper list at $20000 ; MOVE.L #$20000,a1 ; Point at Copper list destination LEA COPPERL(pc),a2 ; Point a2 at Copper list data CLOOP: MOVE.L (a2),(a1)+ ; Move a word CMPI.L #$FFFFFFFE,(a2)+ ; Check for last longword of Copper list BNE CLOOP ; Loop until entire copper list is moved ; ; Point Copper at Copper list ; MOVE.L #$20000,COP1LCH(a0) ; Write to Copper location register MOVE.W COPJMP1(a0),d0 ; Force copper to $20000 ; ; Start DMA ; MOVE.W #(DMAF_SETCLR!DMAF_COPPER!DMAF_RASTER!DMAF_MASTER),DMACON(a0) ; Enable bitplane and Copper DMA BRA .... ; Go do next task ; ; This is the data for the Copper list. ; COPPERL: DC.W BPL1PTH,$0002 ; Move $0002 to address $0E0 (BPL1PTH) DC.W BPL1PTL,$1000 ; Move $1000 to address $0E2 (BPL1PTL) DC.W $FFFF,$FFFE ; End of Copper list ; [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0036.html.txt:1:A Register Summary / INTENA, INTENAR ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- INTENA 09A W P Interrupt enable bits (clear or set bits) INTENAR 01C R P Interrupt enable bits (read) This register contains interrupt enable bits. The bit assignment for both the request and enable registers is given below. BIT# FUNCT LEVEL DESCRIPTION ---- ------ ----- ---------------------------------- 15 SET/CLR Set/clear control bit. Determines if bits written with a 1 get set or cleared. Bits written with a zero are always unchanged. 14 INTEN Master interrupt (enable only, no request) 13 EXTER 6 External interrupt 12 DSKSYN 5 Disk sync register ( DSKSYNC ) matches disk data 11 RBF 5 Serial port receive buffer full 10 AUD3 4 Audio channel 3 block finished 09 AUD2 4 Audio channel 2 block finished 08 AUD1 4 Audio channel 1 block finished 07 AUD0 4 Audio channel 0 block finished 06 BLIT 3 Blitter finished 05 VERTB 3 Start of vertical blank 04 COPER 3 Copper 03 PORTS 2 I/O ports and timers 02 SOFT 1 Reserved for software-initiated interrupt 01 DSKBLK 1 Disk block finished 00 TBE 1 Serial port transmit buffer empty [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0024.html.txt:1:A Register Summary / BPLxPTH, BPLxPTL ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- BPLxPTH 0E0 W A Bitplane x pointer (high 3 bits) BPLxPTL 0E2 W A Bitplane x pointer (low 15 bits) This pair of registers contains the 18-bit pointer to the address of bitplane x (x=1,2,3,4,5,6) DMA data. This pointer must be reinitialized by the processor or copper to point to the beginning of bitplane data every vertical blank time. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0011.html.txt:1:Amiga® Hardware Reference Manual:A Register Summary Alphabetical Order ]" border=0> This appendix contains the definitive summary, in alphabetical order, of the Amiga's custom chip register set and the usages of the individual bits. The addresses shown here are used by the special custom chips (named "Paula", "Agnus", and "Denise") for transferring data among themselves. Also, the Copper uses these addresses for writing to the special chip registers. To write to these registers with the 680x0, calculate the 680x0 address using this formula: 680x0 address = (chip address) + $DFF000 For example, for the 680x0 to write to ADKCON (address = $09E), the address would be $DFF09E. No other access address is valid. Do not attempt to access any documented or unused registers. All of the "pointer" type registers are organized as 32 bits on a long word boundary. These registers may be written with one MOVE.L instruction. The lowest bit of all pointers must be written as zero. The custom chips can only access Chip memory; using a non-Chip address will fail (See the AllocMem() documentation or your compiler manual for more information on Chip memory). Disk data, sprite data, bitplane data, audio data, copper lists and anything that will be blitted or accessed by custom chip DMA must be located in chip memory. When strobing any register which responds to either a read or a write, (for example copjmp2) be sure to use a MOVE.W, not CLR.W. The CLR instruction causes a read and a clear (two accesses) on a 68000, but only a single access on 68020 processors. This will give different results on different processors. Warning: -------- Registers are either read-only or write-only. In the following descriptions, if a register is marked as a read-only register, only read its contents. Do not attempt to write to a read-only register, as this will cause unpredictable results. If a register is marked as a write-only register, do not attempt to read from it, as this may trash the register and crash the system. If a bit is described as unused in a write-only register, be sure to keep that bit clear when writing values to that register. Similarly, do not rely on the values of unused bits when reading from a read only register. Further, do not write to an address or register that is not documented or defined in this appendix. Setting unused bits in a write-only register, reading unused bits from a read only register and writing to undocumented registers or addresses may cause serious future software incompatibility if those bits or addresses are implemented in the future by Amiga, Inc. About the ECS registers. ------------------------ Registers denoted with an "(E)" in the chip column means that those registers have been changed the Enhanced Chip Set(ECS). The ECS is found in the A3000, and is installable in the A500 and A2000. Certain ECS registers are completely new, others have been extended in their functionality. See the register map in Appendix C for information on which ECS registers are new and which have been modified. ADKCON BLTSIZH COP1LCH DSKDAT JOY1DAT STRHOR ADKCONR BLTxDAT COP1LCL DSKDATR JOYTEST STRLONG AUDxDAT BLTxMOD COP2LCH DSKLEN POT0DAT STRVBL AUDxLCH BLTxPTH COP2LCL DSKPTH POT1DAT VBSTOP AUDxLCL BLTxPTL COPCON DSKPTL POTGO VBSTRT AUDxLEN BPL1MOD COPINS DSKSYNC POTGOR VHPOSR AUDxPER BPL2MOD COPJMP1 HBSTOP REFPTR VHPOSW AUDxVOL BPLCON0 COPJMP2 HBSTRT SERDAT VPOSR BEAMCON0 BPLCON1 DDFSTOP HCENTER SERDATR VPOSW BLTAFWM BPLCON2 DDFSTRT HSSTOP SERPER VSSTOP BLTALWM BPLCON3 DENISEID HSSTRT SPRxCTL VSSTRT BLTCON0 BPLxDAT DIWHIGH HTOTAL SPRxDATA VTOTAL BLTCON1 BPLxPTH DIWSTOP INTENA SPRxDATB BLTCON0L BPLxPTL DIWSTRT INTENAR SPRxPOS BLTDDAT CLXCON DMACON INTREQ SPRxPTH BLTSIZE CLXDAT DMACONR INTREQR SPRxPTL BLTSIZV COLORxx DSKBYTR JOY0DAT STREQU [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0006.html.txt:1:1 / Components of the Amiga / Peripherals ]" border=0> Floppy disk storage is provided by a built-in, 3.5 inch floppy disk drive. Disks are 80 track, double sided, and formatted as 11 sectors per track, 512 bytes per sector (over 900,000 bytes per disk). The disk controller can read and write 320/360K IBM PC(TM) (MS-DOS(TM)) formatted 3.5 or 5.25 inch disks, and 640/720K IBM PC (MS-DOS) formatted 3.5 inch disks. Up to three extra 3.5 inch or 5.25 inch disk drives can be added to the Amiga. The A2000 and A3000 also provide room to mount floppy or hard disks internally. The A3000 has a built-in hard disk drive and an on-board SCSI controller which can handle two internal drives and up to seven external SCSI devices. The Amiga has a full complement of dedicated I/O connectors. The circuitry for some of these peripherals resides on the Paula custom chip while the Amiga's two 8520 CIA chips handle other I/O chores not specifically assigned to any of the custom chips. These include modem control, disk status sensing, disk motor and stepping control, ROM enable, parallel input/output interface, and keyboard interface. The Amiga includes a standard RS-232-C serial port for external serial input/output devices such as a modem, MIDI interface, or printer. A programmable, Centronics-compatible parallel port supports parallel printers, audio digitizers, and other peripherals. The Amiga also includes a two-button, opto-mechanical mouse plus a keyboard with numeric keypad, cursor controls, and 10 function keys in the base system. A variety of international keyboards are supported. Many other input options are available. Other types of controllers can be attached through the two controller ports on the base unit including joysticks, keypads, trackballs, light pens, and graphics tablets. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0033.html.txt:1:A Register Summary / DSKPTH, DSKPTL ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- DSKPTH 020 W A( E ) Disk pointer (high 3 bits, high 5 bits if ECS) DSKPTL 022 W A Disk pointer (low 15 bits) This pair of registers contains the 18-bit address of disk DMA data. These address registers must be initialized by the processor or Copper before disk DMA is enabled. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0027.html.txt:1:A Register Summary / COLORxx ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- COLORxx 180 W D Color table xx There are 32 of these registers (xx=00-31) and they are sometimes collectively called the "color palette." They contain 12-bit codes representing red, green, and blue colors for RGB systems. One of these registers at a time is selected (by the BPLxDAT serialized video code) for presentation at the RGB video output pins. The table below shows the color register bit usage. BIT# 15,14,13,12,11,10,09,08,07,06,05,04,03,02,01,00 ----------- ----------- ----------- ----------- RGB X X X X R3 R2 R1 R0 G3 G2 G1 G0 B3 B2 B1 B0 B=blue, G=green, R=red, [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0034.html.txt:1:A Register Summary / DSKSYNC ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- DSKSYNC 07E W P Disk sync register holds the match code for disk read synchronization. See ADKCON bit 10. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0106.html.txt:1:E / / Serial Interface Specification / Pin Assignment (J6) ]" border=0> RS-232-C NAME DIR STD NOTES ---- --- --- -------------------------- FGND y Frame ground -- do not tie to signal ground TXD O y Transmit data RXD I y Receive data RTS O y Request to send CTS I y Clear to send DSR I y Data set ready GND y Signal ground -- do not tie to frame ground CD I y Carrier detect -5V n* 50 ma maximum *** WARNING -5V *** AUDO O n* Audio output from left (channels 0, 3) port, intended to send audio to the modem. AUDI I n* Audio input to right (channels 1, 2) port, intended to receive audio from the modem; this input is mixed with the analog output of the right (channels 1, 2). It is not digitized or used by the computer in any way. DTR O y Data terminal ready. RI I y Ring Indicator (A500/A2000 only) shared with printer "select" signal. RESB* O n* Amiga system reset. NOTES: n*: See warning above See part 1 of this appendix for pin numbers . [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node00D5.html.txt:1:Amiga® Hardware Reference Manual: 5 Audio Hardware ]" border=0> This chapter shows you how to directly access the audio hardware to produce sounds. The major topics in this chapter are: * A brief overview of how a computer produces sound. * How to produce simple steady and changing sounds and more complex ones. * How to use the audio channels for special effects, wiring them for stereo sound if desired, or using one channel to modulate another. * How to produce quality sound within the system limitations. A section at the end of the chapter gives you values to use for creating musical notes on the equal-tempered musical scale. This chapter is not a tutorial on computer sound synthesis; a thorough description of creating sound on a computer would require a far longer document. The purpose here is to point the way and show you how to use the Amiga's features. Computer sound production is fun but complex, and it usually requires a great deal of trial and error on the part of the user -- you use the instructions to create some sound and play it back, readjust the parameters and play it again, and so on. The following works are recommended for more information on creating music with computers: * Wayne A. Bateman, Introduction to Computer Music (New York: John Wiley and Sons, 1980). * Hal Chamberlain, Musical Applications of Microprocessors (Rochelle Park, New Jersey: Hayden, 1980). Introducing Sound Generation Using Direct (Non-DMA) Audio Output Forming and Playing a Sound The Equal-tempered Musical Scale Producing Complex Sounds Decibel Values for Volume Ranges Producing High-quality Sound The Audio State Machine [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0193.html.txt:1:8 / / Timing / DSKBYTR - Disk Data Byte and Status Read (read-only) ]" border=0> This register is the disk-microprocessor data buffer. In read mode, data from the disk is placed into this register one byte at a time. As each byte is received into the register, the DSKBYT bit is set true. DSKBYT is cleared when the DSKBYTR register is read. DSKBYTR may be used to synchronize the processor to the disk rotation before issuing a read or write under DMA control. Table 8-7: DSKBYTR Register Bit Number Name Function ------ ---- -------- 15 DSKBYT When set, indicates that this register contains a valid byte of data (reset by reading this register). 14 DMAON Indicates when DMA is actually enabled. All the various DMA bits must be true. This means the DMAEN bit in DSKLEN , and the DSKEN & DMAEN bits in DMACON . 13 DISKWRITE The disk write bit (in DSKLEN ) is enabled. 12 WORDEQUAL Indicates the DSKSYNC register equals the disk input stream. This bit is true only while the input stream matches the sync register (as little as two microseconds). 11-8 Currently unused; don't depend on read value. 7-0 DATA Disk byte data. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0245.html.txt:1:A Index ]" border=0> A1000, --> A2000, 1 , 5 , 6 , 7 , 7 , 63 , 157 , 238 , 260 A3000, --> A500, 1 , 5 , 7 , 63 , 157 , 238 , 260 Address Registers, 10 ADKCON, --> Agnus, --> Alarm, 344 Aliasing, audio, 154 AllocMem(), 52 Amiga OS, 9 Amplitude Modulation, 4 Animated Objects, 6 Animation, 176 Apple II, 241 Area Fill, 4 , 184 ATTACH, 120 Attachment - audio, 150 , sprites, 120 Audio, --> Audio Channel, 19 AUDx, 220 AUDxEN, 144 , 222 AUDxLCH, 138 , 298 AUDxLCL, 138 AUDxLEN, 139 AUDxPER, 143 , 298 AUDxVOL, 139 AUTOCONFIG, 7 , 223 , 431 [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node01BA.html.txt:1:Glossary / attach mode ]" border=0> 1. With sprites, a mode in which a sprite uses two DMA channels for additional colors. 2. In sound production, combining two audio channels for frequency/amplitude modulation or for stereo sound. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node002F.html.txt:1:A Register Summary / DMACON, DMACONR ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- DMACON 096 W A D P DMA control write (clear or set) DMACONR 002 R A P DMA control (and blitter status) read This register controls all of the DMA channels and contains blitter DMA status bits. BIT# FUNCTION DESCRIPTION ---- --------- ----------------------------------- 15 SET/CLR Set/clear control bit. Determines if bits written with a 1 get set or cleared. Bits written with a zero are unchanged. 14 BBUSY Blitter busy status bit (read only) 13 BZERO Blitter logic zero status bit (read only). 12 X 11 X 10 BLTPRI Blitter DMA priority (over CPU micro) (also called "blitter nasty") (disables /BLS pin, preventing micro from stealing any bus cycles while blitter DMA is running). 09 DMAEN Enable all DMA below 08 BPLEN Bitplane DMA enable 07 COPEN Copper DMA enable 06 BLTEN Blitter DMA enable 05 SPREN Sprite DMA enable 04 DSKEN Disk DMA enable 03 AUD3EN Audio channel 3 DMA enable 02 AUD2EN Audio channel 2 DMA enable 01 AUD1EN Audio channel 1 DMA enable 00 AUD0EN Audio channel 0 DMA enable [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node01B5.html.txt:1:Glossary / amplitude ]" border=0> In audio applications, the voltage or current output expressed as volume from a sound speaker. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node002D.html.txt:1:A Register Summary / DENISEID ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- DENISEID 07C R D( E ) Chip revision level for Denise (video out chip) [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0069.html.txt:1:3 / Basic Playfield / Selecting Horizontal and Vertical Resolution ]" border=0> Standard home television screens are best suited for low resolution displays. Low resolution mode provides 320 pixels for each horizontal line. High resolution monochrome and RGB monitors can produce displays in high resolution mode, which provides 640 pixels for each horizontal line. If you define an object in low resolution mode and then display it in high resolution mode, the object will be only half as wide. To set horizontal resolution mode, you write to bit 15, HIRES, in register BPLCON0 : High resolution mode -- write 1 to bit 15. Low resolution mode -- write 0 to bit 15. Note that in high resolution mode, you can have up to four bitplanes in the playfield and, therefore, up to 16 colors. Interlaced mode allows twice as much data to be displayed in the same vertical area as in non-interlaced mode. This is accomplished by doubling the number of lines appearing on the video screen. The following table shows the number of lines required to fill a normal, non-overscan screen. NTSC PAL ---- --- Non-interlaced 200 256 Interlaced 400 512 Table 3-6: Lines in a Normal Playfield In interlaced mode, the scanning circuitry vertically offsets the start of every other field by half a scan line. _____________________ line 1 _|_____________________|_ |_____________________| \ | _________ | \ | _________ | \ | | \ | Odd Field | \ _____________________ | _________ | \_|_____________________|_ Line 1 | _________ | _|_|___________________|_ Line 2 |_____________________| / | | |_____________________| / | | | |_____________________| / | Video Display | / | | (400 lines NTSC | _____________________ / | 512 lines PAL) | line 2 _|_____________________|_/ | | | |_____________________| | | | _________ | |\|/ | | _________ | |_____________________| | | | Even Field | Same physical space as used | _________ | by a 200-line (256) PAL), | _________ | noninterlaced display. |_____________________| |_____________________| |_____________________| Figure 3-5: Interlacing Even though interlaced mode requires a modest amount of extra work in setting registers (as you will see later on in this section), it provides fine tuning that is needed for certain graphics effects. Consider the diagonal line in Figure 3-6 as it appears in non-interlaced and interlaced modes. Interlacing eliminates much of the jaggedness or "staircasing" in the edges of the line. ___________________ ___________________ |#|#| | | | | | | | | |#|#|_|_|_|_|_|_|_|_| |#|#|_|_|_|_|_|_|_|_| |_|#|#|_|_|_|_|_|_|_| | | |#|#| | | | | | | |_|_|#|#|_|_|_|_|_|_| |_|_|#|#|_|_|_|_|_|_| |_|_|_|#|#|_|_|_|_|_| | | | | |#|#| | | | | |_|_|_|_|#|#|_|_|_|_| |_|_|_|_|#|#|_|_|_|_| |_|_|_|_|_|#|#|_|_|_| | | | | | | |#|#| | | |_|_|_|_|_|_|#|#|_|_| |_|_|_|_|_|_|#|#|_|_| |_|_|_|_|_|_|_|#|#|_| | | | | | | | | |#|#| |_|_|_|_|_|_|_|_|#|#| |_|_|_|_|_|_|_|_|#|#| |_|_|_|_|_|_|_|_|_|#| non-interlaced interlaced Figure 3-6: Effect of Interlaced Mode on Edges of Object When you use the special blitter DMA channel to draw lines or polygons onto an interlaced playfield, the playfield is treated as one display, rather than as odd and even fields. Therefore, you still get the smoother edges provided by interlacing. To set interlaced or non-interlaced mode, you write to bit 2, LACE, in register BPLCON0 : Interlaced mode -- write 1 to bit 2. Non-interlaced mode -- write 0 to bit 2. As explained above in Setting the Number of Bitplanes , bits in BPLCON0 are not independently settable. The following example shows how to specify high resolution and interlaced modes. MOVE.W #$A204, BPLCON0 +CUSTOM ; Write to it The example above also sets the following parameters that are also controlled through register BPLCON0 : * High resolution mode is enabled. * Two bitplanes are used. * Hold-and-modify mode is disabled. * Single-playfield mode is enabled. * Composite video color is enabled. * Genlock audio is disabled. * Light pen is disabled. * Interlaced mode is enabled. * External resynchronization is disabled. The amount of memory you need to allocate for each bitplane depends upon the resolution modes you have selected, because high resolution or interlaced playfields contain more data and require larger bitplanes. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0028.html.txt:1:A Register Summary / COP1LCH, COP1LCL, COP2LCH, COP2LCL ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- COP1LCH 080 W A( E ) Copper first location register (high 3 bits, high 5 bits if ECS) COP1LCL 082 W A Copper first location register (low 15 bits) COP2LCH 084 W A( E ) Copper second location register (high 3 bits, high 5 bits if ECS) COP2LCL 086 W A Copper second location register (low 15 bits) These registers contain the jump addresses described above. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node01FF.html.txt:1:Glossary / manual mode ]" border=0> Non-DMA output. In sprites, a mode in which each line of a sprite is written in a separate operation. In audio applications, a mode in which audio data words are written one at a time to the output channel. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node023A.html.txt:1:Amiga® Hardware Reference Manual: J Custom Chip Pin Allocation List ]" border=0> This section gives the pin assignments used by the Amiga's custom chip set. NOTE: * Means an active low signal. Original Agnus Pin Assignment Paula Pin Assignment Denise Pin Assignment Fat Agnus Pin Assignment [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node001D.html.txt:1:A Register Summary / BLTSIZE, BLTSIZV, BLTSIZH ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- BLTSIZE 058 W A Blitter start and size (window width, height) This register contains the width and height of the blitter operation (in line mode, width must = 2, height = line length). Writing to this register will start the blitter, and should be done last, after all pointers and control registers have been initialized. BIT# 15,14,13,12,11,10,09,08,07,06,05,04,03,02,01,00 ----------------------------------------------- h9 h8 h7 h6 h5 h4 h3 h2 h1 h0,w5 w4 w3 w2 w1 w0 h=height=vertical lines (10 bits=1024 lines max) w=width =horizontal pixels (6 bits=64 words=1024 pixels max) LINE DRAW BLTSIZE controls the line length and starts LINE DRAW the line draw when written to. The h field LINE DRAW controls the line length (10 bits gives LINE DRAW lines up to 1024 dots long). The w field LINE DRAW must be set to 02 for all line drawing. BLTSIZV 05C W A( E ) Blitter V size (for 15 bit vertical size) BLTSIZH 05E W A( E ) Blitter H size and start (for 11 bit H size) [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0255.html.txt:1:Clock Index ]" border=0> Clock, 260 8520, 344 alarm, 344 audio, 140 , 141 , 142 , 159 , 164 blitter, 193 , 194 color, 194 , 255 keyboard, 251 system, 2 , 193 [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0041.html.txt:1:A Register Summary / SPRxPTH, SPRxPTL ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- SPRxPTH 120 W A Sprite x pointer (high 3 bits) SPRxPTL 122 W A Sprite x pointer (low 15 bits) This pair of registers contains the 18-bit address of sprite x (x=0,1,2,3,4,5,6,7) DMA data. These address registers must be initialized by the processor or Copper every vertical blank time. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0037.html.txt:1:A Register Summary / INTREQ, INTREQR ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- INTREQ 09C W P Interrupt request bits (clear or set) INTREQR 01E R P Interrupt request bits (read) This register contains interrupt request bits (or flags). These bits may be polled by the processor; if enabled by the bits listed in the above register, they may cause processor interrupts. Both a set and clear operation are required to load arbitrary data into this register. These status bits are not automatically reset when the interrupt is serviced, and must be reset when desired by writing to this address. The bit assignments are identical to the enable register . [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node003D.html.txt:1:A Register Summary / SERDAT, SERDATR ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- SERDAT 030 W P Serial port data and stop bits write (transmit data buffer) This address writes data to a transmit data buffer. Data from this buffer is moved into a serial shift register for output transmission whenever it is empty. This sets the interrupt request TBE (transmit buffer empty). A stop bit must be provided as part of the data word. The length of the data word is set by the position of the stop bit. BIT# 15,14,13,12,11,10,09,08,07,06,05,04,03,02,01,00 ----------------------------------------------- USE 0 0 0 0 0 0 S D8 D7 D6 D5 D4 D3 D2 D1 D0 Note: S = stop bit = 1, D = data bits. SERDATR 018 R P Serial port data and status read (receive data buffer) This address reads data from a receive data buffer. Data in this buffer is loaded from a receiving shift register whenever it is full. Several interrupt request bits are also read at this address, along with the data, as shown below. BIT# SYM FUNCTION ---- ---- ----------------------- 15 OVRUN Serial port receiver overrun. Reset by resetting bit 11 of INTREQ . 14 RBF Serial port receive buffer full (mirror). 13 TBE Serial port transmit buffer empty (mirror). 12 TSRE Serial port transmit shift register empty. Reset by loading into buffer. 11 RXD RXD pin receives UART serial data for direct bit test by the microprocessor. 10 0 Not used 09 STP Stop bit 08 STP-DB8 Stop bit if LONG, data bit if not. 07 DB7 Data bit 06 DB6 Data bit 05 DB5 Data bit 04 DB4 Data bit 03 DB3 Data bit 02 DB2 Data bit 01 DB1 Data bit 00 DB0 Data bit [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node00EF.html.txt:1:5 Audio Hardware / Using Direct (Non-DMA) Audio Output ]" border=0> It is possible to create sound by writing audio data one word at a time to the audio output addresses, instead of setting up a list of audio data in memory. This method of controlling the output is more processor-intensive and is therefore not recommended. To use direct audio output, do not enable the DMA for the audio channel you wish to use; this changes the timing of the interrupts . The normal interrupt occurs after a data address has been read; in direct audio output, the interrupt occurs after one data word has been output. Unlike in the DMA-controlled automatic data output, in direct audio output, if you do not write a new set of data to the output addresses before two sampling intervals have elapsed, the audio output will cease changing. The last value remains as an output of the digital-to-analog converter . The volume and period registers are set as usual. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node012B.html.txt:1:6 Blitter Hardware / Blitter Operations and System DMA ]" border=0> The operations of the blitter affect the performance of the rest of the system. The following sections explain how system performance is affected by blitter direct memory access priority, DMA time slot allocation, bus sharing between the 680x0 and the display hardware, the operations of the blitter and Copper, and different playfield display sizes. The blitter performs its various data-fetch, modify, and store operations through DMA sequences, and it shares memory access with other devices in the system. Each device that accesses memory has a priority level assigned to it, which indicates its importance relative to other devices. Disk DMA, audio DMA, display DMA, and sprite DMA all have the highest priority level. Display DMA has priority over sprite DMA under certain circumstances. Each of these four devices is allocated a group of time slots during each horizontal scan of the video beam. If a device does not request one of its allocated time slots, the slot is open for other uses. These devices are given first priority because missed DMA cycles can cause lost data, noise in the sound output, or on-screen interruptions. The Copper has the next priority because it has to perform its operations at the same time during each display frame to remain synchronized with the display beam sweeping across the screen. The lowest priorities are assigned to the blitter and the 68000, in that order. The blitter is given the higher priority because it performs data copying, modifying, and line drawing operations operations much faster than the 68000. During a horizontal scan line (about 63 microseconds), there are 227.5 "color clocks", or memory access cycles. A memory cycle is approximately 280 ns in duration. The total of 227.5 cycles per horizontal line includes both display time and non-display time. Of this total time, 226 cycles are available to be allocated to the various devices that need memory access. The time-slot allocation per horizontal line is: 4 cycles for memory refresh 3 cycles for disk DMA 4 cycles for audio DMA (2 bytes per channel) 16 cycles for sprite DMA (2 words per channel) 80 cycles for bitplane DMA (even- or odd-numbered slots according to the display size used) Figure 6-9 shows one complete horizontal scan line and how the clock cycles are allocated. Figure 6-9: DMA Time Slot Allocation The 68000 uses only the even-numbered memory access cycles. The 68000 spends about half of a complete processor instruction time doing internal operations and the other half accessing memory. Therefore, the allocation of alternate memory cycles to the 68000 makes it appear to the 68000 that it has the memory all of the time, and it will run at full speed. Some 68000 instructions do not match perfectly with the allocation of even cycles and cause cycles to be missed. If cycles are missed, the 68000 must wait until its next available memory slot before continuing. However, most instructions do not cause cycles to be missed, so the 68000 runs at full speed most of the time if there is no blitter DMA interference. Figure 6-10 illustrates the normal cycle of the 68000. Avoid the TAS instruction. -------------------------- The 68000 test-and-set instruction (TAS) should never be used in the Amiga; the indivisible read-modify-write cycle that is used only in this instruction will not fit into a DMA memory access slot. | | | | | | | | | | | | | | | operation | access | | portion | portion | | | | | | | | odd cycle, | even cycle, | | assigned to | available to | | other devices | the 68000 | | | | | | | | | | | | | Figure 6-10: Normal 68000 Cycle If the display contains four or fewer low resolution bitplanes, the 68000 can be granted alternate memory cycles (if it is ready to ask for the cycle and is the highest priority item at the time). However, if there are more than four bitplanes, bitplane DMA will begin to steal cycles from the 68000 during the display. During the display time for a six bitplane display (low resolution, 320 pixels wide), 160 time slots will be taken by bitplane DMA for each horizontal line. As you can see from Figure 6-11, bitplane DMA steals 50 percent of the open slots that the processor might have used if there were only four bitplanes displayed. - timing cycle - T T + 7 + * + * _______________________________________________________________ | | | | | | | | | | | 4 | 6 | 2 | | 3 | 5 | 1 | |_______|_______|_______|_______|_______|_______|_______|_______| Figure 6-11: Time Slots Used by a Six Bitplane Display If you specify four high resolution bitplanes (640 pixels wide), bitplane DMA needs all of the available memory time slots during the display time just to fetch the 40 data words for each line of the four bitplanes (40 * 4 = 160 time slots). This effectively locks out the 68000 (as well as the blitter or Copper) from any memory access during the display, except during horizontal and vertical blanking . - timing cycle - T T + 7 _______________________________________________________________ | | | | | | | | | | 4 | 2 | 3 | 1 | 4 | 2 | 3 | 1 | |_______|_______|_______|_______|_______|_______|_______|_______| Figure 6-12: Time Slots Used by a High Resolution Display Each horizontal line in a normal, full-sized display contains 320 pixels in low resolution mode or 640 pixels in high resolution mode. Thus, either 20 or 40 words will be fetched during the horizontal line display time. If you want to scroll a playfield , one extra data word per line must be fetched from the memory. Display size is adjustable (see Chapter 3, "Playfield Hardware"), and bitplane DMA takes precedence over sprite DMA. As shown in Figure 6-9 larger displays may block out one or more of the highest-numbered sprites, especially with scrolling. As mentioned above, the blitter normally has a higher priority than the processor for DMA cycles. There are certain cases, however, when the blitter and the 68000 can share memory cycles. If given the chance, the blitter would steal every available Chip memory cycle. Display, disk, and audio DMA take precedence over the blitter, so it cannot block them from bus access. Depending on the setting of the blitter DMA mode bit, commonly referred to as the "blitter-nasty" bit, the processor may be blocked from bus access. This bit is called DMAF_BLITHOG (bit 10) and is in register DMACON . If DMAF_BLITHOG is a 1, the blitter will keep the bus for every available Chip memory cycle. This could potentially be every cycle (ROM and Fast memory are not typically Chip memory cycles). If DMAF_BLITHOG is a 0, the DMA manager will monitor the 68000 cycle requests. If the 68000 is unsatisfied for three consecutive memory cycles, the blitter will release the bus for one cycle. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0057.html.txt:1:2 / Starting and Stopping the Copper / Stopping the Copper ]" border=0> No stop instruction is provided for the Copper. To ensure that it will stop and do nothing until the screen display ends and the program counter starts again at the top of the instruction list, the last instruction should be to WAIT for an event that cannot occur. A typical instruction is to WAIT for VP = $FF and HP = $FE. An HP of greater than $E2 is not possible. When the screen display ends and vertical blanking starts, the Copper will automatically be pointed to the top of its instruction list, and this final WAIT instruction never finishes. You can also stop the Copper by disabling its ability to use DMA for retrieving instructions or placing data. The register called DMACON controls all of the DMA channels. Bit 7, COPEN, enables Copper DMA when set to 1. For information about controlling the DMA , see Chapter 7, "System Control Hardware." [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node00DF.html.txt:1:5 / / Selecting the Data Output Rate / Specifying the Period Value ]" border=0> After you have selected the desired interval between data samples, you can calculate the value to place in the period register by using the period formula: desired interval clock constant Period value = ---------------- = ------------------ clock interval samples per second As an example, say you wanted to produce a 1 KHz sine wave, using a table of eight data samples (four data words) (see Figure 5-3). Figure 5-3: Example Sine Wave Sampled Values: 0 90 127 90 0 -90 -127 -90 To output the series of eight samples at 1 KHz (1,000 cycles per second), each full cycle is output in 1/1000th of a second. Therefore, each individual value must be retrieved in 1/8th of that time. This translates to 1,000 microseconds per waveform or 125 microseconds per sample. To correctly produce this waveform, the period value should be: 125 microseconds/sample Period value = ------------------------------ = 447 timing 0.279365 microseconds/interval intervals/sample To set the period register, you must write the period value into the register AUDxPER, where "x" is the number of the channel you are using. For example, the following instruction shows how to write a period value of 447 into the period register for channel 0. SETAUD0PERIOD: LEA CUSTOM,a0 MOVE.W #447,AUD0PER(a0) To produce high-quality sound, avoiding aliasing distortion , you should observe the limitations on period values that are discussed in the section called "Producing Quality Sound." For the relationship between period and musical pitch, see the section at the end of the chapter, which contains a listing of the equal-tempered musical scale . [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0015.html.txt:1:A Register Summary / AUDxLEN ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- AUDxLEN 0A4 W P Audio channel x length This register contains the length (number of words) of audio channel x DMA data. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node00E5.html.txt:1:5 / / Joining Tones / Audio DMA Example ]" border=0> This example details the system audio DMA action in a step-by-step fashion. Suppose you wanted to join together a sine and a triangle waveform, end-to-end, for a special audio effect, alternating between them. The following sequence shows the action of your program as well as its interaction with the audio DMA system. The example assumes that the period , volume , and length of the data set remains the same for the sine wave and the triangle wave. Interrupt Program ----------------- If (wave = triangle) write AUD0LCL with address of sine wave data. Else if (wave = sine) write AUD0LCL with address of triangle wave data. Main Program ------------ 1. Set up volume , period , and length . 2. Write AUD0LCL with address of sine wave data. 3. Start DMA. 4. Continue with something else. System Response --------------- As soon as DMA starts, a. Copy to "back-up" length register from AUD0LEN . b. Copy to "back-up" location register from AUD0LCL (will be used as a pointer showing current data word to fetch). c. Create an interrupt for the 680x0 saying that it has completed retrieving working copies of length and location registers . d. Start retrieving audio data each allocated DMA time slot. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0278.html.txt:1:P Index ]" border=0> Packed Font, 180 Paddle Controller - connections, 228 ,reading, 234 PAL, --> Parallel, 9 Parallel Port, --> Paula, 2 , 6 , 255 Peripherals, 6 , 7 Pipeline, 188 Pixels - definition, 40 ,in sprites, 101 , 101 Playfield, 4 , 6 , 9 Playfields, --> Playfield-sprite priority, 209 Port Signal Assignments, 350 Ports, --> POT0DAT, 236 , 298 POT1DAT, 236 , 298 POTGO, 229 POTGO / POTINP, --> POTGOR, 229 POTINP - name changed to POTGOR, 240 POTxDAT, 229 Power up operation, 223 PRECOMPx, 249 Priority, --> Productivity mode, 3 Proportional Controller, 331 - pins, 332 Proportional Controllers - reading, 234 Proportional Joystick - connections, 228 ,reading, 234 [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0042.html.txt:1:A Register Summary / STREQU, STRHOR, STRLONG, STRVBL ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- STREQU 038 S D Strobe for horizontal sync with VB and EQU STRHOR 03C S D P Strobe for horizontal sync STRLONG 03E S D( E ) Strobe for identification of long horizontal line One of the first three strobe addresses above is placed on the destination address bus during the first refresh time slot. The fourth strobe shown above is used during the second refresh time slot of every other line to identify lines with long counts (228). There are four refresh time slots, and any not used for strobes will leave a null (FF) address on the destination address bus. STRVBL 03A S D Strobe for horizontal sync with VB (vertical blank) [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0023.html.txt:1:A Register Summary / BPLxDAT ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- BPLxDAT 110 W D Bitplane x data (parallel-to-serial convert) These registers receive the DMA data fetched from RAM by the bitplane address pointers described above. They may also be written by either microprocessor. They act as a six-word parallel- to-serial buffer for up to six memory bitplanes (x=1-6). The parallel-to-serial conversion is triggered whenever bitplane #1 is written, indicating the completion of all bitplanes for that word (16 pixels). The MSB is output first, and is, therefore, always on the left. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0040.html.txt:1:A Register Summary / SPRxDATA, SPRxDATB ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- SPRxDATA 144 W D Sprite x image data register A SPRxDATB 146 W D Sprite x image data register B These registers buffer the sprite image data. They are usually loaded by the sprite DMA channel but may be loaded by either processor at any time. When a horizontal comparison occurs, the buffers are dumped into shift registers and serially outputted to the display, MSB first on the left. NOTE: Writing to the A buffer enables (arms) the sprite. Writing to the SPRxCTL register disables the sprite. If enabled, data in the A and B buffers will be outputted whenever the beam counter equals the sprite horizontal position value in the SPRxPOS register. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node00EB.html.txt:1:5 / Producing High-quality Sound / Efficiency ]" border=0> A certain amount of overhead is involved in the handling of audio DMA. If you are trying to produce a smooth continuous audio synthesis, you should try to avoid as much of the system control overhead as possible. Basically, the larger the audio buffer you provide to the system, the less often it will need to interrupt to reset the pointers to the top of the next buffer and, coincidentally, the lower the amount of system interaction that will be required. If there is only one waveform buffer, the hardware automatically resets the pointers, so no software overhead is used for resetting them. The Joining Tones section illustrated how you could join "ends" of tones together by responding to interrupts and changing the values of the location registers to splice tones together. If your system is heavily loaded, it is possible that the response to the interrupt might not happen in time to assure a smooth audio transition. Therefore, it is advisable to utilize the longest possible audio table where a smooth output is required. This takes advantage of the audio DMA capability as well as minimizing the number of interrupts to which the 680x0 must respond. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0272.html.txt:1:L,M,N,O Index ]" border=0> LACE, 51 LED - caps-lock, 253 Light Pen, --> Line Drawing, --> Low resolution - color selection, 93 LPEN, 89 Manual mode - in sprites, 123 Memory - adding, 7 ,blitter access to, 169 Memory allocation, --> Memory Allocation - playfields, 76 Memory allocation - sprite data, 105 Memory Cycle Time, 194 Memory map, 388 MFM Encoding, 241 , 250 MFMPREC, 249 MIDI, 318 Minterms, 175 Modulation - amplitude, 149 ,frequency, 149 Modulo, --> Monitors - 260 , See Video Mouse - connections, 228 ,reading, 229 Mouse Port, 328 MOVE, 19 , 20 , 21 MSBSYNC, 249-250 MS-DOS, 6 , 7 , 241 Multiprocessor, 223 Multitasking, 9 Noise - audio, 154 NTSC, --> Octants, 189 OVERRUN, 256 Overscan, 3 , 57 , 99 [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node04D8.html.txt:1:narrator.device/CMD_WRITE ]" border=0> NAME CMD_WRITE - Send speech request to the narrator device SYNOPSIS Standard device command. FUNCTION Sends a phonetic string to the narrator device to be spoken and, optionally, is used to direct the narrator device to return mouth shape changes, and word and syllable sync events in response to read requests from the user. The phonetic string consists of ASCII characters representing the individual phonemes. Refer to the narrator device chapter of the libraries and devices volume of the ROM Kernel Manual for detailed information. INPUTS User IORequest block (struct narrator_rb as defined in .h file). The OpenDevice call will initialize the IORequest block to a "standard male" voice. If you want to change any parms, do so after the OpenDevice call and before the DoIO (or SendIO/WaitIO). For a complete description of the narrator_rb structure, see the narrator.h or .i include file. Note that the OpenDevice call does not initialize all the fields needed by the narrator device. The IORequest fields which must be set by the user before issuing the write request are: io_Command - Set to CMD_WRITE io_Data - Pointer to phonetic string io_Length - Length of phonetic string ch_masks - Array of audio channel selection masks (see audio device documentation for description of this field) nm_masks - Number of audio channel selection masks ****** NEW FOR V37 NARRATOR flags - The bit NDB_NEWIORB must be set in the flags field if any of the new features of the V37 narrator are used In addition to producing synthetic speech, the narrator device also provides features for synchronizing the speech to animation or other user defined events. There are three types of events that the user can request. They are mouth shape changes, start of new word, and start of new syllable. Mouth shape changes are requested by setting the mouths field of the IORequest block to a non-zero value. Word and syllable sync events are requested by setting the NDB_WORDSYNC and/or NDB_SYLSYNC bits in the flags field of the IORequest block. Note that word and syllable sync only work in V37 and later versions of the narrator device. RESULTS The narrator device range checks and performs other validity checks for all input parms. If any input is in error, the device sets the io_Error field of the IORequest block to an appropriate value (see include files for error codes). If everything is in order, the narrator device will produce the speech and clear the io_Error field. The io_Actual field is set to the length of the input string that was actually processed. If the return code indicates a phoneme error (ND_PhonErr), io_Actual is the NEGATIVE of the position in the input string where the error occured. SEE ALSO Read command. Audio device documentation. Exec input/output documentation. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node013E.html.txt:1:F 8520 Complex Interface Adapters / Serial Shift Register (SDR) ]" border=0> The serial port is a buffered, 8-bit synchronous shift register. A control bit (CRA6) selects input or output mode. In the Amiga system one shift register is used for the keyboard, and the other is unassigned. Note that the RS-232 compatible serial port is controlled by the Paula chip ; see chapter 8 for details. Input Mode Output Mode Bidirectional Feature [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node00E1.html.txt:1:5 / Forming and Playing a Sound / Stopping the Audio Dma ]" border=0> You can stop the channel by writing a 0 into the AUDxEN bit at any time. However, you cannot resume the output at the same point in the waveform by just writing a 1 in the bit again. Enabling an audio channel almost always starts the data output again from the top of the list of data pointed to by the location registers for that channel. If the channel is disabled for a very short time (less than two sampling periods ) it may stay on and thus continue from where it left off. The following example shows how to stop audio DMA for one channel. STOPAUDCHAN0: LEA CUSTOM,a0 MOVE.W #(DMAF_AUD0), DMACON (a0) [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node023D.html.txt:1:J Custom Chip Pin Allocation List / Paula Pin Assignment ]" border=0> PIN # DESIGNATION FUNCTION DEFINITION ----- ----------- ------------------ ---------- 01-07 D8-D2 Data bus lines 8 to 2 I/O 08 VSS Ground I 09-10 D1-D0 Data bus lines 1 and 0 I/O 11 RES* System reset I 12 DMAL DMA request line O 13-15 IPL0*-IPL2 Interrupt lines 0-2 O 16 INT2* Interrupt level 2 I 17 INT3* Interrupt level 3 I 18 INT6* Interrupt level 6 I 19-26 RGA8-RGA1 Register address bus 8-1 I 27 VCC +5 Volt I 28 CCK Color clock I 29 CCKQ Color clock delay I 30 AUDB Right audio O 31 AUDA Left audio O 32 POT0X Pot 0X I/O 33 POT0Y Pot 0Y I/O 34 VSSANA Analog ground I 35 POT1X Pot 1X I/O 36 POT1Y Pot 1Y I/O 37 DKRD* Disk read data I 38 DKWD* Disk write data O 39 DKWE Disk write enable O 40 TXD Serial transmit data O 41 RXD Serial receive data I 42-48 D15-D9 Data bus lines 15 to 9 I/O [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0039.html.txt:1:A Register Summary / JOYTEST ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- JOYTEST 036 W D Write to all four joystick-mouse counters at once. Mouse counter write test data: BIT# 15,14,13,12,11,10,09,08 07,06,05,04,03,02,01,00 ----------------------- ----------------------- 0DAT Y7 Y6 Y5 Y4 Y3 Y2 xx xx X7 X6 X5 X4 X3 X2 xx xx 1DAT Y7 Y6 Y5 Y4 Y3 Y2 xx xx X7 X6 X5 X4 X3 X2 xx xx [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node00D7.html.txt:1:5 / Introducing Sound Generation / The Amiga Sound Hardware ]" border=0> The Amiga has four hardware sound channels. You can independently program each of the channels to produce complex sound effects. You can also attach channels so that one channel modulates the sound of another or combine two channels for stereo effects. Each audio channel includes an eight-bit digital-to-analog converter driven by a direct memory access (DMA) channel. The audio DMA can retrieve two data samples during each horizontal video scan line. For simple, steady tones, the DMA can automatically play a waveform repeatedly; you can also program all kinds of complex sound effects. There are two methods of basic sound production on the Amiga -- automatic (DMA) sound generation and direct (non-DMA) sound generation. When you use automatic sound generation, the system retrieves data automatically by direct memory access. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node018D.html.txt:1:8 / Floppy Disk Controller / Registers Used by the Disk Subsystem ]" border=0> The disk subsystem uses two ports on the system's 8520 CIA chips, and several registers in the Paula chip: CIAAPRA ($BFE001) four input bits for disk sensing CIABPRB ($BFD100) eight output bits for disk selection, control and stepping ADKCON ($DFF09E) control bits (write only register) ADKCONR ($DFF010) control bits (read only register) DSKPTH ($DFF020) DMA pointer (32 bits) DSKLEN ($DFF024) length of DMA DSKBYTR ($DFF01A) Disk data byte and status read DSKSYNC ($DFF07E) Disk sync finder; holds a match word [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node00EE.html.txt:1:5 / Producing High-quality Sound / Low-Pass Filter ]" border=0> The system includes a low-pass filter that eliminates aliasing distortion as described above. This filter becomes active around 4 KHz and gradually begins to attenuate (cut off) the signal. Generally, you cannot clearly hear frequencies higher than 7 KHz. Therefore, you get the most complete frequency response in the frequency range of 0 - 7 KHz. If you are making frequencies from 0 to 7 KHz, you should select a sampling rate no less than 14 KHz, which corresponds to a sampling period in the range 124 to 256. At a sampling period around 320, you begin to lose the higher frequency values between 0 KHz and 7 KHz, as shown in Table 5-6. Table 5-6: Sampling Rate and Frequency Relationship Sampling Sampling Maximum Output Period Rate (KHz) Frequency (KHz) -------- ---------- --------------- Maximum sampling rate 124 29 7 Minimum sampling rate 256 14 7 for 7 KHz output Sampling rate too low 320 11 4 for 7 KHz output In A2000's with 2 layer motherboards and later A500 models there is a control bit that allows the audio output to bypass the low pass filter. This control bit is the same output bit of the 8520 CIA that controls the brightness of the red "power" LED (CIA A $BFE001 - Bit 1: /LED). Bypassing the filter allows for improved sound in some applications, but an external filter with an appropriate cutoff frequency may be required. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node01BC.html.txt:1:Glossary / automatic mode ]" border=0> 1. With sprites, the normal mode in which the sprite DMA channel automatically retrieves and displays all of the data for a sprite. 2. In audio applications, the normal mode in which the audio DMA channels automatically retrieve sound data. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0017.html.txt:1:A Register Summary / AUDxVOL ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- AUDxVOL 0A8 W P Audio channel x volume This register contains the volume setting for audio channel x. Bits 6,5,4,3,2,1,0 specify 65 linear volume levels as shown below. Bit# Use ---- -------------------------- 15-07 Not used 06 Forces volume to max (64 ones, no zeros) 05-00 Sets one of 64 levels (000000=no output (111111=63 1s, one 0) [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0192.html.txt:1:8 / / Disk Subsystem Timing / DSKLEN - Length, Direction, DMA Enable ]" border=0> All of the control bits relating to this topic are contained in a write-only register, called DSKLEN: Table 8-6: DSKLEN Register ($DFF024) Bit Number Name Usage ------ ---- ----- 15 DMAEN Secondary disk DMA enable 14 WRITE Disk write (RAM -> disk if 1) 13-0 LENGTH Number of words to transfer The hardware requires a special sequence in order to start DMA to the disk. This sequence prevents accidental writes to the disk. In short, the DMAEN bit in the DSKLEN register must be turned on twice in order to actually enable the disk DMA hardware. Here is the sequence you should follow: 1. Enable disk DMA in the DMACON register (See Chapter 7 for more information) 2. Set DSKLEN to $4000, thereby forcing the DMA for the disk to be turned off. 3. Put the value you want into the DSKLEN register. 4. Write this value again into the DSKLEN register. This actually starts the DMA. 5. After the DMA is complete, set the DSKLEN register back to $4000, to prevent accidental writes to the disk. As each data word is transferred, the length value is decremented. After each transfer occurs, the value of the pointer is incremented. The pointer points to the the next word of data to written or read. When the length value counts down to 0, the transfer stops. The recommended method of reading from the disk is to read an entire track into a buffer and then search for the sector(s) that you want. Using the DSKSYNC register (described below) will guarantee word alignment of the data. With this process you need to read from the disk only once for the entire track. In a high speed loader, the step to the next head can occur while the previous track is processed and checksummed. With this method there are no time-critical sections in reading data, other high-priority subsystems (such as graphics or audio) are be allowed to run. If you have too little memory for track buffering (or for some other reason decide not to read a whole track at once), the disk hardware supports a limited set of sector-searching facilities. There is a register that may be polled to examine the disk input stream. There is a hardware bug that causes the last three bits of data sent to the disk to be lost. Also, the last word in a disk-read DMA operation may not come in (that is, one less word may be read than you asked for). [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node00ED.html.txt:1:5 / Producing High-quality Sound / Aliasing Distortion ]" border=0> When you use sampling to produce a waveform, a side effect is caused when the sampling rate "beats" or combines with the frequency you wish to produce. This produces two additional frequencies, one at the sampling rate plus the desired frequency and the other at the sampling rate minus the desired frequency. This phenomenon is called aliasing distortion. Aliasing distortion is eliminated when the sampling rate exceeds the output frequency by at least 7 KHz. This puts the beat frequency outside the range of the low-pass filter , cutting off the undesirable frequencies. Figure 5-5 shows a frequency domain plot of the anti-aliasing low-pass filter used in the system. /|\ | 0db |________ filter | \ response | \ | \ | \ filter passes all frequences below about 5kHz. | \ -30db |_____________\_____ ___________________________________________\ | | | | | | / 5kHz 10kHz 15kHz 20kHz 25kHz 30kHz Figure 5-5: Frequency Domain Plot of Low-Pass Filter Figure 5-6 shows that it is permissible to use a 12 KHz sampling rate to produce a 4 KHz waveform. Both of the beat frequencies are outside the range of the filter, as shown in these calculations: 12 + 4 = 16 KHz 12 - 4 = 8 KHz /|\ filter 12kHz sampling frequencey | response | 0db |________ | | \ Diff. | Sum | | \ | | | | | \ | | | | | \ | | | | 4kHz| \ | | | -30db |_______|_____\_|___ ___|_______|_______________________________\ | | | | | | | / 5kHz 10kHz 15kHz 20kHz 25kHz 30kHz | | desired output frequency Figure 5-6: Noise-free Output (No Aliasing Distortion) You can see in Figure 5-7 that is unacceptable to use a 10 KHz sampling rate to produce a 4 KHz waveform. One of the beat frequencies (10 - 4) is within the range of the filter, allowing some of that undesirable frequency to show up in the audio output. /|\ filter 10kHz sampling frequencey | response | 0db |________ | | \ Diff. | Sum | | \ | | | | | \| | | | | \ | | | 4kHz| |\ | | -30db |_______|___|_\_____|_______|___________________________________\ | | | | | | | / 5kHz 10kHz 15kHz 20kHz 25kHz 30kHz | | desired output frequency Figure 5-7: Some Aliasing Distortion All of this gives rise to the following equation, showing that the sampling frequency must exceed the output frequency by at least 7 KHz, so that the beat frequency will be above the cutoff range of the anti-aliasing filter : Minimum sampling rate = highest frequency component + 7 KHz The frequency component of the equation is stated as "highest frequency component" because you may be producing a complex waveform with multiple frequency elements, rather than a pure sine wave. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0123.html.txt:1:6 Blitter Hardware / Blitter Done Flag ]" border=0> When the BLTSIZE register is written the blit is started. The processor does not stop while the blitter is working, though; they can both work concurrently, and this provides much of the speed evident in the Amiga. This does require some amount of care when using the blitter. A blitter done flag, also called the blitter busy flag, is provided as DMAF_BLTDONE (bit 14) in DMACONR . This flag is set when a blit is in progress. About the blitter done flag. ---------------------------- If a blit has just been started but has been locked out of memory access because of, for instance, display fetches, this bit may not yet be set. The processor, on the other hand, may be running completely uninhibited out of Fast memory or its internal cache, so it will continue to have memory cycles. The solution is to read a chip memory or hardware register address with the processor before testing the bit. This can easily be done with the sequence: btst.b #DMAB_BLTDONE-8, DMACONR (a1) btst.b #DMAB_BLTDONE-8, DMACONR (a1) where a1 has been preloaded with the address of the hardware registers. The first "test" of the blitter done bit may not return the correct result, but the second will. NOTE: ----- Starting with the Fat Agnus the blitter busy bit has been "fixed" to be set as soon as you write to BLTSIZE to start the blit, rather than when the blitter gets its first DMA cycle. However, not all machines will use these newer chips, so it is best to rely on the above method of testing. Multitasking and the Blitter [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node00DC.html.txt:1:5 / Forming and Playing a Sound / Selecting the Volume ]" border=0> The volume you set here is the overall volume of all the sound coming from the audio channel. The relative loudness of sounds, which will concern you when you combine notes, is determined by the amplitude of the wave form. There is a six-bit volume register for each audio channel. To control the volume of sound that will be output through the selected audio channel, you write the desired value into the register AUDxVOL, where "x" is replaced by the channel number. You can specify values from 64 to 0. These volume values correspond to decibel levels. At the end of this chapter is a table showing the decibel value for each of the 65 volume levels. For a typical output at volume 64, with maximum data values of -128 to 127, the voltage output is between +.4 volts and -.4 volts. Some volume levels and the corresponding decibel values are shown in Table 5-2. Table 5-2: Volume Values Volume Decibel Value ------ ------------- 64 0 (maximum volume) 48 -2.5 32 -6.0 16 -12.0 (12 db down from the volume at maximum level) For any volume setting from 64 to 0, you write the value into bits 5-0 of AUD0VOL. For example: SETAUD0VOLUME: LEA CUSTOM,a0 MOVE.W #48,AUD0VOL(a0) The decibels are shown as negative values from a maximum of 0 because this is the way a recording device, such as a tape recorder, shows the recording level. Usually, the recorder has a dial showing 0 as the optimum recording level. Anything less than the optimum value is shown as a minus quantity. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node001C.html.txt:1:A Register Summary / BLTDDAT ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- BLTDDAT --- - ---- Blitter destination data register This register holds the data resulting from each word of blitter operation until it is sent to a RAM destination. This is a dummy address and cannot be read by the micro. The transfer is automatic during blitter operation. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0222.html.txt:1:Glossary / sample ]" border=0> In audio applications, a single discrete data item which represents a waveform amplitude at a given instant. A group of samples taken over time is used to represent a waveform in the Amiga's memory. [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node006A.html.txt:1:audio.device/CMD_CLEAR ]" border=0> NAME CMD_CLEAR -- throw away internal caches FUNCTION CMD_CLEAR is a standard command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct, CMD_CLEAR does nothing; otherwise, CMD_CLEAR returns an error (ADIOERR_NOALLOCATION). CMD_CLEAR is synchronous and only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. INPUTS mn_ReplyPort- pointer to message port that receives I/O request after if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to clear (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for CMD_CLEAR io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channels successfully cleared (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0092.html.txt:1:3 Playfield Hardware / Summary of Playfield Registers ]" border=0> This section summarizes the registers used in this chapter and the meaning of their bit settings. The color registers are summarized in the next section. See Appendix A for a summary of all registers. BPLCON0 - Bitplane Control (Warning: Bits in this register cannot be independently set.) Bit 0 - unused Bit 1 - ERSY (external synchronization enable) 1 = External synchronization enabled (allows genlock synchronization to occur) 0 = External synchronization disabled Bit 2 - LACE (interlace enable) 1 = interlaced mode enabled 0 = non-interlaced mode enabled Bit 3 - LPEN (light pen enable) Bits 4-7 not used (make 0) Bit 8 - GAUD (genlock audio enable) 1 = Genlock audio enabled 0 = Genlock audio disabled (This bit also appears on Denise pin ZD during blanking period) Bit 9 - COLOR_ON (color enable) 1 = composite video color-burst enabled 0 = composite video color-burst disabled Bit 10 - DBLPF (double-playfield enable) 1 = dual playfields enabled 0 = single playfield enabled Bit 11 - HOMOD (hold-and-modify enable) 1 = hold-and-modify enabled 0 = hold-and-modify disabled; extra-half brite ( EHB ) enabled if DBLPF =0 and BPUx =6 Bits 14, 13, 12 - BPU2, BPU1, BPU0 Number of bitplanes used. 000 = only a background color 001 = 1 bitplane, PLANE 1 010 = 2 bitplanes, PLANES 1 and 2 011 = 3 bitplanes, PLANES 1 - 3 100 = 4 bitplanes, PLANES 1 - 4 101 = 5 bitplanes, PLANES 1 - 5 110 = 6 bitplanes, PLANES 1 - 6 111 not used Bit 15 - HIRES (high resolution enable) 1 = high resolution mode 0 = low resolution mode BPLCON1 - Bitplane Control Bits 3-0 - PF1H(3-0) Playfield 1 delay Bits 7-4 - PF2H(3-0) Playfield 2 delay Bits 15-8 not used BPLCON2 - Bitplane Control Bit 6 - PF2PRI 1 = Playfield 2 has priority 0 = Playfield 1 has priority Bits 0-5 Playfield sprite priority Bits 7-15 not used DDFSTRT - Data-fetch Start (Beginning position for data fetch) Bits 15-8 - not used Bits 7-2 - pixel position H8-H3 (bit H3 only respected in Hires Mode.) Bits 1-0 - not used DDFSTOP - Data-fetch Stop (Ending position for data fetch) Bits 15-8 - not used Bits 7-2 - pixel position H8-H3 (bit H3 only respected in Hires Mode.) Bits 1-0 - not used BPLxPTH - Bitplane Pointer (Bitplane pointer high word, where x is the bitplane number) BPLxPTL - Bitplane Pointer (Bitplane pointer low word, where x is the bitplane number) DIWSTRT - Display Window Start (Starting vertical and horizontal coordinates) Bits 15-8 - VSTART (V7-V0) Bits 7-0 - HSTART (H7-H0) DIWSTOP - Display Window Stop (Ending vertical and horizontal coordinates) Bits 15-8 - VSTOP (V7-V0) Bits 7-0 - HSTOP (H7-H0) BPL1MOD - Bitplane Modulo (Odd-numbered bitplanes, playfield 1) BPL2MOD - Bitplane Modulo (Even-numbered bitplanes, playfield 2) [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node05AB.html.txt:1:Text_Autodocs/serial.doc ]" border=0> TABLE OF CONTENTS serial.device/AbortIO serial.device/BeginIO serial.device/CloseDevice serial.device/CMD_CLEAR serial.device/CMD_FLUSH serial.device/CMD_READ serial.device/CMD_RESET serial.device/CMD_START serial.device/CMD_STOP serial.device/CMD_WRITE serial.device/OpenDevice serial.device/SDCMD_BREAK serial.device/SDCMD_QUERY serial.device/SDCMD_SETPARAMS serial.device/AbortIO serial.device/AbortIO NAME AbortIO(ioRequest) -- abort an I/O request A1 FUNCTION This is an exec.library call. This function attempts to aborts a specified read or write request. If the request is active, it is stopped immediately. If the request is queued, it is painlessly removed. The request will be returned in the same way any completed request it. After AbortIO(), you must generally do a WaitIO(). INPUTS iORequest -- pointer to the IORequest Block that is to be aborted. RESULTS io_Error -- if the Abort succeded, then io_Error will be #IOERR_ABORTED (-2) and the request will be flagged as aborted (bit 5 of io_Flags is set). If the Abort failed, then the Error will be zero. BUGS Previous to version 34, the serial.device would often hang when aborting CTS/RTS handshake requests. This was the cause of the incorrect assumption that AbortIO() does not need to be followed by a wait for a reply (or a WaitIO()). serial.device/BeginIO serial.device/BeginIO NAME BeginIO(ioRequest),deviceNode -- start up an I/O process A1 A6 FUNCTION This is a direct function call to the device. It is intended for more advanced programmers. See exec's DoIO() and SendIO() for the normal method of calling devices. This function initiates a I/O request made to the serial device. Other than read or write, the functions are performed synchronously, and do not depend on any interrupt handling logic (or it's associated discontinuities), and hence should be performed as IO_QUICK. With some exceptions, reads and writes are merely initiated by BeginIO, and thusly return to the caller as begun, not completed. Completion is signalled via the standard ReplyMsg routine. Multiple requests are handled via FIFO queueing. One exception to this non-QUICK handling of reads and writes is for READS when: - IO_QUICK bit is set - There are no pending read requests - There is already enough data in the input buffer to satisfy this I/O Request immediately. In this case, the IO_QUICK flag is not cleared, and the request is completed by the time it returns to the caller. There is no ReplyMsg or signal bit activity in this case. INPUTS ioRequest -- pointer to an I/O Request Block of size io_ExtSerSize (see serial.i for size/definition), containing a valid command in io_Command to process, as well as the command's other required parameters. deviceNode -- pointer to the "serial.device", as found in the IO_DEVICE of the ioRequest. RESULTS io_Error -- if the BeginIO succeded, then Error will be null. If the BeginIO failed, then the Error will be non-zero. I/O errors won't be reported until the io completes. SEE ALSO devices/serial.h serial.device/CloseDevice serial.device/CloseDevice NAME CloseDevice -- close the serial port SYNOPSIS CloseDevice(deviceNode) A1 FUNCTION This is an exec call that terminates communication with the serial device. Upon closing, the device's input buffer is freed. Note that all IORequests MUST be complete before closing. If any are pending, your program must AbortIO() then WaitIO() to complete them. INPUTS deviceNode - pointer to the device node, set by Open SEE ALSO serial.device/OpenDevice serial.device/CMD_CLEAR serial.device/CMD_CLEAR NAME Clear -- clear the serial port buffers FUNCTION This command resets the serial port's read buffer pointers. IO REQUEST io_Message mn_ReplyPort initialized io_Device set by OpenDevice io_Unit set by OpenDevice io_Command CMD_CLEAR RESULTS Error -- If the Clear succeded, then io_Error will be null. If the Clear failed, then the io_Error will be non-zero. serial.device/CMD_FLUSH serial.device/CMD_FLUSH NAME Flush -- clear all queued I/O requests for the serial port FUNCTION This command purges the read and write request queues for the serial device. Flush will not affect active requests. IO REQUEST io_Message mn_ReplyPort initialized io_Device set by OpenDevice io_Unit set by OpenDevice io_Command CMD_FLUSH RESULTS Error -- if the Flush succeded, then io_Error will be null. If the Flush failed, then the io_Error will be non-zero. serial.device/CMD_READ serial.device/CMD_READ NAME Read -- read input from serial port FUNCTION This command causes a stream of characters to be read in from the serial port buffer. The number of characters is specified in io_Length. The Query function can be used to check how many characters are currently waiting in the serial port buffer. If more characters are requested than are currently available, the ioRequest will be queued until it can be satisfied. The best way to handle reads is to first Query to get the number of characters currently in the buffer. Then post a read request for that number of characters (or the maximum size of your buffer). If zero characters are in the buffer, post a request for 1 character. When at least one is ready, the device will return it. Now start over with another Query. Before the program exits, it must be sure to AbortIO() then WaitIO() any outstanding ioRequests. IO REQUEST io_Message A mn_ReplyPort is required io_Device set by OpenDevice io_Unit set by OpenDevice io_Command CMD_READ io_Flags If the IOB_QUICK bit is set, read will try to complete the IO quickly io_Length number of characters to receive. io_Data pointer to buffer RESULTS Error -- if the Read succeded, then io_Error will be null. If the Read failed, then io_Error will be non-zero. io_Error will indicate problems such as parity mismatch, break, and buffer overrun. SEE ALSO serial.device/SDCMD_QUERY serial.device/SDCMD_SETPARAMS BUGS Having multiple outstanding read IORequests at any one time will probably fail. Old documentation mentioned a mode where io_Length was set to -1. If you want a NULL terminated read, use the io_TermArray instead. serial.device/CMD_RESET serial.device/CMD_RESET NAME Reset -- reinitializes the serial port FUNCTION This command resets the serial port to its freshly initialized condition. It aborts all I/O requests both queued and current, relinquishes the current buffer, obtains a new default sized buffer, and sets the port's flags and parameters to their boot-up time default values. The functions places the reset parameter values in the ioRequest block. IO REQUEST io_Message mn_ReplyPort initialized io_Device set by OpenDevice io_Unit set by OpenDevice io_Command CMD_RESET RESULTS Error -- if the Reset succeded, then Error will be null. If the Reset failed, then the Error will be non-zero. serial.device/CMD_START serial.device/CMD_START NAME Start -- restart paused I/O over the serial port FUNCTION This function restarts all current I/O on the serial port by sending an xON to the "other side", and submitting a "logical xON" to "our side", if/when appropriate to current activity. IO REQUEST io_Message mn_ReplyPort initialized io_Device set by OpenDevice io_Unit set by OpenDevice io_Command CMD_START RESULTS SEE ALSO serial.device/CMD_STOP serial.device/CMD_STOP serial.device/CMD_STOP NAME Stop -- pause all current I/O over the serial port FUNCTION This command halts all current I/O on the serial port by sending an xOFF to the "other side", and submitting a "logical xOFF" to "our side", if/when appropriate to current activity. IO REQUEST io_Message mn_ReplyPort initialized io_Device set by OpenDevice io_Unit set by OpenDevice io_Command CMD_STOP RESULTS SEE ALSO serial.device/CMD_START serial.device/CMD_WRITE serial.device/CMD_WRITE NAME Write -- send output to serial port FUNCTION This command causes a stream of characters to be written out the serial port. The number of characters is specified in io_Length, unless -1 is used, in which case output is sent until a null(0x00) is encountered. IO REQUEST io_Message must have mn_ReplyPort initialized io_Device set by OpenDevice io_Unit set by OpenDevice io_Command CMD_WRITE io_Flags Set IOF_QUICK to try quick I/O io_Length number of characters to transmit, or if set to -1 transmit until null encountered in buffer io_Data pointer to block of data to transmit RESULTS Error -- if the Write succeded, then io_Error will be null. If the Write failed, then the io_Error will be non-zero. SEE ALSO serial.device/SDCMD_SETPARAMS serial.device/OpenDevice serial.device/OpenDevice NAME OpenDevice -- Request an opening of the serial device. SYNOPSIS error = OpenDevice("serial.device", unit, ioRequest, flags) D0 A0 D0 A1 D1 BYTE OpenDevice(STRPTR, ULONG, struct IOExtSer *, ULONG); FUNCTION This is an exec call. Exec will search for the serial.device, and if found, will pass this call on to the device. Unless the shared-access bit (bit 5 of io_SerFlags) is set, exclusive use is granted and no other access to that unit is allowed until the owner closes it. All the serial-specific fields in the ioRequest are initialized to their most recent values (or the Preferences default, for the first time open). If support of 7-wire handshaking (i.e. RS232-C CTS/RTS protocol) is required, use the serial.device/SDCMD_SETPARAMS command. This feature should also be specified at inital OpenDevice() time. INPUTS "serial.device" - pointer to literal string "serial.device" unit - Must be zero, or a user setable unit number. (This field is used by multiple port controllers) Zero specifies the default serial port. ioRequest - pointer to an ioRequest block of size io_ExtSerSize to be initialized by the serial.device. (see devices/serial.h for the definition) NOTE use of io_SerFlags (see FUNCTION above) IMPORTANT: The ioRequest block MUST be of size io_ExtSerSize, and zeroed (with the exeptions as noted)! flags - Must be zero for future compatibility RESULTS D0 - same as io_Error io_Error - If the Open succeded, then io_Error will be null. If the Open failed, then io_Error will be non-zero. io_Device - A pointer to whatever device will handle the calls for this unit. This pointer may be different depending on what unit is requested. BUGS If 7-wire handshaking is specified, a timeout "feature" is enabled. If the device holds off the computer for more than about 30-60 seconds, the device will return the write request with the error SerErr_TimerErr. Don't depend on this, however. If you want a timeout, set up the timer.device and wait for either timer, or serial IO to complete. On open, the serial.device allocates the misc.resource for the serial port. It does not return it until the serial.device is expunged from memory. It should return it when no more openers exist. This code can force a specified device to try and expunge. Of course, if the device is in use nothing will happen: #include "exec/types.h" #include "exec/execbase.h" #include "proto/exec.h" void FlushDevice(char *); extern struct ExecBase *SysBase; void main() { FlushDevice("serial.device"); /* or parallel.device */ } /* * Attempts to flush the named device out of memory. * If it fails, no status is returned; examination of * the problem will reveal that information has no * valid use after the Permit(). */ void FlushDevice(name) char *name; { struct Device *result; Forbid(); if( result=(struct Device *)FindName(&SysBase->DeviceList,name) ) RemDevice(result); Permit(); } SEE ALSO serial.device/CloseDevice serial.device/SDCMD_SETPARAMS devices/serial.h serial.device/SDCMD_BREAK serial.device/SDCMD_BREAK NAME Break -- send a break signal over the serial line FUNCTION This command sends a break signal (serial line held low for an extended period) out the serial port. For the built-in port, This is accomplished by setting the UARTBRK bit of regisrer ADKCON. After a duration (user specifiable via setparams, default 250000 microseconds) the bit is reset and the signal discontinued. If the QUEUEDBRK bit of io_SerFlags is set in the io_Request block, the request is placed at the back of the write-request queue and executed in turn. If the QUEUEDBRK bit is not set, the break is started immediately, control returns to the caller, and the timer discontinues the signal after the duration is completed. Be aware that calling BREAK may affect other commands such as ABORT, FLUSH, STOP, START, etc... IO REQUEST io_Message mn_ReplyPort initialized io_Device set by OpenDevice io_Unit set by OpenDevice io_Command SDCMD_BREAK io_Flags set/reset IO_QUICK per above description RESULTS Error -- if the Break succeded, then Error will be null. If the Break failed, then the Error will be non-zero. serial.device/SDCMD_QUERY serial.device/SDCMD_QUERY NAME Query -- query serial port/line status FUNCTION This command return the status of the serial port lines and registers. The number of unread bytes in the serial device's read buffer is shown in io_Actual. The break send & received flags are cleared by a query, and whenever a read IORequest is returned with a error in io_Error. IO REQUEST io_Message mn_ReplyPort initialized io_Device preset by OpenDevice io_Unit preset by OpenDevice io_Command SDCMD_QUERY RESULTS io_Status BIT ACTIVE FUNCTION LSB 0 --- reserved 1 --- reserved 2 high parallel "sel" on the A1000 On the A500 & A2000, "sel" is also connected to the serial port's "Ring Indicator". Be cautious when making cables. 3 low Data Set Ready 4 low Clear To Send 5 low Carrier Detect 6 low Ready To Send 7 low Data Terminal Ready MSB 8 high hardware overrun 9 high break sent (most recent output) 10 high break received (as latest input) 11 high transmit x-OFFed 12 high receive x-OFFed 13-15 --- reserved io_Actual set to count of unread input characters io_Error -- Query will always succeded. serial.device/SDCMD_SETPARAMS serial.device/SDCMD_SETPARAMS NAME SetParams -- change parameters for the serial port FUNCTION This command allows the caller to change parameters for the serial device. Except for xON-xOFF enable/disable, it will reject a setparams call if any reads or writes are active or pending. Note specifically: 1. Valid input for io_Baud is between 112 and 292000 baud inclusive; asynchronous i/o above 32KB (especially on a busy system) may be ambitious. 2. The EOFMODE and QUEUEDBRK bits of io_SerFlags can be set/reset in the io_Rqst block without a call to SetParams. The SHARED and 7WIRE bits of io_SerFlags can be used in OpenDevice calls. ALL OTHER PARAMETERS CAN ONLY BE CHANGED BY THE SetParams COMMAND. 3. RBufLen must be at least 64. The buffer may be any multiple of 64 bytes. 4. If not used, io_ExtFlags MUST be set to zero. 5. xON-xOFF is by default enabled. The XDISABLED bit is the only parameter that can be changed via a SetParams call while the device is active. Note that this will return the value SerErr_DevBusy in the io_Error field. xON/xOFF handshaking is inappropriate for certain binary transfer protocalls, such as Xmodem. The binary data might contain the xON (ASCII 17) and xOFF (ASCII 19) characters. 6. If trying to run MIDI, you should set the RAD_BOOGIE bit of io_SerFlags to eliminate unneeded overhead. Specifically, this skips checks for parity, x-OFF handling, character lengths other than 8 bits, and testing for a break signal. Setting RAD_BOOGIE will also set the XDISABLED bit. Note that writing data (that's already in MIDI format) at MIDI rates is easily accomplished. Using this driver alone for MIDI reads may, however, may not be reliable, due to MIDI timestamping requirements, and possibility of overruns in a busy multitasking and/or display intensive environment. 7. If you select mark or space parity (see io_ExtFlags in serial.h), this will cause the SERB_PARTY_ON bit to be set, and the setting of SERB_PARTY_ODD to be ignored. 8. For best results, set the RAD_BOOGIE flag whenever possible. See #6 for details. 9. Note that at this time parity is *not* calculated for the xON-xOFF characters. If you have a system that is picky about the parity of these, you must set your own xON-xOFF characters in io_CtlChar. 10. 7WIRE (CTS/RTS) handshake is bi-directional. The external side is expected to drop CTS several character times before the external buffer is full. The Amiga will drop RTS several character times before the Amiga's buffer is full. IO REQUEST io_Message mn_ReplyPort initialized io_Device preset by OpenDevice io_Unit preset by OpenDevice io_Command SDCMD_SETPARAMS (0x0B) NOTE that the following fields are filled in by Open to reflect the serial device's current configuration. io_CtlChar a longword containing byte values for the xON,xOFF,INQ,ACK fields (respectively) (INQ/ACK not used at this time) io_RBufLen length in bytes of input buffer NOTE that any change in buffer size causes the current buffer to be deallocated and a new, correctly sized one to be allocated. Thusly, the CONTENTS OF THE OLD BUFFER ARE LOST. io_ExtFlags additional serial flags (bitdefs in devices/serial.h) mark & space parity may be specified here. io_Baud baud rate for reads AND writes. (See 1 above) io_BrkTime duration of break signal in MICROseconds io_TermArray ASCII descending-ordered 8-byte array of termination characters. If less than 8 chars used, fill out array w/lowest valid value. Terminators are checked only if EOFMODE bit of io_Serflags is set. (e.g. x512F040303030303 ) io_ReadLen number of bits in read word (1-8) not including parity io_WriteLen number of bits in write word (1-8) " " " io_StopBits number of stop bits (0, 1 or 2) io_SerFlags see devices/serial.h for bit equates, NOTE that x00 yields exclusive access, xON/OFF-enabled, no parity checking, 3-wire protocol and TermArray inactive. RESULTS Error -- if the SetParams succeded, then Error will be null. If the SetParams failed, then the Error will be non-zero. SEE ALSO exec/OpenDevice [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node021B.html.txt:1:Glossary / quantization noise ]" border=0> In audio applications, noise introduced by round-off errors when you are trying to reproduce a signal by approximation. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node00DE.html.txt:1:5 / / Data Output Rate / Limitations on Selection of Sampling Period ]" border=0> The sampling period is limited by the number of DMA cycles allocated to an audio channel. Each audio channel is allocated one DMA slot per horizontal scan line of the screen display. An audio channel can retrieve two data samples during each horizontal scan line. The following calculation gives the maximum sampling rate in samples per second. 2 samples/line * 262.5 lines/frame * 59.94 frames/second = 31,469 samples/second The figure of 31,469 is a theoretical maximum. In order to save buffers, the hardware is designed to handle 28,867 samples/second. The system timing interval is 279.365 nanoseconds, or .279365 microseconds. The maximum sampling rate of 28,867 samples per second is 34.642 microseconds per sample (1/28,867 = .000034642). The formula for calculating the sampling period is: sample interval clock constant Period value = --------------- = ------------------ clock interval samples per second Thus, the minimum period value is derived by dividing 34.642 microseconds per sample by the number of microseconds per interval: 34.642 microseconds/sample Minumum period = ------------------------------ = 124 timing 0.279365 microseconds/interval intervals/sample or: 3,579,545 ticks/second Minumum period = ---------------------- = 124 ticks/sample 28,867 samples/second Therefore, a value of at least 124 must be written into the period register to assure that the audio system DMA will be able to retrieve the next data sample. If the period value is below 124, by the time the cycle count has reached 0, the audio DMA will not have had enough time to retrieve the next data sample and the previous sample will be reused. 28,867 samples/second is also the maximum sampling rate for PAL systems. Thus, for PAL systems, a value of at least 123 ticks/sample must be written into the period register . Clock Values ------------ NTSC PAL units ---- --- ----- Clock Constant 3579545 3546895 ticks per second Clock Interval 0.279365 0.281937 microseconds per interval NOTE: ----- The Clock Interval is derived from the clock constant, where: 1 clock interval = -------------- clock constant then scale the result to microseconds. In all of these calculations "ticks" and "timing intervals" refer to the same thing. [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node04AC.html.txt:1:audio.device/ADCMD_WAITCYCLE ]" border=0> NAME ADCMD_WAITCYCLE -- wait for an audio channel to complete the current cycle of a write FUNCTION ADCMD_WAITCYCLE is a command for a single audio channel (io_Unit). If the allocation key (ioa_AllocKey) is correct and there is a write (CMD_WRITE) in progress on selected channel, ADCMD_WAITCYCLE does not reply (mn_ReplyPort) until the end of the current cycle. If there is no write is progress, ADCMD_WAITCYCLE replies immediately. If the allocation key is incorrect, ADCMD_WAITCYCLE returns an error (ADIOERR_NOALLOCATION). ADCMD_WAITCYCLE returns an error (IOERR_ABORTED) if it is canceled (AbortIO) or the channel is stolen (ADCMD_ALLOCATE). ADCMD_WAITCYCLE is only asynchronous if it is waiting for a cycle to complete, in which case it clears the quick flag (IOF_QUICK); otherwise, it is synchronous and only replies if the quick flag (IOF_QUICK) is clear. Do not use ADCMD_WAITCYCLE in interrupt code at interrupt level 5 or higher. INPUTS mn_ReplyPort- pointer to message port that receives I/O request, if the quick flag (IOF_QUICK) is clear, or if a write is in progress on the selected channel and a cycle has completed io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channel to wait for cycle (bits 0 thru 3 correspond to channels 0 thru 3), if more then one bit is set lowest bit number channel is used io_Command - command number for CMD_WAITCYCLE io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request (SET) only reply I/O request if a write is in progress on the selected channel and a cycle has completed ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channel that successfully waited for cycle (bits 0 thru 3 correspond to channels 0 thru 3) io_Flags - IOF_QUICK flag cleared if a write is in progress on the selected channel io_Error - error number: 0 - no error IOERR_ABORTED - canceled (AbortIO) or channel stolen ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node00DB.html.txt:1:5 / Forming and Playing a Sound / Telling the System About the Data ]" border=0> In order to retrieve the sound data for the audio channel, the system needs to know where the data is located and how long (in words) the data is. The location registers AUDxLCH and AUDxLCL contain the high three bits and the low fifteen bits, respectively, of the starting address of the audio data. Since these two register addresses are contiguous, writing a long word into AUDxLCH moves the audio data address into both locations. The "x" in the register names stands for the number of the audio channel where the output will occur. The channels are numbered 0, 1, 2, and 3. These registers are location registers, as distinguished from pointer registers. You need to specify the contents of these registers only once; no resetting is necessary when you wish the audio channel to keep on repeating the same waveform. Each time the system retrieves the last audio word from the data area, it uses the contents of these location registers to again find the start of the data. Assuming the first word of data starts at location "audiodata" and you are using channel 0, here is how to set the location registers: WHERE0DATA: LEA CUSTOM,a0 ; Base chip address... LEA AUDIODATA,a1 MOVE.L a1,AUD0LCH(a0) ;Put address (32 bits) ; into location register. The length of the data is the number of samples in your waveform divided by 2, or the number of words in the data set. Using the sample data set above, the length of the data is 16 words. You write this length into the audio data length register for this channel. The length register is called AUDxLEN, where "x" refers to the channel number. You set the length register AUD0LEN to 16 as shown below. SETAUD0LENGTH: LEA CUSTOM,a0 ; Base chip address MOVE.W #16,AUD0LEN(a0) ; Store the length... [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node02D9.html.txt:1:Hard_examples/sinewave.asm ]" border=0> ; ; sinewave.asm ; ; In this example, which gathers together all of the program segments ; from the Audio Hardware sections, a sine wave is played through ; channel 0. The example assumes exclusive access to the Audio ; hardware, and will not work directly in a multitasking environment. ; MAIN: LEA CUSTOM,a0 ; Custom chip base address LEA SINEDATA(pc),a1 ;Address of data to ; audio location register 0 WHERE0DATA: MOVE.L a1,AUD0LCH(a0) ;The 680x0 writes this as though it were a ; 32-bit register at the low-bits location ; (common to all locations and pointer ; registers in the system). SETAUD0LENGTH: MOVE.W #4,AUD0LEN(a0) ;Set length in words SETAUD0VOLUME: MOVE.W #64,AUD0VOL(a0) ;Use maximum volume SETAUD0PERIOD: MOVE.W #447,AUD0PER(a0) BEGINCHAN0: MOVE.W #(DMAF_SETCLR!DMAF_AUD0!DMAF_MASTER),DMACON(a0) RTS ; Return to main code... DS.W 0 ; Be sure word-aligned SINEDATA: ; Audio data must be in Chip memory DC.B 0, 90, 127, 90, 0, -90, -127, -90 END [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0117.html.txt:1:E Connectors And Interfaces / Port Signal Assignments for 8520 CIAS ]" border=0> CIA-A Address BFEx01 data bits 7-0 (A12*) (int2) -------------------------------------------------- PA7..game port 1, pin 6 (fire button*) PA6..game port 0, pin 6 (fire button*) PA5.. RDY* disk ready* PA4.. TK0* disk track 00* PA3.. WPRO* write protect* PA2.. CHNG* disk change* PA1..LED* led light (0=bright)/audio filter control (A500 & A2000) PA0..OVL ROM/RAM overlay bit SP... KDAT keyboard data CNT.. KCLK keyboard clock PB7..P7 data 7 PB6..P6 data 6 PB5..P5 data 5 Centronics parallel interface PB4..P4 data 4 data PB3..P3 data 3 PB2..P2 data 2 PB1..P1 data 1 PB0..P0 data 0 PC... drdy* Centronics control F.... ack* CIA-B Address BFDx00 data bits 15-8 (A13*) (int6) ----------------------------------------------------- PA7..com line DTR* , driven output PA6..com line RTS* , driven output PA5..com line carrier detect* PA4..com line CTS* PA3..com line DSR* PA2.. SEL Centronics control PA1.. POUT +--- paper out ------------+ PA0.. BUSY | +--busy -------------+ | | | | | SP... BUSY | +- commodore serial bus + | CNT.. POUT +----commodore serial bus --+ PB7.. MTR* motor PB6.. SEL3* select external 3rd drive PB5.. SEL2* select external 2nd drive PB4.. SEL1* select external 1st drive PB3.. SEL0* select internal drive PB2.. SIDE* side select* PB1.. DIR direction PB0.. STEP* step* PC...not used F.... INDEX* disk index pulse* [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0082.html.txt:1:3 / / When Picture is Larger than Display Window / Memory Allocation ]" border=0> For larger memory pictures, you need to allocate more memory. Here is a formula for calculating memory requirements in general: bytes per line * lines in playfield * # of bitplanes The number of bytes must be even. Thus, if the wide playfield described in this section is formed from two bitplanes, it requires: 80 * 200 * 2 = 32,000 bytes of memory Recall that this is the memory requirement for the playfield alone. You need more memory for any sprites , animation , audio , or application programs you are using. The amount of Chip memory is one of the basic constraints on the size of playfields. For instance, a playfield 2000 by 2000 pixels with five bitplanes would exceed even the two megabytes of Chip memory possible on an Amiga 3000. Another constraint on playfield size is the bit plane modulos which limit the width (but not the height) of a playfield to 262,144 pixels. As a practical matter, the blitter size registers also limit the size of playfields (unless the 680x0 CPU is used for drawing operations). With the original chip set the largest area the blitter can draw in is 1008 by 1024. With the Enhanced Chip Set (ECS), the largest area the blitter can draw in is increased to 16368 by 16384 pixels. For more information on ECS and blitter limits refer to Appendix C, Enhanced Chip Set. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0030.html.txt:1:A Register Summary / DSKBYTR ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- DSKBYTR 01A R P Disk data byte and status read This register is the disk-microprocessor data buffer. Data from the disk (in read mode) is loaded into this register one byte at a time, and bit 15 (DSKBYT) is set true. BIT# ---- --------- -------------------------------- 15 DSKBYT Disk byte ready (reset on read) 14 DMAON Mirror of bit 15 (DMAEN) in DSKLEN , ANDed with Bit09 (DMAEN) in DMACON 13 DISKWRITE Mirror of bit 14 (WRITE) in DSKLEN 12 WORDEQUAL This bit true only while the DSKSYNC register equals the data from disk. 11-08 X Not used 07-00 DATA Disk byte data [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node00AD.html.txt:1:C Enhanced Chip Set / ECS Registers ]" border=0> The register map listed below shows the changes and new registers in the Amiga's Enhanced Chip Set. --------------------------------------------------------------------------- ADD REGISTER V2.0 R/W CHIP FUNCTION --------------------------------------------------------------------------- 004 VPOSR chg R A Read vertical most sig. bits (and frame flop) 012 POT0DAT chg R P Pot counter data left pair (vertical, horiz) 014 POT1DAT chg R P Pot counter data right pair (vertical, horiz) 020 DSKPTH chg W A Disk pointer (high 5 bits, was 3 bits) 02E COPCON chg W A Coprocessor control 03E STRLONG chg S D Strobe for identification of long horiz line 042 BLTCON1 chg W A Blitter control register 1 050 BLTxPTH chg W A Blitter pointer to x (high 5 bits, was 3 bits) 05A BLTCON0L new W A Blitter control 0, lower 8 bits (minterms) 05C BLTSIZV new W A Blitter V size (for 15 bit vertical size) 05E BLTSIZH new W A Blitter H size and start (for 11 bit H size) 07C DENISEID new R D Chip revision level for Denise (video out chip) 080 COP1LCH chg W A Coprocessor 1st location(high 5 bits,was 3 bits) 084 COP2LCH chg W A Coprocessor 2nd location(high 5 bits,was 3 bits) 0A0 AUDxLCH chg W A Audio channel x location(high 5 bits was 3 bits) 0A6 AUDxPER chg W P Audio channel x period 100 BPLCON0 chg W A,D Bitplane control (miscellaneous control bits) 104 BPLCON2 chg W D Bitplane control (video priority control) 106 BPLCON3 new W D Bitplane control (enhanced features) 142 SPRxCTL chg W A Sprite x position and control data 1C0 HTOTAL new W A Highest number count, horiz line (VARBEAMEN=1) 1C2 HSSTOP new W A Horizontal line position for HSYNC stop 1C4 HBSTRT new W A Horizontal line position for HBLANK start 1C6 HBSTOP new W A Horizontal line position for HBLANK stop 1C8 VTOTAL new W A Highest numbered vertical line (VARBEAMEN=1) 1CA VSSTOP new W A Vertical line position for VSYNC stop 1CC VBSTRT new W A Vertical line for VBLANK start 1CE VBSTOP new W A Vertical line for VBLANK stop 1DC BEAMCON0 new W A Beam counter control register (SHRES,UHRES,PAL) 1DE HSSTRT new W A Horizontal sync start (VARHSY) 1E0 VSSTRT new W A Vertical sync start (VARVSY) 1E2 HCENTER new W A Horizontal position for Vsync on interlace 1E4 DIWHIGH new W A,D Display window - upper bits for start, stop --------------------------------------------------------------------------- A=Agnus chip, D=Denise chip, P=Paula chip, W=Write, R=Read, S=Strobe [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node016B.html.txt:1:7 / / Setting and Clearing Bits / Audio Interrupts ]" border=0> Bits 10 - 7, AUD3 - 0, are assigned to the audio channels. They are called AUD3, AUD2, AUD1, and AUD0 and are assigned to channels 3, 2, 1, and 0, respectively. This level 4 interrupt signals "audio block done." When the audio DMA is operating in automatic mode , this interrupt occurs when the last word in an audio data stream has been accessed. In manual mode , it occurs when the audio data register is ready to accept another word of data. See Chapter 5, "Audio Hardware," for more information about interrupt generation and timing . [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node01A7.html.txt:1:8 Interface Hardware / Display Output Connections ]" border=0> All Amigas provide a 23-pin connector on the back. This jack contains video outputs and inputs for external genlock devices. Two separate type of RGB video are available on the connector: * RGB Monitors ("analog RGB"). Provides four outputs; Red (R), Green (G), Blue (B), and Sync (S). They can generate up to 4,096 different colors on-screen simultaneously using the circuitry presently available on the Amiga. * Digital RGB Monitors. Provides four outputs, distinct from those shown above, named Red (R), Green (G), Blue (B), Half-Intensity (I), and Sync (S). All output levels are logic levels (0 or 1). On some monitors these outputs allow up to 15 possible color combinations, where the values 0000 and 0001 map to the same output value (Half intensity with no color present is the same as full intensity, no color). Some monitors arbitrarily map the 16 combinations to 16 arbitrary colors. Note that the sync signals from the Amiga are unbuffered. For use with any device that presents a heavy load on the sync outputs, external buffers will be required. The Amiga 500 and 2000 provide a full-bandwidth monochrome video jack for use with inexpensive monochrome monitors. The Amiga colors are combined into intensities based on the following table: Red Green Blue --- ----- ---- 30% 60% 10% The A3000 is not equipped with a monochrome video jack. The Amiga 1000 provides an RF modulator jack. An adapter is available that allows all Amiga models to use a television set for display. Stereo sound is available on the jack, but will generally be combined into monaural sound for the TV set. The Amiga 1000 provides a color composite video jack. This is suitable for recording directly with a VCR, but the output is not broadcast quality. For use on a monochrome monitor, the color information often has undesired effects; careful color selection or a modification to the internal circuitry can improve the results. The A500, A2000 and A3000 do not have a color composite video jack. High quality composite adapters for the A500, A1000, A2000 and A3000 plug into the 23 pin RGB port. The Amiga 2000 and 3000 provide a special "video slot" that contains many more signals than are available elsewhere: all the 23-pin RGB port signals, the unencoded digital video, light pen, power, audio, colorburst, pixel switch, sync, clock signals, etc. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node00D9.html.txt:1:5 / Forming and Playing a Sound / Deciding Which Channel to Use #marker1 { color: red } #marker1::after { vertical-align: super; font-size: 0.8em; content: "[1]" } .footnote { font-family: monospace } ]" border=0> The Amiga has four audio channels. Channels 1 and 2 are connected to the left-side stereo output jack. Channels 0 and 3 are connected to the right-side output jack. Select a channel on the side from which the output is to appear. [1]: Belage says (in November 2020): [...] in the printed manual Amiga HRM 1e, 6th print, August 1988, page 136 you can find the following: DECIDING WHICH CHANNEL TO USE The Amiga has four audio channels. Channels 0 and 3 are connected to the left-side stereo output jack. Channels 1 and 2 are connected to the right-side output jack. Select a channel on the side from which the output is to appear. [...] So in the web version you find: 0-3 = R-L-L-R. In the printed manual you find: 0-3 = L-R-R-L, which is identical how the real hardware works. [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node0371.html.txt:1:exec.library/RemIntServer ]" border=0> NAME RemIntServer -- remove an interrupt server from a server chain SYNOPSIS RemIntServer(intNum, interrupt) D0 A1 void RemIntServer(ULONG,struct Interrupt *); FUNCTION This function removes an interrupt server node from the given server chain. If this server was the last one on this chain, interrupts for this chain are disabled. INPUTS intNum - the Paula interrupt bit (0..14) interrupt - pointer to an interrupt server node BUGS Before V36 Kickstart, the feature that disables the interrupt would not function. For most server chains this does not cause a problem. SEE ALSO AddIntServer , hardware/intbits.h [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node006D.html.txt:1:audio.device/CMD_RESET ]" border=0> NAME CMD_RESET -- restore device to a known state FUNCTION CMD_RESET is a standard command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct, CMD_RESET: . clears the hardware audio registers and attach bits, . sets the audio interrupt vector, . cancels all pending I/O (CMD_FLUSH), and . un-stops the channel if it is stopped (CMD_STOP), Otherwise, CMD_RESET returns an error (ADIOERR_NOALLOCATION). CMD_RESET is synchronous and only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. Do not use CMD_RESET in interrupt code at interrupt level 5 or higher. INPUTS mn_ReplyPort- pointer to message port that receives I/O request if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to reset (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for CMD_RESET io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channels to successfully reset (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0038.html.txt:1:A Register Summary / JOY0DAT, JOY1DAT ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- JOY0DAT 00A R D Joystick-mouse 0 data (left vertical, horizontal) JOY1DAT 00C R D Joystick-mouse 1 data (right vertical, horizontal) These addresses each read a pair of 8-bit mouse counters. 0=left controller pair, 1=right controller pair (four counters total). The bit usage for both left and right addresses is shown below. Each counter is clocked by signals from two controller pins. Bits 1 and 0 of each counter may be read to determine the state of these two clock pins. This allows these pins to double as joystick switch inputs. Mouse counter usage: (pins 1,3=Yclock, pins 2,4=Xclock) BIT# 15,14,13,12,11,10,09,08 07,06,05,04,03,02,01,00 ----------------------- ----------------------- 0DAT Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 X7 X6 X5 X4 X3 X2 X1 X0 1DAT Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 X7 X6 X5 X4 X3 X2 X1 X0 The following table shows the mouse/joystick connector pin usage. The pins (and their functions) are sampled (multiplexed) into the DENISE chip during the clock times shown in the table. This table is for reference only and should not be needed by the programmer. (Note that the joystick functions are all "active low" at the connector pins.) Sampled by DENISE Conn Joystick Mouse ----------------- Pin Function Function Pin Name Clock ---- -------- -------- --- ---- ----- L1 FORW* Y 38 M0V at CCK L3 LEFT* YQ 38 M0V at CCK* L2 BACK* X 9 M0H at CCK L4 RIGH* XQ 9 M0H at CCK* R1 FORW* Y 39 M1V at CCK R3 LEFT* YQ 39 M1V at CCK* R2 BACK* X 8 M1H at CCK R4 RIGH* XQ 8 M1H at CCK* After being sampled, these connector pin signals are used in quadrature to clock the mouse counters. The LEFT and RIGHT joystick functions (active high) are directly available on the Y1 and X1 bits of each counter. In order to recreate the FORWARD and BACK joystick functions, however, it is necessary to logically combine (exclusive OR) the lower two bits of each counter. This is illustrated in the following table. To detect Read these counter bits -------- ---------------- Forward Y1 xor Y0 (BIT#09 xor BIT#08) Left Y1 Back X1 xor X0 (BIT#01 xor BIT#00) Right X1 [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0021.html.txt:1:A Register Summary / BPL1MOD, BPL2MOD ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- BPL1MOD 108 W A Bitplane modulo (odd planes) BPL2MOD 10A W A Bitplane modulo (even planes) These registers contain the modulos for the odd and even bitplanes. A modulo is a number that is automatically added to the address at the end of each line, so that the address then points to the start of the next line. Since they have separate modulos, the odd and even bitplanes may have sizes that are different from each other, as well as different from the display window size. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node023F.html.txt:1:Amiga® Hardware Reference Manual: List of Tables ]" border=0> Table 1-1: Summary of Amiga Memory Configurations Table 2-1: Interrupting the 680x0 Table 2-2: Copper Instruction Summary Table 3-1: Colors in a Single Playfield Table 3-2: Portion of the Color Table Table 3-3: Contents of the Color Registers Table 3-4: Sample Color Register Contents Table 3-5: Setting the Number of Bitplanes Table 3-6: Lines in a Normal Playfield Table 3-7: Playfield Memory Requirements, NTSC Table 3-8: Playfield Memory Requirements, PAL Table 3-9: DIWSTRT and DIWSTOP Summary Table 3-10: Playfield 1 Color Registers -- Low resolution Mode Table 3-11: Playfield 2 Color Registers -- Low resolution Mode Table 3-12: Playfields 1 and 2 Color Registers -- High resolution Mode Table 3-13: Maximum Allowable Vertical Screen Video Table 3-14: Maximum Allowable Horizontal Screen Video Table 3-15: Color Register Contents Table 3-16: Some Register Values and Resulting Colors Table 3-17: Low resolution Color Selection Table 3-18: High resolution Color Selection Table 3-19: Color Selection in Hold-and-modify Mode Table 4-1: Sprite Data Structure Table 4-2: Sprite Color Registers Table 4-3: Color Registers for Sprite Pairs Table 4-4: Data Words for First Line of Spaceship Sprite Table 4-5: Color Registers in Attached Sprites Table 4-6: Color Registers for Single Sprites Table 4-7: Color Registers for Attached Sprites Table 5-1: Sample Audio Data Set for Channel 0 Table 5-2: Volume Values Table 5-3: DMA and Audio Channel Enable Bits Table 5-4: Data Interpretation in Attach Mode Table 5-5: Channel Attachment for Modulation Table 5-6: Sampling Rate and Frequency Relationship Table 5-7: Equal-tempered Octave for a 16 Byte Sample Table 5-8: Five Octave Even-tempered Scale Table 5-9: Decibel Values and Volume Ranges Table 6-1: Table of Common Minterm Values Table 6-2: Typical Blitter Cycle Sequence Table 6-3: BLTCON1 Code Bits for Octant Line Drawing Table 7-1: Bits in BPLCON2 Table 7-2: Priority of Playfields Based on Values of Bits PF1P2-PF1P0 Table 7-3: CLXDAT Bits Table 7-4: CLXCON Bits Table 7-5: Contents of the Beam Position Counter Table 7-6: Contents of DMA Control Register Table 8-1: Typical Controller Connections Table 8-2: Determining the Direction of the Mouse Table 8-3: Interpreting Data from JOY0DAT and JOY1DAT Table 8-4: POTGO ($DFF034) and POTINP ($DFF016) Registers Table 8-5: Disk Subsystem Table 8-6: DSKLEN Register ($DFF024) Table 8-7: DSKBYTR Register Table 8-8: ADKCON and ADKCONR Register Table 8-9: SERDATR / ADKCON Registers Table K-1: Memory Space Type Codes [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node061F.html.txt:1:include/devices/audio.h ]" border=0> #ifndef DEVICES_AUDIO_H #define DEVICES_AUDIO_H /* ** $VER: audio.h 36.3 (29.8.1990) ** Includes Release 44.1 ** ** audio.device include file ** ** (C) Copyright 1985-1999 Amiga, Inc. ** All Rights Reserved */ #ifndef EXEC_IO_H #include #endif #define AUDIONAME "audio.device" #define ADHARD_CHANNELS 4 #define ADALLOC_MINPREC -128 #define ADALLOC_MAXPREC 127 #define ADCMD_FREE (CMD_NONSTD+0) #define ADCMD_SETPREC (CMD_NONSTD+1) #define ADCMD_FINISH (CMD_NONSTD+2) #define ADCMD_PERVOL (CMD_NONSTD+3) #define ADCMD_LOCK (CMD_NONSTD+4) #define ADCMD_WAITCYCLE (CMD_NONSTD+5) #define ADCMD_ALLOCATE 32 #define ADIOB_PERVOL 4 #define ADIOF_PERVOL (1 struct IOAudio { struct IORequest ioa_Request; WORD ioa_AllocKey; UBYTE *ioa_Data; ULONG ioa_Length; UWORD ioa_Period; UWORD ioa_Volume; UWORD ioa_Cycles; struct Message ioa_WriteMsg; }; #endif /* DEVICES_AUDIO_H */ [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node00E0.html.txt:1:5 / Forming and Playing a Sound / Playing the Waveform ]" border=0> After you have defined the audio data location , length , volume and period , you can play the waveform by starting the DMA for that audio channel. This starts the output of sound. Once started, the DMA continues until you specifically stop it. Thus, the waveform is played over and over again, producing the steady tone. The system uses the value in the location registers each time it replays the waveform. For any audio DMA to occur (or any other DMA, for that matter), the DMAEN bit in DMACON must be set. When both DMAEN and AUDxEN are set, the DMA will start for channel x. All these bits and their meanings are shown in table 5-3. Table 5-3: DMA and Audio Channel Enable Bits DMACON Register --------------- Bit Name Function --- ---- -------- 15 SET/CLR When this bit is written as a 1, it sets any bit in DMACONW for which the corresponding bit position is also a 1, leaving all other bits alone. 9 DMAEN Only while this bit is a 1 can any direct memory access occur. 3 AUD3EN Audio channel 3 enable. 2 AUD2EN Audio channel 2 enable. 1 AUD1EN Audio channel 1 enable. 0 AUD0EN Audio channel 0 enable. For example, if you are using channel 0, then you write a 1 into bit 9 to enable DMA and a 1 into bit 0 to enable the audio channel, as shown below. BEGINCHAN0: LEA CUSTOM,a0 MOVE.W #(DMAF_SETCLR!DMAF_AUD0!DMAF_MASTER), DMACON (a0) [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node0630.html.txt:1:include/devices/narrator.h ]" border=0> #ifndef DEVICES_NARRATOR_H #define DEVICES_NARRATOR_H /* ** $VER: narrator.h 1.7 (12.3.1991) ** Includes Release 44.1 ** ** V37 Narrator device C language include file ** ** Copyright 1990, 1991 Joseph Katz/Mark Barton. ** All rights reserved. ** ** This include file (narrator.h) may be freely distributed ** as long as the above copyright notice remains intact. ** */ #ifndef EXEC_IO_H #include #endif /* Device Options */ #define NDB_NEWIORB 0 /* Use new extended IORB */ #define NDB_WORDSYNC 1 /* Generate word sync messages */ #define NDB_SYLSYNC 2 /* Generate syllable sync messages */ #define NDF_NEWIORB (1 struct narrator_rb { struct IOStdReq message; /* Standard IORB */ UWORD rate; /* Speaking rate (words/minute) */ UWORD pitch; /* Baseline pitch in Hertz */ UWORD mode; /* Pitch mode */ UWORD sex; /* Sex of voice */ UBYTE *ch_masks; /* Pointer to audio alloc maps */ UWORD nm_masks; /* Number of audio alloc maps */ UWORD volume; /* Volume. 0 (off) thru 64 */ UWORD sampfreq; /* Audio sampling freq */ UBYTE mouths; /* If non-zero, generate mouths */ UBYTE chanmask; /* Which ch mask used (internal)*/ UBYTE numchan; /* Num ch masks used (internal) */ UBYTE flags; /* New feature flags */ UBYTE F0enthusiasm; /* F0 excursion factor */ UBYTE F0perturb; /* Amount of F0 perturbation */ BYTE F1adj; /* F1 adjustment in ±5% steps */ BYTE F2adj; /* F2 adjustment in ±5% steps */ BYTE F3adj; /* F3 adjustment in ±5% steps */ BYTE A1adj; /* A1 adjustment in decibels */ BYTE A2adj; /* A2 adjustment in decibels */ BYTE A3adj; /* A3 adjustment in decibels */ UBYTE articulate; /* Transition time multiplier */ UBYTE centralize; /* Degree of vowel centralization */ char *centphon; /* Pointer to central ASCII phon */ BYTE AVbias; /* AV bias */ BYTE AFbias; /* AF bias */ BYTE priority; /* Priority while speaking */ BYTE pad1; /* For alignment */ }; /* Standard Read request */ struct mouth_rb { struct narrator_rb voice; /* Speech IORB */ UBYTE width; /* Width (returned value) */ UBYTE height; /* Height (returned value) */ UBYTE shape; /* Internal use, do not modify */ UBYTE sync; /* Returned sync events */ }; #endif /* DEVICES_NARRATOR_H */ [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0029.html.txt:1:A Register Summary / COPCON ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- COPCON 02E W A( E ) Copper control register This is a 1-bit register that when set true, allows the Copper to access the blitter hardware. This bit is cleared by power-on reset, so that the Copper cannot access the blitter hardware. See Appendix C for ECS operation. BIT# NAME FUNCTION ---- ------- ------------------ 01 CDANG Copper danger mode. Allows Copper access to blitter if true. [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node006B.html.txt:1:audio.device/CMD_FLUSH ]" border=0> NAME CMD_FLUSH -- cancel all pending I/O FUNCTION CMD_FLUSH is a standard command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct, CMD_FLUSH aborts all writes (CMD_WRITE) in progress or queued and any I/O requests waiting to synchronize with the end of the cycle (ADCMD_WAITCYCLE); otherwise, CMD_FLUSH returns an error (ADIOERR_NOALLOCATION). CMD_FLUSH is synchronous and only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. Do not use CMD_FLUSH in interrupt code at interrupt level 5 or higher. INPUTS mn_ReplyPort- pointer to message port that receives I/O request if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to flush (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for CMD_FLUSH io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channels successfully flushed (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0032.html.txt:1:A Register Summary / DSKLEN ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- DSKLEN 024 W P Disk length This register contains the length (number of words) of disk DMA data. It also contains two control bits, a DMA enable bit, and a DMA direction (read/write) bit. BIT# FUNCTION DESCRIPTION ---- ----------- -------------------------------- 15 DMAEN Disk DMA enable 14 WRITE Disk write (RAM to disk) if 1 13-0 LENGTH Length (# of words) of DMA data. [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node04B8.html.txt:1:audio.device/OpenDevice ]" border=0> NAME OpenDevice - open the audio device SYNOPSIS error = OpenDevice("audio.device", unitNumber, iORequest, flags); FUNCTION The OpenDevice routine grants access to the audio device. It takes an I/O audio request block (iORequest) and if it can successfully open the audio device, it loads the device pointer (io_Device) and the allocation key (ioa_AllocKey); otherwise, it returns an error (IOERR_OPENFAIL). OpenDevice increments the open count keeping the device from being expunged (Expunge). If the length (ioa_Length) is non-zero, OpenDevice tries to allocate (ADCMD_ALLOCATE) audio channels from a array of channel combination options (ioa_Data). If the allocation succeeds, the allocated channel combination is loaded into the unit field (ioa_Unit); otherwise, OpenDevice returns an error (ADIOERR_ALLOCFAILED). OpenDevice does not wait for allocation to succeed and closes (CloseDevice) the audio device if it fails. To allocate channels, OpenDevice also requires a properly initialized reply port (mn_ReplyPort) with an allocated signal bit. INPUTS unitNumber- not used iORequest - pointer to audio request block (struct IOAudio) ln_Pri - allocation precedence (-128 thru 127), only necessary for allocation (non-zero length) mn_ReplyPort- pointer to message port for allocation, only necessary for allocation (non-zero length) ioa_AllocKey- allocation key; zero to generate new key. Otherwise, it must be set by (or copied from I/O block that is set by) previous OpenDevice function or ADCMD_ALLOCATE command (non-zero length) ioa_Data - pointer to channel combination options (byte array, bits 0 thru 3 correspond to channels 0 thru 3), only necessary for allocation (non-zero length) ioa_Length - length of the channel combination option array (0 thru 16), zero for no allocation flags - not used OUTPUTS iORequest - pointer to audio request block (struct IOAudio) io_Device - pointer to device node if OpenDevice succeeds, otherwise -1 io_Unit - bit map of successfully allocated channels (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error IOERR_OPENFAIL - open failed ADIOERR_ALLOCFAILED - allocation failed, no open ioa_AllocKey- allocation key, set to a unique number if passed a zero and OpenDevice succeeds error - copy of io_Error [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0016.html.txt:1:A Register Summary / AUDxPER ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- AUDxPER 0A6 W P( E ) Audio channel x Period This register contains the period (rate) of audio channel x DMA data transfer. The minimum period is 124 color clocks. This means that the smallest number that should be placed in this register is 124 decimal. This corresponds to a maximum sample frequency of 28.86 khz. [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node0068.html.txt:1:audio.device/BeginIO ]" border=0> NAME BeginIO - dispatch a device command SYNOPSIS BeginIO(iORequest); A1 FUNCTION BeginIO has the responsibility of dispatching all device commands. Immediate commands are always called directly, and all other commands are queued to make them single threaded. INPUTS iORequest -- pointer to the I/O Request for this command [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node003C.html.txt:1:Includes/devices/audio.i ]" border=0> IFND DEVICES_AUDIO_I DEVICES_AUDIO_I SET 1 ** ** $Filename: devices/audio.i $ ** $Release: 2.04 Includes, V37.4 $ ** $Revision: 36.3 $ ** $Date: 90/08/29 $ ** ** audio.device include file ** ** (C) Copyright 1985-1999 Amiga, Inc. ** All Rights Reserved ** IFND EXEC_IO_I INCLUDE "exec/io.i" ENDC AUDIONAME MACRO DC.B 'audio.device',0 ENDM ADHARD_CHANNELS EQU 4 ADALLOC_MINPREC EQU -128 ADALLOC_MAXPREC EQU 127 ADCMD_FREE EQU CMD_NONSTD+0 ADCMD_SETPREC EQU CMD_NONSTD+1 ADCMD_FINISH EQU CMD_NONSTD+2 ADCMD_PERVOL EQU CMD_NONSTD+3 ADCMD_LOCK EQU CMD_NONSTD+4 ADCMD_WAITCYCLE EQU CMD_NONSTD+5 ADCMD_ALLOCATE EQU 32 ADIOB_PERVOL EQU 4 ADIOF_PERVOL EQU 1 [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0019.html.txt:1:A Register Summary / BLTAFWM, BLTALWM ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- BLTAFWM 044 W A Blitter first-word mask for source A BLTALWM 046 W A Blitter last-word mask for source A The patterns in these two registers are ANDed with the first and last words of each line of data from source A into the blitter. A zero in any bit overrides data from source A. These registers should be set to all 1s for fill mode or for line-drawing mode. [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node04A8.html.txt:1:audio.device/ADCMD_FREE ]" border=0> NAME ADCMD_FREE -- free audio channels for allocation FUNCTION ADCMD_FREE is a command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct, ADCMD_FREE does the following: . restores the channel to a known state (CMD_RESET), . changes the channels allocation key, and . makes the channel available for re-allocation. . If the channel is locked (ADCMD_LOCK) ADCMD_FREE unlocks it and clears the bit for the channel (io_Unit) in the lock I/O request. If the lock I/O request has no channel bits set ADCMD_FREE replies the lock I/O request, and . checks if there are allocation requests (ADCMD_ALLOCATE) waiting for the channel. Otherwise, ADCMD_FREE returns an error (ADIOERR_NOALLOCATION). ADCMD_FREE is synchronous and only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. Do not use ADCMD_FREE in interrupt code. INPUTS mn_ReplyPort- pointer to message port that receives I/O request if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to free (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for ADCMD_FREE io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channels successfully freed (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node00E7.html.txt:1:5 / Producing Complex Sounds / Modulating Sound ]" border=0> To provide more complex audio effects, you can use one audio channel to modulate another. This increases the range and type of effects that can be produced. You can modulate a channel's frequency or amplitude , or do both types of modulation on a channel at the same time. Amplitude modulation affects the volume of the waveform. It is often used to produce vibrato or tremolo effects. Frequency modulation affects the period of the waveform. Although the basic waveform itself remains the same, the pitch is increased or decreased by frequency modulation. The system uses one channel to modulate another when you attach two channels. The attach bits in the ADKCON register control how the data from an audio channel is interpreted (see the table below). Normally, each channel produces sound when it is enabled. If the "attach" bit for an audio channel is set, that channel ceases to produce sound and its data is used to modulate the sound of the next higher-numbered channel. When a channel is used as a modulator, the words in its data set are no longer treated as two individual bytes. Instead, they are used as "modulator" words. The data words from the modulator channel are written into the corresponding registers of the modulated channel each time the period register of the modulator channel times out. To modulate only the amplitude of the audio output, you must attach a channel as a volume modulator. Define the modulator channel's data set as a series of words, each containing volume information in the following format: Bits Function ---- -------- 15 - 7 Not used 6 - 0 Volume information, V6 - V0 To modulate only the frequency, you must attach a channel as a period modulator. Define the modulator channel's data set as a series of words, each containing period information in the following format: Bits Function ---- -------- 15 - 0 Period information, P15 - P0 If you want to modulate both period and volume on the same channel, you need to attach the channel as both a period and volume modulator. For instance, if channel 0 is used to modulate both the period and frequency of channel 1, you set two attach bits -- bit 0 to modulate the volume and bit 4 to modulate the period . When period and volume are both modulated, words in the modulator channel's data set are defined alternately as volume and period information. The sample set of data in Table 5-4 shows the differences in interpretation of data when a channel is used directly for audio, when it is attached as volume modulator, when it is attached as a period modulator, and when it is attached as a modulator of both volume and period . Table 5-4: Data Interpretation in Attach Mode Independent Modulating Data (not Both Modulating Modulating Words Modulating) Period and Volume Period Only Volume Only ----- ----------- ----------------- ----------- ----------- Word 1 |data|data| |volume for other channel| |period| |volume| Word 2 |data|data| |period for other channel| |period| |volume| Word 3 |data|data| |volume for other channel| |period| |volume| Word 4 |data|data| |period for other channel| |period| |volume| The lengths of the data sets of the modulator and the modulated channels are completely independent. Channels are attached by the system in a predetermined order, as shown in Table 5-5. To attach a channel as a modulator, you set its attach bit to 1. If you set either the volume or period attach bits for a channel, that channel's audio output will be disabled; the channel will be attached to the next higher channel, as shown in Table 5-5. Because an attached channel always modulates the next higher numbered channel, you cannot attach channel 3. Writing a 1 into channel 3's modulate bits only disables its audio output. Table 5-5: Channel Attachment for Modulation ADKCON Register --------------- Bit Name Function --- ---- -------- 7 ATPER3 Use audio channel 3 to modulate nothing (disables audio output of channel 3) 6 ATPER2 Use audio channel 2 to modulate period of channel 3 5 ATPER1 Use audio channel 1 to modulate period of channel 2 4 ATPER0 Use audio channel 0 to modulate period of channel 1 3 ATVOL3 Use audio channel 3 to modulate nothing (disables audio output of channel 3) 2 ATVOL2 Use audio channel 2 to modulate volume of channel 3 1 ATVOL1 Use audio channel 1 to modulate volume of channel 2 0 ATVOL0 Use audio channel 0 to modulate volume of channel 1 [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0003.html.txt:1:1 Introduction / Components of the Amiga ]" border=0> These are the hardware components of the Amiga: * Motorola MC68000 16/32-bit main processor. The Amiga also supports the 68010, 68020, and 68030 processors as an option. The A1000, A500 and A2000 contain the 68000, while the A3000 utilizes the 68030 processor. * Custom graphics and audio chips with DMA capability. All Amiga models are equipped with three custom chips named Paula, Agnus, and Denise which provide for superior color graphics, digital audio, and high-performance interrupt and I/O handling. The custom chips can access up to 2MB of memory directly without using the 68000 CPU. * From 256K to 2 MB of RAM expandable to a total of 8 MB (over a gigabyte on the Amiga 3000). * 512K of system ROM containing a real time, multitasking operating system with sound, graphics, and animation support routines. (V1.3 and earlier versions of the OS used 256K of system ROM.) * Built-in 3.5 inch double sided disk drive with expansion floppy disk ports for connecting up to three additional disk drives (either 3.5 inch or 5.25 inch, double sided). * SCSI disk port for connecting additional SCSI disk drives (A3000 Only). * Fully programmable parallel and RS-232-C serial ports. * Two button opto-mechanical mouse and two reconfigurable controller ports (for mice, joysticks, light pens, paddles, or custom controllers). * A professional keyboard with numeric keypad, 10 function keys, and cursor keys. A variety of international keyboards are also supported. * Ports for analog or digital RGB output (all models), monochrome video (A500 and A2000), composite video (A1000), and VGA-style multiscan video (A3000). * Ports for left and right stereo audio from four special purpose audio channels. * Expansion options that allow you to add RAM, additional disk drives (floppy or hard), peripherals, or coprocessors. The MC68000 and the Amiga Custom Chips Amiga Memory System Peripherals System Expandability and Adaptability VCR and Direct Camera Interface Amiga System Block Diagram [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node0066.html.txt:1:audio.device/ADCMD_SETPREC ]" border=0> NAME ADCMD_SETPREC -- set the allocation precedence for audio channels FUNCTION ADCMD_SETPREC is a command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct, ADCMD_SETPREC sets the allocation precedence to a new value (ln_Pri) and checks if there are allocation requests (ADCMD_ALLOCATE) waiting for the channel which now have higher precedence; otherwise, ADCMD_SETPREC returns an error (ADIOERR_NOALLOCATION). ADCMD_SETPREC is synchronous and only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. Do not use ADCMD_SETPREC in interrupt code. INPUTS ln_Pri - new allocation precedence (-128 thru 127) mn_ReplyPort- pointer to message port that receives I/O request if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to set precedence (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for ADCMD_SETPREC io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channels that successfully set precedence (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0046.html.txt:1:A Register Summary / VSSTOP, VSSTRT, VTOTAL ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- VSSTOP 1CA W A( E ) Vertical line position for VSYNC stop VSSTRT 1E0 W A( E ) Vertical sync start (VARVSY) VTOTAL 1C8 W A( E ) Highest numbered vertical line (VARBEAMEN=1) [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0195.html.txt:1:8 / / Disk Subsystem Timing / DSKSYNC - Disk Input Synchronizer ]" border=0> The DSKSYNC register is used to synchronize the input stream. This is highly useful when reading disks. If the WORDSYNC bit is enabled in ADKCON , no data is transferred until a word is found in the input stream that matches the word in the DSKSYNC register. On read, DMA will start with the following word from the disk. During disk read DMA, the controller will resync every time the word match is found. Typically the DSKSYNC will be set to the magic MFM sync mark value, $4489. In addition, the DSKSYNC bit in INTREQ is set when the input stream matches the DSKSYNC register. The DSKSYNC bit in INTREQ is independent of the WORDSYNC enable. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node00E4.html.txt:1:5 / Producing Complex Sounds / Joining Tones ]" border=0> Tones are joined by writing the location and length registers , starting the audio output, and rewriting the registers in preparation for the next audio waveform that you wish to connect to the first one. This is made easy by the timing of the audio interrupts and the existence of back-up registers. The location and length registers are read by the DMA channel before audio output begins. The DMA channel then stores the values in back-up registers. Once the original registers have been read by the DMA channel, you can change their values without disturbing the operation you started with the original register contents. Thus, you can write the contents of these registers, start an audio output, and then rewrite the registers in preparation for the next waveform you want to connect to this one. Interrupts occur immediately after the audio DMA channel has read the location and length registers and stored their values in the back-up registers. Once the interrupt has occurred, you can rewrite the registers with the location and length for the next waveform segment. This combination of back-up registers and interrupt timing lets you keep one step ahead of the audio DMA channel, allowing your sound output to be continuous and smooth. If you do not rewrite the registers, the current waveform will be repeated. Each time the length counter reaches zero, both the location and length registers are reloaded with the same values to continue the audio output. Audio DMA Example [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node000A.html.txt:1:1 Introduction / About the Examples ]" border=0> The examples in this book all demonstrate direct manipulation of the Amiga hardware. However, as a general rule, it is not permissible to directly access the hardware in the Amiga unless your software either has full control of the system, or has arbitrated via the OS for exclusive access to the particular parts of the hardware you wish to control. Almost all of the hardware discussed in this manual, most notably the Blitter, Copper, playfield, sprite, CIA, trackdisk, and system control hardware, are in either exclusive or arbitrated use by portions of the Amiga OS in any running Amiga system. Additional hardware, such as the audio, parallel, and serial hardware, may be in use by applications which have allocated their use through the system software. Before attempting to directly manipulate any part of the hardware in the Amiga's multitasking environment, your application must first be granted exclusive access to that hardware by the operating system library, device, or resource which arbitrates its ownership. The operating system functions for requesting and receiving control of parts of the Amiga hardware are varied and are not within the scope of this manual. Generally such functions, when available, will be found in the library, device, or resource which manages that portion of the Amiga hardware in the multitasking environment. The following list will help you to find the appropriate operating system functions or mechanisms which may exist for arbitrated access to the hardware discussed in this manual. Hardware component Amiga system module that controls it ------------------ ------------------------------------ Copper, Playfield, Sprite, Blitter................graphics.library Audio.................................................audio.device Trackdisk..........................trackdisk.device, disk.resource Serial................................serial.device, misc.resource Parallel..............parallel.device, cia.resource, misc.resource Gameport.............input.device, gameport.device, potgo.resource Keyboard.............................input.device, keyboard.device System Control.........graphics.library, exec.library (interrupts) Most of the examples in this book use the hw_examples.i file (see Appendix I ) to define the chip register names. Hw_examples.i uses the system include file hardware/custom.i to define the chip structures and relative addresses. The values defined in hardware/custom.i and hw_examples.i are offsets from the base of the chip register address space. In general, this base value is defined as _custom and is resolved during linking with the linker library amiga.lib. (_ciaa and _ciab are also resolved in this way.) Normally, the base address is loaded into an address register and the offsets given by hardware/custom.i and hw_examples.i are then used to access the correct register. (One exception to this rule is the Copper which uses only the offset access the registers.) For example, in assembler: INCLUDE "exec/types.i" INCLUDE "hardware/custom.i" XREF _custom ; External reference... Start: lea _custom,a0 ; Use a0 as base register and move.w #$7FFF,intena(a0) ; use the name intena as an offset ; to disable all interrupts In C, you would use the structure definitions in hardware/custom.h For example: #include "exec/types.h" #include "hardware/custom.h" extern struct Custom custom; /* You may need to define the above external as ** extern struct Custom far custom; ** Check you compiler manual. */ main() { custom.intena = 0x7FFF; /* Disable all interrupts */ } The Amiga hardware include files are generally supplied with your compiler or assembler. Listings of the hardware include files may also be found in the Amiga ROM Kernel Manual: Includes and Autodocs. Generally, the include file label names are very similar to the equivalent hardware register list names with the following typical differences. * Address registers which have low word and high word components are generally listed as two word sized registers in the hardware register list, with each register name containing either a suffix or embedded "L" or "H" for low and high. The include file label for the same register will generally treat the whole register as a longword (32 bit) register, and therefore will not contain the "L" or "H" distinction. * Related sequential registers which are given individual names with number suffixes in the hardware register list, are generally referenced from a single base register definition in the include files. For example, the color registers in the hardware list (COLOR00, COLOR01, etc.) would be referenced from the "color" label defined in hardware/custom.i (color+0, color+2, etc.). * Examples of how to define the correct register offset can be found in the hw_examples.i file listed in Appendix I . Except as noted, 68000 assembly language examples have been assembled under the Innovatronics CAPE assembler V2.x, the HiSoft Devpac assembler V1.2, and the Lake Forest Logic ADAPT assembler 1.0. No substantial changes should be required to switch between assemblers. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0053.html.txt:1:2 Coprocessor Hardware / Putting Together a Copper Instruction List ]" border=0> The Copper instruction list contains all the register resetting done during the vertical blanking interval and the register modifications necessary for making mid-screen alterations. As you are planning what will happen during each display field, you may find it easier to think of each aspect of the display as a separate subsystem, such as playfields, sprites, audio, interrupts, and so on. Then you can build a separate list of things that must be done for each subsystem individually at each video beam position. When you have created all these intermediate lists of things to be done, you must merge them together into a single instruction list to be executed by the Copper once for each display frame. The alternative is to create this all-inclusive list directly, without the intermediate steps. For example, the bitplane pointers used in playfield displays and the sprite pointers must be rewritten during the vertical blanking interval so the data will be properly retrieved when the screen display starts again. This can be done with a Copper instruction list that does the following: WAIT until first line of the display MOVE data to bitplane pointer 1 MOVE data to bitplane pointer 2 MOVE data to sprite pointer 1, and so on. As another example, the sprite DMA channels that create movable objects can be reused multiple times during the same display field. You can change the size and shape of the reuses of a sprite; however, every multiple reuse normally uses the same set of colors during a full display frame. You can change sprite colors mid-screen with a Copper instruction list that waits until the last line of the first use of the sprite processor and changes the colors before the first line of the next use of the same sprite processor: WAIT for first line of display MOVE firstcolor1 to COLOR17 MOVE firstcolor2 to COLOR18 MOVE firstcolor3 to COLOR19 WAIT for last line +1 of sprite's first use MOVE secondcolor1 to COLOR17 MOVE secondcolor2 to COLOR18 MOVE secondcolor3 to COLOR19, and so on. As you create Copper instruction lists, note that the final list must be in the same order as that in which the video beam creates the display. The video beam traverses the screen from position (0,0) in the upper left hand corner of the screen to the end of the display (226,262) NTSC (or (226,312) PAL) in the lower right hand corner. The first 0 in (0,0) represents the x position. The second 0 represents the y position. For example, an instruction that does something at position (0,100) should come after an instruction that affects the display at position (0,60). Note that given the form of the WAIT instruction, you can sometimes get away with not sorting the list in strict video beam order. The WAIT instruction causes the Copper to wait until the value in the beam counter is equal to or greater than the value in the instruction. This means, for example, if you have instructions following each other like this: WAIT for position (64,64) MOVE data WAIT for position (60,60) MOVE data then the Copper will perform both moves, even though the instructions are out of sequence. The "greater than" specification prevents the Copper from locking up if the beam has already passed the specified position. A side effect is that the second MOVE below will be performed: WAIT for position (60,60) MOVE data WAIT for position (60,60) MOVE data At the time of the second WAIT in this sequence, the beam counters will be greater than the position shown in the instructions. Therefore, the second MOVE will also be performed. Note also that the above sequence of instructions could just as easily be WAIT for position (60,60) MOVE data MOVE data because multiple MOVE s can follow a single WAIT . Complete Sample Copper List [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node04B1.html.txt:1:audio.device/CMD_READ ]" border=0> NAME CMD_READ -- normal I/O entry point FUNCTION CMD_READ is a standard command for a single audio channel (io_Unit). If the allocation key (ioa_AllocKey) is correct, CMD_READ returns a pointer (io_Data) to the I/O block currently writing (CMD_WRITE) on the selected channel; otherwise, CMD_READ returns an error (ADIOERR_NOALLOCATION). If there is no write in progress, CMD_READ returns zero. CMD_READ is synchronous and only replies (mn_ReplyPort) if the quick bit (IOF_QUICK) is clear. INPUTS mn_ReplyPort- pointer to message port that receives I/O request after if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channel to read (bit 0 thru 3 corresponds to channel 0 thru 3), if more then one bit is set lowest bit number channel read io_Command - command number for CMD_READ io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channel successfully read (bit 0 thru 3 corresponds to channel 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel ioa_Data - pointer to I/O block for current write, zero if none is progress [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node01AC.html.txt:1:Hard_examples/hw_examples.i ]" border=0> ; ; hw_examples.i ; ; This appendix contains an include file that maps the hardware ; register names, given in Appendix A and Appendix B, to names that can ; be resolved by the standard include files. Use of these names in code ; sections of this manual places the emphasis on what the code is ; doing, rather than getting bogged down in include file names. ; ; All code examples in this manual reference the names given in this ; file. ; IFND HARDWARE_HW_EXAMPLES_I HARDWARE_HW_EXAMPLES_I SET 1 ** ** Filename: hardware/hw_examples.i ** $Release: 1.3 $ ** ** (C) Copyright 1985-1999 Amiga, Inc. ** All Rights Reserved ** ******************************************************************************* IFND HARDWARE_CUSTOM_I INCLUDE "hardware/custom.i" ENDC ******************************************************************************* * * This include file is designed to be used in conjunction with the hardware * manual examples. This file defines the register names based on the * hardware/custom.i definition file. There is no C-Language version of this * file. * ******************************************************************************* * * This instruction for the copper will cause it to wait forever since * the wait command described in it will never happen. * COPPER_HALT equ $FFFFFFFE * ******************************************************************************* * * This is the offset in the 680x0 address space to the custom chip registers * It is the same as _custom when linking with AMIGA.lib * CUSTOM equ $DFF000 * * Various control registers * DMACONR equ dmaconr ; Just capitalization... VPOSR equ vposr ; " " VHPOSR equ vhposr ; " " JOY0DAT equ joy0dat ; " " JOY1DAT equ joy1dat ; " " CLXDAT equ clxdat ; " " ADKCONR equ adkconr ; " " POT0DAT equ pot0dat ; " " POT1DAT equ pot1dat ; " " POTINP equ potinp ; " " SERDATR equ serdatr ; " " INTENAR equ intenar ; " " INTREQR equ intreqr ; " " REFPTR equ refptr ; " " VPOSW equ vposw ; " " VHPOSW equ vhposw ; " " SERDAT equ serdat ; " " SERPER equ serper ; " " POTGO equ potgo ; " " JOYTEST equ joytest ; " " STREQU equ strequ ; " " STRVBL equ strvbl ; " " STRHOR equ strhor ; " " STRLONG equ strlong ; " " DIWSTRT equ diwstrt ; " " DIWSTOP equ diwstop ; " " DDFSTRT equ ddfstrt ; " " DDFSTOP equ ddfstop ; " " DMACON equ dmacon ; " " INTENA equ intena ; " " INTREQ equ intreq ; " " * * Disk control registers * DSKBYTR equ dskbytr ; Just capitalization... DSKPT equ dskpt ; " " DSKPTH equ dskpt DSKPTL equ dskpt+$02 DSKLEN equ dsklen ; " " DSKDAT equ dskdat ; " " DSKSYNC equ dsksync ; " " * * Blitter registers * BLTCON0 equ bltcon0 ; Just capitalization... BLTCON1 equ bltcon1 ; " " BLTAFWM equ bltafwm ; " " BLTALWM equ bltalwm ; " " BLTCPT equ bltcpt ; " " BLTCPTH equ bltcpt BLTCPTL equ bltcpt+$02 BLTBPT equ bltbpt ; " " BLTBPTH equ bltbpt BLTBPTL equ bltbpt+$02 BLTAPT equ bltapt ; " " BLTAPTH equ bltapt BLTAPTL equ bltapt+$02 BLTDPT equ bltdpt ; " " BLTDPTH equ bltdpt BLTDPTL equ bltdpt+$02 BLTSIZE equ bltsize ; " " BLTCMOD equ bltcmod ; " " BLTBMOD equ bltbmod ; " " BLTAMOD equ bltamod ; " " BLTDMOD equ bltdmod ; " " BLTCDAT equ bltcdat ; " " BLTBDAT equ bltbdat ; " " BLTADAT equ bltadat ; " " BLTDDAT equ bltddat ; " " * * Copper control registers * COPCON equ copcon ; Just capitalization... COPINS equ copins ; " " COPJMP1 equ copjmp1 ; " " COPJMP2 equ copjmp2 ; " " COP1LC equ cop1lc ; " " COP1LCH equ cop1lc COP1LCL equ cop1lc+$02 COP2LC equ cop2lc ; " " COP2LCH equ cop2lc COP2LCL equ cop2lc+$02 * * * Audio channel registers * ADKCON equ adkcon ; Just capitalization... AUD0LC equ aud0 AUD0LCH equ aud0 AUD0LCL equ aud0+$02 AUD0LEN equ aud0+$04 AUD0PER equ aud0+$06 AUD0VOL equ aud0+$08 AUD0DAT equ aud0+$0A AUD1LC equ aud1 AUD1LCH equ aud1 AUD1LCL equ aud1+$02 AUD1LEN equ aud1+$04 AUD1PER equ aud1+$06 AUD1VOL equ aud1+$08 AUD1DAT equ aud1+$0A AUD2LC equ aud2 AUD2LCH equ aud2 AUD2LCL equ aud2+$02 AUD2LEN equ aud2+$04 AUD2PER equ aud2+$06 AUD2VOL equ aud2+$08 AUD2DAT equ aud2+$0A AUD3LC equ aud3 AUD3LCH equ aud3 AUD3LCL equ aud3+$02 AUD3LEN equ aud3+$04 AUD3PER equ aud3+$06 AUD3VOL equ aud3+$08 AUD3DAT equ aud3+$0A * * * The bitplane registers * BPL1PT equ bplpt+$00 BPL1PTH equ bplpt+$00 BPL1PTL equ bplpt+$02 BPL2PT equ bplpt+$04 BPL2PTH equ bplpt+$04 BPL2PTL equ bplpt+$06 BPL3PT equ bplpt+$08 BPL3PTH equ bplpt+$08 BPL3PTL equ bplpt+$0A BPL4PT equ bplpt+$0C BPL4PTH equ bplpt+$0C BPL4PTL equ bplpt+$0E BPL5PT equ bplpt+$10 BPL5PTH equ bplpt+$10 BPL5PTL equ bplpt+$12 BPL6PT equ bplpt+$14 BPL6PTH equ bplpt+$14 BPL6PTL equ bplpt+$16 BPLCON0 equ bplcon0 ; Just capitalization... BPLCON1 equ bplcon1 ; " " BPLCON2 equ bplcon2 ; " " BPL1MOD equ bpl1mod ; " " BPL2MOD equ bpl2mod ; " " DPL1DATA equ bpldat+$00 DPL2DATA equ bpldat+$02 DPL3DATA equ bpldat+$04 DPL4DATA equ bpldat+$06 DPL5DATA equ bpldat+$08 DPL6DATA equ bpldat+$0A * * * Sprite control registers * SPR0PT equ sprpt+$00 SPR0PTH equ SPR0PT+$00 SPR0PTL equ SPR0PT+$02 SPR1PT equ sprpt+$04 SPR1PTH equ SPR1PT+$00 SPR1PTL equ SPR1PT+$02 SPR2PT equ sprpt+$08 SPR2PTH equ SPR2PT+$00 SPR2PTL equ SPR2PT+$02 SPR3PT equ sprpt+$0C SPR3PTH equ SPR3PT+$00 SPR3PTL equ SPR3PT+$02 SPR4PT equ sprpt+$10 SPR4PTH equ SPR4PT+$00 SPR4PTL equ SPR4PT+$02 SPR5PT equ sprpt+$14 SPR5PTH equ SPR5PT+$00 SPR5PTL equ SPR5PT+$02 SPR6PT equ sprpt+$18 SPR6PTH equ SPR6PT+$00 SPR6PTL equ SPR6PT+$02 SPR7PT equ sprpt+$1C SPR7PTH equ SPR7PT+$00 SPR7PTL equ SPR7PT+$02 ; ; Note: SPRxDATB is defined as being +$06 from SPRxPOS. ; sd_datab should be defined as $06, however, in the 1.3 assembler ; include file hardware/custom.i it is incorrectly defined as $08. ; SPR0POS equ spr+$00 SPR0CTL equ SPR0POS+sd_ctl SPR0DATA equ SPR0POS+sd_dataa SPR0DATB equ SPR0POS+$06 ; should use sd_datab ... SPR1POS equ spr+$08 SPR1CTL equ SPR1POS+sd_ctl SPR1DATA equ SPR1POS+sd_dataa SPR1DATB equ SPR1POS+$06 ; should use sd_datab ... SPR2POS equ spr+$10 SPR2CTL equ SPR2POS+sd_ctl SPR2DATA equ SPR2POS+sd_dataa SPR2DATB equ SPR2POS+$06 ; should use sd_datab ... SPR3POS equ spr+$18 SPR3CTL equ SPR3POS+sd_ctl SPR3DATA equ SPR3POS+sd_dataa SPR3DATB equ SPR3POS+$06 ; should use sd_datab ... SPR4POS equ spr+$20 SPR4CTL equ SPR4POS+sd_ctl SPR4DATA equ SPR4POS+sd_dataa SPR4DATB equ SPR4POS+$06 ; should use sd_datab ... SPR5POS equ spr+$28 SPR5CTL equ SPR5POS+sd_ctl SPR5DATA equ SPR5POS+sd_dataa SPR5DATB equ SPR5POS+$06 ; should use sd_datab ... SPR6POS equ spr+$30 SPR6CTL equ SPR6POS+sd_ctl SPR6DATA equ SPR6POS+sd_dataa SPR6DATB equ SPR6POS+$06 ; should use sd_datab ... SPR7POS equ spr+$38 SPR7CTL equ SPR7POS+sd_ctl SPR7DATA equ SPR7POS+sd_dataa SPR7DATB equ SPR7POS+$06 ; should use sd_datab ... * * Color registers... * COLOR00 equ color+$00 COLOR01 equ color+$02 COLOR02 equ color+$04 COLOR03 equ color+$06 COLOR04 equ color+$08 COLOR05 equ color+$0A COLOR06 equ color+$0C COLOR07 equ color+$0E COLOR08 equ color+$10 COLOR09 equ color+$12 COLOR10 equ color+$14 COLOR11 equ color+$16 COLOR12 equ color+$18 COLOR13 equ color+$1A COLOR14 equ color+$1C COLOR15 equ color+$1E COLOR16 equ color+$20 COLOR17 equ color+$22 COLOR18 equ color+$24 COLOR19 equ color+$26 COLOR20 equ color+$28 COLOR21 equ color+$2A COLOR22 equ color+$2C COLOR23 equ color+$2E COLOR24 equ color+$30 COLOR25 equ color+$32 COLOR26 equ color+$34 COLOR27 equ color+$36 COLOR28 equ color+$38 COLOR29 equ color+$3A COLOR30 equ color+$3C COLOR31 equ color+$3E ******************************************************************************* ** ** ENDC ; HARDWARE_HW_EXAMPLES_I [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node05AA.html.txt:1:Text_Autodocs/narrator.doc ]" border=0> TABLE OF CONTENTS narrator.device/AbortIO narrator.device/OpenDevice narrator.device/CMD_FLUSH narrator.device/CMD_READ narrator.device/CMD_RESET narrator.device/CMD_START narrator.device/CMD_STOP narrator.device/CMD_WRITE narrator.device/CloseDevice narrator.device/AbortIO narrator.device/AbortIO NAME AbortIO - Abort an IO request SYNOPSIS AbortIO(IORequest) A1 FUNCTION Exec library call to abort a specified READ or WRITE request. The IORequest may be in the queue or currently active. If currently active, the request is immediately stopped and then removed. INPUTS Pointer to the IORequest block to be aborted. RESULTS io_Error field in the IORequest block set to #IOERR_ABORTED. SEE ALSO narrator.device/CloseDevice narrator.device/CloseDevice NAME CloseDevice - terminates access to the narrator device SYNOPSIS CloseDevice(IORequest) A1 FUNCTION Close invalidates the IO_UNIT and IO_DEVICE fields in the IORequest block, preventing subsequent IO until another OpenDevice. CloseDevice also reduces the open count. If the count goes to 0 and the expunge bit is set, the device is expunged. If the open count goes to zero and the delayed expunge bit is not set, CloseDevice sets the expunge bit. INPUTS A valid IORequest block with its io_Message structure, and io_Device and io_Unit fields properly initialized. These fields are initialized by OpenDevice. RESULTS CloseDevice invalidates the unit and device pointers in the IORequest block. SEE ALSO narrator.device/CMD_FLUSH narrator.device/CMD_FLUSH NAME CMD_FLUSH - Aborts all inprogress and queued requests SYNOPSIS Standard device command. FUNCTION Aborts all inprogress and queued speech requests. INPUTS Valid IORequest block with the io_Command field set to CMD_FLUSH. A valid IORequest block is one with its io_Message structure, and io_Device and io_Unit fields properly initialized. The easiest way to insure proper initialization is to make a copy of the IORequest block after a successful OpenDevice call. RESULTS io_Error in IORequest block set to 0 SEE ALSO Exec input/output documentation. narrator.device/CMD_Read narrator.device/CMD_Read NAME CMD_READ - Query the narrator device for mouth shape or other synchronization events. SYNOPSIS Standard device command. FUNCTION Currently, there are three events which the user can inquire about from the narrator device. These are: mouth shape changes, start of word, and start of syllable. Each read request returns information about any or all of these events as determined by the bits set in the sync field of the read IORequest block. In the case of mouth shape changes, each shape returned is guaranteed to be different from the previously returned shape to allow updating to be done only when necessary. Each read request is associated with a write request by information contained in the IORequest block used to open the device. Since the first field in the read IORequest block is a write IORequest structure, this association is easily made by copying the write IORequest block (after the OpenDevice call) into the voice field of the read IORequest block. If there is no write in progress or in the device input queue with the same pseudo unit number as the read request, the read will be returned to the user with an error. This is also how the user knows that the write request has finished and that s/he should not issue any more reads. Note that in this case the mouth shapes may not be different from previously returned values. INPUTS mouth_rb IORequest block with the voice field (a narrator_rb structure) copied from the associated write request with the following fields modified: io_Message - Pointer to message port for read request io_Command - CMD_READ io_Error - Clear before issuing first read width - 0 height - 0 RESULTS As long as the speech is in progress, each read returns the following information in the mouth_rb IORequest block. If mouth shape changes are requested the following fields are modified: width - Contains mouth width value in arbitrary units height - Contains mouth height value in arbitrary units shape - Compressed form of mouth shapes (internal use only) ****** NEW FOR V37 NARRATOR If word synchronization is requested: sync - Bit NDB_WORDSYNC is set If syllable synchronization is requested: sync - Bit NDB_SYLSYNC is set Note that any or all of the above fields can be set and it is the user's responsibility to check for all possibilities. SEE ALSO CMD_WRITE Exec input/output documentation. narrator.device/CMD_RESET narrator.device/CMD_RESET NAME CMD_RESET - Reset the device to a known state SYNOPSIS Standard device command. FUNCTION Resets the device as though it has just be initialized. Aborts all read/write requests whether active of enqueued. Restarts device if it has been stopped. INPUTS Valid IORequest block with the io_Command field set to CMD_RESET. A valid IORequest block is one with its io_Message structure, and io_Device and io_Unit fields properly initialized. The easiest way to insure proper initialization is to make a copy of the IORequest block after a successful OpenDevice call. RESULTS SEE ALSO Exec input/output documentation. narrator.device/CMD_START narrator.device/CMD_START NAME CMD_START - Restarts the device after a CMD_STOP command SYNOPSIS Standard device command. FUNCTION CMD_START restarts the currently active speech (if any) and allows queued requests to start. INPUTS Valid IORequest block with the io_Command field set to CMD_START A valid IORequest block is one with its io_Message structure, and io_Device and io_Unit fields properly initialized. The easiest way to insure proper initialization is to make a copy of the IORequest block after a successful OpenDevice call. RESULTS io_Error set to 0. SEE ALSO Exec input/output documentation. narrator.device/CMD_STOP narrator.device/CMD_STOP NAME CMD_STOP - Stops the device. SYNOPSIS Standard device command. FUNCTION CMD_STOP halts the currently active speech (if any) and prevents any queued requests from starting. INPUTS Valid IORequest block with the io_Command field set to CMD_STOP. A valid IORequest block is one with its io_Message structure, and io_Device and io_Unit fields properly initialized. The easiest way to insure proper initialization is to make a copy of the IORequest block after a successful OpenDevice call. RESULTS io_Error set to 0. SEE ALSO Exec input/output documentation. narrator.device/CMD_WRITE narrator.device/CMD_WRITE NAME CMD_WRITE - Send speech request to the narrator device SYNOPSIS Standard device command. FUNCTION Sends a phonetic string to the narrator device to be spoken and, optionally, is used to direct the narrator device to return mouth shape changes, and word and syllable sync events in response to read requests from the user. The phonetic string consists of ASCII characters representing the individual phonemes. Refer to the narrator device chapter of the libraries and devices volume of the ROM Kernel Manual for detailed information. INPUTS User IORequest block (struct narrator_rb as defined in .h file). The OpenDevice call will initialize the IORequest block to a "standard male" voice. If you want to change any parms, do so after the OpenDevice call and before the DoIO (or SendIO/WaitIO). For a complete description of the narrator_rb structure, see the narrator.h or .i include file. Note that the OpenDevice call does not initialize all the fields needed by the narrator device. The IORequest fields which must be set by the user before issuing the write request are: io_Command - Set to CMD_WRITE io_Data - Pointer to phonetic string io_Length - Length of phonetic string ch_masks - Array of audio channel selection masks (see audio device documentation for description of this field) nm_masks - Number of audio channel selection masks ****** NEW FOR V37 NARRATOR flags - The bit NDB_NEWIORB must be set in the flags field if any of the new features of the V37 narrator are used In addition to producing synthetic speech, the narrator device also provides features for synchronizing the speech to animation or other user defined events. There are three types of events that the user can request. They are mouth shape changes, start of new word, and start of new syllable. Mouth shape changes are requested by setting the mouths field of the IORequest block to a non-zero value. Word and syllable sync events are requested by setting the NDB_WORDSYNC and/or NDB_SYLSYNC bits in the flags field of the IORequest block. Note that word and syllable sync only work in V37 and later versions of the narrator device. RESULTS The narrator device range checks and performs other validity checks for all input parms. If any input is in error, the device sets the io_Error field of the IORequest block to an appropriate value (see include files for error codes). If everything is in order, the narrator device will produce the speech and clear the io_Error field. The io_Actual field is set to the length of the input string that was actually processed. If the return code indicates a phoneme error (ND_PhonErr), io_Actual is the NEGATIVE of the position in the input string where the error occured. SEE ALSO Read command. Audio device documentation. Exec input/output documentation. narrator.device/OpenDevice narrator.device/OpenDevice NAME OpenDevice - opens the narrator device. SYNOPSIS error = OpenDevice("narrator.device", unit, IORequest, flags); D0 A0 D0 A1 D1 FUNCTION The OpenDevice routine grants access to the narrator device. OpenDevice checks the unit number, and if non-zero, returns an error (ND_UnitErr). If this is the first time the driver has been opened, OpenDevice will attempt to open the audio device and allocate the driver's static buffers. If either of these operations fail, an error is returned. See the .h and .i include files for possible error return codes. Next, OpenDevice (done for all opens, not just the first one) initializes various fields in the user's IORequest block (see below). If users wish to use non-default values for these parms, the values must be set after the open is done. OpenDevice also assigns a pseudo unit number to the IORB for use in synchronizing read and write requests. See the read command for more details. Finally, OpenDevice stores the device node pointer in the IORequest block and clears the delayed expunge bit. ***** NEW FOR V37 NARRATOR ***** Several new fields in the IORequest block have been added for V37 narrator. These fields are initialized when the device is opened if the NDB_NEWIORB bit is set in the flags field of the user's IORequest block. Note that NDB_NEWIORB is set in the IORequest block, NOT in the "flags" input parm to the OpenDevice call. INPUTS device - "narrator.device" unit - 0 IORequest - Pointer to the user's IORequest block flags - 0 RESULTS The narrator device will initialize the IORequest block as follows (assume IORB points to the IOrequest block): IORB->rate = 150; /* Speaking rate in words/minute */ IORB->pitch = 110; /* Baseline pitch in Hertz */ IORB->mode = NATURALF0; /* Pitch (F0) mode */ IORB->sex = MALE; /* Sex of voice */ IORB->volume = 64 /* Volume, full on */ IORB->sampfreq = 22200 /* Audio sampling freq */ IORB->mouths = 0 /* Don't generate sync events */ and if the NDB_NEWIORB bit is set: IORB->F0enthusiasm = 0 /* F0 excursion factor */ IORB->F0perturb = 32 /* F0 perturbation (in 32nds) */ IORB->F1adj = 0 /* F1 adjustment in ±5% steps */ IORB->F2adj = 0 /* F2 adjustment in ±5% steps */ IORB->F3adj = 0 /* F3 adjustment in ±5% steps */ IORB->A1adj = 0 /* A1 adjustment in decibels */ IORB->A2adj = 0 /* A2 adjustment in decibels */ IORB->A3adj = 0 /* A3 adjustment in decibels */ IORB->articulate = 100 /* Transition time multiplier */ IORB->centralize = 0 /* Degree of vowel centralization */ IORB->centphon = "" /* Pointer to central ASCII phon */ IORB->AVbias = 0 /* AV bias */ IORB->AFbias = 0 /* AF bias */ IORB->priority = 100 /* Priority while speaking */ SEE ALSO The include files contain the complete IORequest block definition, default settings, and error return codes. Exec input/output documentation. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0285.html.txt:1:T,U,V,W,Z Index ]" border=0> TAS, 196 , 223 Trackball, --> Trackdisk, 9 TSRE, 259 UART, 255 UARTBRK, 257 VBSTOP, 298 VBSTRT, 298 VCR, 46 Vertical Blanking, 30 , 30 , 32 , 304 VGA, 304 VHPOSR, --> VHPOSW - with beam counter, 216 Video, --> Video Beam Position, 26 Video Input, 46 Video Port, 319 Volume, 139 VPOSR, --> VPOSW - with beam counter, 216 VSSTOP, 298 VSSTRT, 298 VSTART, 59 , 91 , 107 , 107 , 108 , 113 VSTOP, 59 , 78 , 91 , 107 , 108 , 113 VTOTAL, 298 , 304 WAIT, 19 , 20 Waveform, 4 Waveforms - audio, 134 WORDSYNC, 249 , 250 Zero Detection, 187 Zorro Expansion Bus, --> [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0048.html.txt:1:2 Coprocessor Hardware / About the Copper ]" border=0> The Copper is a general purpose coprocessor that resides in one of the Amiga's custom chips. It retrieves its instructions via direct memory access (DMA). The Copper can control nearly the entire graphics system, freeing the 680x0 to execute program logic; it can also directly affect the contents of most of the chip control registers. It is a very powerful tool for directing mid-screen modifications in graphics displays and for directing the register changes that must occur during the vertical blanking periods. Among other things, it can control register updates, reposition sprites, change the color palette, update the audio channels, and control the blitter. One of the features of the Copper is its ability to WAIT for a specific video beam position, then MOVE data into a system register. During the WAIT period, the Copper examines the contents of the video beam position counter directly. This means that while the Copper is waiting for the beam to reach a specific position, it does not use the memory bus at all. Therefore, the bus is freed for use by the other DMA channels or by the 680x0. When the WAIT condition has been satisfied, the Copper steals memory cycles from either the blitter or the 680x0 to move the specified data into the selected special-purpose register. The Copper is a two-cycle processor that requests the bus only during odd-numbered memory cycles. This prevents collision with audio, disk, refresh, sprites, and most low resolution display DMA access, all of which use only the even-numbered memory cycles. The Copper, therefore, needs priority over only the 680x0 and the blitter (the DMA channel that handles animation, line drawing, and polygon filling). As with all the other DMA channels in the Amiga system, the Copper can retrieve its instructions only from the chip RAM area of system memory. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0026.html.txt:1:A Register Summary / CLXDAT ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- CLXDAT 00E R D Collision data register (read and clear) This address reads (and clears) the collision detection register. The bit assignments are below. NOTE: Playfield 1 is all odd-numbered enabled bitplanes. Playfield 2 is all even-numbered enabled bitplanes BIT# COLLISIONS REGISTERED ----- -------------------------- 15 not used 14 Sprite 4 (or 5) to sprite 6 (or 7) 13 Sprite 2 (or 3) to sprite 6 (or 7) 12 Sprite 2 (or 3) to sprite 4 (or 5) 11 Sprite 0 (or 1) to sprite 6 (or 7) 10 Sprite 0 (or 1) to sprite 4 (or 5) 09 Sprite 0 (or 1) to sprite 2 (or 3) 08 Playfield 2 to sprite 6 (or 7) 07 Playfield 2 to sprite 4 (or 5) 06 Playfield 2 to sprite 2 (or 3) 05 Playfield 2 to sprite 0 (or 1) 04 Playfield 1 to sprite 6 (or 7) 03 Playfield 1 to sprite 4 (or 5) 02 Playfield 1 to sprite 2 (or 3) 01 Playfield 1 to sprite 0 (or 1) 00 Playfield 1 to playfield 2 [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node0557.html.txt:1:2.0 IncludeXREF: E ]" border=0> eac_Entries unsigned long int in struct ExAllControl +0x0000 dos/exall.h : *60 eac_LastKey unsigned long int in struct ExAllControl +0x0004 dos/exall.h : *61 eac_MatchFunc pointer to struct Hook in struct ExAllControl +0x000c dos/exall.h : *63 eac_MatchString pointer to unsigned char in struct ExAllControl +0x0008 dos/exall.h : *62 eb_Private01 unsigned char in struct ExpansionBase +0x0023 libraries/expansionbase.h : *50 eb_Private02 unsigned long int in struct ExpansionBase +0x0024 libraries/expansionbase.h : *51 eb_Private03 unsigned long int in struct ExpansionBase +0x0028 libraries/expansionbase.h : *52 eb_Private04 struct CurrentBinding(size 0x0010 bytes) in struct ExpansionBase +0x002c libraries/expansionbase.h : *53 eb_Private05 struct List(size 0x000e bytes) in struct ExpansionBase +0x003c libraries/expansionbase.h : *54 ec_BaseAddress unsigned char in struct ExpansionControl +0x0002 libraries/configregs.h : *74 ec_Interrupt unsigned char in struct ExpansionControl +0x0000 libraries/configregs.h : *72 ec_Reserved14 unsigned char in struct ExpansionControl +0x0004 libraries/configregs.h : *76 ec_Reserved15 unsigned char in struct ExpansionControl +0x0005 libraries/configregs.h : *77 ec_Reserved16 unsigned char in struct ExpansionControl +0x0006 libraries/configregs.h : *78 ec_Reserved17 unsigned char in struct ExpansionControl +0x0007 libraries/configregs.h : *79 ec_Reserved18 unsigned char in struct ExpansionControl +0x0008 libraries/configregs.h : *80 ec_Reserved19 unsigned char in struct ExpansionControl +0x0009 libraries/configregs.h : *81 ec_Reserved1a unsigned char in struct ExpansionControl +0x000a libraries/configregs.h : *82 ec_Reserved1b unsigned char in struct ExpansionControl +0x000b libraries/configregs.h : *83 ec_Reserved1c unsigned char in struct ExpansionControl +0x000c libraries/configregs.h : *84 ec_Reserved1d unsigned char in struct ExpansionControl +0x000d libraries/configregs.h : *85 ec_Reserved1e unsigned char in struct ExpansionControl +0x000e libraries/configregs.h : *86 ec_Reserved1f unsigned char in struct ExpansionControl +0x000f libraries/configregs.h : *87 ec_Shutup unsigned char in struct ExpansionControl +0x0003 libraries/configregs.h : *75 ec_Z3_HighBase unsigned char in struct ExpansionControl +0x0001 libraries/configregs.h : *73 ed_Comment pointer to unsigned char in struct ExAllData +0x0020 dos/exall.h : *46 ed_Days unsigned long int in struct ExAllData +0x0014 dos/exall.h : *43 ed_Mins unsigned long int in struct ExAllData +0x0018 dos/exall.h : *44 ed_Name pointer to unsigned char in struct ExAllData +0x0004 dos/exall.h : *39 ed_Next pointer to struct ExAllData in struct ExAllData +0x0000 dos/exall.h : *38 ed_Prot unsigned long int in struct ExAllData +0x0010 dos/exall.h : *42 ed_Size unsigned long int in struct ExAllData +0x000c dos/exall.h : *41 ed_Ticks unsigned long int in struct ExAllData +0x001c dos/exall.h : *45 ed_Type long int in struct ExAllData +0x0008 dos/exall.h : *40 er_Flags unsigned char in struct ExpansionRom +0x0002 libraries/configregs.h : *51 er_InitDiagVec unsigned short int in struct ExpansionRom +0x000a libraries/configregs.h : *55 er_Manufacturer unsigned short int in struct ExpansionRom +0x0004 libraries/configregs.h : *53 er_Product unsigned char in struct ExpansionRom +0x0001 libraries/configregs.h : *50 er_Reserved03 unsigned char in struct ExpansionRom +0x0003 libraries/configregs.h : *52 er_Reserved0c unsigned char in struct ExpansionRom +0x000c libraries/configregs.h : *56 er_Reserved0d unsigned char in struct ExpansionRom +0x000d libraries/configregs.h : *57 er_Reserved0e unsigned char in struct ExpansionRom +0x000e libraries/configregs.h : *58 er_Reserved0f unsigned char in struct ExpansionRom +0x000f libraries/configregs.h : *59 er_SerialNumber unsigned long int in struct ExpansionRom +0x0006 libraries/configregs.h : *54 er_Type unsigned char in struct ExpansionRom +0x0000 libraries/configregs.h : *49 es_Flags unsigned long int in struct EasyStruct +0x0004 intuition/intuition.h : *1253 es_GadgetFormat pointer to unsigned char in struct EasyStruct +0x0010 intuition/intuition.h : *1256 es_StructSize unsigned long int in struct EasyStruct +0x0000 intuition/intuition.h : *1252 es_TextFormat pointer to unsigned char in struct EasyStruct +0x000c intuition/intuition.h : *1255 es_Title pointer to unsigned char in struct EasyStruct +0x0008 intuition/intuition.h : *1254 estr_Nums pointer to long int in struct ErrorString +0x0000 dos/dosextens.h : *219 estr_Strings pointer to unsigned char in struct ErrorString +0x0004 dos/dosextens.h : *220 ev_hi unsigned long int in struct EClockVal +0x0000 devices/timer.h : *33 ev_lo unsigned long int in struct EClockVal +0x0004 devices/timer.h : *34 ex_CacheControl unsigned long int in struct ExecBase +0x023c exec/execbase.h : *137 ex_EClockFrequency unsigned long int in struct ExecBase +0x0238 exec/execbase.h : *136 ex_MMULock pointer to void in struct ExecBase +0x0258 exec/execbase.h : *144 ex_Pad0 unsigned short int in struct ExecBase +0x022e exec/execbase.h : *128 ex_PoolThreshold unsigned long int in struct ExecBase +0x0248 exec/execbase.h : *141 ex_PublicPool struct MinList(size 0x000c bytes) in struct ExecBase +0x024c exec/execbase.h : *142 ex_PuddleSize unsigned long int in struct ExecBase +0x0244 exec/execbase.h : *140 ex_RamLibPrivate pointer to void in struct ExecBase +0x0234 exec/execbase.h : *130 ex_Reserved array [12] of unsigned char in struct ExecBase +0x025c exec/execbase.h : *146 ex_Reserved0 unsigned long int in struct ExecBase +0x0230 exec/execbase.h : *129 ex_TaskID unsigned long int in struct ExecBase +0x0240 exec/execbase.h : *138 exp #define IEEEDPExp libraries/mathffp.h : *45 libraries/mathieeedp.h : *45 ext_size unsigned char in struct Preferences +0x00e7 intuition/preferences.h : *127 E #define ((float) 2.718281828459045) libraries/mathffp.h : *22 libraries/mathieeedp.h : 22 EBB_BADMEM #define 2 = 0x00000002 libraries/expansionbase.h : *72 EBB_CLOGGED #define 0 = 0x00000000 libraries/expansionbase.h : *68 EBB_DOSFLAG #define 3 = 0x00000003 libraries/expansionbase.h : *74 EBB_KICKBACK33 #define 4 = 0x00000004 libraries/expansionbase.h : *76 EBB_KICKBACK36 #define 5 = 0x00000005 libraries/expansionbase.h : *78 EBB_SHORTMEM #define 1 = 0x00000001 libraries/expansionbase.h : *70 EBB_SILENTSTART #define 6 = 0x00000006 libraries/expansionbase.h : *83 EBF_BADMEM #define (1 libraries/expansionbase.h : *73 EBF_CLOGGED #define (1 libraries/expansionbase.h : *69 EBF_DOSFLAG #define (1 libraries/expansionbase.h : *75 EBF_KICKBACK33 #define (1 libraries/expansionbase.h : *77 EBF_KICKBACK36 #define (1 libraries/expansionbase.h : *79 EBF_SHORTMEM #define (1 libraries/expansionbase.h : *71 EBF_SILENTSTART #define (1 libraries/expansionbase.h : *84 ECIB_INT2PEND #define 4 = 0x00000004 libraries/configregs.h : *175 ECIB_INT6PEND #define 5 = 0x00000005 libraries/configregs.h : *176 ECIB_INT7PEND #define 6 = 0x00000006 libraries/configregs.h : *177 ECIB_INTENA #define 1 = 0x00000001 libraries/configregs.h : *173 ECIB_INTERRUPTING #define 7 = 0x00000007 libraries/configregs.h : *178 ECIB_RESET #define 3 = 0x00000003 libraries/configregs.h : *174 ECIF_INT2PEND #define (1 libraries/configregs.h : *182 ECIF_INT6PEND #define (1 libraries/configregs.h : *183 ECIF_INT7PEND #define (1 libraries/configregs.h : *184 ECIF_INTENA #define (1 libraries/configregs.h : *180 ECIF_INTERRUPTING #define (1 libraries/configregs.h : *185 ECIF_RESET #define (1 libraries/configregs.h : *181 ECOFFSET macro (1 argument) libraries/configregs.h : *205 ECS_SPECIFIC #define graphics/view.h : *15 hardware/custom.h : 144 EC_MEMADDR macro (1 argument) libraries/configregs.h : *200 EClockVal structure tag size 0x0008 devices/timer.h : *32 ED_COMMENT #define 6 = 0x00000006 dos/exall.h : *31 ED_DATE #define 5 = 0x00000005 dos/exall.h : *30 ED_NAME #define 1 = 0x00000001 dos/exall.h : *26 ED_PROTECTION #define 4 = 0x00000004 dos/exall.h : *29 ED_SIZE #define 3 = 0x00000003 dos/exall.h : *28 ED_TYPE #define 2 = 0x00000002 dos/exall.h : *27 EE_BADMEM #define 44 = 0x0000002c libraries/expansionbase.h : *65 EE_LASTBOARD #define 40 = 0x00000028 libraries/expansionbase.h : *61 EE_NOBOARD #define 43 = 0x0000002b libraries/expansionbase.h : *64 EE_NOEXPANSION #define 41 = 0x00000029 libraries/expansionbase.h : *62 EE_NOMEMORY #define 42 = 0x0000002a libraries/expansionbase.h : *63 EE_OK #define 0 = 0x00000000 libraries/expansionbase.h : *60 EIGHT_LPI #define 0x200 = 0x00000200 intuition/preferences.h : *169 ELITE #define 0x400 = 0x00000400 intuition/preferences.h : *160 ENDGADGET #define GACT_ENDGADGET = 0x00000004 intuition/iobsolete.h : *71 EO_BADFORMAT #define (0x0009) = 0x00000009 intuition/sghooks.h : *81 EO_BIGCHANGE #define (0x000A) = 0x0000000a intuition/sghooks.h : *83 EO_CLEAR #define (0x000C) = 0x0000000c intuition/sghooks.h : *87 EO_DELBACKWARD #define (0x0002) = 0x00000002 intuition/sghooks.h : *67 EO_DELFORWARD #define (0x0003) = 0x00000003 intuition/sghooks.h : *69 EO_ENTER #define (0x0005) = 0x00000005 intuition/sghooks.h : *73 EO_INSERTCHAR #define (0x0008) = 0x00000008 intuition/sghooks.h : *79 EO_MOVECURSOR #define (0x0004) = 0x00000004 intuition/sghooks.h : *71 EO_NOOP #define (0x0001) = 0x00000001 intuition/sghooks.h : *65 EO_REPLACECHAR #define (0x0007) = 0x00000007 intuition/sghooks.h : *77 EO_RESET #define (0x0006) = 0x00000006 intuition/sghooks.h : *75 EO_SPECIAL #define (0x000D) = 0x0000000d intuition/sghooks.h : *89 EO_UNDO #define (0x000B) = 0x0000000b intuition/sghooks.h : *85 EPSON #define 0x07 = 0x00000007 intuition/preferences.h : *199 EPSON_JX_80 #define 0x08 = 0x00000008 intuition/preferences.h : *200 ERFB_EXTENDED #define 5 = 0x00000005 libraries/configregs.h : *160 ERFB_MEMSPACE #define 7 = 0x00000007 libraries/configregs.h : *154 ERFB_NOSHUTUP #define 6 = 0x00000006 libraries/configregs.h : *157 ERFB_ZORRO_III #define 4 = 0x00000004 libraries/configregs.h : *164 ERFF_EXTENDED #define (1 libraries/configregs.h : *159 ERFF_MEMSPACE #define (1 libraries/configregs.h : *153 ERFF_NOSHUTUP #define (1 libraries/configregs.h : *156 ERFF_ZORRO_III #define (1 libraries/configregs.h : *163 EROFFSET macro (1 argument) libraries/configregs.h : *203 ERR10_001 #define (ERRC_MSG+1) = 0x00000001 rexx/errors.h : *16 ERR10_002 #define (ERRC_MSG+2) = 0x00000002 rexx/errors.h : *17 ERR10_003 #define (ERRC_MSG+3) = 0x00000003 rexx/errors.h : *18 ERR10_004 #define (ERRC_MSG+4) = 0x00000004 rexx/errors.h : *19 ERR10_005 #define (ERRC_MSG+5) = 0x00000005 rexx/errors.h : *20 ERR10_006 #define (ERRC_MSG+6) = 0x00000006 rexx/errors.h : *21 ERR10_007 #define (ERRC_MSG+7) = 0x00000007 rexx/errors.h : *22 ERR10_008 #define (ERRC_MSG+8) = 0x00000008 rexx/errors.h : *23 ERR10_009 #define (ERRC_MSG+9) = 0x00000009 rexx/errors.h : *24 ERR10_010 #define (ERRC_MSG+10) = 0x0000000a rexx/errors.h : *26 ERR10_011 #define (ERRC_MSG+11) = 0x0000000b rexx/errors.h : *27 ERR10_012 #define (ERRC_MSG+12) = 0x0000000c rexx/errors.h : *28 ERR10_013 #define (ERRC_MSG+13) = 0x0000000d rexx/errors.h : *29 ERR10_014 #define (ERRC_MSG+14) = 0x0000000e rexx/errors.h : *30 ERR10_015 #define (ERRC_MSG+15) = 0x0000000f rexx/errors.h : *31 ERR10_016 #define (ERRC_MSG+16) = 0x00000010 rexx/errors.h : *32 ERR10_017 #define (ERRC_MSG+17) = 0x00000011 rexx/errors.h : *33 ERR10_018 #define (ERRC_MSG+18) = 0x00000012 rexx/errors.h : *34 ERR10_019 #define (ERRC_MSG+19) = 0x00000013 rexx/errors.h : *35 ERR10_020 #define (ERRC_MSG+20) = 0x00000014 rexx/errors.h : *37 ERR10_021 #define (ERRC_MSG+21) = 0x00000015 rexx/errors.h : *38 ERR10_022 #define (ERRC_MSG+22) = 0x00000016 rexx/errors.h : *39 ERR10_023 #define (ERRC_MSG+23) = 0x00000017 rexx/errors.h : *40 ERR10_024 #define (ERRC_MSG+24) = 0x00000018 rexx/errors.h : *41 ERR10_025 #define (ERRC_MSG+25) = 0x00000019 rexx/errors.h : *42 ERR10_026 #define (ERRC_MSG+26) = 0x0000001a rexx/errors.h : *43 ERR10_027 #define (ERRC_MSG+27) = 0x0000001b rexx/errors.h : *44 ERR10_028 #define (ERRC_MSG+28) = 0x0000001c rexx/errors.h : *45 ERR10_029 #define (ERRC_MSG+29) = 0x0000001d rexx/errors.h : *46 ERR10_030 #define (ERRC_MSG+30) = 0x0000001e rexx/errors.h : *48 ERR10_031 #define (ERRC_MSG+31) = 0x0000001f rexx/errors.h : *49 ERR10_032 #define (ERRC_MSG+32) = 0x00000020 rexx/errors.h : *50 ERR10_033 #define (ERRC_MSG+33) = 0x00000021 rexx/errors.h : *51 ERR10_034 #define (ERRC_MSG+34) = 0x00000022 rexx/errors.h : *52 ERR10_035 #define (ERRC_MSG+35) = 0x00000023 rexx/errors.h : *53 ERR10_036 #define (ERRC_MSG+36) = 0x00000024 rexx/errors.h : *54 ERR10_037 #define (ERRC_MSG+37) = 0x00000025 rexx/errors.h : *55 ERR10_038 #define (ERRC_MSG+38) = 0x00000026 rexx/errors.h : *56 ERR10_039 #define (ERRC_MSG+39) = 0x00000027 rexx/errors.h : *57 ERR10_040 #define (ERRC_MSG+40) = 0x00000028 rexx/errors.h : *59 ERR10_041 #define (ERRC_MSG+41) = 0x00000029 rexx/errors.h : *60 ERR10_042 #define (ERRC_MSG+42) = 0x0000002a rexx/errors.h : *61 ERR10_043 #define (ERRC_MSG+43) = 0x0000002b rexx/errors.h : *62 ERR10_044 #define (ERRC_MSG+44) = 0x0000002c rexx/errors.h : *63 ERR10_045 #define (ERRC_MSG+45) = 0x0000002d rexx/errors.h : *64 ERR10_046 #define (ERRC_MSG+46) = 0x0000002e rexx/errors.h : *65 ERR10_047 #define (ERRC_MSG+47) = 0x0000002f rexx/errors.h : *66 ERR10_048 #define (ERRC_MSG+48) = 0x00000030 rexx/errors.h : *67 ERRC_MSG #define 0 = 0x00000000 rexx/errors.h : *15 ERROR_ACTION_NOT_KNOWN #define 209 = 0x000000d1 dos/dos.h : *165 ERROR_BAD_HUNK #define 235 = 0x000000eb dos/dos.h : *187 ERROR_BAD_NUMBER #define 115 = 0x00000073 dos/dos.h : *150 ERROR_BAD_STREAM_NAME #define 206 = 0x000000ce dos/dos.h : *163 ERROR_BAD_TEMPLATE #define 114 = 0x00000072 dos/dos.h : *149 ERROR_BREAK #define 304 = 0x00000130 dos/dosasl.h : *149 ERROR_BUFFER_OVERFLOW #define 303 = 0x0000012f dos/dosasl.h : *148 ERROR_COMMENT_TOO_BIG #define 220 = 0x000000dc dos/dos.h : *176 ERROR_DELETE_PROTECTED #define 222 = 0x000000de dos/dos.h : *178 ERROR_DEVICE_NOT_MOUNTED #define 218 = 0x000000da dos/dos.h : *174 ERROR_DIRECTORY_NOT_EMPTY #define 216 = 0x000000d8 dos/dos.h : *172 ERROR_DIR_NOT_FOUND #define 204 = 0x000000cc dos/dos.h : *161 ERROR_DISK_FULL #define 221 = 0x000000dd dos/dos.h : *177 ERROR_DISK_NOT_VALIDATED #define 213 = 0x000000d5 dos/dos.h : *169 ERROR_DISK_WRITE_PROTECTED #define 214 = 0x000000d6 dos/dos.h : *170 ERROR_FILE_NOT_OBJECT #define 121 = 0x00000079 dos/dos.h : *156 ERROR_INVALID_COMPONENT_NAME #define 210 = 0x000000d2 dos/dos.h : *166 ERROR_INVALID_LOCK #define 211 = 0x000000d3 dos/dos.h : *167 ERROR_INVALID_RESIDENT_LIBRARY #define 122 = 0x0000007a dos/dos.h : *157 ERROR_IS_SOFT_LINK #define 233 = 0x000000e9 dos/dos.h : *185 ERROR_KEY_NEEDS_ARG #define 117 = 0x00000075 dos/dos.h : *152 ERROR_LINE_TOO_LONG #define 120 = 0x00000078 dos/dos.h : *155 ERROR_LOCK_COLLISION #define 241 = 0x000000f1 dos/dos.h : *190 ERROR_LOCK_TIMEOUT #define 242 = 0x000000f2 dos/dos.h : *191 ERROR_NOT_A_DOS_DISK #define 225 = 0x000000e1 dos/dos.h : *181 ERROR_NOT_EXECUTABLE #define 305 = 0x00000131 dos/dosasl.h : *150 ERROR_NOT_IMPLEMENTED #define 236 = 0x000000ec dos/dos.h : *188 ERROR_NO_DEFAULT_DIR #define 201 = 0x000000c9 dos/dos.h : *158 ERROR_NO_DISK #define 226 = 0x000000e2 dos/dos.h : *182 ERROR_NO_FREE_STORE #define 103 = 0x00000067 dos/dos.h : *147 ERROR_NO_MORE_ENTRIES #define 232 = 0x000000e8 dos/dos.h : *183 ERROR_OBJECT_EXISTS #define 203 = 0x000000cb dos/dos.h : *160 ERROR_OBJECT_IN_USE #define 202 = 0x000000ca dos/dos.h : *159 ERROR_OBJECT_LINKED #define 234 = 0x000000ea dos/dos.h : *186 ERROR_OBJECT_NOT_FOUND #define 205 = 0x000000cd dos/dos.h : *162 ERROR_OBJECT_TOO_LARGE #define 207 = 0x000000cf dos/dos.h : *164 ERROR_OBJECT_WRONG_TYPE #define 212 = 0x000000d4 dos/dos.h : *168 ERROR_READ_PROTECTED #define 224 = 0x000000e0 dos/dos.h : *180 ERROR_RECORD_NOT_LOCKED #define 240 = 0x000000f0 dos/dos.h : *189 ERROR_RENAME_ACROSS_DEVICES #define 215 = 0x000000d7 dos/dos.h : *171 ERROR_REQUIRED_ARG_MISSING #define 116 = 0x00000074 dos/dos.h : *151 ERROR_SEEK_ERROR #define 219 = 0x000000db dos/dos.h : *175 ERROR_TASK_TABLE_FULL #define 105 = 0x00000069 dos/dos.h : *148 ERROR_TOO_MANY_ARGS #define 118 = 0x00000076 dos/dos.h : *153 ERROR_TOO_MANY_LEVELS #define 217 = 0x000000d9 dos/dos.h : *173 ERROR_UNLOCK_ERROR #define 243 = 0x000000f3 dos/dos.h : *192 ERROR_UNMATCHED_QUOTES #define 119 = 0x00000077 dos/dos.h : *154 ERROR_WRITE_PROTECTED #define 223 = 0x000000df dos/dos.h : *179 ERTB_CHAINEDCONFIG #define 3 = 0x00000003 libraries/configregs.h : *138 ERTB_DIAGVALID #define 4 = 0x00000004 libraries/configregs.h : *137 ERTB_MEMLIST #define 5 = 0x00000005 libraries/configregs.h : *136 ERTF_CHAINEDCONFIG #define (1 libraries/configregs.h : *142 ERTF_DIAGVALID #define (1 libraries/configregs.h : *141 ERTF_MEMLIST #define (1 libraries/configregs.h : *140 ERT_MEMBIT #define 0 = 0x00000000 libraries/configregs.h : *146 ERT_MEMMASK #define 0x07 ;Bits 2-0 libraries/configregs.h : *145 ERT_MEMNEEDED macro (1 argument) libraries/configregs.h : *191 ERT_MEMSIZE #define 3 = 0x00000003 libraries/configregs.h : *147 ERT_NEWBOARD #define 0xc0 = 0x000000c0 libraries/configregs.h : *131 ERT_SLOTSNEEDED macro (1 argument) libraries/configregs.h : *195 ERT_TYPEBIT #define 6 = 0x00000006 libraries/configregs.h : *129 ERT_TYPEMASK #define 0xc0 ;Bits 7-6 libraries/configregs.h : *128 ERT_TYPESIZE #define 2 = 0x00000002 libraries/configregs.h : *130 ERT_Z3_SSBIT #define 0 = 0x00000000 libraries/configregs.h : *167 ERT_Z3_SSMASK #define 0x0F = 0x0000000f libraries/configregs.h : *166 ERT_Z3_SSSIZE #define 4 = 0x00000004 libraries/configregs.h : *168 ERT_ZORROII #define ERT_NEWBOARD = 0x000000c0 libraries/configregs.h : *132 ERT_ZORROIII #define 0x80 = 0x00000080 libraries/configregs.h : *133 ETD_CLEAR #define (CMD_CLEAR|TDF_EXTCOM) = 0x00008005 devices/trackdisk.h : *109 ETD_FORMAT #define (TD_FORMAT|TDF_EXTCOM) = 0x0000800b devices/trackdisk.h : *107 ETD_MOTOR #define (TD_MOTOR|TDF_EXTCOM) = 0x00008009 devices/trackdisk.h : *105 ETD_RAWREAD #define (TD_RAWREAD|TDF_EXTCOM) = 0x00008010 devices/trackdisk.h : *110 ETD_RAWWRITE #define (TD_RAWWRITE|TDF_EXTCOM) = 0x00008011 devices/trackdisk.h : *111 ETD_READ #define (CMD_READ|TDF_EXTCOM) = 0x00008002 devices/trackdisk.h : *104 ETD_SEEK #define (TD_SEEK|TDF_EXTCOM) = 0x0000800a devices/trackdisk.h : *106 ETD_UPDATE #define (CMD_UPDATE|TDF_EXTCOM) = 0x00008004 devices/trackdisk.h : *108 ETD_WRITE #define (CMD_WRITE|TDF_EXTCOM) = 0x00008003 devices/trackdisk.h : *103 EVENTMAX #define 10 = 0x0000000a intuition/intuitionbase.h : *39 EXAMINE_BIT #define 2 = 0x00000002 dos/dosasl.h : *140 EXCLUSIVE_LOCK #define -1 = 0xffffffff dos/dos.h : *51 EXEC_ALERTS_H #define exec/alerts.h : *2, 1 EXEC_DEVICES_H #define exec/devices.h : *2, 1 devices/trackdisk.h : 22 EXEC_ERRORS_H #define exec/errors.h : *2, 1 EXEC_EXECBASE_H #define exec/execbase.h : *2, 1 EXEC_EXEC_H #define exec/exec.h : *2 EXEC_INITIALIZERS_H #define exec/initializers.h : *2, 1 EXEC_INTERRUPTS_H #define exec/interrupts.h : *2, 1 exec/execbase.h : 19 graphics/gfxbase.h : 21 intuition/intuitionbase.h : 28 resources/disk.h : 27 EXEC_IO_H #define exec/io.h : *2, 1(2) devices/audio.h : 15 devices/console.h : 19 devices/gameport.h : 19 devices/input.h : 15 devices/keyboard.h : 15 devices/narrator.h : 17 devices/parallel.h : 15 devices/serial.h : 15 devices/trackdisk.h : 18 EXEC_LIBRARIES_H #define exec/libraries.h : *2, 1(2) exec/execbase.h : 23 devices/prtbase.h : 27 dos/dosextens.h : 21 dos/dosasl.h : 17 graphics/gfxbase.h : 18 intuition/intuitionbase.h : 19 libraries/asl.h : 24 libraries/expansionbase.h : 19 libraries/mathlibrary.h : 17 resources/disk.h : 31 resources/misc.h : 19 rexx/storage.h : 31 EXEC_LISTS_H #define exec/lists.h : *2, 1(2) exec/tasks.h : 19 exec/interrupts.h : 19 exec/semaphores.h : 19 exec/execbase.h : 15 devices/clipboard.h : 21 devices/keymap.h : 19 devices/printer.h : 23 devices/prtbase.h : 21 graphics/layers.h : 15 dos/dosasl.h : 21 graphics/gfxbase.h : 15 libraries/asl.h : 20 libraries/diskfont.h : 21 libraries/iffparse.h : 19 resources/disk.h : 19 resources/filesysres.h : 18 rexx/storage.h : 23 workbench/workbench.h : 23 EXEC_MEMORY_H #define exec/memory.h : *2, 1 EXEC_NODES_H #define exec/nodes.h : *2, 1(2) exec/ports.h : 15 exec/lists.h : 15 exec/tasks.h : 15 exec/memory.h : 15 exec/interrupts.h : 15 exec/semaphores.h : 15 devices/clipboard.h : 18 devices/keymap.h : 16 devices/printer.h : 19 devices/prtbase.h : 18 utility/hooks.h : 19 graphics/gfxnodes.h : 15 dos/rdargs.h : 21 dos/var.h : 18 graphics/graphint.h : 15 libraries/configvars.h : 18 libraries/diskfont.h : 18 libraries/mathresource.h : 17 resources/filesysres.h : 15 rexx/storage.h : 19 workbench/workbench.h : 19 EXEC_PORTS_H #define exec/ports.h : *2, 1(2) exec/semaphores.h : 23 exec/io.h : 15 devices/clipboard.h : 24 devices/conunit.h : 19 devices/printer.h : 27 devices/prtbase.h : 24 dos/dosextens.h : 18 graphics/text.h : 15 intuition/intuition.h : 43 dos/filehandler.h : 15 dos/notify.h : 21 workbench/startup.h : 19 libraries/iffparse.h : 22 resources/disk.h : 23 rexx/storage.h : 27 EXEC_RESIDENT_H #define exec/resident.h : *2, 1 EXEC_SEMAPHORES_H #define exec/semaphores.h : *2, 1 dos/dosextens.h : 24 graphics/clip.h : 22 graphics/monitor.h : 15 graphics/layers.h : 19 libraries/expansionbase.h : 23 EXEC_TASKS_H #define exec/tasks.h : *2, 1(2) exec/semaphores.h : 27 exec/execbase.h : 27 devices/prtbase.h : 30 dos/dosextens.h : 15 dos/notify.h : 25 workbench/workbench.h : 27 EXEC_TYPES_H #define exec/types.h : *2 exec/resident.h : 15 devices/prtgfx.h : 15 devices/scsidisk.h : 16 devices/bootblock.h : 15 devices/clipboard.h : 15 devices/console.h : 15 devices/conunit.h : 15 devices/gameport.h : 15 devices/hardblocks.h : 15 devices/printer.h : 15 devices/prtbase.h : 15 dos/dos.h : 15 intuition/intuition.h : 15 graphics/gfx.h : 15 graphics/clip.h : 15 utility/hooks.h : 15 graphics/view.h : 17 graphics/copper.h : 15 hardware/custom.h : 15 graphics/rastport.h : 15 utility/tagitem.h : 15 intuition/screens.h : 15 intuition/preferences.h : 15 dos/exall.h : 17 dos/notify.h : 17 dos/rdargs.h : 17 graphics/displayinfo.h : 15 graphics/gels.h : 15 graphics/gfxmacros.h : 15 graphics/regions.h : 15 graphics/scale.h : 15 graphics/sprite.h : 15 graphics/videocontrol.h : 15 hardware/cia.h : 16 intuition/cghooks.h : 15 intuition/gadgetclass.h : 15 intuition/intuitionbase.h : 15 intuition/sghooks.h : 15 libraries/asl.h : 16 workbench/startup.h : 15 libraries/commodities.h : 16 libraries/configregs.h : 16 libraries/configvars.h : 14 libraries/diskfont.h : 15 libraries/expansionbase.h : 15 libraries/gadtools.h : 17 libraries/iffparse.h : 16 resources/disk.h : 15 resources/misc.h : 15 rexx/storage.h : 15 workbench/workbench.h : 15 EXPANSIONNAME #define "expansion.library" libraries/expansion.h : *15 EXTENDED_MODE #define 0x1000 = 0x00001000 graphics/view.h : *98 EXTEND_VSTRUCT #define 0x1000 = 0x00001000 graphics/view.h : *86 EXTRAHALFBRITELACE_KEY #define 0x00000084 = 0x00000084 graphics/displayinfo.h : *176 EXTRAHALFBRITE_KEY #define 0x00000080 = 0x00000080 graphics/displayinfo.h : *175 EXTRA_HALFBRITE #define 0x0080 = 0x00000080 graphics/view.h : *94 EXT_ABS #define 2 = 0x00000002 dos/doshunks.h : *43 EXT_COMMON #define 130 = 0x00000082 dos/doshunks.h : *46 EXT_DEF #define 1 = 0x00000001 dos/doshunks.h : *42 EXT_DEXT16 #define 134 = 0x00000086 dos/doshunks.h : *50 EXT_DEXT32 #define 133 = 0x00000085 dos/doshunks.h : *49 EXT_DEXT8 #define 135 = 0x00000087 dos/doshunks.h : *51 EXT_REF16 #define 131 = 0x00000083 dos/doshunks.h : *47 EXT_REF32 #define 129 = 0x00000081 dos/doshunks.h : *45 EXT_REF8 #define 132 = 0x00000084 dos/doshunks.h : *48 EXT_RES #define 3 = 0x00000003 dos/doshunks.h : *44 EXT_SYMB #define 0 = 0x00000000 dos/doshunks.h : *41 EZ3_CONFIGAREA #define 0x40000000 = 0x40000000 libraries/configregs.h : *119 EZ3_CONFIGAREAEND #define 0x7FFFFFFF = 0x7fffffff libraries/configregs.h : *120 EZ3_EXPANSIONBASE #define 0xff000000 = 0xff000000 libraries/configregs.h : *110 EZ3_SIZEGRANULARITY #define 0x00080000 = 0x00080000 libraries/configregs.h : *121 E_EXPANSIONBASE #define 0x00e80000 = 0x00e80000 libraries/configregs.h : *109 E_EXPANSIONSIZE #define 0x00080000 = 0x00080000 libraries/configregs.h : *112 E_EXPANSIONSLOTS #define 8 = 0x00000008 libraries/configregs.h : *113 E_MEMORYBASE #define 0x00200000 = 0x00200000 libraries/configregs.h : *115 E_MEMORYSIZE #define 0x00800000 = 0x00800000 libraries/configregs.h : *116 E_MEMORYSLOTS #define 128 = 0x00000080 libraries/configregs.h : *117 E_SLOTMASK #define 0xffff = 0x0000ffff libraries/configregs.h : *103 E_SLOTSHIFT #define 16 = 0x00000010 libraries/configregs.h : *104 E_SLOTSIZE #define 0x10000 = 0x00010000 libraries/configregs.h : *102 EasyStruct structure tag size 0x0014 intuition/intuition.h : *1251 EditHook pointer to struct Hook in struct StringExtend +0x000c intuition/sghooks.h : *27 EditOp unsigned short int in struct SGWork +0x002a intuition/sghooks.h : *50 Elapsed unsigned short int in struct ExecBase +0x0122 exec/execbase.h : *68 EnableCLI short int in struct Preferences +0x007c intuition/preferences.h : *80 ErrorString structure tag size 0x0008 dos/dosextens.h : *218, 235 ExAllControl structure tag size 0x0010 dos/exall.h : *59 ExAllData structure tag size 0x0024 dos/exall.h : *37, 38 ExecBase structure tag size 0x0268 exec/execbase.h : *36 ExecBase pointer to unsigned long int in struct GfxBase +0x01a2 graphics/gfxbase.h : *92 ExecMessage struct Message(size 0x0014 bytes) in struct IntuiMessage +0x0000 intuition/intuition.h : *679 ExpansionBase structure tag size 0x0058 libraries/expansionbase.h : *46 ExpansionControl structure tag size 0x0010 libraries/configregs.h : *71 ExpansionRom structure tag size 0x0010 libraries/configregs.h : *48 libraries/configvars.h : 36 ExtData pointer to unsigned char in struct Window +0x0074 intuition/intuition.h : *883 ExtData pointer to unsigned char in struct Screen +0x0152 intuition/screens.h : *147 ExtNewScreen structure tag size 0x0024 intuition/screens.h : *346 ExtNewWindow structure tag size 0x0034 intuition/intuition.h : *1044 ExtendedModes unsigned char in struct ViewPort +0x0023 graphics/view.h : *54 ExtendedNode structure tag size 0x0018 graphics/gfxnodes.h : *19 graphics/monitor.h : 29, 144 graphics/view.h : 72, 81 Extension pointer to struct StringExtend in struct StringInfo +0x0018 intuition/intuition.h : *546 Extension pointer to struct TagItem in struct ExtNewWindow +0x0030 intuition/intuition.h : *1082 Extension pointer to struct TagItem in struct ExtNewScreen +0x0020 intuition/screens.h : *357 [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0025.html.txt:1:A Register Summary / CLXCON ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- CLXCON 098 W D Collision control This register controls which bitplanes are included (enabled) in collision detection and their required state if included. It also controls the individual inclusion of odd-numbered sprites in the collision detection by logically OR-ing them with their corresponding even-numbered sprite. BIT# FUNCTION DESCRIPTION ---- -------- ------------------------------ 15 ENSP7 Enable sprite 7 (ORed with sprite 6) 14 ENSP5 Enable sprite 5 (ORed with sprite 4) 13 ENSP3 Enable sprite 3 (ORed with sprite 2) 12 ENSP1 Enable sprite 1 (ORed with sprite 0) 11 ENBP6 Enable bitplane 6 (match required for collision) 10 ENBP5 Enable bitplane 5 (match required for collision) 09 ENBP4 Enable bitplane 4 (match required for collision) 08 ENBP3 Enable bitplane 3 (match required for collision) 07 ENBP2 Enable bitplane 2 (match required for collision) 06 ENBP1 Enable bitplane 1 (match required for collision) 05 MVBP6 Match value for bitplane 6 collision 04 MVBP5 Match value for bitplane 5 collision 03 MVBP4 Match value for bitplane 4 collision 02 MVBP3 Match value for bitplane 3 collision 01 MVBP2 Match value for bitplane 2 collision 00 MVBP1 Match value for bitplane 1 collision NOTE: Disabled bitplanes cannot prevent collisions. Therefore if all bitplanes are disabled, collisions will be continuous, regardless of the match values. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node02DE.html.txt:1:Hard_examples/clearmem.asm #marker1 { color: red } #marker1::after { vertical-align: super; font-size: 0.8em; content: "[1]" } .footnote { font-family: monospace } ]" border=0> ; ; clearmem.asm ; ; Blitter example---memory clear (link with amiga.lib) ; include 'exec/types.i' include 'hardware/custom.i' include 'hardware/dmabits.i' include 'hardware/blit.i' include 'hardware/hw_examples.i" xref _custom ; ; Wait for previous blit to complete. ; waitblit: btst.b #DMAB_BLTDONE-8,DMACONR(a1) waitblit2: btst.b #DMAB_BLTDONE-8,DMACONR(a1) bne waitblit2 rts ; ; This routine uses a side effect in the blitter. When each ; of the blits is finished, the pointer in the blitter is pointing ; to the next word to be blitted. ; ; When this routine returns, the last blit is started and might ; not be finished, so be sure to call waitblit above before ; assuming the data is clear. ; ; a0 = pointer to first word to clear ; d0 = number of bytes to clear (must be even) ; xdef clearmem clearmem: lea _custom,a1 ; Get pointer to chip registers bsr waitblit ; Make sure previous blit is done move.l a0,BLTDPT(a1) ; Set up the D pointer to the region to clear clr.w BLTDMOD(a1) ; Clear the D modulo (don't skip no bytes) asr.l #1,d0 ; Get number of words from number of bytes clr.w BLTCON1(a1) ; No special modes move.w #DEST,BLTCON0(a1) ; only enable destination ; ; First we deal with the smaller blits ; moveq #$3f,d1 ; Mask out mod 64 words and.w d0,d1 beq dorest ; none? good, do one blit sub.l d1,d0 ; otherwise remove remainder or.l #$40,d1 ; set the height to 1, width to n move.w d1,BLTSIZE(a1) ; trigger the blit ; ; Here we do the rest of the words, as chunks of 128k ; dorest: move.w #$ffc0,d1 ; look at some more upper bits and.w d0,d1 ; extract 10 more bits beq dorest2 ; any to do? sub.l d1,d0 ; pull of the ones we're doing here bsr waitblit ; wait for prev blit to complete move.w d0 ,BLTSIZE(a1) ; do another blit dorest2: swap d0 ; more? beq done ; nope. clr.w d1 ; do a 1024x64 word blit (128K) keepon: bsr waitblit ; finish up this blit move.w d1,BLTSIZE(a1) ; and again, blit subq.w #1,d0 ; still more? bne keepon ; keep on going. done: rts ; finished. Blit still in progress. end [1]: Roy Schneider says (in March 2019): I found a bug in the Blitter based memory clear function [...] This must be 'd1'. Othwerwise you overwrite memory. [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node04D5.html.txt:1:serial.device/SDCMD_BREAK ]" border=0> NAME Break -- send a break signal over the serial line FUNCTION This command sends a break signal (serial line held low for an extended period) out the serial port. For the built-in port, This is accomplished by setting the UARTBRK bit of regisrer ADKCON. After a duration (user specifiable via setparams, default 250000 microseconds) the bit is reset and the signal discontinued. If the QUEUEDBRK bit of io_SerFlags is set in the io_Request block, the request is placed at the back of the write-request queue and executed in turn. If the QUEUEDBRK bit is not set, the break is started immediately, control returns to the caller, and the timer discontinues the signal after the duration is completed. Be aware that calling BREAK may affect other commands such as ABORT, FLUSH, STOP, START, etc... IO REQUEST io_Message mn_ReplyPort initialized io_Device set by OpenDevice io_Unit set by OpenDevice io_Command SDCMD_BREAK io_Flags set/reset IO_QUICK per above description RESULTS Error -- if the Break succeded, then Error will be null. If the Break failed, then the Error will be non-zero. [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node055F.html.txt:1:2.0 IncludeXREF: M ]" border=0> mc_Bytes unsigned long int in struct MemChunk +0x0004 exec/memory.h : *24 mc_Next pointer to struct MemChunk in struct MemChunk +0x0000 exec/memory.h : *23 mday unsigned short int in struct ClockData +0x0006 utility/date.h : *23 me_Addr #define me_Un.meu_Addr exec/memory.h : *52 me_Length unsigned long int in struct MemEntry +0x0004 exec/memory.h : *47 me_Reqs #define me_Un.meu_Reqs exec/memory.h : *51 me_Un union (no tag) (size 0x0004 bytes) in struct MemEntry +0x0000 exec/memory.h : *46 me_un #define me_Un exec/memory.h : *50 message struct IOStdReq(size 0x0030 bytes) in struct narrator_rb +0x0000 devices/narrator.h : *94 meu_Addr pointer to void in union (no tag) +0x0000 exec/memory.h : *45 meu_Reqs unsigned long int in union (no tag) +0x0000 exec/memory.h : *44 mh_Attributes unsigned short int in struct MemHeader +0x000e exec/memory.h : *32 mh_First pointer to struct MemChunk in struct MemHeader +0x0010 exec/memory.h : *33 mh_Free unsigned long int in struct MemHeader +0x001c exec/memory.h : *36 mh_Lower pointer to void in struct MemHeader +0x0014 exec/memory.h : *34 mh_Node struct Node(size 0x000e bytes) in struct MemHeader +0x0000 exec/memory.h : *31 mh_Upper pointer to void in struct MemHeader +0x0018 exec/memory.h : *35 min unsigned short int in struct ClockData +0x0002 utility/date.h : *21 min_row unsigned short int in struct MonitorSpec +0x002a graphics/monitor.h : *37 minterms array [8] of unsigned char in struct RastPort +0x0028 graphics/rastport.h : *75 ml_ME array [1] of struct MemEntry(size 0x0008 bytes) in struct MemList +0x0010 exec/memory.h : *61 ml_Node struct Node(size 0x000e bytes) in struct MemList +0x0000 exec/memory.h : *59 ml_NumEntries unsigned short int in struct MemList +0x000e exec/memory.h : *60 ml_me #define ml_ME exec/memory.h : *64 mlh_Head pointer to struct MinNode in struct MinList +0x0000 exec/lists.h : *34 mlh_Tail pointer to struct MinNode in struct MinList +0x0004 exec/lists.h : *35 mlh_TailPred pointer to struct MinNode in struct MinList +0x0008 exec/lists.h : *36 mln_Pred pointer to struct MinNode in struct MinNode +0x0004 exec/nodes.h : *35 mln_Succ pointer to struct MinNode in struct MinNode +0x0000 exec/nodes.h : *34 mn_Length unsigned short int in struct Message +0x0012 exec/ports.h : *52 mn_Node struct Node(size 0x000e bytes) in struct Message +0x0000 exec/ports.h : *50 mn_ReplyPort pointer to struct MsgPort in struct Message +0x000e exec/ports.h : *51 mode unsigned short int in struct narrator_rb +0x0034 devices/narrator.h : *97 monitor_id unsigned short int in struct GfxBase +0x00f2 graphics/gfxbase.h : *69 month unsigned short int in struct ClockData +0x0008 utility/date.h : *24 mouth_rb structure tag size 0x005c devices/narrator.h : *128 mouths unsigned char in struct narrator_rb +0x0042 devices/narrator.h : *103 mp_Flags unsigned char in struct MsgPort +0x000e exec/ports.h : *32 mp_MsgList struct List(size 0x000e bytes) in struct MsgPort +0x0014 exec/ports.h : *35 mp_Node struct Node(size 0x000e bytes) in struct MsgPort +0x0000 exec/ports.h : *31 mp_SigBit unsigned char in struct MsgPort +0x000f exec/ports.h : *33 mp_SigTask pointer to void in struct MsgPort +0x0010 exec/ports.h : *34 mp_SoftInt #define mp_SigTask exec/ports.h : *38 ms_Flags unsigned short int in struct MonitorSpec +0x0018 graphics/monitor.h : *30 ms_LegalView struct Rectangle(size 0x0008 bytes) in struct MonitorSpec +0x0042 graphics/monitor.h : *45 ms_Node struct ExtendedNode(size 0x0018 bytes) in struct MonitorSpec +0x0000 graphics/monitor.h : *29 ms_OpenCount unsigned short int in struct MonitorSpec +0x0030 graphics/monitor.h : *39 ms_Special pointer to struct SpecialMonitor in struct MonitorSpec +0x002c graphics/monitor.h : *38 ms_maxoscan pointer to function returning long int in struct MonitorSpec +0x004a graphics/monitor.h : *46 ms_reserved00 unsigned long int in struct MonitorSpec +0x0094 graphics/monitor.h : *52 ms_reserved01 unsigned long int in struct MonitorSpec +0x0098 graphics/monitor.h : *53 ms_scale pointer to function returning long int in struct MonitorSpec +0x003a graphics/monitor.h : *42 ms_transform pointer to function returning long int in struct MonitorSpec +0x0032 graphics/monitor.h : *40 ms_translate pointer to function returning long int in struct MonitorSpec +0x0036 graphics/monitor.h : *41 ms_videoscan pointer to function returning long int in struct MonitorSpec +0x004e graphics/monitor.h : *47 ms_xoffset unsigned short int in struct MonitorSpec +0x003e graphics/monitor.h : *43 ms_yoffset unsigned short int in struct MonitorSpec +0x0040 graphics/monitor.h : *44 MAKE_ID macro (4 arguments) libraries/iffparse.h : *143 MALE #define 0 = 0x00000000 devices/narrator.h : *63 MANUALF0 #define 2 = 0x00000002 devices/narrator.h : *67 MATHIEEERESOURCEF_DBLBAS #define (1 libraries/mathresource.h : *49 MATHIEEERESOURCEF_DBLTRANS #define (1 libraries/mathresource.h : *50 MATHIEEERESOURCEF_EXTBAS #define (1 libraries/mathresource.h : *53 MATHIEEERESOURCEF_EXTTRANS #define (1 libraries/mathresource.h : *54 MATHIEEERESOURCEF_SGLBAS #define (1 libraries/mathresource.h : *51 MATHIEEERESOURCEF_SGLTRANS #define (1 libraries/mathresource.h : *52 MAX macro (2 arguments) clib/macros.h : *15 MAXBODY #define 0xFFFF = 0x0000ffff intuition/intuition.h : *514 MAXBYTESPERROW #define 4096 = 0x00001000 hardware/blit.h : *25 MAXCENT #define 100 = 0x00000064 devices/narrator.h : *88 MAXFONTMATCHWEIGHT #define 32767 = 0x00007fff graphics/text.h : *87 MAXFONTNAME #define 32 = 0x00000020 libraries/diskfont.h : *62, 76 MAXFONTPATH #define 256 = 0x00000100 libraries/diskfont.h : *28, 31, 38 MAXFREQ #define 28000 = 0x00006d60 devices/narrator.h : *84 MAXINT #define 0x7FFFFFFF = 0x7fffffff dos/dos.h : *45 MAXPITCH #define 320 = 0x00000140 devices/narrator.h : *82 MAXPOT #define 0xFFFF = 0x0000ffff intuition/intuition.h : *515 MAXPUBSCREENNAME #define (139) = 0x0000008b intuition/screens.h : *394 MAXRATE #define 400 = 0x00000190 devices/narrator.h : *80 MAXRMARG #define 15 = 0x0000000f rexx/storage.h : *121 MAXTABS #define 80 = 0x00000050 devices/conunit.h : *52, 78 MAXVOL #define 64 = 0x00000040 devices/narrator.h : *86 MAX_MULTIARGS #define 128 = 0x00000080 dos/rdargs.h : *124 MAX_TEMPLATE_ITEMS #define 100 = 0x00000064 dos/rdargs.h : *117 MCOMPAT_MIXED #define 0 = 0x00000000 graphics/displayinfo.h : *126 MCOMPAT_NOBODY #define -1 = 0xffffffff graphics/displayinfo.h : *128 MCOMPAT_SELF #define 1 = 0x00000001 graphics/displayinfo.h : *127 MEMCLEAR #define (1L rexx/storage.h : *221 MEMF_24BITDMA #define (1L exec/memory.h : *75 MEMF_ANY #define (0L) = 0x00000000 exec/memory.h : *70 MEMF_CHIP #define (1L exec/memory.h : *72 MEMF_CLEAR #define (1L exec/memory.h : *77 MEMF_FAST #define (1L exec/memory.h : *73 MEMF_LARGEST #define (1L exec/memory.h : *78 MEMF_LOCAL #define (1L exec/memory.h : *74 MEMF_PUBLIC #define (1L exec/memory.h : *71 MEMF_REVERSE #define (1L exec/memory.h : *79 MEMF_TOTAL #define (1L exec/memory.h : *80 MEMMASK #define 0xFFFFFFF0 = 0xfffffff0 rexx/storage.h : *218 MEMQUANT #define 16L = 0x00000010 rexx/storage.h : *217 MEMQUICK #define (1L rexx/storage.h : *220 MEM_BLOCKMASK #define (MEM_BLOCKSIZE-1) = 0x00000007 exec/memory.h : *83 MEM_BLOCKSIZE #define 8L = 0x00000008 exec/memory.h : *82 MENUCANCEL #define 0x0002 = 0x00000002 intuition/intuition.h : *767 MENUDOWN #define (IECODE_RBUTTON) = 0x00000069 intuition/intuition.h : *1333 MENUENABLED #define 0x0001 = 0x00000001 intuition/intuition.h : *77 MENUHELP #define IDCMP_MENUHELP = 0x01000000 intuition/iobsolete.h : *138 MENUHOT #define 0x0001 = 0x00000001 intuition/intuition.h : *766 MENUNULL #define 0xFFFF = 0x0000ffff intuition/intuition.h : *1288 MENUNUM macro (1 argument) intuition/intuition.h : *1266 MENUPICK #define IDCMP_MENUPICK = 0x00000100 intuition/iobsolete.h : *122 MENUSTATE #define WFLG_MENUSTATE = 0x00008000 intuition/iobsolete.h : *163 MENUTOGGLE #define 0x0008 = 0x00000008 intuition/intuition.h : *121 MENUTOGGLED #define 0x4000 = 0x00004000 intuition/intuition.h : *137 MENUUP #define (IECODE_RBUTTON | IECODE_UP_PREFIX) = 0x000000e9 intuition/intuition.h : *1332 MENUVERIFY #define IDCMP_MENUVERIFY = 0x00002000 intuition/iobsolete.h : *127 MENUWAITING #define 0x0003 = 0x00000003 intuition/intuition.h : *768 MENU_IMAGE #define 128 = 0x00000080 libraries/gadtools.h : *139 MENU_USERDATA macro (1 argument) libraries/gadtools.h : *176 MIDDLEDOWN #define (IECODE_MBUTTON) = 0x0000006a intuition/intuition.h : *1334 MIDDLEUP #define (IECODE_MBUTTON | IECODE_UP_PREFIX) = 0x000000ea intuition/intuition.h : *1335 MIDRAWN #define 0x0100 = 0x00000100 intuition/intuition.h : *80 MIN macro (2 arguments) clib/macros.h : *16 MINBYTESPERROW #define 128 = 0x00000080 hardware/blit.h : *24 MINCENT #define 0 = 0x00000000 devices/narrator.h : *87 MINFREQ #define 5000 = 0x00001388 devices/narrator.h : *83 MININT #define 0x80000000 = 0x80000000 dos/dos.h : *46 MINPITCH #define 65 = 0x00000041 devices/narrator.h : *81 MINRATE #define 40 = 0x00000028 devices/narrator.h : *79 MINVOL #define 0 = 0x00000000 devices/narrator.h : *85 MIN_NTSC_ROW #define 21 = 0x00000015 graphics/monitor.h : *80 MIN_PAL_ROW #define 29 = 0x0000001d graphics/monitor.h : *81 MIN_VGA70_ROW #define 35 = 0x00000023 graphics/monitor.h : *111 MIN_VGA_ROW #define 29 = 0x0000001d graphics/monitor.h : *96 MISCNAME #define "misc.resource" resources/misc.h : *43 MKBADDR macro (1 argument) dos/dos.h : *113 MODELCLASS #define "modelclass" intuition/classusr.h : *54 MODE_640 #define 0x8000 = 0x00008000 graphics/display.h : *16 MODE_NEWFILE #define 1006 = 0x000003ee dos/dos.h : *31 MODE_OLDFILE #define 1005 = 0x000003ed dos/dos.h : *29 MODE_READWRITE #define 1004 = 0x000003ec dos/dos.h : *33 MONITOR_ID_MASK #define 0xFFFF1000 = 0xffff1000 graphics/displayinfo.h : *145 MONITOR_SPEC_TYPE #define 4 = 0x00000004 graphics/gfxnodes.h : *36 MOUSEBUTTONS #define IDCMP_MOUSEBUTTONS = 0x00000008 intuition/iobsolete.h : *117 MOUSEMOVE #define IDCMP_MOUSEMOVE = 0x00000010 intuition/iobsolete.h : *118 MOUSE_ACCEL #define (1 intuition/preferences.h : *138 MR_ALLOCMISCRESOURCE #define (LIB_BASE) = 0xfffffffa resources/misc.h : *40 MR_FREEMISCRESOURCE #define (LIB_BASE-LIB_VECTSIZE) = 0xfffffff4 resources/misc.h : *41 MR_PARALLELBITS #define 3 = 0x00000003 resources/misc.h : *35 MR_PARALLELPORT #define 2 = 0x00000002 resources/misc.h : *33 MR_SERIALBITS #define 1 = 0x00000001 resources/misc.h : *31 MR_SERIALPORT #define 0 = 0x00000000 resources/misc.h : *30 MTYPE_APPICON #define 8 = 0x00000008 workbench/workbench.h : *99 MTYPE_APPMENUITEM #define 9 = 0x00000009 workbench/workbench.h : *100 MTYPE_APPWINDOW #define 7 = 0x00000007 workbench/workbench.h : *98 MTYPE_CLOSEDOWN #define 5 = 0x00000005 workbench/workbench.h : *96 MTYPE_COPYEXIT #define 10 = 0x0000000a workbench/workbench.h : *101 MTYPE_DISKCHANGE #define 3 = 0x00000003 workbench/workbench.h : *94 MTYPE_ICONPUT #define 11 = 0x0000000b workbench/workbench.h : *102 MTYPE_IOPROC #define 6 = 0x00000006 workbench/workbench.h : *97 MTYPE_PSTD #define 1 = 0x00000001 workbench/workbench.h : *92 MTYPE_TIMER #define 4 = 0x00000004 workbench/workbench.h : *95 MTYPE_TOOLEXIT #define 2 = 0x00000002 workbench/workbench.h : *93 MULTIPLY_DIMENSIONS #define 0x0080 = 0x00000080 intuition/preferences.h : *251 MUSTDRAW #define 0x0008 = 0x00000008 graphics/gels.h : *25 MXIDCMP #define (IDCMP_GADGETDOWN) = 0x00000020 libraries/gadtools.h : *72 MXIMAGE #define (0x0FL) = 0x0000000f intuition/imageclass.h : *111 MX_KIND #define 5 = 0x00000005 libraries/gadtools.h : *39 M_ASM #define ">1" devices/console.h : *99 M_AWM #define "?7" devices/console.h : *100 M_LNM #define 20 = 0x00000014 devices/console.h : *98 devices/conunit.h : 98 Mask unsigned char in struct RastPort +0x0018 graphics/rastport.h : *64 Mask pointer to unsigned short int in struct BoolInfo +0x0002 intuition/intuition.h : *431 MathIEEEBase structure tag size 0x003c libraries/mathlibrary.h : *21 MathIEEEBase_LibNode struct Library(size 0x0022 bytes) in struct MathIEEEBase +0x0000 libraries/mathlibrary.h : *23 MathIEEEBase_TaskCloseLib pointer to function returning int in struct MathIEEEBase +0x0038 libraries/mathlibrary.h : *26 MathIEEEBase_TaskOpenLib pointer to function returning int in struct MathIEEEBase +0x0034 libraries/mathlibrary.h : *25 MathIEEEBase_reserved array [18] of unsigned char in struct MathIEEEBase +0x0022 libraries/mathlibrary.h : *24 MathIEEEResource structure tag size 0x002c libraries/mathresource.h : *35 MathIEEEResource_BaseAddr pointer to unsigned short int in struct MathIEEEResource +0x0010 libraries/mathresource.h : *39 MathIEEEResource_DblBasInit pointer to function returning void in struct MathIEEEResource +0x0014 libraries/mathresource.h : *40 MathIEEEResource_DblTransInit pointer to function returning void in struct MathIEEEResource +0x0018 libraries/mathresource.h : *41 MathIEEEResource_ExtBasInit pointer to function returning void in struct MathIEEEResource +0x0024 libraries/mathresource.h : *44 MathIEEEResource_ExtTransInit pointer to function returning void in struct MathIEEEResource +0x0028 libraries/mathresource.h : *45 MathIEEEResource_Flags unsigned short int in struct MathIEEEResource +0x000e libraries/mathresource.h : *38 MathIEEEResource_Node struct Node(size 0x000e bytes) in struct MathIEEEResource +0x0000 libraries/mathresource.h : *37 MathIEEEResource_SglBasInit pointer to function returning void in struct MathIEEEResource +0x001c libraries/mathresource.h : *42 MathIEEEResource_SglTransInit pointer to function returning void in struct MathIEEEResource +0x0020 libraries/mathresource.h : *43 MaxChars short int in struct StringInfo +0x000a intuition/intuition.h : *530 MaxCount short int in struct cprlist +0x0008 graphics/copper.h : *60 MaxCount short int in struct CopList +0x001e graphics/copper.h : *73 MaxCount short int in struct AreaInfo +0x0012 graphics/rastport.h : *30 MaxDepth unsigned short int in struct DimensionInfo +0x0010 graphics/displayinfo.h : *95 MaxDisplayColumn unsigned short int in struct GfxBase +0x00d6 graphics/gfxbase.h : *57 MaxDisplayRow unsigned short int in struct GfxBase +0x00d4 graphics/gfxbase.h : *56 MaxExtMem pointer to void in struct ExecBase +0x004e exec/execbase.h : *53 MaxHeight unsigned short int in struct Window +0x0016 intuition/intuition.h : *805 MaxHeight unsigned short int in struct NewWindow +0x002c intuition/intuition.h : *1026 MaxHeight unsigned short int in struct ExtNewWindow +0x002c intuition/intuition.h : *1061 MaxLocMem unsigned long int in struct ExecBase +0x003e exec/execbase.h : *49 MaxOScan struct Rectangle(size 0x0008 bytes) in struct DimensionInfo +0x0022 graphics/displayinfo.h : *101 MaxRasterHeight unsigned short int in struct DimensionInfo +0x0018 graphics/displayinfo.h : *99 MaxRasterWidth unsigned short int in struct DimensionInfo +0x0016 graphics/displayinfo.h : *98 MaxWidth unsigned short int in struct Window +0x0014 intuition/intuition.h : *805 MaxWidth unsigned short int in struct NewWindow +0x002a intuition/intuition.h : *1026 MaxWidth unsigned short int in struct ExtNewWindow +0x002a intuition/intuition.h : *1061 MaxX short int in struct Rectangle +0x0004 graphics/gfx.h : *32 MaxX long int in struct Rect32 +0x0008 graphics/gfx.h : *38 MaxY short int in struct Rectangle +0x0006 graphics/gfx.h : *32 MaxY long int in struct Rect32 +0x000c graphics/gfx.h : *38 MeMask short int in struct VSprite +0x0020 graphics/gels.h : *102 MemChunk structure tag size 0x0008 exec/memory.h : *22, 23, 33 MemEntry structure tag size 0x0008 exec/memory.h : *42, 61 MemHeader structure tag size 0x0020 exec/memory.h : *30 MemList structure tag size 0x0018 exec/memory.h : *58 MemList struct List(size 0x000e bytes) in struct ExecBase +0x0142 exec/execbase.h : *86 Memory pointer to unsigned char in struct Remember +0x0008 intuition/intuition.h : *1235 Menu structure tag size 0x001e intuition/intuition.h : *62, 64, 809 MenuHBorder char in struct Screen +0x0022 intuition/screens.h : *121 MenuItem structure tag size 0x0022 intuition/intuition.h : *69, 90, 92, 108 MenuName pointer to char in struct Menu +0x000e intuition/intuition.h : *68 MenuStrip pointer to struct Menu in struct Window +0x001c intuition/intuition.h : *809 MenuVBorder char in struct Screen +0x0021 intuition/screens.h : *121 Message structure tag size 0x0014 exec/ports.h : *49 exec/io.h : 21, 30 devices/audio.h : 55 devices/clipboard.h : 44, 60 devices/printer.h : 143, 157 dos/dosextens.h : 92, 111, 142 graphics/text.h : 92 intuition/intuition.h : 679 dos/notify.h : 42 workbench/startup.h : 28 resources/disk.h : 44 rexx/storage.h : 100 workbench/workbench.h : 127 MessageKey pointer to struct IntuiMessage in struct Window +0x005e intuition/intuition.h : *857 MethodID unsigned long int in struct (no tag) +0x0000 intuition/classusr.h : *32 MethodID unsigned long int in struct opSet +0x0000 intuition/classusr.h : *79 MethodID unsigned long int in struct opUpdate +0x0000 intuition/classusr.h : *89 MethodID unsigned long int in struct opGet +0x0000 intuition/classusr.h : *109 MethodID unsigned long int in struct opAddTail +0x0000 intuition/classusr.h : *118 MethodID unsigned long int in struct opMember +0x0000 intuition/classusr.h : *125 MethodID unsigned long int in struct gpHitTest +0x0000 intuition/gadgetclass.h : *177 MethodID unsigned long int in struct gpRender +0x0000 intuition/gadgetclass.h : *189 MethodID unsigned long int in struct gpInput +0x0000 intuition/gadgetclass.h : *202 MethodID unsigned long int in struct gpGoInactive +0x0000 intuition/gadgetclass.h : *232 MethodID unsigned long int in struct impFrameBox +0x0000 intuition/imageclass.h : *140 MethodID unsigned long int in struct impDraw +0x0000 intuition/imageclass.h : *153 MethodID unsigned long int in struct impErase +0x0000 intuition/imageclass.h : *173 MethodID unsigned long int in struct impHitTest +0x0000 intuition/imageclass.h : *189 Micros unsigned long int in struct IntuiMessage +0x0028 intuition/intuition.h : *708 Micros unsigned long int in struct IntuitionBase +0x004c intuition/intuitionbase.h : *87 MicrosPerLine unsigned short int in struct GfxBase +0x00e8 graphics/gfxbase.h : *65 MinDisplayColumn unsigned short int in struct GfxBase +0x00ea graphics/gfxbase.h : *66 MinHeight short int in struct Window +0x0012 intuition/intuition.h : *804 MinHeight short int in struct NewWindow +0x0028 intuition/intuition.h : *1025 MinHeight short int in struct ExtNewWindow +0x0028 intuition/intuition.h : *1060 MinList structure tag size 0x000c exec/lists.h : *33 exec/semaphores.h : 44 exec/execbase.h : 142 dos/dosextens.h : 65, 251 graphics/layers.h : 39 MinNode structure tag size 0x0008 exec/nodes.h : *33, 34, 35 exec/lists.h : 34, 35, 36 exec/semaphores.h : 36 dos/dosextens.h : 265 utility/hooks.h : 25 intuition/classes.h : 69 libraries/iffparse.h : 70, 84 MinRasterHeight unsigned short int in struct DimensionInfo +0x0014 graphics/displayinfo.h : *97 MinRasterWidth unsigned short int in struct DimensionInfo +0x0012 graphics/displayinfo.h : *96 MinRow unsigned short int in struct MonitorInfo +0x0028 graphics/displayinfo.h : *118 MinWidth short int in struct Window +0x0010 intuition/intuition.h : *804 MinWidth short int in struct NewWindow +0x0026 intuition/intuition.h : *1025 MinWidth short int in struct ExtNewWindow +0x0026 intuition/intuition.h : *1060 MinX short int in struct Rectangle +0x0000 graphics/gfx.h : *31 MinX long int in struct Rect32 +0x0000 graphics/gfx.h : *37 MinY short int in struct Rectangle +0x0002 graphics/gfx.h : *31 MinY long int in struct Rect32 +0x0004 graphics/gfx.h : *37 Modes unsigned short int in struct ViewPort +0x0020 graphics/view.h : *52 Modes unsigned short int in struct View +0x0010 graphics/view.h : *65 Modes unsigned short int in struct GfxBase +0x009e graphics/gfxbase.h : *39 Modes unsigned long int in struct SGWork +0x0010 intuition/sghooks.h : *39 Monitor pointer to struct MonitorSpec in struct ViewExtra +0x001c graphics/view.h : *74 MonitorInfo structure tag size 0x0058 graphics/displayinfo.h : *109 MonitorList struct List(size 0x000e bytes) in struct GfxBase +0x0180 graphics/gfxbase.h : *86 MonitorListSemaphore pointer to struct SignalSemaphore in struct GfxBase +0x0192 graphics/gfxbase.h : *88 MonitorSpec structure tag size 0x009c graphics/monitor.h : *27 graphics/view.h : 74 graphics/displayinfo.h : 112 graphics/gfxbase.h : 85, 87 MoreFlags unsigned long int in struct Window +0x0084 intuition/intuition.h : *901 MountList struct List(size 0x000e bytes) in struct ExpansionBase +0x004a libraries/expansionbase.h : *55 MouseX short int in struct IntuiMessage +0x0020 intuition/intuition.h : *703 MouseX short int in struct Window +0x000e intuition/intuition.h : *802 MouseX short int in struct Screen +0x0012 intuition/screens.h : *106 MouseX short int in struct IntuitionBase +0x0046 intuition/intuitionbase.h : *83 MouseY short int in struct IntuiMessage +0x0022 intuition/intuition.h : *703 MouseY short int in struct Window +0x000c intuition/intuition.h : *802 MouseY short int in struct Screen +0x0010 intuition/screens.h : *106 MouseY short int in struct IntuitionBase +0x0044 intuition/intuitionbase.h : *83 Msg pointer to "UBYTE" intuition/classusr.h : *34 MsgPort structure tag size 0x0022 exec/ports.h : *30, 51 exec/devices.h : 34 exec/semaphores.h : 55 devices/conunit.h : 56 dos/dosextens.h : 41, 93, 94, 112, 253, 267, 334, 364, 411, 447 graphics/text.h : 126 intuition/intuition.h : 856 devices/prtbase.h : 67, 92 dos/filehandler.h : 104 dos/notify.h : 62, 76 workbench/startup.h : 29 libraries/commodities.h : 57 libraries/iffparse.h : 118, 119 rexx/storage.h : 108, 189 rexx/rexxio.h : 66 rexx/rxslib.h : 55 Mspc pointer to struct MonitorSpec in struct MonitorInfo +0x0010 graphics/displayinfo.h : *112 MutualExclude long int in struct MenuItem +0x000e intuition/intuition.h : *97 MutualExclude long int in struct Gadget +0x001e intuition/intuition.h : *253 [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node001A.html.txt:1:A Register Summary / BLTCON0, BLTCON1 ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- BLTCON0 040 W A Blitter control register 0 BLTCON1 042 W A( E ) Blitter control register 1 These two control registers are used together to control blitter operations. There are two basic modes, area and line, which are selected by bit 0 of BLTCON1, as shown below. AREA MODE ("normal") ------------------------- BIT# BLTCON0 BLTCON1 ---- ------- ------- 15 ASH3 BSH3 14 ASH2 BSH2 13 ASH1 BSH1 12 ASA0 BSH0 11 USEA X 10 USEB X 09 USEC X 08 USED X 07 LF7 DOFF 06 LF6 X 05 LF5 X 04 LF4 EFE 03 LF3 IFE 02 LF2 FCI 01 LF1 DESC 00 LF0 LINE(=0) ASH3-0 Shift value of A source BSH3-0 Shift value of B source USEA Mode control bit to use source A USEB Mode control bit to use source B USEC Mode control bit to use source C USED Mode control bit to use destination D LF7-0 Logic function minterm select lines EFE Exclusive fill enable IFE Inclusive fill enable FCI Fill carry input DESC Descending (decreasing address) control bit LINE Line mode control bit (set to 0) LINE DRAW LINE MODE (line draw) LINE DRAW ------------------------------ LINE DRAW BIT# BLTCON0 BLTCON1 LINE DRAW ---- ------- ------- LINE DRAW 15 START3 TEXTURE3 LINE DRAW 14 START2 TEXTURE2 LINE DRAW 13 START1 TEXTURE1 LINE DRAW 12 START0 TEXTURE0 LINE DRAW 11 1 0 LINE DRAW 10 0 0 LINE DRAW 09 1 0 LINE DRAW 08 1 0 LINE DRAW 07 LF7 0 LINE DRAW 06 LF6 SIGN LINE DRAW 05 LF5 0 (Reserved) LINE DRAW 04 LF4 SUD LINE DRAW 03 LF3 SUL LINE DRAW 02 LF2 AUL LINE DRAW 01 LF1 SING LINE DRAW 00 LF0 LINE(=1) LINE DRAW LINE DRAW START3-0 Starting point of line LINE DRAW (0 thru 15 hex) LINE DRAW LF7-0 Logic function minterm LINE DRAW select lines should be preloaded LINE DRAW with 4A to select the equation LINE DRAW D=(AC+ABC). Since A contains a LINE DRAW single bit true (8000), most bits LINE DRAW will pass the C field unchanged LINE DRAW (not A and C), but one bit will LINE DRAW invert the C field and combine it LINE DRAW with texture (A and B and not C). LINE DRAW The A bit is automatically moved LINE DRAW across the word by the hardware. LINE DRAW LINE DRAW LINE Line mode control bit (set to 1) LINE DRAW SIGN Sign flag LINE DRAW 0 Reserved for new mode LINE DRAW SING Single bit per horizontal line for LINE DRAW use with subsequent area fill LINE DRAW SUD Sometimes up or down (=AUD*) LINE DRAW SUL Sometimes up or left LINE DRAW AUL Always up or left LINE DRAW The 3 bits above select the octant LINE DRAW for line drawing: LINE DRAW OCT SUD SUL AUL LINE DRAW --- --- --- --- LINE DRAW 0 1 1 0 LINE DRAW 1 0 0 1 LINE DRAW 2 0 1 1 LINE DRAW 3 1 1 1 LINE DRAW 4 1 0 1 LINE DRAW 5 0 1 0 LINE DRAW 6 0 0 0 LINE DRAW 7 1 0 0 LINE DRAW The "B" source is used for LINE DRAW texturing the drawn lines. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node00EA.html.txt:1:5 / Producing High-quality Sound / Sampling Rate ]" border=0> If you need high precision in your frequency output, you may find that the frequency you wish to produce is somewhere between two available sampling rates, but not close enough to either rate for your requirements. In those cases, you may have to adjust the length of the audio data table in addition to altering the sampling rate. For higher frequencies, you may also need to use audio data tables that contain more than one full cycle of the audio waveform to reproduce the desired frequency more accurately, as illustrated in Figure 5-4. Figure 5-4: Waveform with Multiple Cycles [Back to Amiga Developer Docs ]
Libraries_Manual_guide/node002F.html.txt:1:A Index ]" border=0> AbortIO(), 451 Accessing a Device, 446 Activate - window on open, 110 ActivateCxObj(), 731 ActivateGadget(), 150 , 166 , 321 ActivateWindow(), 91 , 115 active gadget, 323 Active Window, --> AddAnimOb(), 659 , 668 AddBob(), 641 , 668 AddBootNode(), 759 , 776 AddClass(), 312 , 330 AddDosNode(), 759 , 776 AddGadget(), 166 AddGList(), 122 , 129 , 166 ADDHEAD, 498 AddHead(), 492 , 498 , 520 AddIEvents(), 749 AddIntServer(), 525 AddLibrary(), 443 AddPort(), 501 , 511 AddPublicSemaphore(), 511 Address error, 474 AddSemaphore(), 511 , 515 ADDTAIL, 498 AddTail(), 492 , 498 , 520 AddTask(), 466 , 480 AddTOF(), 888 AddVSprite(), 627 , 668 Adjust - window size, 111 AFF_DISK, 689 AFF_MEMORY, 689 AFF_SCALED, 689 AFF_TAGGED, 689 afp(), 888 Agnus, 11 Alert, --> Alert(), 520 AllocAslRequest(), 416 AllocAslRequestTags(), 421 Allocate(), 462 Allocating memory, 455 AllocEntry(), 459 , 461 , 462 AllocIFF(), 344 , 810 AllocLocalItem(), 790 , 810 AllocMem(), 274 , 284 , 288 , 430 , 455 , 457 , 466 AllocRaster(), 98 , 552 , 610 , allocating memory, 560 AllocRemember(), 283 , 284 , 284 , 285 , 288 , 289 AllocSignal(), 254 , 476 , 482 , 485 AllocTrap(), 476 , 480 AllocVec(), 430 Alt Key, 282 - with right Amiga key, 176 Alternate - Alt key, 282 , window size zoom, 108 Amiga --> Amiga Key Glyph - menus, 184 Amiga keys - as command keys, 282 , Workbench shortcuts, 281 Amiga.lib, 438 , 885 , stub, 438 AndRectRegion(), 722 AndRegionRegion(), 722 ANFRACSIZE, 661 Animate(), 660 , 668 Animation, --> AnimComp structure, 652 ANIMHALF, 661 AnimOb structure, 652 ANSI Codes, 90 AOlPen - in filling, 584 , in RastPort, 584 Area pattern, 585 AreaCircle(), 590 , 611 AreaDraw(), 611 - adding a vertex, 589 , in area fill, 582 AreaEllipse(), 590 , 611 AreaEnd(), 611 - drawing and filling shapes, 590 , in area fill, 582 AreaInfo pointer, 582 AreaMove(), 611 - beginning a polygon, 589 , in area fill, 582 ARexx, 21 , 888 ArgArrayDone(), 735 , 888 ArgArrayInit(), 735 , 888 ArgInt(), 735 , 888 ArgString(), 735 , 888 arnd(), 888 AskKeyMapDefault(), 812 AskSoftStyle(), 675 ASL, --> ASL Library, 20 asl.library - see ASL AslRequest(), 416 AslRequestTags(), 421 ASL_BackPen, 423 ASL_CancelText, 417 ASL_Dir, 417 ASL_File, 417 ASL_FontFlags, 423 ASL_FontHeight, 423 ASL_FontName, 423 ASL_FontStyles, 423 ASL_FrontPen, 423 ASL_FuncFlags, 419 ASL_Hail, 417 ASL_Height, 417 ASL_Hookfunc, 425 ASL_LeftEdge, 417 ASL_MaxHeight, 423 ASL_MinHeight, 423 ASL_ModeList, 423 ASL_OKText, 417 ASL_TopEdge, 417 ASL_Width, 417 Aspect Ratio, 20 AttachCxObj(), 737 AttemptSemaphore(), 513 , 513 , 515 attributes, --> AUD0-AUD3 Interrupts, 519 Audio device, 925 AUserStuff, 651 Autoboot, 760 AUTOCONFIG - hardware manufacturer number, 756 , see Expansion, AUTOCONFIG AUTOKNOB, 147 AutoRequest(), 97 , 188 , 201 , 211 , 215 , 216 , 222 AUTOSCROLL, 49 Autovector Address, 518 AvailFonts(), 688 AvailFonts structure, 688 AvailFontsHeader structure, 688 AvailMem(), 459 A-Pen - see FgPen [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0022.html.txt:1:A Register Summary / BPLCON0, BPLCON1, BPLCON2, BPLCON3 ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- BPLCON0 100 W A D( E ) Bitplane control register (misc. control bits) BPLCON1 102 W D Bitplane control register (horizontal scroll control) BPLCON2 104 W D( E ) Bitplane control register (video priority control) These registers control the operation of the bitplanes and various aspects of the display. BIT# BPLCON0 BPLCON1 BPLCON2 ---- -------- -------- -------- 15 HIRES X X 14 BPU2 X X 13 BPU1 X X 12 BPU0 X X 11 HOMOD X X 10 DBLPF X X 09 COLOR X X 08 GAUD X X 07 X PF2H3 X 06 X PF2H2 PF2PRI 05 X PF2H1 PF2P2 04 X PF2H0 PF2P1 03 LPEN PF1H3 PF2P0 02 LACE PF1H2 PF1P2 01 ERSY PF1H1 PF1P1 00 X PF1H0 PF1P0 HIRES=High-resolution (70 ns pixels) BPU =Bitplane use code 000-110 (NONE through 6 inclusive) HOMOD=Hold-and-modify mode (1 = Hold-and-modify mode (HAM); 0 = Extra Half Brite (EHB) if HAM=0 and BPU=6 and DBLPF=0 then bitplane 6 controls an intensity reduction in the other five bitplanes) DBLPF=Double playfield (PF1=odd PF2=even bitplanes) COLOR=Composite video COLOR enable GAUD=Genlock audio enable (muxed on BKGND pin during vertical blanking LPEN =Light pen enable (reset on power up) LACE =Interlace enable (reset on power up) ERSY =External resync (HSYNC, VSYNC pads become inputs) (reset on power up) PF2PRI=Playfield 2 (even planes) has priority over (appears in front of) playfield 1 (odd planes). PF2P=Playfield 2 priority code (with respect to sprites) PF1P=Playfield 1 priority code (with respect to sprites) PF2H=Playfield 2 horizontal scroll code PF1H=Playfield 1 horizontal scroll code BPLCON3 106 W D( E ) Bitplane control (enhanced features) [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node003A.html.txt:1:A Register Summary / POT0DAT, POT1DAT ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- POT0DAT 012 R P( E ) Pot counter data left pair (vert,horiz.) POT1DAT 014 R P( E ) Pot counter data right pair (vert,horiz.) These addresses each read a pair of 8-bit pot counters. (Four counters total.) The bit assignment for both addresses is shown below. The counters are stopped by signals from two controller connectors (left-right) with two pins each. BIT# 15,14,13,12,11,10,09,08 07,06,05,04,03,02,01,00 ----- ------------------------ ----------------------- RIGHT Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 X7 X6 X5 X4 X3 X2 X1 X0 LEFT Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 X7 X6 X5 X4 X3 X2 X1 X0 CONNECTORS PAULA -------------------- ---------------- Loc. Dir. Sym Pin Pin# Pin Name ---- --- ---- ---- ---- -------- RIGHT Y RY 9 36 (POT1Y) RIGHT X RX 5 35 (POT1X) LEFT Y LY 9 33 (POT0Y) LEFT X LX 5 32 (POT0X) [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node0239.html.txt:1:exec.library/SetIntVector ]" border=0> NAME SetIntVector -- set a new handler for a system interrupt vector SYNOPSIS oldInterrupt = SetIntVector(intNumber, interrupt) D0 D0 A1 struct Interrupt *SetIntVector(ULONG, struct Interrupt *); FUNCTION This function provides a mechanism for setting the system interrupt vectors. These are non-sharable; setting a new interrupt handler disconnects the old one. Installed handlers are responsible for processing, enabling and clearing the interrupt. Note that interrupts may have been left in any state by the previous code. The IS_CODE and IS_DATA pointers of the Interrupt structure will be copied into a private place by Exec. A pointer to the previously installed Interrupt structure is returned. When the system calls the specified interrupt code, the registers are setup as follows: D0 - scratch D1 - scratch (on entry: active interrupts -> equals INTENA & INTREQ) A0 - scratch (on entry: pointer to base of custom chips for fast indexing) A1 - scratch (on entry: Interrupt's IS_DATA pointer) A5 - jump vector register (scratch on call) A6 - Exec library base pointer (scratch on call) all other registers must be preserved INPUTS intNum - the Paula interrupt bit number (0..14). Only non-chained interrupts should be set. Use AddIntServer() for server chains. interrupt - a pointer to an Interrupt structure containing the handler's entry point and data segment pointer. A NULL interrupt pointer will remove the current interrupt and set illegal values for IS_CODE and IS_DATA. By convention, the LN_NAME of the interrupt structure must point a descriptive string so that other users may identify who currently has control of the interrupt. RESULT A pointer to the prior interrupt structure which had control of this interrupt. SEE ALSO AddIntServer() ,exec/interrupts.i,hardware/intbits.i [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0004.html.txt:1:1 / Components of the Amiga / The MC68000 and the Amiga Custom Chips ]" border=0> The Motorola MC68000 microprocessor is the CPU used in the A1000, the A500, and the A2000. The 68000 is a 16/32-bit microprocessor; internal registers are 32 bits wide, while the data bus and ALU are 16 bits. The 68000's system clock speed is 7.15909 MHz on NTSC systems (USA) or 7.09379 MHz on PAL systems (Europe). These speeds can vary when using an external system clock, such as from a genlock board. The 68000 has an address space of 16 megabytes. In the Amiga, the 68000 can address up to 9 megabytes of random access memory (RAM). In the A3000, the Motorola MC68030 microprocessor is the CPU. This is a full 32-bit microprocessor with a system clock speed of 16 or 25 megahertz. The 68030 has an address space of 4 gigabytes. In the A3000, over a gigabyte of RAM can be addressed. In addition to the 680x0, all Amiga models contain special purpose hardware known as the custom chips that greatly enhance system performance. The term custom chips refers to the three integrated circuits which were designed specifically for the Amiga computer. These three custom chips, named Paula, Agnus, and Denise, each contain the logic to handle a specific set of tasks such as video, audio, or I/O. Because the custom chips have DMA capability, they can access memory without using the 680x0 CPU - this frees the CPU for other types of operations. The division of labor between the custom chips and the 680x0 gives the Amiga its power; on most other systems the CPU has to do everything. The memory shared between the Amiga's CPU and the custom chips is called Chip memory. The more Chip memory the Amiga has, the more graphics, audio, and I/O data it can operate on without the CPU being involved. All Amigas can access at least 512K of Chip memory. The latest version of the custom chips, known as the Enhanced Chip Set or ECS, can handle up to 2 MB of memory and has other advanced features. For more details about the Enhanced Chip Set, refer to Appendix C . Although there are different versions of the Amiga's custom chips, all versions have some common features. Among other functions, the custom chips provide the following: * Bitplane generated, high resolution graphics capable of supporting both PAL and NTSC video standards. NTSC systems. ------------- On NTSC systems, the Amiga typically produces a 320 by 200 non-interlaced or 320 by 400 interlaced display in 32 colors. A high resolution mode provides a 640 by 200 non-interlaced or 640 by 400 interlaced display in 16 colors. PAL systems. ------------ On PAL systems, the Amiga typically produces a 320 by 256 non-interlaced or 320 by 512 interlaced display in 32 colors. High resolution mode provides a 640 by 256 non-interlaced or 640 by 512 interlaced display in 16 colors. The design of the Amiga's display system is very flexible and there are many other modes available. Hold-and-modify (HAM) mode allows for the display of up to 4,096 colors on screen simultaneously. Overscan mode allows the creation of higher resolution displays specially suited for video and film applications. Displays of arbitrary size, larger than the visible viewing area can be created. Amigas which contain the Enhanced Chip Set (ECS) support Productivity mode giving displays of 640 by 480, non-interlaced with 4 colors from a pallette of 64. * A custom graphics coprocessor, called the Copper, that allows changes to most of the special purpose registers in synchronization with the position of the video beam. This allows such special effects as mid-screen changes to the color palette, splitting the screen into multiple horizontal slices each having different video resolutions and color depths, beam-synchronized interrupt generation for the 680x0, and more. The coprocessor can trigger many times per screen, in the middle of lines, and at the beginning or during the blanking interval. The coprocessor itself can directly affect most of the registers in the other custom chips, freeing the 680x0 for general computing tasks. * 32 system color registers, each of which contains a 12-bit number as four bits of red, four bits of green, and four bits of blue intensity information. This allows a system color palette of 4,096 different choices of color for each register. * Eight reusable 16-bit wide sprites with up to 15 color choices per sprite pixel (when sprites are paired). A sprite is an easily movable graphics object whose display is entirely independent of the background (called a playfield); sprites can be displayed over or under this background. A sprite is 16 low resolution pixels wide and an arbitrary number of lines tall. After producing the last line of a sprite on the screen, a sprite DMA channel may be used to produce yet another sprite image elsewhere on screen (with at least one horizontal line between each reuse of a sprite processor). Thus, many small sprites can be produced by simply reusing the sprite processors appropriately. * Dynamically controllable inter-object priority, with collision detection. This means that the system can dynamically control the video priority between the sprite objects and the bitplane backgrounds (playfields). You can control which object or objects appear over or under the background at any time. Additionally, you can use system hardware to detect collisions between objects and have your program react to such collisions. * Custom bit blitter used for high speed data movement, adaptable to bitplane animation. The blitter has been designed to efficiently retrieve data from up to three sources, combine the data in one of 256 different possible ways, and optionally store the combined data in a destination area. The bit blitter, in a special mode, draws patterned lines into rectangularly organized memory regions at a speed of about 1 million dots per second; and it can efficiently handle area fill. * Audio consisting of four digital channels with independently programmable volume and sampling rate. The audio channels retrieve their control and sample data via DMA. Once started, each channel can automatically play a specified waveform without further processor interaction. Two channels are directed into each of the two stereo audio outputs. The audio channels may be linked together to provide amplitude or frequency modulation or both forms of modulation simultaneously. * DMA controlled floppy disk read and write on a full track basis. This means that the built-in disk can read over 5600 bytes of data in a single disk revolution (11 sectors of 512 bytes each). [Back to Amiga Developer Docs ]
Libraries_Manual_guide/node029A.html.txt:1:19 Exec Device I/O / What is a Device? ]" border=0> An Amiga device is a software module that accepts commands and data and performs I/O operations based on the commands it receives. In most cases, it interacts with either internal or external hardware, (the exceptions are the clipboard device and ramdrive device which simply use memory). Generally, an Amiga device runs as a separate task which is capable of processing your commands while your application attends to other things. Table 19-1: Amiga System Devices Amiga Device Purpose ------------ ------- Audio Controls the use of the audio hardware. Clipboard Manages the cutting and pasting of common data blocks Console Provides the line-oriented user interface. Gameport Controls the two mouse/joystick ports. Input Processes input from the gameport and keyboard devices. Keyboard Controls the keyboard. Narrator Produces the Amiga synthesized speech. Parallel Controls the parallel port. Printer Converts a standard set of printer control codes to printer specific codes. SCSI Controls the Small Computer Standard Interface hardware. Serial Controls the serial port. Timer Provides timing functions to measure time intervals and send interrupts. Trackdisk Controls the Amiga floppy disk drives. The philosophy behind the devices is that I/O operations should be consistent and uniform. You print a file in the same manner as you play an audio sample, i.e., you send the device in question a WRITE command and the address of the buffer holding the data you wish to write. The result is that the interface presented to the programmer is essentially device independent and accessible from any computer language. This greatly expands the power the Amiga brings to the programmer and, ultimately, to the user. Devices support two types of commands: Exec standard commands like READ and WRITE , and device specific commands like the trackdisk device MOTOR command which controls the floppy drive motor, and the keyboard device READMATRIX command which returns the state of each key on the keyboard. You should keep in mind, however, that supporting standard commands does not mean that all devices execute them in exactly the same manner. This chapter contains an introduction to the Exec and amiga.lib functions that are used when accessing Amiga devices. Consult the Amiga ROM Kernel Manual: Devices volume for chapters on each of the Amiga devices and the commands they support. In addition, the Amiga ROM Kernel Reference Manual: Includes and Autodocs contains Autodocs summarizing the commands of each device, and listings of the device include files. Both are very useful manuals to have around when you are programming the devices. [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node0069.html.txt:1:audio.device/CloseDevice ]" border=0> NAME CloseDevice - terminate access to the audio device SYNOPSIS CloseDevice(iORequest); A1 FUNCTION The CloseDevice routine notifies the audio device that it will no longer be used. It takes an I/O audio request block (IOAudio) and clears the device pointer (io_Device). If there are any channels allocated with the same allocation key (ioa_AllocKey), CloseDevice frees (ADCMD_FREE) them. CloseDevice decrements the open count, and if it falls to zero and an expunge (Expunge) is pending, the device is expunged. INPUTS iORequest - pointer to audio request block (struct IOAudio) io_Device - pointer to device node, must be set by (or copied from I/O block set by) open (OpenDevice) io_Unit - bit map of channels to free (ADCMD_FREE) (bits 0 thru 3 correspond to channels 0 thru 3) ioa_AllocKey- allocation key, used to free channels OUTPUTS iORequest - pointer to audio request block (struct IOAudio) io_Device - set to -1 io_Unit - set to zero [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0275.html.txt:1:Memory allocation Index ]" border=0> Memory allocation audio, 137 formula for playfields, 76 playfields, 52 [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node059D.html.txt:1:Text_Autodocs/exec.doc ]" border=0> TABLE OF CONTENTS exec.library/AbortIO exec.library/AddDevice exec.library/AddHead exec.library/AddIntServer exec.library/AddLibrary exec.library/AddMemList exec.library/AddPort exec.library/AddResource exec.library/AddSemaphore exec.library/AddTail exec.library/AddTask exec.library/Alert exec.library/AllocAbs exec.library/Allocate exec.library/AllocEntry exec.library/AllocMem exec.library/AllocSignal exec.library/AllocTrap exec.library/AllocVec exec.library/AttemptSemaphore exec.library/AvailMem exec.library/CacheClearE exec.library/CacheClearU exec.library/CacheControl exec.library/CachePostDMA exec.library/CachePreDMA exec.library/Cause exec.library/CheckIO exec.library/CloseDevice exec.library/CloseLibrary exec.library/ColdReboot exec.library/CopyMem exec.library/CopyMemQuick exec.library/CreateIORequest exec.library/CreateMsgPort exec.library/Deallocate exec.library/Debug exec.library/DeleteIORequest exec.library/DeleteMsgPort exec.library/Disable exec.library/DoIO exec.library/Enable exec.library/Enqueue exec.library/FindName exec.library/FindPort exec.library/FindResident exec.library/FindSemaphore exec.library/FindTask exec.library/Forbid exec.library/FreeEntry exec.library/FreeMem exec.library/FreeSignal exec.library/FreeTrap exec.library/FreeVec exec.library/GetCC exec.library/GetMsg exec.library/InitCode exec.library/InitResident exec.library/InitSemaphore exec.library/InitStruct exec.library/Insert exec.library/MakeFunctions exec.library/MakeLibrary exec.library/ObtainSemaphore exec.library/ObtainSemaphoreList exec.library/ObtainSemaphoreShared exec.library/OldOpenLibrary exec.library/OpenDevice exec.library/OpenLibrary exec.library/OpenResource exec.library/Permit exec.library/Procure exec.library/PutMsg exec.library/RawDoFmt exec.library/ReleaseSemaphore exec.library/ReleaseSemaphoreList exec.library/RemDevice exec.library/RemHead exec.library/RemIntServer exec.library/RemLibrary exec.library/Remove exec.library/RemPort exec.library/RemResource exec.library/RemSemaphore exec.library/RemTail exec.library/RemTask exec.library/ReplyMsg exec.library/SendIO exec.library/SetExcept exec.library/SetFunction exec.library/SetIntVector exec.library/SetSignal exec.library/SetSR exec.library/SetTaskPri exec.library/Signal exec.library/StackSwap exec.library/SumKickData exec.library/SumLibrary exec.library/SuperState exec.library/Supervisor exec.library/TypeOfMem exec.library/UserState exec.library/Vacate exec.library/Wait exec.library/WaitIO exec.library/WaitPort exec.library/AbortIO exec.library/AbortIO NAME AbortIO - attempt to abort an in-progress I/O request SYNOPSIS AbortIO(iORequest) A1 VOID AbortIO(struct IORequest *); FUNCTION Ask a device to abort a previously started IORequest. This is done by calling the device's ABORTIO vector, with your given IORequest. AbortIO is a command the device that may or may not grant. If successful, the device will stop processing the IORequest, and reply to it earlier than it would otherwise have done. NOTE AbortIO() does NOT Remove() the IORequest from your ReplyPort, OR wait for it to complete. After an AbortIO() you must wait normally for the reply message before actually reusing the request. If a request has already completed when AbortIO() is called, no action is taken. EXAMPLE AbortIO(timer_request); WaitIO(timer_request); /* Message is free to be reused */ INPUTS iORequest - pointer to an I/O request block (must have been used at least once. May be active or finished). SEE ALSO WaitIO, DoIO, SendIO, CheckIO exec.library/AddDevice exec.library/AddDevice NAME AddDevice -- add a device to the system SYNOPSIS AddDevice(device) A1 void AddDevice(struct Device *); FUNCTION This function adds a new device to the system device list, making it available to other programs. The device must be ready to be opened at this time. INPUTS device - pointer to a properly initialized device node SEE ALSO RemDevice, OpenDevice, CloseDevice, MakeLibrary exec.library/AddHead exec.library/AddHead NAME AddHead -- insert node at the head of a list SYNOPSIS AddHead(list, node) A0 A1 void AddHead(struct List *, struct Node *) FUNCTION Add a node to the head of a doubly linked list. Assembly programmers may prefer to use the ADDHEAD macro from "exec/lists.i". WARNING This function does not arbitrate for access to the list. The calling task must be the owner of the involved list. INPUTS list - a pointer to the target list header node - the node to insert at head SEE ALSO AddTail, Enqueue, Insert, Remove, RemHead, RemTail exec.library/AddIntServer exec.library/AddIntServer NAME AddIntServer -- add an interrupt server to a system server chain SYNOPSIS AddIntServer(intNum, interrupt) D0-0:4 A1 void AddIntServer(ULONG, struct Interrupt *); FUNCTION This function adds a new interrupt server to a given server chain. The node is located on the chain in a priority dependent position. If this is the first server on a particular chain, interrupts will be enabled for that chain. Each link in the chain will be called in priority order until the chain ends or one of the servers returns with the 68000's Z condition code clear (indicating non-zero). Servers on the chain should return with the Z flag clear if the interrupt was specifically for that server, and no one else. VERTB servers should always return Z set. (Take care with High Level Language servers, the language may not have a mechanism for reliably setting the Z flag on exit). Servers are called with the following register conventions: D0 - scratch D1 - scratch A0 - scratch A1 - server is_Data pointer (scratch) A5 - jump vector register (scratch) A6 - scratch all other registers must be preserved INPUTS intNum - the Paula interrupt bit number (0 through 14). Processor level seven interrupts (NMI) are encoded as intNum 15. The PORTS, COPER, VERTB, EXTER and NMI interrupts are set up as server chains. interrupt - pointer to an Interrupt structure. By convention, the LN_NAME of the interrupt structure must point a descriptive string so that other users may identify who currently has control of the interrupt. WARNING Some compilers or assemblers may optimize code in unexpected ways, affecting the conditions codes returned from the function. Watch out for a "MOVEM" instruction (which does not affect the condition codes) turning into "MOVE" (which does). BUGS The graphics library's VBLANK server, and some user code, currently assume that address register A0 will contain a pointer to the custom chips. If you add a server at a priority of 10 or greater, you must compensate for this by providing the expected value ($DFF000). SEE ALSO RemIntServer, SetIntVector, hardware/intbits.i,exec/interrupts.i exec.library/AddLibrary exec.library/AddLibrary NAME AddLibrary -- add a library to the system SYNOPSIS AddLibrary(library) A1 void AddLibrary(struct Library *); FUNCTION This function adds a new library to the system, making it available to other programs. The library should be ready to be opened at this time. It will be added to the system library name list, and the checksum on the library entries will be calculated. INPUTS library - pointer to a properly initialized library structure SEE ALSO RemLibrary, CloseLibrary, OpenLibrary, MakeLibrary exec.library/AddMemList exec.library/AddMemList NAME AddMemList - add memory to the system free pool SYNOPSIS AddMemList( size, attributes, pri, base, name ) D0 D1 D2 A0 A1 void AddMemList(ULONG, ULONG, LONG, APTR, STRPTR); FUNCTION Add a new region of memory to the system free pool. The first few bytes will be used to hold the MemHeader structure. The remainder will be made available to the rest of the world. INPUTS size - the size (in bytes) of the memory area attributes - the attributes word that the memory pool will have pri - the priority for this memory. CHIP memory has a pri of -10, 16 bit expansion memory has a priority of 0. The higher the priority, the closer to the head of the memory list it will be placed. base - the base of the new memory area name - the name that will be used in the memory header, or NULL if no name is to be provided. This name is not copied, so it must remain valid for as long as the memory header is in the system. SEE ALSO AllocMem, exec/memory.h exec.library/AddPort exec.library/AddPort NAME AddPort -- add a public message port to the system SYNOPSIS AddPort(port) A1 void AddPort(struct MsgPort *); FUNCTION This function attaches a message port structure to the system's public message port list, where it can be found by the FindPort() function. The name and priority fields of the port structure must be initialized prior to calling this function. If the user does not require the priority field, it should be initialized to zero. Only ports that will be searched for with FindPort() need to be added to the system list. In addition, adding ports is often useful during debugging. If the port will be searched for, the priority field should be at least 1 (to avoid the large number of inactive ports at priority zero). If the port will be searched for often, set the proritiry in the 50-100 range (so it will be before other less used ports). Once a port has been added to the naming list, you must be careful to remove the port from the list (via RemPort) before deallocating its memory. NOTE A point of confusion is that clearing a MsgPort structure to all zeros is not enough to prepare it for use. As mentioned in the Exec chapter of the ROM Kernel Manual, the List for the MsgPort must be initialized. This is automatically handled by AddPort(), and amiga.lib/CreatePort. This initialization can be done manually with amiga.lib/NewList or the assembly NEWLIST macro. Do not AddPort an active port. INPUTS port - pointer to a message port SEE ALSO RemPort, FindPort, amiga.lib/CreatePort, amiga.lib/NewList exec.library/AddResource exec.library/AddResource NAME AddResource -- add a resource to the system SYNOPSIS AddResource(resource) A1 void AddResource(APTR); FUNCTION This function adds a new resource to the system and makes it available to other users. The resource must be ready to be called at this time. Resources currently have no system-imposed structure, however they must start with a standard named node (LN_SIZE), and should with a standard Library node (LIB_SIZE). INPUTS resource - pointer an initialized resource node SEE ALSO RemResource, OpenResource, MakeLibrary exec.library/AddSemaphore exec.library/AddSemaphore NAME AddSemaphore -- initialize then add a signal semaphore to the system SYNOPSIS AddSemaphore(signalSemaphore) A1 void AddSemaphore(struct SignalSemaphore *); FUNCTION This function attaches a signal semaphore structure to the system's public signal semaphore list. The name and priority fields of the semaphore structure must be initialized prior to calling this function. If you do not want to let others rendezvous with this semaphore, use InitSemaphore() instead. If a semaphore has been added to the naming list, you must be careful to remove the semaphore from the list (via RemSemaphore) before deallocating its memory. Semaphores that are linked together in an allocation list (which ObtainSemaphoreList() would use) may not be added to the system naming list, because the facilities use the link field of the signal semaphore in incompatible ways INPUTS signalSemaphore -- an signal semaphore structure BUGS Does not work in Exec #include extern struct ExecBase *SysBase; ... void LocalAddSemaphore(s) struct SignalSemaphore *s; { s->ss_Link.ln_Type=NT_SIGNALSEM; InitSemaphore(s); Forbid(); Enqueue(&SysBase->SemaphoreList,s); Permit(); } SEE ALSO RemSemaphore, FindSemaphore, InitSemaphore exec.library/AddTail exec.library/AddTail NAME AddTail -- append node to tail of a list SYNOPSIS AddTail(list, node) A0 A1 void AddTail(struct List *, struct Node *); FUNCTION Add a node to the tail of a doubly linked list. Assembly programmers may prefer to use the ADDTAIL macro from "exec/lists.i". WARNING This function does not arbitrate for access to the list. The calling task must be the owner of the involved list. INPUTS list - a pointer to the target list header node - a pointer to the node to insert at tail of the list SEE ALSO AddHead, Enqueue, Insert, Remove, RemHead, RemTail exec.library/AddTask exec.library/AddTask NAME AddTask -- add a task to the system SYNOPSIS AddTask(task, initialPC, finalPC) A1 A2 A3 APTR AddTask(struct Task *, APTR, APTR); FUNCTION Add a task to the system. A reschedule will be run; the task with the highest priority in the system will start to execute (this may or may not be the new task). Certain fields of the task control block must be initialized and a stack allocated prior to calling this function. The absolute smallest stack that is allowable is something in the range of 100 bytes, but in general the stack size is dependent on what subsystems are called. In general 256 bytes is sufficient if only Exec is called, and 4K will do if anything in the system is called. DO NOT UNDERESTIMATE. If you use a stack sniffing utility, leave a healthy pad above the minimum value. The system guarantees that its stack operations will leave the stack longword aligned. This function will temporarily use space from the new task's stack for the task's initial set of registers. This space is allocated starting at the SPREG location specified in the task control block (not from SPUPPER). This means that a task's stack may contain static data put there prior to its execution. This is useful for providing initialized global variables or some tasks may want to use this space for passing the task its initial arguments. A task's initial registers are set to zero (except the PC). The TC_MEMENTRY field of the task structure may be extended by the user to hold additional MemLists (as returned by AllocEntry()). These will be automatically be deallocated at RemTask() time. If the code you have used to start the task has already added something to the MEMENTRY list, simply use AddHead to add your new MemLists in. If no initialization has been done, a NewList will need to be performed. INPUTS task - pointer to the task control block (TCB). All unset fields must be zero. initialPC - the initial entry point's address finalPC - the finalization code entry point's address. If zero, the system will use a general finalizer. This pointer is placed on the stack as if it were the outermost return address. RESULTS For V36, AddTask returns either a NULL or the address of the new task. Old code need not check this. WARNING Tasks are a low-level building block, and are unable to call dos.library, or any system function that might call dos.library. See the AmigaDOS CreateProc() for information on Processes. SEE ALSO RemTask, FindTask, amiga.lib/CreateTask, dos/CreateProc, amiga.lib/NewList exec.library/Alert exec.library/Alert NAME Alert -- alert the user of an error SYNOPSIS Alert(alertNum) D7 void Alert(ULONG); FUNCTION Alerts the user of a serious system problem. This function will bring the system to a grinding halt, and do whatever is necessary to present the user with a message stating what happened. Interrupts are disabled, and an attempt to post the alert is made. If that fails, the system is reset. When the system comes up again, Exec notices the cause of the failure and tries again to post the alert. If the Alert is a recoverable type, this call MAY return. This call may be made at any time, including interrupts. POST-MORTEM DIAGNOSIS There are several options for determining the cause of a crash. Descriptions of each alert number can be found in the "alerts.h" include file. Low numbers not mentioned in the include file represent 68000 exceptions, see a 68000 manual for details. The most common numbers are: $00000003 - Address Error $00000004 - Illegal Instruction A remote terminal can be attached to the Amiga's first built-in serial port. Set the communication parameters to 9600 baud, 8 bits, no parity. Before resetting the machine, the Alert function will blink the power LED 10 times. While the power indicator is flashing, pressing DELETE on the remote terminal will invoke the ROMWack debugger. For Alerts caused by a 68000 exception, all registers are copied to a magic low memory location (currently 16 longwords at $180). INPUT alertNum - a number indicating the particular alert. -1 is not a valid input. NOTE Much more needs to be said about this function and its implications. SEE ALSO exec/alerts.h exec.library/AllocAbs exec.library/AllocAbs NAME AllocAbs -- allocate at a given location SYNOPSIS memoryBlock = AllocAbs(byteSize, location) D0 D0 A1 void *AllocAbs(ULONG, APTR); FUNCTION This function attempts to allocate memory at a given absolute memory location. Often this is used by boot-surviving entities such as recoverable ram-disks. If the memory is already being used, or if there is not enough memory to satisfy the request, AllocAbs will return NULL. This block may not be exactly the same as the requested block because of rounding, but if the return value is non-zero, the block is guaranteed to contain the requested range. INPUTS byteSize - the size of the desired block in bytes This number is rounded up to the next larger block size for the actual allocation. location - the address where the memory MUST be. RESULT memoryBlock - a pointer to the newly allocated memory block, or NULL if failed. NOTE If the free list is corrupt, the system will panic with alert AN_MemCorrupt, $01000005. The 8 bytes past the end of an AllocAbs will be changed by Exec relinking the next block of memory. Generally you can't trust the first 8 bytes of anything you AllocAbs. SEE ALSO AllocMem, FreeMem exec.library/Allocate exec.library/Allocate NAME Allocate - allocate a block of memory SYNOPSIS memoryBlock=Allocate(memHeader, byteSize) D0 A0 D0 void *Allocate(struct MemHeader *, ULONG); FUNCTION This function is used to allocate blocks of memory from a given private free memory pool (as specified by a MemHeader and its memory chunk list). Allocate will return the first free block that is greater than or equal to the requested size. All blocks, whether free or allocated, will be block aligned; hence, all allocation sizes are rounded up to the next block even value (e.g. the minimum allocation resolution is currently 8 bytes. A request for 8 bytes will use up exactly 8 bytes. A request for 7 bytes will also use up exactly 8 bytes.). This function can be used to manage an application's internal data memory. Note that no arbitration of the MemHeader and associated free chunk list is done. You must be the owner before calling Allocate. INPUTS memHeader - points to the local memory list header. byteSize - the size of the desired block in bytes. RESULT memoryBlock - a pointer to the just allocated free block. If there are no free regions large enough to satisfy the request, return zero. EXAMPLE #include #include void *AllocMem(); #define BLOCKSIZE 4096L /* Or whatever you want */ void main() { struct MemHeader *mh; struct MemChunk *mc; APTR block1; APTR block2; /* Get the MemHeader needed to keep track of our new block */ mh = (struct MemHeader *) AllocMem((long)sizeof(struct MemHeader), MEMF_CLEAR ); if( !mh ) exit(10); /* Get the actual block the above MemHeader will manage */ mc = (struct MemChunk *)AllocMem( BLOCKSIZE, 0L ); if( !mc ) { FreeMem( mh, (long)sizeof(struct MemHeader) ); exit(10); } mh->mh_Node.ln_Type = NT_MEMORY; mh->mh_Node.ln_Name = "myname"; mh->mh_First = mc; mh->mh_Lower = (APTR) mc; mh->mh_Upper = (APTR) ( BLOCKSIZE + (ULONG) mc ); mh->mh_Free = BLOCKSIZE; /* Set up first chunk in the freelist */ mc->mc_Next = NULL; mc->mc_Bytes = BLOCKSIZE; block1 = (APTR) Allocate( mh, 20L ); block2 = (APTR) Allocate( mh, 314L ); printf("mh=$%lx mc=$%lx\n",mh,mc); printf("Block1=$%lx, Block2=$%lx\n",block1,block2); FreeMem( mh, (long)sizeof(struct MemHeader) ); FreeMem( mc, BLOCKSIZE ); } NOTE If the free list is corrupt, the system will panic with alert AN_MemCorrupt, $01000005. SEE ALSO Deallocate, exec/memory.h exec.library/AllocEntry exec.library/AllocEntry NAME AllocEntry -- allocate many regions of memory SYNOPSIS memList = AllocEntry(memList) D0 A0 struct MemList *AllocEntry(struct MemList *); FUNCTION This function takes a memList structure and allocates enough memory to hold the required memory as well as a MemList structure to keep track of it. These MemList structures may be linked together in a task control block to keep track of the total memory usage of this task. (See the description of TC_MEMENTRY under RemTask). INPUTS memList -- A MemList structure filled in with MemEntry structures. RESULTS memList -- A different MemList filled in with the actual memory allocated in the me_Addr field, and their sizes in me_Length. If enough memory cannot be obtained, then the requirements of the allocation that failed is returned and bit 31 is set. WARNING: The result is unusual! Bit 31 indicates faulure. EXAMPLES The user wants five regions of 2, 4, 8, 16, and 32 bytes in size with requirements of MEMF_CLEAR, MEMF_PUBLIC, MEMF_CHIP!MEMF_CLEAR, MEMF_CLEAR, and MEMF_PUBLIC!MEMF_CLEAR respectively. The following code fragment would do that: MemListDecl: DS.B LN_SIZE * reserve space for list node DC.W 5 * number of entries DC.L MEMF_CLEAR * entry #0 DC.L 2 DC.L MEMF_PUBLIC * entry #1 DC.L 4 DC.L MEMF_CHIP!MEMF_CLEAR * entry #2 DC.L 8 DC.L MEMF_CLEAR * entry #3 DC.L 16 DC.L MEMF_PUBLIC!MEMF_CLEAR * entry #4 DC.L 32 start: LEA.L MemListDecl(PC),A0 JSR _LVOAllocEntry(a6) BCLR.L #31,D0 BEQ.S success ------- Type of memory that we failed on is in D0 BUGS If any one of the allocations fails, this function fails to back out fully. This is fixed by the "SetPatch" program on V1.3 Workbench disks. SEE ALSO exec/memory.h exec.library/AllocMem exec.library/AllocMem NAME AllocMem -- allocate memory given certain requirements SYNOPSIS memoryBlock = AllocMem(byteSize, attributes) D0 D0 D1 void *AllocMem(ULONG, ULONG); FUNCTION This is the memory allocator to be used by system code and applications. It provides a means of specifying that the allocation should be made in a memory area accessible to the chips, or accessible to shared system code. Memory is allocated based on requirements and options. Any "requirement" must be met by a memory allocation, any "option" will be applied to the block regardless. AllocMem will try all memory spaces until one is found with the proper requirements and room for the memory request. INPUTS byteSize - the size of the desired block in bytes. (The operating system will automatically round this number to a multiple of the system memory chunk size) attributes - requirements If no flags are set, the system will return the best available memory block. For expanded systems, the fast memory pool is searched first. MEMF_CHIP: If the requested memory will be used by the Amiga custom chips, this flag *must* be set. Only certain parts of memory are reachable by the special chip sets' DMA circuitry. Chip DMA includes screen memory, images that are blitted, audio data, copper lists, sprites and Pre-V36 trackdisk.device buffers. MEMF_FAST: This is non-chip memory. If no flag is set MEMF_FAST is taken as the default. DO NOT SPECIFY MEMF_FAST unless you know exactly what you are doing! If MEMF_FAST is set, AllocMem() will fail on machines that only have chip memory! This flag may not be set when MEMF_CHIP is set. MEMF_PUBLIC: Memory that must not be mapped, swapped, or otherwise made non-addressable. ALL MEMORY THAT IS REFERENCED VIA INTERRUPTS AND/OR BY OTHER TASKS MUST BE EITHER PUBLIC OR LOCKED INTO MEMORY! This includes both code and data. MEMF_LOCAL: This is memory that will not go away after the CPU RESET instruction. Normally, autoconfig memory boards become unavailable after RESET while motherboard memory may still be available. This memory type is now automatically set in V36. Pre-V36 systems may not have this memory type and AllocMem() will then fail. MEMF_24BITDMA: This is memory that is within the address range of 24-bit DMA devices. (Zorro-II) This is required if you run a Zorro-II DMA device on a machine that has memory beyond the 24-bit addressing limit of Zorro-II. This memory type is now automatically set in V36. Pre-V36 systems may not have this memory type and AllocMem() will then fail. options MEMF_CLEAR: The memory will be initialized to all zeros. MEMF_REVERSE: This allocates memory from the top of the memory pool. It searches the pools in the same order, such that FAST memory will be found first. However, the memory will be allocated from the highest address available in the pool. This option is new as of V36. RESULT memoryBlock - a pointer to the newly allocated memory block. If there are no free memory regions large enough to satisfy the request, zero will be returned. The pointer must be checked for zero before the memory block may be used! WARNING The result of any memory allocation MUST be checked, and a viable error handling path taken. ANY allocation may fail if memory has been filled. EXAMPLES AllocMem(64,0L) - Allocate the best available memory AllocMem(25,MEMF_CLEAR) - Allocate the best available memory, and clear it before returning. AllocMem(128,MEMF_CHIP) - Allocate chip memory AllocMem(128,MEMF_CHIP|MEMF_CLEAR) - Allocate cleared chip memory AllocMem(821,MEMF_CHIP|MEMF_PUBLIC|MEMF_CLEAR) - Allocate cleared, public, chip memory. NOTE If the free list is corrupt, the system will panic with alert AN_MemCorrupt, $01000005. This function may not be called from interrupts. A DOS process will have its pr_Result2 field set to ERROR_NO_FREE_STORE if the memory allocation fails. SEE ALSO FreeMem exec.library/AllocSignal exec.library/AllocSignal NAME AllocSignal -- allocate a signal bit SYNOPSIS signalNum = AllocSignal(signalNum) D0 D0 BYTE AllocSignal(BYTE); FUNCTION Allocate a signal bit from the current tasks' pool. Either a particular bit, or the next free bit may be allocated. The signal associated with the bit will be properly initialized (cleared). At least 16 user signals are available per task. Signals should be deallocated before the task exits. If the signal is already in use (or no free signals are available) a -1 is returned. Allocated signals are only valid for use with the task that allocated them. WARNING Signals may not be allocated or freed from exception handling code. INPUTS signalNum - the desired signal number {of 0..31} or -1 for no preference. RESULTS signalNum - the signal bit number allocated {0..31}. If no signals are available, this function returns -1. SEE ALSO FreeSignal exec.library/AllocTrap exec.library/AllocTrap NAME AllocTrap -- allocate a processor trap vector SYNOPSIS trapNum = AllocTrap(trapNum) D0 D0 LONG AllocTrap(LONG); FUNCTION Allocate a trap number from the current task's pool. These trap numbers are those associated with the 68000 TRAP type instructions. Either a particular number, or the next free number may be allocated. If the trap is already in use (or no free traps are available) a -1 is returned. This function only affects the currently running task. Traps are sent to the trap handler pointed at by tc_TrapCode. Unless changed by user code, this points to a standard trap handler. The stack frame of the exception handler will be: 0(SP) = Exception vector number. This will be in the range of 32 to 47 (corresponding to the Trap #1...Trap #15 instructions). 4(SP) = 68000/68010/68020/68030, etc. exception frame tc_TrapData is not used. WARNING Traps may not be allocated or freed from exception handling code. You are not allowed to write to the exception table yourself. In fact, on some machines you will have trouble finding it - the VBR register may be used to remap its location. INPUTS trapNum - the desired trap number {of 0..15} or -1 for no preference. RESULTS trapNum - the trap number allocated {of 0..15}. If no traps are available, this function returns -1. Instructions of the form "Trap #trapNum" will be sent to the task's trap handler. SEE ALSO FreeTrap exec.library/AllocVec exec.library/AllocVec NAME AllocVec -- allocate memory and keep track of the size (V36) SYNOPSIS memoryBlock = AllocVec(byteSize, attributes) D0 D0 D1 void *AllocVec(ULONG, ULONG); FUNCTION This function works identically to AllocMem(), but tracks the size of the allocation. See the AllocMem() documentation for details. WARNING The result of any memory allocation MUST be checked, and a viable error handling path taken. ANY allocation may fail if memory has been filled. SEE ALSO FreeVec, AllocMem exec.library/AttemptSemaphore exec.library/AttemptSemaphore NAME AttemptSemaphore -- try to obtain without blocking SYNOPSIS success = AttemptSemaphore(signalSemaphore) D0 A0 LONG AttemptSemaphore(struct SignalSemaphore *); FUNCTION This call is similar to ObtainSemaphore(), except that it will not block if the semaphore could not be locked. INPUT signalSemaphore -- an initialized signal semaphore structure RESULT success -- TRUE if the semaphore was locked, false if some other task already possessed the semaphore. NOTE This call does NOT preserve registers. SEE ALSO ObtainSemaphore() ObtainSemaphoreShared(), ReleaseSemaphore(), exec/semaphores.h exec.library/AvailMem exec.library/AvailMem NAME AvailMem -- memory available given certain requirements SYNOPSIS size = AvailMem(attributes) D0 D1 ULONG AvailMem(ULONG); FUNCTION This function returns the amount of free memory given certain attributes. To find out what the largest block of a particular type is, add MEMF_LARGEST into the requirements argument. Returning the largest block is a slow operation. WARNING Due to the effect of multitasking, the value returned may not actually be the amount of free memory available at that instant. INPUTS requirements - a requirements mask as specified in AllocMem. Any of the AllocMem bits are valid, as is MEMF_LARGEST which returns the size of the largest block matching the requirements. RESULT size - total free space remaining (or the largest free block). NOTE For V36 Exec, AvailMem(MEMF_LARGEST) does a consistency check on the memory list. Alert AN_MemoryInsane will be pulled if any mismatch is noted. EXAMPLE AvailMem(MEMF_CHIP|MEMF_LARGEST); /* return size of largest available chip memory chunk */ SEE ALSO exec/memory.h exec.library/CacheClearE exec.library/CacheClearE NAME CacheClearE - Cache clearing with extended control (V37) SYNOPSIS CacheClearE(address,length,caches) a0 d0 d1 void CacheClearE(APTR,ULONG,ULONG); FUNCTION Flush out the contents of the CPU instruction and/or data caches. If dirty data cache lines are present, push them to memory first. Motorola CPUs have separate instruction and data caches. A data write does not update the instruction cache. If an instruction is written to memory or modified, the old instruction may still exist in the cache. Before attempting to execute the code, a flush of the instruction cache is required. For most systems, the data cache is not updated by Direct Memory Access (DMA), or if some external factor changes shared memory. Caches must be cleared after *any* operation that could cause invalid or stale data. The most common cases are DMA and modifying instructions using the processor. Some examples: Self modifying code Building Jump tables Run-time code patches Relocating code for use at different addresses. Loading code from disk INPUTS address - Address to start the operation. This may be rounded due to hardware granularity. length - Length of area to be cleared, or $FFFFFFFF to indicate all addresses should be cleared. caches - Bit flags to indicate what caches to affect. The current supported flags are: CACRF_ClearI ;Clear instruction cache CACRF_ClearD ;Clear data cache All other bits are reserved for future definition. NOTES On systems with a copyback mode cache, any dirty data is pushed to memory as a part of this operation. Regardless of the length given, the function will determine the most efficient way to implement the operation. For some cache systems, including the 68030, the overhead partially clearing a cache is often too great. The entire cache may be cleared. For all current Amiga models, Chip memory is set with Instruction caching enabled, data caching disabled. This prevents coherency conflicts with the blitter or other custom chip DMA. Custom chip registers are marked as non-cacheable by the hardware. The system takes care of appropriately flushing the caches for normal operations. The instruction cache is cleared by all calls that modify instructions, including LoadSeg(), MakeLibrary() and SetFunction(). SEE ALSO exec/execbase.i, CacheControl, CacheClearU exec.library/CacheClearU exec.library/CacheClearU NAME CacheClearU - User callable simple cache clearing (V37) SYNOPSIS CacheClearU() void CacheClearU(void); FUNCTION Flush out the contents of any CPU instruction and data caches. If dirty data cache lines are present, push them to memory first. Caches must be cleared after *any* operation that could cause invalid or stale data. The most common cases are DMA and modifying instructions using the processor. See the CacheClearE() autodoc for a more complete description. Some examples of when the cache needs clearing: Self modifying code Building Jump tables Run-time code patches Relocating code for use at different addresses. Loading code from disk SEE ALSO exec/execbase.i, CacheControl, CacheClearE exec.library/CacheControl exec.library/CacheControl NAME CacheControl - Instruction & data cache control SYNOPSIS oldBits = CacheControl(cacheBits,cacheMask) D0 D0 D1 ULONG CacheControl(ULONG,ULONG); FUNCTION This function provides global control of any instruction or data caches that may be connected to the system. All settings are global -- per task control is not provided. The action taken by this function will depend on the type of CPU installed. This function may be patched to support external caches, or different cache architectures. In all cases the function will attempt to best emulate the provided settings. Use of this function may save state specific to the caches involved. The list of supported settings is provided in the exec/execbase.i include file. The bits currently defined map directly to the Motorola 68030 CPU CACR register. Alternate cache solutions may patch into the Exec cache functions. Where possible, bits will be interpreted to have the same meaning on the installed cache. INPUTS cacheBits - new values for the bits specified in cacheMask. cacheMask - a mask with ones for all bits to be changed. RESULT oldBits - the complete prior values for all settings. NOTE As a side effect, this function clears all caches. SEE ALSO exec/execbase.i, CacheClearU, CacheClearE exec.library/CachePostDMA exec.library/CachePostDMA NAME CachePostDMA - Take actions after to hardware DMA (V37) SYNOPSIS CachePostDMA(vaddress,&length,flags) a0 a1 d0 CachePostDMA(APTR,LONG *,ULONG); FUNCTION Take all appropriate steps after Direct Memory Access (DMA). This function is primarily intended for writers of DMA device drivers. The action will depend on the CPU type installed, caching modes, and the state of any Memory Management Unit (MMU) activity. As implemented 68000 - Do nothing 68010 - Do nothing 68020 - Do nothing 68030 - Flush the data cache 68040 - Flush matching areas of the data cache ????? - External cache boards, Virtual Memory Systems, or future hardware may patch this vector to best emulate the intended behavior. With a Bus-Snooping CPU, this function my end up doing nothing. INPUTS address - Same as initially passed to CachePreDMA length - Same as initially passed to CachePreDMA flags - Values: DMA_NoModify - If the area was not modified (and thus there is no reason to flush the cache) set this bit. SEE ALSO exec/execbase.i, CachePreDMA, CacheClearU, CacheClearE exec.library/CachePreDMA exec.library/CachePreDMA NAME CachePreDMA - Take actions prior to hardware DMA (V37) SYNOPSIS paddress = CachePreDMA(vaddress,&length,flags) d0 a0 a1 d0 APTR CachePreDMA(APTR,LONG *,ULONG); FUNCTION Take all appropriate steps before Direct Memory Access (DMA). This function is primarily intended for writers of DMA device drivers. The action will depend on the CPU type installed, caching modes, and the state of any Memory Management Unit (MMU) activity. This function supports advanced cache architectures that have "copyback" modes. With copyback, write data may be cached, but not actually flushed out to memory. If the CPU has unflushed data at the time of DMA, data may be lost. As implemented 68000 - Do nothing 68010 - Do nothing 68020 - Do nothing 68030 - Do nothing 68040 - Write any matching dirty cache lines back to memory. As a side effect of the 68040's design, matching data cache lines are also invalidated -- future CPUs may be different. ????? - External cache boards, Virtual Memory Systems, or future hardware may patch this vector to best emulate the intended behavior. With a Bus-Snooping CPU, this function my end up doing nothing. INPUTS address - Base address to start the action. length - Pointer to a longword with a length. flags - Values: DMA_Continue - Indicates this call is to complete a prior request that was broken up. RESULTS paddress- Physical address that coresponds to the input virtual address. &length - This length value will be updated to reflect the contiguous length of physical memory present at paddress. This may be smaller than the requested length. To get the mapping for the next chunk of memory, call the function again with a new address, length, and the DMA_Continue flag. NOTE Due to processor granularity, areas outside of the address range may be affected by the cache flushing actions. Care has been taken to ensure that no harm is done outside the range, and that activities on overlapping cache lines won't harm data. SEE ALSO exec/execbase.i, CachePostDMA, CacheClearU, CacheClearE exec.library/Cause exec.library/Cause NAME Cause -- cause a software interrupt SYNOPSIS Cause(interrupt) A1 void Cause(struct Interrupt *); FUNCTION This function causes a software interrupt to occur. If it is called from user mode (and processor level 0), the software interrupt will preempt the current task. This call is often used by high-level hardware interrupts to defer medium-length processing down to a lower interrupt level. Note that a software interrupt is still a real interrupt, and must obey the same restrictions on what system function it may call. Currently only 5 software interrupt priorities are implemented: -32, -16, 0, +16, and +32. Priorities in between are truncated, values outside the -32/+32 range are not allowed. NOTE When setting up the Interrupt structure, set the node type to NT_INTERRUPT, or NT_UNKOWN. IMPLEMENTATION 1> Checks if the node type is NT_SOFTINT. If so does nothing since the softint is already pending. No nest count is maintained. 2> Sets the node type to NT_SOFTINT. 3> Links into one of the 5 priority queues. 4> Pokes the hardware interrupt bit used for softints. The node type returns to NT_INTERRUPT after removal from the list. INPUTS interrupt - pointer to a properly initialized interrupt node BUGS Unlike other Interrupts, SoftInts must preserve the value of A6. exec.library/CheckIO exec.library/CheckIO NAME CheckIO -- get the status of an IORequest SYNOPSIS result = CheckIO(iORequest) D0 A1 BOOL CheckIO(struct IORequest *); FUNCTION This function determines the current state of an I/O request and returns FALSE if the I/O has not yet completed. This function effectively hides the internals of the I/O completion mechanism. CheckIO() will NOT remove the returned IORequest from the reply port. This is best performed with WaitIO(). If the request has already completed, WaitIO() will return quickly. Use of the Remove() function is dangerous, since other tasks may still be adding things to your message port; a Disable() would be required. This function should NOT be used to busy loop (looping until IO is complete). WaitIO() is provided for that purpose. INPUTS iORequest - pointer to an I/O request block RESULTS result - NULL if I/O is still in progress. Otherwise D0 points to the IORequest block. NOTE CheckIO can hang if called on an IORequest that has never been used. This occurs if LN_TYPE of the IORequest is set to "NT_MESSAGE". Instead simply set LN_TYPE to 0. SEE ALSO DoIO, SendIO, WaitIO, AbortIO exec.library/CloseDevice exec.library/CloseDevice NAME CloseDevice -- conclude access to a device SYNOPSIS CloseDevice(iORequest) A1 void CloseDevice(struct IORequest *); FUNCTION This function informs the device that access to a device/unit previously opened has been concluded. The device may perform certain house-cleaning operations. The user must ensure that all outstanding IORequests have been returned before closing the device. The AbortIO function can kill any stragglers. After a close, the I/O request structure is free to be reused. Starting with V36 exec it is safe to CloseDevice() with an IORequest that is either cleared to zeros, or failed to open. INPUTS iORequest - pointer to an I/O request structure SEE ALSO OpenDevice exec.library/CloseLibrary exec.library/CloseLibrary NAME CloseLibrary -- conclude access to a library SYNOPSIS CloseLibrary(library) A1 void CloseLibrary(struct Library *); FUNCTION This function informs the system that access to the given library has been concluded. The user must not reference the library or any function in the library after this close. Starting with V36, it is safe to pass a NULL instead of a library pointer. INPUTS library - pointer to a library node NOTE Library writers must pass a SegList pointer or NULL back from their open point. This value is used by the system, and not visible as a return code from CloseLibrary. SEE ALSO OpenLibrary exec.library/ColdReboot exec.library/ColdReboot NAME ColdReboot - reboot the Amiga (V36) SYNOPSIS ColdReboot() void ColdReboot(void); FUNCTION Reboot the machine. All external memory and periperals will be RESET, and the machine will start its power up diagnostics. This function never returns. INPUT A chaotic pile of disoriented bits. RESULTS An altogether totally integrated living system. exec.library/CopyMem exec.library/CopyMem NAME CopyMem - general purpose memory copy function SYNOPSIS CopyMem( source, dest, size ) A0 A1 D0 void CopyMem(APTR,APTR,ULONG); FUNCTION CopyMem is a general purpose, fast memory copy function. It can deal with arbitrary lengths, with its pointers on arbitrary alignments. It attempts to optimize larger copies with more efficient copies, it uses byte copies for small moves, parts of larger copies, or the entire copy if the source and destination are misaligned with respect to each other. Arbitrary overlapping copies are not supported. The internal implementation of this function will change from system to system, and may be implemented via hardware DMA. INPUTS source - a pointer to the source data region dest - a pointer to the destination data region size - the size (in bytes) of the memory area. Zero copies zero bytes SEE ALSO CopyMemQuick exec.library/CopyMemQuick exec.library/CopyMemQuick NAME CopyMemQuick - optimized memory copy function SYNOPSIS CopyMemQuick( source, dest, size ) A0 A1 D0 void CopyMemQuick(ULONG *,ULONG *,ULONG); FUNCTION CopyMemQuick is a highly optimized memory copy function, with restrictions on the size and alignment of its arguments. Both the source and destination pointers must be longword aligned. In addition, the size must be an integral number of longwords (e.g. the size must be evenly divisible by four). Arbitrary overlapping copies are not supported. The internal implementation of this function will change from system to system, and may be implemented via hardware DMA. INPUTS source - a pointer to the source data region, long aligned dest - a pointer to the destination data region, long aligned size - the size (in bytes) of the memory area. Zero copies zero bytes. SEE ALSO CopyMem exec.library/CreateIORequest exec.library/CreateIORequest NAME CreateIORequest() -- create an IORequest structure (V36) SYNOPSIS ioReq = CreateIORequest( ioReplyPort, size ); A0 D0 struct IORequest *CreateIORequest(struct MsgPort *, ULONG); FUNCTION Allocates memory for and initializes a new IO request block of a user-specified number of bytes. The number of bytes must be at least as large as a "struct Message". INPUTS ioReplyPort - Pointer to a port for replies (an initialized message port, as created by CreateMsgPort() ). If NULL, this function fails. size - the size of the IO request to be created. RESULT ioReq - A pointer to the new IORequest block, or NULL. SEE ALSO DeleteIORequest, CreateMsgPort(), amiga.lib/CreateExtIO() exec.library/CreateMsgPort exec.library/CreateMsgPort NAME CreateMsgPort - Allocate and initialize a new message port (V36) SYNOPSIS CreateMsgPort() struct MsgPort * CreateMsgPort(void); FUNCTION Allocates and initializes a new message port. The message list of the new port will be prepared for use (via NewList). A signal bit will be allocated, and the port will be set to signal your task when a message arrives (PA_SIGNAL). You *must* use DeleteMsgPort() to delete ports created with CreateMsgPort()! RESULT MsgPort - A new MsgPort structure ready for use, or NULL if out of memory or signals. If you wish to add this port to the public port list, fill in the ln_Name and ln_Pri fields, then call AddPort(). Don't forget RemPort()! SEE ALSO DeleteMsgPort(), exec/AddPort(), exec/ports.h, amiga.lib/CreatePort() exec.library/Deallocate exec.library/Deallocate NAME Deallocate -- deallocate a block of memory SYNOPSIS Deallocate(memHeader, memoryBlock, byteSize) A0 A1 D0 void Deallocate(struct MemHeader *,APTR,ULONG); FUNCTION This function deallocates memory by returning it to the appropriate private free memory pool. This function can be used to free an entire block allocated with the above function, or it can be used to free a sub-block of a previously allocated block. Sub-blocks must be an even multiple of the memory chunk size (currently 8 bytes). This function can even be used to add a new free region to an existing MemHeader, however the extent pointers in the MemHeader will no longer be valid. If memoryBlock is not on a block boundary (MEM_BLOCKSIZE) then it will be rounded down in a manner compatible with Allocate(). Note that this will work correctly with all the memory allocation functions, but may cause surprises if one is freeing only part of a region. The size of the block will be rounded up, so the freed block will fill to an even memory block boundary. INPUTS memHeader - points to the memory header this block is part of. memoryBlock - address of memory block to free. byteSize - the size of the block in bytes. If NULL, nothing happens. SEE ALSO Allocate, exec/memory.h exec.library/Debug exec.library/Debug NAME Debug -- run the system debugger SYNOPSIS Debug(flags) D0 void Debug(ULONG); FUNCTION This function calls the system debugger. By default this debugger is "ROM-WACK". Other debuggers are encouraged to take over this entry point (via SetFunction()) so that when an application calls Debug(), the alternative debugger will get control. Currently a zero is passed to allow future expansion. NOTE The Debug() call may be made when the system is in a questionable state; if you have a SetFunction() patch, make few assumptions, be prepared for Supervisor mode, and be aware of differences in the Motorola stack frames on the 68000,'10,'20, and '30. SEE ALSO SetFunction your favorite debugger's manual the ROM-WACK chapter of the ROM Kernel Manual exec.library/DeleteIORequest exec.library/DeleteIORequest NAME DeleteIORequest() - Free a request made by CreateIORequest() (V36) SYNOPSIS DeleteIORequest( ioReq ); a0 void DeleteIORequest(struct IORequest *); FUNCTION Frees up an IO request as allocated by CreateIORequest(). INPUTS ioReq - A pointer to the IORequest block to be freed, or NULL. This function uses the mn_Length field to determine how much memory to free. SEE ALSO CreateIORequest(), amiga.lib/DeleteExtIO() exec.library/DeleteMsgPort exec.library/DeleteMsgPort NAME DeleteMsgPort - Free a message port created by CreateMsgPort (V36) SYNOPSIS DeleteMsgPort(msgPort) a0 void DeleteMsgPort(struct MsgPort *); FUNCTION Frees a message port created by CreateMsgPort(). All messages that may have been attached to this port must have already been replied to. INPUTS msgPort - A message port. NULL for no action. SEE ALSO CreateMsgPort(), amiga.lib/DeletePort() exec.library/Disable exec.library/Disable NAME Disable -- disable interrupt processing. SYNOPSIS Disable(); void Disable(void); FUNCTION Prevents interrupts from being handled by the system, until a matching Enable() is executed. Disable() implies Forbid(). DO NOT USE THIS CALL WITHOUT GOOD JUSTIFICATION. THIS CALL IS VERY DANGEROUS! RESULTS All interrupt processing is deferred until the task executing makes a call to Enable() or is placed in a wait state. Normal task rescheduling does not occur while interrupts are disabled. In order to restore normal interrupt processing, the programmer must execute exactly one call to Enable() for every call to Disable(). IMPORTANT REMINDER: It is important to remember that there is a danger in using disabled sections. Disabling interrupts for more than ~250 microseconds will prevent vital system functions (especially serial I/0) from operating in a normal fashion. Think twice before using Disable(), then think once more. After all that, think again. With enough thought, the need for a Disable() can often be eliminated. For the user of many device drivers, a write to disable *only* the particular interrupt of interest can replace a Disable(). For example: MOVE.W #INTF_PORTS,_intena Do not use a macro for Disable(), insist on the real thing. This call may be made from interrupts, it will have the effect of locking out all higher-level interrupts (lower-level interrupts are automatically disabled by the CPU). Note: In the event of a task entering a Wait() after disabling interrupts, the system "breaks" the disabled state and runs normally until the task which called Disable() is rescheduled. NOTE This call is guaranteed to preserve all registers. SEE ALSO Forbid, Permit, Enable exec.library/DoIO exec.library/DoIO NAME DoIO -- perform an I/O command and wait for completion SYNOPSIS error = DoIO(iORequest) D0 A1 BYTE DoIO(struct IORequest *); FUNCTION This function requests a device driver to perform the I/O command specified in the I/O request. This function will always wait until the I/O request is fully complete. DoIO() handles all the details, including Quick I/O, waiting for the request, and removing the reply message, etc.. IMPLEMENTATION This function first tries to complete the IO via the "Quick I/O" mechanism. The io_Flags field is always set to IOF_QUICK (0x01) before the internal device call. The LN_TYPE field is used internally to flag completion. Active requests have type NT_MESSAGE. Requests that have been replied have type NT_REPLYMSG. It is illegal to start IO using a still active IORequest, or a request with type NT_REPLYMSG. INPUTS iORequest - pointer to an IORequest initialized by OpenDevice() RESULTS error - a sign-extended copy of the io_Error field of the IORequest. Most device commands require that the error return be checked. SEE ALSO SendIO, CheckIO, WaitIO, AbortIO, amiga.lib/BeginIO exec.library/Enable exec.library/Enable NAME Enable -- permit system interrupts to resume. SYNOPSIS Enable(); void Enable(void); FUNCTION Allow system interrupts to again occur normally, after a matching Disable() has been executed. RESULTS Interrupt processing is restored to normal operation. The programmer must execute exactly one call to Enable() for every call to Disable(). NOTE This call is guaranteed to preserve all registers. SEE ALSO Forbid, Permit, Disable exec.library/Enqueue exec.library/Enqueue NAME Enqueue -- insert or append node to a system queue SYNOPSIS Enqueue(list, node) A0 A1 void Enqueue(struct List *, struct Node *); FUNCTION Insert or append a node into a system queue. The insert is performed based on the node priority -- it will keep the list properly sorted. New nodes will be inserted in front of the first node with a lower priority. Hence a FIFO queue for nodes of equal priority WARNING This function does not arbitrate for access to the list. The calling task must be the owner of the involved list. INPUTS list - a pointer to the system queue header node - the node to enqueue. This must be a full featured list with type, priority and name fields. SEE ALSO AddHead, AddTail, Insert, Remove, RemHead, RemTail exec.library/FindName exec.library/FindName NAME FindName -- find a system list node with a given name SYNOPSIS node = FindName(start, name) D0,Z A0 A1 struct Node *FindName(struct List *, STRPTR); FUNCTION Traverse a system list until a node with the given name is found. To find multiple occurrences of a string, this function may be called with a node starting point. No arbitration is done for access to the list! If multiple tasks access the same list, an arbitration mechanism such as SignalSemaphores must be used. INPUTS start - a list header or a list node to start the search (if node, this one is skipped) name - a pointer to a name string terminated with NULL RESULTS node - a pointer to the node with the same name else zero to indicate that the string was not found. exec.library/FindPort exec.library/FindPort NAME FindPort -- find a given system message port SYNOPSIS port = FindPort(name) D0 A1 struct MsgPort *FindPort(STRPTR); FUNCTION This function will search the system message port list for a port with the given name. The first port matching this name will be returned. No arbitration of the port list is done. This function MUST be protected with A Forbid()/Permit() pair! EXAMPLE #include struct MsgPort *FindPort(); ULONG SafePutToPort(message, portname) struct Message *message; STRPTR portname; { struct MsgPort *port; Forbid(); port = FindPort(portname); if (port) PutMsg(port,message); Permit(); return((ULONG)port); /* If zero, the port has gone away */ } INPUT name - name of the port to find RETURN port - a pointer to the message port, or zero if not found. exec.library/FindResident exec.library/FindResident NAME FindResident - find a resident module by name SYNOPSIS resident = FindResident(name) D0 A1 struct Resident *FindResident(STRPTR); FUNCTION Search the system resident tag list for a resident tag ("ROMTag") with the given name. If found return a pointer to the resident tag structure, else return zero. Resident modules are used by the system to pull all its parts together at startup. Resident tags are also found in disk based devices and libraries. INPUTS name - pointer to name string RESULT resident - pointer to the resident tag structure or zero if none found. SEE ALSO exec/resident.h, InitResident exec.library/FindSemaphore exec.library/FindSemaphore NAME FindSemaphore -- find a given system signal semaphore SYNOPSIS signalSemaphore = FindSemaphore(name) D0 A1 struct SignalSemaphore *FindSemaphore(STRPTR); FUNCTION This function will search the system signal semaphore list for a semaphore with the given name. The first semaphore matching this name will be returned. This function does not arbitrate for access to the semaphore list, surround the call with a Forbid()/Permit() pair. INPUT name - name of the semaphore to find RESULT semaphore - a pointer to the signal semaphore, or zero if not found. exec.library/FindTask exec.library/FindTask NAME FindTask -- find a task with the given name or find oneself SYNOPSIS task = FindTask(name) D0 A1 struct Task *FindTask(STRPTR); FUNCTION This function will check all task queues for a task with the given name, and return a pointer to its task control block. If a NULL name pointer is given a pointer to the current task will be returned. Finding oneself with a NULL for the name is very quick. Finding a task by name is very system expensive, and will disable interrupts for a long time. Since a task may remove itself at any time, a Forbid()/Permit() pair may be needed to ensure the pointer returned by FindTask() is still valid when used. INPUT name - pointer to a name string RESULT task - pointer to the task (or Process) exec.library/Forbid exec.library/Forbid NAME Forbid -- forbid task rescheduling. SYNOPSIS Forbid() void Forbid(void); FUNCTION Prevents other tasks from being scheduled to run by the dispatcher, until a matching Permit() is executed, or this task is scheduled to Wait(). Interrupts are NOT disabled. DO NOT USE THIS CALL WITHOUT GOOD JUSTIFICATION. THIS CALL IS DANGEROUS! RESULTS The current task will not be rescheduled as long as it is ready to run. In the event that the current task enters a wait state, other tasks may be scheduled. Upon return from the wait state, the original task will continue to run without disturbing the Forbid(). Calls to Forbid() nest. In order to restore normal task rescheduling, the programmer must execute exactly one call to Permit() for every call to Forbid(). WARNING In the event of a task entering a Wait() after a Forbid(), the system "breaks" the forbidden state and runs normally until the task which called Forbid() is rescheduled. If caution is not taken, this can cause subtle bugs, since any device or DOS call will (in effect) cause your task to wait. Forbid() is not useful or safe from within interrupt code (All interrupts are always higher priority than tasks, and interrupts are allowed to break a Forbid()). NOTE This call is guaranteed to preserve all registers. SEE ALSO Permit, Disable, ObtainSemaphore, ObtainSemaphoreShared exec.library/FreeEntry exec.library/FreeEntry NAME FreeEntry -- free many regions of memory SYNOPSIS FreeEntry(memList) A0 void FreeEntry(struct MemList *); FUNCTION This function takes a memList structure (as returned by AllocEntry) and frees all the entries. INPUTS memList -- pointer to structure filled in with MemEntry structures SEE ALSO AllocEntry exec.library/FreeMem exec.library/FreeMem NAME FreeMem -- deallocate with knowledge SYNOPSIS FreeMem(memoryBlock, byteSize) A1 D0 void FreeMem(void *,ULONG); FUNCTION Free a region of memory, returning it to the system pool from which it came. Freeing partial blocks back into the system pool is unwise. NOTE If a block of memory is freed twice, the system will Guru. The Alert is AN_FreeTwice ($01000009). If you pass the wrong pointer, you will probably see AN_MemCorrupt $01000005. Future versions may add more sanity checks to the memory lists. INPUTS memoryBlock - pointer to the memory block to free byteSize - the size of the desired block in bytes. (The operating system will automatically round this number to a multiple of the system memory chunk size) SEE ALSO AllocMem exec.library/FreeSignal exec.library/FreeSignal NAME FreeSignal -- free a signal bit SYNOPSIS FreeSignal(signalNum) D0 void FreeSignal(BYTE); FUNCTION This function frees a previously allocated signal bit for reuse. This call must be performed while running in the same task in which the signal was allocated. WARNING Signals may not be allocated or freed from exception handling code. NOTE Starting with V37, an attempt to free signal -1 is harmless. INPUTS signalNum - the signal number to free {0..31}. exec.library/FreeTrap exec.library/FreeTrap NAME FreeTrap -- free a processor trap SYNOPSIS FreeTrap(trapNum) D0 void FreeTrap(ULONG); FUNCTION This function frees a previously allocated trap number for reuse. This call must be performed while running in the same task in which the trap was allocated. WARNING Traps may not be allocated or freed from exception handling code. INPUTS trapNum - the trap number to free {of 0..15} exec.library/FreeVec exec.library/FreeVec NAME FreeVec -- return AllocVec() memory to the system (V36) SYNOPSIS FreeVec(memoryBlock) A1 void FreeVec(void *); FUNCTION Free an allocation made by the AllocVec() call. The memory will be returned to the system pool from which it came. NOTE If a block of memory is freed twice, the system will Guru. The Alert is AN_FreeTwice ($01000009). If you pass the wrong pointer, you will probably see AN_MemCorrupt $01000005. Future versions may add more sanity checks to the memory lists. INPUTS memoryBlock - pointer to the memory block to free, or NULL. SEE ALSO AllocVec exec.library/GetCC exec.library/GetCC NAME GetCC -- get condition codes in a 68010 compatible way. SYNOPSIS conditions = GetCC() D0 UWORD GetCC(void); FUNCTION The 68000 processor has a "MOVE SR, " instruction which gets a copy of the processor condition codes. On the 68010,20 and 30 CPUs, "MOVE SR, " is privileged. User code will trap if it is attempted. These processors need to use the "MOVE CCR, " instruction instead. This function provides a means of obtaining the CPU condition codes in a manner that will make upgrades transparent. This function is VERY short and quick. RESULTS conditions - the 680XX condition codes NOTE This call is guaranteed to preserve all registers. This function may be implemented as code right in the jump table. exec.library/GetMsg exec.library/GetMsg NAME GetMsg -- get next message from a message port SYNOPSIS message = GetMsg(port) D0 A0 struct Message *GetMsg(struct MsgPort *); FUNCTION This function receives a message from a given message port. It provides a fast, non-copying message receiving mechanism. The received message is removed from the message port. This function will not wait. If a message is not present this function will return zero. If a program must wait for a message, it can Wait() on the signal specified for the port or use the WaitPort() function. There can only be one task waiting for any given port. Getting a message does not imply to the sender that the message is free to be reused by the sender. When the receiver is finished with the message, it may ReplyMsg() it back to the sender. Getting a signal does NOT always imply a message is ready. More than one message may arrive per signal, and signals may show up without messages. Typically you must loop to GetMsg() until it returns zero, then Wait() or WaitPort(). INPUT port - a pointer to the receiver message port RESULT message - a pointer to the first message available. If there are no messages, return zero. Callers must be prepared for zero at any time. SEE ALSO PutMsg, ReplyMsg, WaitPort, Wait, exec/ports.h exec.library/InitCode exec.library/InitCode NAME InitCode - initialize resident code modules (internal function) SYNOPSIS InitCode(startClass, version) D0 D1 void InitCode(ULONG,ULONG); FUNCTION (This function may be ignored by application programmers) Call InitResident() for all resident modules in the ResModules array with the given startClass and with versions equal or greater than that specified. The segList parameter is passed as zero. Resident modules are used by the system to pull all its parts together at startup. Modules are initialized in a prioritized order. Modules that do not have a startclass should be of priority -120. RTF_AFTERDOS modues should start at -100 (working down). INPUTS startClass - the class of code to be initialized: BITDEF RT,COLDSTART,0 BITDEF RT,SINGLETASK,1 ;ExecBase->ThisTask==0 (V36 only) BITDEF RT,AFTERDOS,2 ;(V36 only) version - a major version number SEE ALSO ResidentTag (RT) structure definition (resident.h) exec.library/InitResident exec.library/InitResident NAME InitResident - initialize resident module SYNOPSIS object = InitResident(resident, segList) D0 A1 D1 APTR InitResident(struct Resident *,ULONG); FUNCTION Initialize a ROMTag. ROMTags are used to link system modules together. Each disk based device or library must contain a ROMTag structure in the first code hunk. Once the validity of the ROMTag is verified, the RT_INIT pointer is jumped to with the following registers: D0 = 0 A0 = segList A6 = ExecBase INPUTS resident - Pointer to a ROMTag segList - SegList of the loaded object, if loaded from disk. Libraries & Devices will cache this value for later return at close or expunge time. Pass NULL for ROM modules. RESULTS object - Return value from the init code, usually the library or device base. NULL for failure. AUTOINIT FEATURE An automatic method of library/device base and vector table initialization is also provided by InitResident(). The initial code hunk of the library or device should contain "MOVEQ #-1,d0; RTS;". Following that must be an initialized Resident structure with RTF_AUTOINIT set in rt_Flags, and an rt_Init pointer which points to four longwords. These four longwords will be used in a call to MakeLibrary(); - The size of your library/device base structure including initial Library or Device structure. - A pointer to a longword table of standard, then library specific function offsets, terminated with -1L. (short format offsets are also acceptable) - Pointer to data table in exec/InitStruct format for initialization of Library or Device structure. - Pointer to library initialization function, or NULL. Calling sequence: D0 = library base A0 = segList A6 = ExecBase This function must return in D0 the library/device base to be linked into the library/device list. If the initialization function fails, the device memory must be manually deallocated, then NULL returned in D0. SEE ALSO exec/resident.i, FindResident exec.library/InitSemaphore exec.library/InitSemaphore NAME InitSemaphore -- initialize a signal semaphore SYNOPSIS InitSemaphore(signalSemaphore) A0 void InitSemaphore(struct SignalSemaphore *); FUNCTION This function initializes a signal semaphore and prepares it for use. It does not allocate anything, but does initialize list pointers and the semaphore counters. Semaphores are often used to protect critical data structures or hardware that can only be accessed by one task at a time. After initialization, the address of the SignalSemaphore may be made available to any number of tasks. Typically a task will try to ObtainSemaphore(), passing this address in. If no other task owns the semaphore, then the call will lock and return quickly. If more tasks try to ObtainSemaphore(), they will be put to sleep. When the owner of the semaphore releases it, the next waiter in turn will be woken up. Semaphores are often preferable to the old-style Forbid()/Permit() type arbitration. With Forbid()/Permit() *all* other tasks are prevented from running. With semaphores, only those tasks that need access to whatever the semaphore protects are subject to waiting. INPUT signalSemaphore -- a signal semaphore structure (with all fields set to zero before the call) SEE ALSO ObtainSemaphore(), ObtainSemaphoreShared(), AttemptSemaphore(), ReleaseSemaphore(), exec/semaphores.h exec.library/InitStruct exec.library/InitStruct NAME InitStruct - initialize memory from a table SYNOPSIS InitStruct(initTable, memory, size); A1 A2 D0 void InitStruct(struct InitStruct *, APTR, ULONG); FUNCTION Clear a memory area, then set up default values according to the data and offset values in the initTable. Typically only assembly programs take advantage of this function, and only with the macros defined in "exec/initializers.i". The initialization table has byte commands to |a ||byte| |given||byte| |once | load |count||word| into |next ||rptr| offset, |repetitively | |long| Not all combinations are supported. The offset, when specified, is relative to the memory pointer provided (Memory), and is initially zero. The initialization data (InitTable) contains byte commands whose 8 bits are interpreted as follows: ddssnnnn dd the destination type (and size): 00 no offset, use next destination, nnnn is count 01 no offset, use next destination, nnnn is repeat 10 destination offset is in the next byte, nnnn is count 11 destination offset is in the next 24-bits, nnnn is count ss the size and location of the source: 00 long, from the next two aligned words 01 word, from the next aligned word 10 byte, from the next byte 11 ERROR - will cause an ALERT (see below) nnnn the count or repeat: count the (number+1) of source items to copy repeat the source is copied (number+1) times. initTable commands are always read from the next even byte. Given destination offsets are always relative to the memory pointer (A2). The command %00000000 ends the InitTable stream: use %00010001 if you really want to copy one longword without a new offset. 24 bit APTR not supported for 68020 compatibility -- use long. INPUTS initTable - the beginning of the commands and data to init Memory with. Must be on an even boundary unless only byte initialization is done. End table with "dc.b 0" or "dc.w 0". memory - the beginning of the memory to initialize. Must be on an even boundary if size is specified. size - the size of memory, which is used to clear it before initializing it via the initTable. If Size is zero, memory is not cleared before initializing. size must be an even number. SEE ALSO exec/initializers.i exec.library/Insert exec.library/Insert NAME Insert -- insert a node into a list SYNOPSIS Insert(list, node, listNode) A0 A1 A2 void Insert(struct List *, struct Node *, struct Node *); FUNCTION Insert a node into a doubly linked list AFTER a given node position. Insertion at the head of a list is possible by passing a zero value for listNode, though the AddHead function is slightly faster for that special case. WARNING This function does not arbitrate for access to the list. The calling task must be the owner of the involved list. INPUTS list - a pointer to the target list header node - the node to insert listNode - the node after which to insert SEE ALSO AddHead, AddTail, Enqueue, RemHead, Remove, RemTail exec.library/MakeFunctions exec.library/MakeFunctions NAME MakeFunctions -- construct a function jump table SYNOPSIS tableSize = MakeFunctions(target, functionArray, funcDispBase) D0 A0 A1 A2 ULONG MakeFunctions(APTR,APTR,APTR); FUNCTION A low level function used by MakeLibrary to build jump tables of the type used by libraries, devices and resources. It allows the table to be built anywhere in memory, and can be used both for initialization and replacement. This function also supports function pointer compression by expanding relative displacements into absolute pointers. The processor instruction cache is cleared after the table building. INPUT destination - the target address for the high memory end of the function jump table. Typically this will be the library base pointer. functionArray - pointer to an array of function pointers or function displacements. If funcDispBase is zero, the array is assumed to contain absolute pointers to functions. If funcDispBase is not zero, then the array is assumed to contain word displacements to functions. In both cases, the array is terminated by a -1 (of the same size as the actual entry. funcDispBase - pointer to the base about which all function displacements are relative. If zero, then the function array contains absolute pointers. RESULT tableSize - size of the new table in bytes (for LIB_NEGSIZE). SEE ALSO exec/MakeLibrary exec.library/MakeLibrary exec.library/MakeLibrary NAME MakeLibrary -- construct a library SYNOPSIS library = MakeLibrary(vectors, structure, init, dSize, segList) D0 A0 A1 A2 D0 D1 struct Library *MakeLibrary (APTR,struct InitStruct *,APTR,ULONG,BPTR); FUNCTION This function is used for constructing a library vector and data area. The same call is used to make devices. Space for the library is allocated from the system's free memory pool. The data portion of the library is initialized. init may point to a library specific entry point. NOTE Starting with V36, the library base is longword adjusted. The lib_PosSize and lib_NegSize fields of the library structure are adjusted to match. INPUTS vectors - pointer to an array of function pointers or function displacements. If the first word of the array is -1, then the array contains relative word displacements (based off of vectors); otherwise, the array contains absolute function pointers. The vector list is terminated by a -1 (of the same size as the pointers). structure - points to an "InitStruct" data region. If NULL, then it will not be used. init - If non-NULL, an entry point that will be called before adding the library to the system. Registers are as follows: d0 = libAddr ;Your Library Address a0 = segList ;Your AmigaDOS segment list a6 = ExecBase ;Address of exec.library The result of the init function must be the library address, or NULL for failure. If NULL, the init point must manually deallocate the library base memory (based on the sizes stored in lib_PosSize and lib_NegSize). dSize - the size of the library data area, including the standard library node data. This must be at leas sizeof(struct Library). segList - pointer to an AmigaDOS SegList (segment list). This is passed to a library's init code, and is used later for removing the library from memory. RESULT library - the reference address of the library. This is the address used in references to the library, not the beginning of the memory area allocated. If the library vector table require more system memory than is available, this function will return NULL. SEE ALSO InitStruct, InitResident, exec/initializers.i exec.library/ObtainSemaphore exec.library/ObtainSemaphore NAME ObtainSemaphore -- gain exclusive access to a semaphore SYNOPSIS ObtainSemaphore(signalSemaphore) A0 void ObtainSemaphore(struct SignalSemaphore *); FUNCTION Signal semaphores are used to gain exclusive access to an object. ObtainSemaphore is the call used to gain this access. If another user currently has the semaphore locked the call will block until the object is available. If the current task already has locked the semaphore and attempts to lock it again the call will still succeed. A "nesting count" is incremented each time the current owning task of the semaphore calls ObtainSemaphore(). This counter is decremented each time ReleaseSemaphore() is called. When the counter returns to zero the semaphore is actually released, and the next waiting task is called. A queue of waiting tasks is maintained on the stacks of the waiting tasks. Each will be called in turn as soon as the current task releases the semaphore. Signal Semaphores are different than Procure()/Vacate() semaphores. The former requires less CPU time, especially if the semaphore is not currently locked. They require very little set up and user thought. The latter flavor of semaphore make no assumptions about how they are used -- they are completely general. Unfortunately they are not as efficient as signal semaphores, and require the locker to have done some setup before doing the call. INPUT signalSemaphore -- an initialized signal semaphore structure NOTE This function preserves all registers (see BUGS). BUGS Until V37, this function could destroy A0. SEE ALSO ObtainSemaphoreShared(), InitSemaphore(), ReleaseSemaphore(), AttemptSemaphore(), ObtainSemaphoreList() exec.library/ObtainSemaphoreList exec.library/ObtainSemaphoreList NAME ObtainSemaphoreList -- get a list of semaphores. SYNOPSIS ObtainSemaphoreList(list) A0 void ObtainSemaphoreList(struct List *); FUNCTION Signal semaphores may be linked together into a list. This function takes a list of these semaphores and attempts to lock all of them at once. This call is preferable to applying ObtainSemaphore() to each element in the list because it attempts to lock all the elements simultaneously, and won't deadlock if someone is attempting to lock in some other order. This function assumes that only one task at a time will attempt to lock the entire list of semaphores. In other words, there needs to be a higher level lock (perhaps another signal semaphore...) that is used before someone attempts to lock the semaphore list via ObtainSemaphoreList(). Note that deadlocks may result if this call is used AND someone attempts to use ObtainSemaphore() to lock more than one semaphore on the list. If you wish to lock more than semaphore (but not all of them) then you should obtain the higher level lock (see above) INPUT list -- a list of signal semaphores SEE ALSO InitSemaphore(), ReleaseSemaphoreList() exec.library/ObtainSemaphoreShared exec.library/ObtainSemaphoreShared NAME ObtainSemaphoreShared -- gain shared access to a semaphore (V36) SYNOPSIS ObtainSemaphoreShared(signalSemaphore) a0 void ObtainSemaphoreShared(struct SignalSemaphore *); FUNCTION A lock on a signal semaphore may either be exclusive, or shared. Exclusive locks are granted by the ObtainSemaphore() and AttemptSemaphore() functions. Shared locks are granted by ObtainSemaphoreShared(). Calls may be nested. Any number of tasks may simultaneously hold a shared lock on a semaphore. Only one task may hold an exclusive lock. A typical application is a list that is often read, but only occasionally written to. Any exlusive locker will be held off until all shared lockers release the semaphore. Likewise, if an exlusive lock is held, all potential shared lockers will block until the exclusive lock is released. All shared lockers are restarted at the same time. EXAMPLE ObtainSemaphoreShared(ss); /* read data */ ReleaseSemaohore(ss); ObtainSemaphore(ss); /* modify data */ ReleaseSemaohore(ss); NOTES While this function was added for V36, the feature magically works with all older semaphore structures. A task owning a shared lock must not attempt to get an exclusive lock on the same semaphore. INPUT signalSemaphore -- an initialized signal semaphore structure NOTE This call is guaranteed to preserve all registers, starting with V37 exec. RESULT SEE ALSO InitSemaphore(), ReleaseSemaphore() exec.library/OldOpenLibrary exec.library/OldOpenLibrary NAME OldOpenLibrary -- obsolete OpenLibrary SYNOPSIS library = OldOpenLibrary(libName) D0 A1 struct Library *OldOpenLibrary(APTR); FUNCTION The 1.0 release of the Amiga system had an incorrect version of OpenLibrary that did not check the version number during the library open. This obsolete function is provided so that object code compiled using a 1.0 system will still run. This exactly the same as "OpenLibrary(libName,0L);" INPUTS libName - the name of the library to open RESULTS library - a library pointer for a successful open, else zero SEE ALSO CloseLibrary exec.library/OpenDevice exec.library/OpenDevice NAME OpenDevice -- gain access to a device SYNOPSIS error = OpenDevice(devName, unitNumber, iORequest, flags) D0 A0 D0 A1 D1 BYTE OpenDevice(STRPTR,ULONG,struct IORequest *,ULONG); FUNCTION This function opens the named device/unit and initializes the given I/O request block. Specific documentation on opening procedures may come with certain devices. The device may exist in memory, or on disk; this is transparent to the OpenDevice caller. A full path name for the device name is legitimate. For example "test:devs/fred.device". This allows the use of custom devices without requiring the user to copy the device into the system's DEVS: directory. NOTES All calls to OpenDevice should have matching calls to CloseDevice! Devices on disk cannot be opened until after DOS has been started. As of V36 tasks can safely call OpenDevice, though DOS may open system requesters (e.g., asking the user to insert the Workbench disk if DEVS: is not online). You must call this function from a DOS Process if you want to turn off DOS requesters. INPUTS devName - requested device name unitNumber - the unit number to open on that device. The format of the unit number is device specific. If the device does not have separate units, send a zero. iORequest - the I/O request block to be returned with appropriate fields initialized. flags - additional driver specific information. This is sometimes used to request opening a device with exclusive access. RESULTS error - Returns a sign-extended copy of the io_Error field of the IORequest. Zero if successful, else an error code is returned. BUGS AmigaDOS file names are not case sensitive, but Exec lists are. If the library name is specified in a different case than it exists on disk, unexpected results may occur. Prior to V36, tasks could not make OpenDevice calls requiring disk access (since tasks are not allowed to make dos.library calls). Now OpenDevice is protected from tasks. SEE ALSO CloseDevice, DoIO, SendIO, CheckIO, AbortIO, WaitIO exec.library/OpenLibrary exec.library/OpenLibrary NAME OpenLibrary -- gain access to a library SYNOPSIS library = OpenLibrary(libName, version) D0 A1 D0 struct Library *OpenLibrary(STRPTR, ULONG); FUNCTION This function returns a pointer to a library that was previously installed into the system. If the requested library is exists, and if the library version is greater than or equal to the requested version, then the open will succeed. The device may exist in memory, or on disk; this is transparent to the OpenDevice caller. Only Processes are allowed to call OpenLibrary (since OpenLibrary may in turn call dos.library). A full path name for the library name is legitimate. For example "wp:libs/wp.library". This allows the use of custom libraries without requiring the user to copy the library into the system's LIBS: directory. NOTES All calls to OpenLibrary should have matching calls to CloseLibrary! Libraries on disk cannot be opened until after DOS has been started. As of V36 tasks can safely call OpenLibrary, though DOS may open system requesters (e.g., asking the user to insert the Workbench disk if LIBS: is not online). You must call this function from a DOS Process if you want to turn off DOS requesters. INPUTS libName - the name of the library to open version - the version of the library required. RESULTS library - a library pointer for a successful open, else zero BUGS AmigaDOS file names are not case sensitive, but Exec lists are. If the library name is specified in a different case than it exists on disk, unexpected results may occur. Prior to V36, tasks could not make OpenLibrary calls requiring disk access (since tasks are not allowed to make dos.library calls). Now OpenLibrary is protected from tasks. The version number of the resident tag in disk based library must match the version number of the library, or V36 may fail to load it. SEE ALSO CloseLibrary exec.library/OpenResource exec.library/OpenResource NAME OpenResource -- gain access to a resource SYNOPSIS resource = OpenResource(resName) D0 A1 APTR OpenResource(STRPTR); FUNCTION This function returns a pointer to a resource that was previously installed into the system. There is no CloseResource() function. INPUTS resName - the name of the resource requested. RESULTS resource - if successful, a resource pointer, else NULL exec.library/Permit exec.library/Permit NAME Permit -- permit task rescheduling. SYNOPSIS Permit() void Permit(void); FUNCTION Allow other tasks to be scheduled to run by the dispatcher, after a matching Forbid() has been executed. RESULTS Other tasks will be rescheduled as they are ready to run. In order to restore normal task rescheduling, the programmer must execute exactly one call to Permit() for every call to Forbid(). NOTE This call is guaranteed to preserve all registers. SEE ALSO Forbid, Disable, Enable exec.library/Procure exec.library/Procure NAME Procure -- bid for a message lock (semaphore) SYNOPSIS result = Procure(semaphore, bidMessage) D0 A0 A1 BYTE Procure(struct Semaphore *, struct Message *); FUNCTION This function is used to obtain a message based semaphore lock. If the lock is immediate, Procure() returns a true result, and the bidMessage is not used. If the semaphore is already locked, Procure() returns false, and the task must wait for the bidMessage to arrive at its reply port. Straight "Semaphores" use the message system. They are therefore queueable, and users may wait on several of them at the same time. This makes them more powerful than "Signal Semaphores" INPUT semaphore - a semaphore message port. This port is used to queue all pending lockers. This port should be initialized with the PA_IGNORE option, as the MP_SigTask field is used for a pointer to the current locker message (not a task). New semaphore ports must also have the SM_BIDS word initialized to -1. If the semaphore is public, it should be named, its priority set, and the added with AddPort. Message port priority is often used for anti-deadlock locking conventions. RESULT result - true when the semaphore is free. In such cases no waiting needs to be done. If false, then the task should wait at its bidMessage reply port. BUGS Procure() and Vacate() do not have proven reliability. SEE ALSO Vacate() exec.library/PutMsg exec.library/PutMsg NAME PutMsg -- put a message to a message port SYNOPSIS PutMsg(port, message) A0 A1 void PutMsg(struct MsgPort *, struct Message *); FUNCTION This function attaches a message to the end of a given message port. It provides a fast, non-copying message sending mechanism. Messages can be attached to only one port at a time. The message body can be of any size or form. Because messages are not copied, cooperating tasks share the same message memory. The sender task must not recycle the message until it has been replied by the receiver. Of course this depends on the message handling conventions setup by the involved tasks. If the ReplyPort field is non-zero, when the message is replied by the receiver, it will be sent back to that port. Any one of the following actions can be set to occur when a message is put: 1. no special action 2. signal a given task (specified by MP_SIGTASK) 3. cause a software interrupt (specified by MP_SIGTASK) The action is selected depending on the value found in the MP_FLAGS of the destination port. IMPLEMENTATION 1. Sets the LN_TYPE field to "NT_MESSAGE". 2. Attaches the message to the destination port. 3. Performs the specified arrival action at the destination. INPUT port - pointer to a message port message - pointer to a message SEE ALSO GetMsg, ReplyMsg, exec/ports.h exec.library/RawDoFmt exec.library/RawDoFmt NAME RawDoFmt -- format data into a character stream. SYNOPSIS NextData = RawDoFmt(FormatString, DataStream, PutChProc, PutChData); d0 a0 a1 a2 a3 APTR RawDoFmt(STRPTR,APTR,void (*)(),APTR); FUNCTION perform "C"-language-like formatting of a data stream, outputting the result a character at a time. Where % formatting commands are found in the FormatString, they will be replaced with the corresponding element in the DataStream. %% must be used in the string if a % is desired in the output. Under V36, RawDoFmt() returns a pointer to the end of the DataStream (The next argument that would have been processed). This allows multiple formatting passes to be made using the same data. INPUTS FormatString - a "C"-language-like NULL terminated format string, with the following supported % options: %[flags][width.limit][length]type flags - only one allowed. '-' specifies left justification. width - field width. If the first character is a '0', the field will be padded with leading 0's. . - must follow the field width, if specified limit - maximum number of characters to output from a string. (only valid for %s). length - size of input data defaults to WORD for types d, x, and c, 'l' changes this to long (32-bit). type - supported types are: b - BSTR, data is 32-bit BPTR to byte count followed by a byte string, or NULL terminated byte string. A NULL BPTR is treated as an empty string. (Added in V36 exec) d - decimal u - unsigned decimal (Added in V37 exec) x - hexadecimal s - string, a 32-bit pointer to a NULL terminated byte string. In V36, a NULL pointer is treated as an empty string c - character DataStream - a stream of data that is interpreted according to the format string. Often this is a pointer into the task's stack. PutChProc - the procedure to call with each character to be output, called as: PutChProc(Char, PutChData); D0-0:8 A3 the procedure is called with a NULL Char at the end of the format string. PutChData - a value that is passed through to the PutChProc procedure. This is untouched by RawDoFmt, and may be modified by the PutChProc. EXAMPLE ; ; Simple version of the C "sprintf" function. Assumes C-style ; stack-based function conventions. ; ; long eyecount; ; eyecount=2; ; sprintf(string,"%s have %ld eyes.","Fish",eyecount); ; ; would produce "Fish have 2 eyes." in the string buffer. ; XDEF _sprintf XREF _AbsExecBase XREF _LVORawDoFmt _sprintf: ; ( ostring, format, {values} ) movem.l a2/a3/a6,-(sp) move.l 4*4(sp),a3 ;Get the output string pointer move.l 5*4(sp),a0 ;Get the FormatString pointer lea.l 6*4(sp),a1 ;Get the pointer to the DataStream lea.l stuffChar(pc),a2 move.l _AbsExecBase,a6 jsr _LVORawDoFmt(a6) movem.l (sp)+,a2/a3/a6 rts ;------ PutChProc function used by RawDoFmt ----------- stuffChar: move.b d0,(a3)+ ;Put data to output string rts WARNING This Amiga ROM function formats word values in the data stream. If your compiler defaults to longs, you must add an "l" to your % specifications. This can get strange for characters, which might look like "%lc". The result of RawDoFmt() is *ONLY* valid in V36 and later releases of EXEC. Pre-V36 versions of EXEC have "random" return values. SEE ALSO Documentation on the C language "printf" call in any C language reference book. exec.library/ReleaseSemaphore exec.library/ReleaseSemaphore NAME ReleaseSemaphore -- make signal semaphore available to others SYNOPSIS ReleaseSemaphore(signalSemaphore) A0 void ReleaseSemaphore(struct SignalSemaphore *); FUNCTION ReleaseSemaphore() is the inverse of ObtainSemaphore(). It makes the semaphore lockable to other users. If tasks are waiting for the semaphore and this this task is done with the semaphore then the next waiting task is signalled. Each ObtainSemaphore() call must be balanced by exactly one ReleaseSemaphore() call. This is because there is a nesting count maintained in the semaphore of the number of times that the current task has locked the semaphore. The semaphore is not released to other tasks until the number of releases matches the number of obtains. Needless to say, havoc breaks out if the task releases more times than it has obtained. INPUT signalSemaphore -- an initialized signal semaphore structure NOTE This call is guaranteed to preserve all registers. SEE ALSO InitSemaphore(), ObtainSemaphore(), ObtainSemaphoreShared() exec.library/ReleaseSemaphoreList exec.library/ReleaseSemaphoreList NAME ReleaseSemaphoreList -- make a list of semaphores available SYNOPSIS ReleaseSemaphoreList(list) A0 void ReleaseSemaphoreList(struct List *); FUNCTION ReleaseSemaphoreList() is the inverse of ObtainSemaphoreList(). It releases each element in the semaphore list. Needless to say, havoc breaks out if the task releases more times than it has obtained. INPUT list -- a list of signal semaphores SEE ALSO ObtainSemaphoreList() exec.library/RemDevice exec.library/RemDevice NAME RemDevice -- remove a device from the system SYNOPSIS RemDevice(device) A1 void RemDevice(struct Device *); FUNCTION This function calls the device's EXPUNGE vector, which requests that a device delete itself. The device may refuse to do this if it is busy or currently open. This is not typically called by user code. There are certain, limited circumstances where it may be appropriate to attempt to specifically flush a certain device. Example: /* Attempts to flush the named device out of memory. */ #include #include void FlushDevice(name) STRPTR name; { struct Device *result; Forbid(); if(result=(struct Device *)FindName(&SysBase->DeviceList,name)) RemDevice(result); Permit(); } INPUTS device - pointer to a device node SEE ALSO AddLibrary exec.library/RemHead exec.library/RemHead NAME RemHead -- remove the head node from a list SYNOPSIS node = RemHead(list) D0 A0 struct Node *RemHead(struct List *); FUNCTION Get a pointer to the head node and remove it from the list. Assembly programmers may prefer to use the REMHEAD macro from "exec/lists.i". WARNING This function does not arbitrate for access to the list. The calling task must be the owner of the involved list. INPUTS list - a pointer to the target list header RESULT node - the node removed or zero when empty list SEE ALSO AddHead, AddTail, Enqueue, Insert, Remove, RemTail exec.library/RemIntServer exec.library/RemIntServer NAME RemIntServer -- remove an interrupt server from a server chain SYNOPSIS RemIntServer(intNum, interrupt) D0 A1 void RemIntServer(ULONG,struct Interrupt *); FUNCTION This function removes an interrupt server node from the given server chain. If this server was the last one on this chain, interrupts for this chain are disabled. INPUTS intNum - the Paula interrupt bit (0..14) interrupt - pointer to an interrupt server node BUGS Before V36 Kickstart, the feature that disables the interrupt would not function. For most server chains this does not cause a problem. SEE ALSO AddIntServer, hardware/intbits.h exec.library/RemLibrary exec.library/RemLibrary NAME RemLibrary -- remove a library from the system SYNOPSIS RemLibrary(library) A1 void RemLibrary(struct Library *); FUNCTION This function calls the library's EXPUNGE vector, which requests that a library delete itself. The library may refuse to do this if it is busy or currently open. This is not typically called by user code. There are certain, limited circumstances where it may be appropriate to attempt to specifically flush a certain Library. Example: /* Attempts to flush the named library out of memory. */ #include #include void FlushLibrary(name) STRPTR name; { struct Library *result; Forbid(); if(result=(struct Library *)FindName(&SysBase->LibList,name)) RemLibrary(result); Permit(); } INPUTS library - pointer to a library node structure exec.library/Remove exec.library/Remove NAME Remove -- remove a node from a list SYNOPSIS Remove(node) A1 void Remove(struct Node *); FUNCTION Unlink a node from whatever list it is in. Nodes that are not part of a list must not be passed to this funcion! Assembly programmers may prefer to use the REMOVE macro from "exec/lists.i". WARNING This function does not arbitrate for access to the list. The calling task must be the owner of the involved list. INPUTS node - the node to remove SEE ALSO AddHead, AddTail, Enqueue, Insert, RemHead, RemTail exec.library/RemPort exec.library/RemPort NAME RemPort -- remove a message port from the system SYNOPSIS RemPort(port) A1 void RemPort(struct MsgPort *); FUNCTION This function removes a message port structure from the system's message port list. Subsequent attempts to rendezvous by name with this port will fail. INPUTS port - pointer to a message port SEE ALSO AddPort, FindPort exec.library/RemResource exec.library/RemResource NAME RemResource -- remove a resource from the system SYNOPSIS RemResource(resource) A1 void RemResource(APTR); FUNCTION This function removes an existing resource from the system resource list. There must be no outstanding users of the resource. INPUTS resource - pointer to a resource node SEE ALSO AddResource exec.library/RemSemaphore exec.library/RemSemaphore NAME RemSemaphore -- remove a signal semaphore from the system SYNOPSIS RemSemaphore(signalSemaphore) A1 void RemSemaphore(struct SignalSemaphore *); FUNCTION This function removes a signal semaphore structure from the system's signal semaphore list. Subsequent attempts to rendezvous by name with this semaphore will fail. INPUTS signalSemaphore -- an initialized signal semaphore structure SEE ALSO AddSemaphore, FindSemaphore exec.library/RemTail exec.library/RemTail NAME RemTail -- remove the tail node from a list SYNOPSIS node = RemTail(list) D0 A0 struct Node *RemTail(struct List *); FUNCTION Remove the last node from a list, and return a pointer to it. If the list is empty, return zero. Assembly programmers may prefer to use the REMTAIL macro from "exec/lists.i". WARNING This function does not arbitrate for access to the list. The calling task must be the owner of the involved list. INPUTS list - a pointer to the target list header RESULT node - the node removed or zero when empty list SEE ALSO AddHead, AddTail, Enqueue, Insert, Remove, RemHead, RemTail exec.library/RemTask exec.library/RemTask NAME RemTask -- remove a task from the system SYNOPSIS RemTask(task) A1 void RemTask(struct Task *); FUNCTION This function removes a task from the system. Deallocation of resources should have been performed prior to calling this function. Removing some other task is very dangerous. Generally is is best to arrange for tasks to call RemTask(0L) on themselves. RemTask will automagically free any memory lists attached to the task's TC_MEMENTRY list. INPUTS task - pointer to the task node representing the task to be removed. A zero value indicates self removal, and will cause the next ready task to begin execution. BUGS Before V36 if RemTask() was called on a task other than the current task, and that task was created with amiga.lib/CreateTask, there was a slight chance of a crash. The problem can be hidden by bracketing RemTask() with Forbid()/Permit(). SEE ALSO AddTask, exec/AllocEntry, amiga.lib/DeleteTask exec.library/ReplyMsg exec.library/ReplyMsg NAME ReplyMsg -- put a message to its reply port SYNOPSIS ReplyMsg(message) A1 void ReplyMsg(struct Message *); FUNCTION This function sends a message to its reply port. This is usually done when the receiver of a message has finished and wants to return it to the sender (so that it can be re-used or deallocated, whatever). This call may be made from interrupts. INPUT message - a pointer to the message IMPLEMENTATION 1> Places "NT_REPLYMSG" into LN_TYPE. 2> Puts the message to the port specified by MN_REPLYPORT If there is no replyport, sets LN_TYPE to "NT_FREEMSG" (use this feature only with extreeme care). SEE ALSO GetMsg, PutMsg, exec/ports.h exec.library/SendIO exec.library/SendIO NAME SendIO -- initiate an I/O command SYNOPSIS SendIO(iORequest) A1 void SendIO(struct IORequest *); FUNCTION This function requests the device driver start processing the given I/O request. The device will return control without waiting for the I/O to complete. The io_Flags field of the IORequest will be set to zero before the request is sent. See BeginIO() for more details. INPUTS iORequest - pointer to an I/O request, or a device specific extended IORequest. SEE ALSO DoIO, CheckIO, WaitIO, AbortIO exec.library/SetExcept exec.library/SetExcept NAME SetExcept -- define certain signals to cause exceptions SYNOPSIS oldSignals = SetExcept(newSignals, signalMask) D0 D0 D1 ULONG SetExcept(ULONG,ULONG); FUNCTION This function defines which of the task's signals will cause a private task exception. When any of the signals occurs the task's exception handler will be dispatched. If the signal occurred prior to calling SetExcept, the exception will happen immediately. The user function pointed to by the task's tc_ExceptCode gets called as: newExcptSet = (signals, exceptData),SysBase D0 D0 A1 A6 signals - The set of signals that caused this exception. These Signals have been disabled from the current set of signals that can cause an exception. exceptData - A copy of the task structure tc_ExceptData field. newExcptSet - The set of signals in NewExceptSet will be re- enabled for exception generation. Usually this will be the same as the Signals that caused the exception. INPUTS newSignals - the new values for the signals specified in signalMask. signalMask - the set of signals to be effected RESULTS oldSignals - the prior exception signals EXAMPLE Get the current state of all exception signals: SetExcept(0,0) Change a few exception signals: SetExcept($1374,$1074) SEE ALSO Signal, SetSignal exec.library/SetFunction exec.library/SetFunction NAME SetFunction -- change a function vector in a library SYNOPSIS oldFunc = SetFunction(library, funcOffset, funcEntry) D0 A1 A0.W D0 APTR SetFunction(struct Library *,LONG,APTR); FUNCTION SetFunction is a functional way of changing where vectors in a library point. They are changed in such a way that the checksumming process will never falsely declare a library to be invalid. WARNING If you use SetFunction on a function that can be called from interrupts, you are obligated to provide your own arbitration. NOTE SetFunction cannot be used on non-standard libraries like pre-V36 dos.library. Here you must manually Forbid(), preserve all 6 original bytes, set the new vector, SumLibrary(), then Permit(). INPUTS library - a pointer to the library to be changed funcOffset - the offset of the function to be replaced funcEntry - pointer to new function RESULTS oldFunc - pointer to the old function that was just replaced exec.library/SetIntVector exec.library/SetIntVector NAME SetIntVector -- set a new handler for a system interrupt vector SYNOPSIS oldInterrupt = SetIntVector(intNumber, interrupt) D0 D0 A1 struct Interrupt *SetIntVector(ULONG, struct Interrupt *); FUNCTION This function provides a mechanism for setting the system interrupt vectors. These are non-sharable; setting a new interrupt handler disconnects the old one. Installed handlers are responsible for processing, enabling and clearing the interrupt. Note that interrupts may have been left in any state by the previous code. The IS_CODE and IS_DATA pointers of the Interrupt structure will be copied into a private place by Exec. A pointer to the previously installed Interrupt structure is returned. When the system calls the specified interrupt code, the registers are setup as follows: D0 - scratch D1 - scratch (on entry: active interrupts -> equals INTENA & INTREQ) A0 - scratch (on entry: pointer to base of custom chips for fast indexing) A1 - scratch (on entry: Interrupt's IS_DATA pointer) A5 - jump vector register (scratch on call) A6 - Exec library base pointer (scratch on call) all other registers must be preserved INPUTS intNum - the Paula interrupt bit number (0..14). Only non-chained interrupts should be set. Use AddIntServer() for server chains. interrupt - a pointer to an Interrupt structure containing the handler's entry point and data segment pointer. A NULL interrupt pointer will remove the current interrupt and set illegal values for IS_CODE and IS_DATA. By convention, the LN_NAME of the interrupt structure must point a descriptive string so that other users may identify who currently has control of the interrupt. RESULT A pointer to the prior interrupt structure which had control of this interrupt. SEE ALSO AddIntServer(),exec/interrupts.i,hardware/intbits.i exec.library/SetSignal exec.library/SetSignal NAME SetSignal -- define the state of this task's signals SYNOPSIS oldSignals = SetSignal(newSignals, signalMask) D0 D0 D1 ULONG SetSignal(ULONG,ULONG); FUNCTION This function can query or modify the state of the current task's received signal mask. Setting the state of signals is considered dangerous. Reading the state of signals is safe. INPUTS newSignals - the new values for the signals specified in signalSet. signalMask - the set of signals to be affected. RESULTS oldSignals - the prior values for all signals EXAMPLES Get the current state of all signals: SetSignal(0L,0L); Clear the CTRL-C signal: SetSignal(0L,SIGBREAKF_CTRL_C); Check if the CTRL-C signal was pressed: #include /* Check & clear CTRL_C signal */ if(SetSignal(0L,SIGBREAKF_CTRL_C) & SIGBREAKF_CTRL_C) { printf("CTRL-C pressed!\n"); } SEE ALSO Signal, Wait exec.library/SetSR exec.library/SetSR NAME SetSR -- get and/or set processor status register SYNOPSIS oldSR = SetSR(newSR, mask) D0 D0 D1 ULONG SetSR(ULONG, ULONG); FUNCTION This function provides a means of modifying the CPU status register in a "safe" way (well, how safe can a function like this be anyway?). This function will only affect the status register bits specified in the mask parameter. The prior content of the entire status register is returned. INPUTS newSR - new values for bits specified in the mask. All other bits are not effected. mask - bits to be changed RESULTS oldSR - the entire status register before new bits EXAMPLES To get the current SR: currentSR = SetSR(0,0); To change the processor interrupt level to 3: oldSR = SetSR($0300,$0700); Set processor interrupts back to prior level: SetSR(oldSR,$0700); exec.library/SetTaskPri exec.library/SetTaskPri NAME SetTaskPri -- get and set the priority of a task SYNOPSIS oldPriority = SetTaskPri(task, priority) D0-0:8 A1 D0-0:8 BYTE SetTaskPri(struct Task *,LONG); FUNCTION This function changes the priority of a task regardless of its state. The old priority of the task is returned. A reschedule is performed, and a context switch may result. To change the priority of the currently running task, pass the result of FindTask(0); as the task pointer. INPUTS task - task to be affected priority - the new priority for the task RESULT oldPriority - the tasks previous priority exec.library/Signal exec.library/Signal NAME Signal -- signal a task SYNOPSIS Signal(task, signals) A1 D0 void Signal(struct Task *,ULONG); FUNCTION This function signals a task with the given signals. If the task is currently waiting for one or more of these signals, it will be made ready and a reschedule will occur. If the task is not waiting for any of these signals, the signals will be posted to the task for possible later use. A signal may be sent to a task regardless of whether its running, ready, or waiting. This function is considered "low level". Its main purpose is to support multiple higher level functions like PutMsg. This function is safe to call from interrupts. INPUT task - the task to be signalled signals - the signals to be sent SEE ALSO Wait, SetSignal exec.library/StackSwap exec.library/StackSwap NAME StackSwap - EXEC supported method of replacing task's stack (V37) SYNOPSIS StackSwap(newStack) A0 VOID StackSwap(struct StackSwapStruct *); FUNCTION This function will, in an EXEC supported manner, swap the stack of your task with the given values in StackSwap. The StackSwapStruct structure will then contain the values of the old stack such that the old stack can be restored. This function is new in V37. NOTE If you do a stack swap, only the new stack is set up. This function does not copy the stack or do anything else other than set up the new stack for the task. It is generally required that you restore your stack before exiting. INPUTS newStack - A structure that contains the values for the new upper and lower stack bounds and the new stack pointer. This structure will have its values replaced by those in you task such that you can restore the stack later. RESULTS newStack - The structure will now contain the old stack. This means that StackSwap(foo); StackSwap(foo); will effectively do nothing. SEE ALSO AddTask, RemTask, exec/tasks.h exec.library/SumKickData exec.library/SumKickData NAME SumKickData -- compute the checksum for the Kickstart delta list SYNOPSIS checksum = SumKickData() D0 ULONG SumKickData(void); FUNCTION The Amiga system has some ROM (or Kickstart) resident code that provides the basic functions for the machine. This code is unchangeable by the system software. This function is part of a support system to modify parts of the ROM. The ROM code is linked together at run time via ROMTags (also known as Resident structures, defined in exec/resident.h). These tags tell Exec's low level boot code what subsystems exist in which regions of memory. The current list of ROMTags is contained in the ResModules field of ExecBase. By default this list contains any ROMTags found in the address ranges $F80000-$FFFFFF and $F00000-$F7FFFF. There is also a facility to selectively add or replace modules to the ROMTag list. These modules can exist in RAM, and the memory they occupy will be deleted from the memory free list during the boot process. SumKickData() plays an important role in this run-time modification of the ROMTag array. Three variables in ExecBase are used in changing the ROMTag array: KickMemPtr, KickTagPtr, and KickCheckSum. KickMemPtr points to a linked list of MemEntry structures. The memory that these MemEntry structures reference will be allocated (via AllocAbs) at boot time. The MemEntry structure itself must also be in the list. KickTagPtr points to a long-word array of the same format as the ResModules array. The array has a series of pointers to ROMTag structures. The array is either NULL terminated, or will have an entry with the most significant bit (bit 31) set. The most significant bit being set says that this is a link to another long-word array of ROMTag entries. This new array's address can be found by clearing bit 31. KickCheckSum has the result of SumKickData(). It is the checksum of both the KickMemPtr structure and the KickTagPtr arrays. If the checksum does not compute correctly then both KickMemPtr and KickTagPtr will be ignored. If all the memory referenced by KickMemPtr can't be allocated then KickTagPtr will be ignored. There is one more important caveat about adding ROMTags. All this ROMTag magic is run very early on in the system -- before expansion memory is added to the system. Therefore any memory in this additional ROMTag area must be addressable at this time. This means that your ROMTag code, MemEntry structures, and resident arrays cannot be in expansion memory. There are two regions of memory that are acceptable: one is chip memory, and the other is "Ranger" memory (memory in the range between $C00000-$D80000). Remember that changing an existing ROMTag entry falls into the "heavy magic" category -- be very careful when doing it. The odd are that you will blow yourself out of the water. NOTE SumKickData was introduced in the 1.2 release RESULT Value to be stuffed into ExecBase->KickCheckSum. WARNING After writing to KickCheckSum, you should push the data cache. This prevents potential problems with large copyback style caches. A call to CacheClearU will do fine. SEE ALSO InitResident, FindResident exec.library/SumLibrary exec.library/SumLibrary NAME SumLibrary -- compute and check the checksum on a library SYNOPSIS SumLibrary(library) A1 void SumLibrary(struct Library *); FUNCTION SumLibrary computes a new checksum on a library. It can also be used to check an old checksum. If an old checksum does not match, and the library has not been marked as changed, then the system will call Alert(). This call could also be periodically made by some future system-checking task. INPUTS library - a pointer to the library to be changed NOTE An alert will occur if the checksum fails. SEE ALSO SetFunction exec.library/SuperState exec.library/SuperState NAME SuperState -- enter supervisor state with user stack SYNOPSIS oldSysStack = SuperState() D0 APTR SuperState(void); FUNCTION Enter supervisor mode while running on the user's stack. The user still has access to user stack variables. Be careful though, the user stack must be large enough to accommodate space for all interrupt data -- this includes all possible nesting of interrupts. This function does nothing when called from supervisor state. RESULTS oldSysStack - system stack pointer; save this. It will come in handy when you return to user state. If the system is already in supervisor mode, oldSysStack is zero. SEE ALSO UserState/Supervisor exec.library/Supervisor exec.library/Supervisor NAME Supervisor -- trap to a short supervisor mode function SYNOPSIS result = Supervisor(userFunc) Rx A5 ULONG Supervisor(void *); FUNCTION Allow a normal user-mode program to execute a short assembly language function in the supervisor mode of the processor. Supervisor() does not modify or save registers; the user function has full access to the register set. All rules that apply to interrupt code must be followed. In addition, no system calls are permitted. The function must end with an RTE instruction. EXAMPLE ;Obtain the Exception Vector base. 68010 or greater only! MOVECtrap: movec.l VBR,d0 ;$4e7a,$0801 rte INPUTS userFunc - A pointer to a short assembly language function ending in RTE. The function has full access to the register set. RESULTS result - Whatever values the userFunc left in the registers. SEE ALSO SuperState,UserState exec.library/TypeOfMem exec.library/TypeOfMem NAME TypeOfMem -- determine attributes of a given memory address SYNOPSIS attributes = TypeOfMem(address) D0 A1 ULONG TypeOfMem(void *); FUNCTION Given a RAM memory address, search the system memory lists and return its memory attributes. The memory attributes are similar to those specified when the memory was first allocated: (eg. MEMF_CHIP and MEMF_FAST). This function is usually used to determine if a particular block of memory is within CHIP space. If the address is not in known-space, a zero will be returned. (Anything that is not RAM, like the ROM or expansion area, will return zero. Also the first few bytes of a memory area are used up by the MemHeader.) INPUT address - a memory address RESULT attributes - a long word of memory attribute flags. If the address is not in known RAM, zero is returned. SEE ALSO AllocMem() exec.library/UserState exec.library/UserState NAME UserState -- return to user state with user stack SYNOPSIS UserState(sysStack) D0 void UserState(APTR); FUNCTION Return to user state with user stack, from supervisor state with user stack. This function is normally used in conjunction with the SuperState function above. This function must not be called from the user state. INPUT sysStack - supervisor stack pointer BUGS This function is broken in V33/34 Kickstart. Fixed in V1.31 setpatch. SEE ALSO SuperState/Supervisor exec.library/Vacate exec.library/Vacate NAME Vacate -- release a message lock (semaphore) SYNOPSIS Vacate(semaphore) A0 void Vacate(struct Semaphore *); FUNCTION This function releases a previously locked semaphore (see the Procure() function). If another task is waiting for the semaphore, its bidMessage will be sent to its reply port. INPUT semaphore - the semaport message port representing the semaphore to be freed. BUGS Procure() and Vacate() do not have proven reliability. SEE ALSO Procure exec.library/Wait exec.library/Wait NAME Wait -- wait for one or more signals SYNOPSIS signals = Wait(signalSet) D0 D0 ULONG Wait(ULONG); FUNCTION This function will cause the current task to suspend waiting for one or more signals. When one or more of the specified signals occurs, the task will return to the ready state, and those signals will be cleared. If a signal occurred prior to calling Wait(), the wait condition will be immediately satisfied, and the task will continue to run without delay. CAUTION This function cannot be called while in supervisor mode or interrupts! This function will break the action of a Forbid() or Disable() call. INPUT signalSet - The set of signals for which to wait. Each bit represents a particular signal. RESULTS signals - the set of signals that were active exec.library/WaitIO exec.library/WaitIO NAME WaitIO -- wait for completion of an I/O request SYNOPSIS error = WaitIO(iORequest) D0 A1 BYTE WaitIO(struct IORequest *); FUNCTION This function waits for the specified I/O request to complete, then removes it from the replyport. If the I/O has already completed, this function will return immediately. This function should be used with care, as it does not return until the I/O request completes; if the I/O never completes, this function will never return, and your task will hang. If this situation is a possibility, it is safer to use the Wait() function. Wait() will return return when any of a specified set of signal is received. This is how I/O timeouts can be properly handled. WARNING If this IORequest was "Quick" or otherwise finished BEFORE this call, this function drops though immediately, with no call to Wait(). A side effect is that the signal bit related the port may remain set. Expect this. When removing a known complete IORequest from a port, WaitIO() is the preferred method. A simple Remove() would require a Disable/Enable pair! INPUTS iORequest - pointer to an I/O request block RESULTS error - zero if successful, else an error is returned (a sign extended copy of io_Error). SEE ALSO DoIO, SendIO, CheckIO, AbortIO exec.library/WaitPort exec.library/WaitPort NAME WaitPort -- wait for a given port to be non-empty SYNOPSIS message = WaitPort(port) D0 A0 struct Message *WaitPort(struct MsgPort *); FUNCTION This function waits for the given port to become non-empty. If necessary, the Wait() function will be called to wait for the port signal. If a message is already present at the port, this function will return immediately. The return value is always a pointer to the first message queued (but it is not removed from the queue). CAUTION More than one message may be at the port when this returns. It is proper to call the GetMsg() function in a loop until all messages have been handled, then wait for more to arrive. To wait for more than one port, combine the signal bits from each port into one call to the Wait() function, then use a GetMsg() loop to collect any and all messages. It is possible to get a signal for a port WITHOUT a message showing up. Plan for this. INPUT port - a pointer to the message port RETURN message - a pointer to the first available message SEE ALSO GetMsg [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node001E.html.txt:1:A Register Summary / BLTxDAT ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- BLTxDAT 074 W A Blitter source x data register This register holds source x (x=A,B,C) data for use by the blitter. It is normally loaded by the blitter DMA channel; however, it may also be preloaded by the microprocessor. LINE DRAW BLTADAT is used as an index register LINE DRAW and must be preloaded with 8000. LINE DRAW BLTBDAT is used for texture; it must LINE DRAW be preloaded with FF if no texture LINE DRAW (solid line) is desired. [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node00AB.html.txt:1:cd.device/CD_PAUSE ]" border=0> NAME CD_PAUSE -- Pause or unPause play command. IO REQUEST io_Device preset by the call to OpenDevice() io_Unit preset by the call to OpenDevice() io_Command CD_PAUSE io_Data NULL io_Length pausemode : 1 = pause play; 0 = do not pause play; io_Offset 0 RESULTS io_Actual - if io_Error is 0, this contains the previous pause state. FUNCTION This command will place the CD in, or take the CD out of pause mode. The desired pause state is placed in io_Length. This command only effects play commands. When the audio is playing and the pausemode is set, this command will immediately pause the audio output suspending the play command until the play is unpaused. When audio is not playing and the pausemode is set, this command will set the pause mode (having no immediate effect). When a play command is submitted, the laser will seek to the appropriate position and pause at that spot. The play command will be suspended until the play is unpaused (or the play is aborted). EXAMPLE NOTES BUGS SEE ALSO [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0020.html.txt:1:A Register Summary / BLTxPTH, BLTxPTL ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- BLTxPTH 050 W A( E ) Blitter pointer to x (high 3 bits, 5 bits if ECS) BLTxPTL 052 W A Blitter pointer to x (low 15 bits) This pair of registers contains the 18-bit address of blitter source (x=A,B,C) or destination (x=D) DMA data. This pointer must be preloaded with the starting address of the data to be processed by the blitter. After the blitter is finished, it will contain the last data address (plus increment and modulo). LINE DRAW BLTAPTL is used as an accumulator LINE DRAW register and must be preloaded with LINE DRAW the starting value of (2Y-X) where LINE DRAW Y/X is the line slope. BLTCPT and LINE DRAW BLTDPT (both H and L) must be LINE DRAW preloaded with the starting address LINE DRAW of the line. [Back to Amiga Developer Docs ]
Libraries_Manual_guide/node0550.html.txt:1:D / Errors / Memory Loss ]" border=0> First determine that your program is actually causing a memory loss. It is important to boot with a standard Workbench because a number of third party items such as some background utilities, shells, and network handlers dynamically allocate and free pieces of memory. Open a Shell for memory checking, and a Shell or Workbench drawer for starting your program. Arrange windows so that all are accessible, and so that no window rearrangement will be needed to run your program. In the Shell, type Avail FLUSH several times (2.0 option). This will flush all non-open disk-loaded fonts, devices, etc., from memory. Note the amount of free memory. Now without rearranging any windows, start your program and use all of your program features. Exit your program, wait a few seconds, then type Avail FLUSH several times. Note the amount of free memory. If this matches the first value you noted, your program is fine, and is not causing a memory loss. If memory was actually lost, and your program can be run from CLI or Workbench, then try the above procedure with both methods of starting your program. Note that under 2.0, there will be a slight permanent (until reboot) memory usage of about 672 bytes when the audio.device or narrator.device is first opened. See " Memory Loss--CLI Only " and " Memory Loss--WorkBench Only " if appropriate. If you lose memory from both WB and CLI, then check all of the open/alloc/get/create/lock type calls in your code, and make sure that there is a matching close/free/delete/unlock type call for each of them (note--there are a few system calls that have or require no corresponding free--check the Autodocs). Generally, the close/free/delete/unlock calls should be in opposite order of the allocations. If you are losing a fixed small amount of memory, look for a structure of that size in the Structure Offsets listing in the Amiga ROM Kernel Reference Manual: Includes and Autodocs. For example, a loss of exactly 24 bytes is probably a Lock() which has not been UnLock() ed. If you are using ScrollRaster() , be aware that ScrollRaster() left or right in a Superbitmap window with no TmpRas will lose memory under 1.3 (workaround--attach a TmpRas). If you lose much more memory when started from Workbench, make sure your program is not using Exit (n). This would bypass startup code cleanups and prevent a Workbench-loaded program from being unloaded. Use exit(n) instead. [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node04D9.html.txt:1:narrator.device/OpenDevice ]" border=0> NAME OpenDevice - opens the narrator device. SYNOPSIS error = OpenDevice("narrator.device", unit, IORequest , flags); D0 A0 D0 A1 D1 FUNCTION The OpenDevice routine grants access to the narrator device. OpenDevice checks the unit number, and if non-zero, returns an error (ND_UnitErr). If this is the first time the driver has been opened, OpenDevice will attempt to open the audio device and allocate the driver's static buffers. If either of these operations fail, an error is returned. See the .h and .i include files for possible error return codes. Next, OpenDevice (done for all opens, not just the first one) initializes various fields in the user's IORequest block (see below). If users wish to use non-default values for these parms, the values must be set after the open is done. OpenDevice also assigns a pseudo unit number to the IORB for use in synchronizing read and write requests. See the read command for more details. Finally, OpenDevice stores the device node pointer in the IORequest block and clears the delayed expunge bit. ***** NEW FOR V37 NARRATOR ***** Several new fields in the IORequest block have been added for V37 narrator. These fields are initialized when the device is opened if the NDB_NEWIORB bit is set in the flags field of the user's IORequest block. Note that NDB_NEWIORB is set in the IORequest block, NOT in the "flags" input parm to the OpenDevice call. INPUTS device - "narrator.device" unit - 0 IORequest - Pointer to the user's IORequest block flags - 0 RESULTS The narrator device will initialize the IORequest block as follows (assume IORB points to the IOrequest block): IORB->rate = 150; /* Speaking rate in words/minute */ IORB->pitch = 110; /* Baseline pitch in Hertz */ IORB->mode = NATURALF0; /* Pitch (F0) mode */ IORB->sex = MALE; /* Sex of voice */ IORB->volume = 64 /* Volume, full on */ IORB->sampfreq = 22200 /* Audio sampling freq */ IORB->mouths = 0 /* Don't generate sync events */ and if the NDB_NEWIORB bit is set: IORB->F0enthusiasm = 0 /* F0 excursion factor */ IORB->F0perturb = 32 /* F0 perturbation (in 32nds) */ IORB->F1adj = 0 /* F1 adjustment in ±5% steps */ IORB->F2adj = 0 /* F2 adjustment in ±5% steps */ IORB->F3adj = 0 /* F3 adjustment in ±5% steps */ IORB->A1adj = 0 /* A1 adjustment in decibels */ IORB->A2adj = 0 /* A2 adjustment in decibels */ IORB->A3adj = 0 /* A3 adjustment in decibels */ IORB->articulate = 100 /* Transition time multiplier */ IORB->centralize = 0 /* Degree of vowel centralization */ IORB->centphon = "" /* Pointer to central ASCII phon */ IORB->AVbias = 0 /* AV bias */ IORB->AFbias = 0 /* AF bias */ IORB->priority = 100 /* Priority while speaking */ SEE ALSO The include files contain the complete IORequest block definition, default settings, and error return codes. Exec input/output documentation. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0012.html.txt:1:A Register Summary / ADKCON, ADKCONR ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- ADKCON 09E W P Audio, disk, control write ADKCONR 010 R P Audio, disk, control read BIT# USE ---- ------------------------------------ 15 SET/CLR Set/clear control bit. Determines if bits written with a 1 get set or cleared. Bits written with a zero are always unchanged. 14-13 PRECOMP 1-0 CODE PRECOMP VALUE ---- ------------- 00 none 01 140 ns 10 280 ns 11 560 ns 12 MFMPREC ( 1=MFM precomp 0=GCR precomp) 11 UARTBRK Forces a UART break (clears TXD) if true. 10 WORDSYNC Enables disk read synchronizing on a word equal to DISK SYNC CODE, located in address (3F)*2. 09 MSBSYNC Enables disk read synchronizing on the MSB (most significant bit). Appl type GCR. 08 FAST Disk data clock rate control 1=fast(2us) 0=slow(4us). (fast for MFM, slow for MFM or GCR) 07 USE3PN Use audio channel 3 to modulate nothing. 06 USE2P3 Use audio channel 2 to modulate period of channel 3. 05 USE1P2 Use audio channel 1 to modulate period of channel 2. 04 USE0P1 Use audio channel 0 to modulate period of channel 1. 03 USE3VN Use audio channel 3 to modulate nothing. 02 USE2V3 Use audio channel 2 to modulate volume of channel 3. 01 USE1V2 Use audio channel 1 to modulate volume of channel 2. 00 USE0V1 Use audio channel 0 to modulate volume of channel 1. NOTE: If both period and volume are modulated on the same channel, the period and volume will be alternated. First word xxxxxxxx V6-V0 , Second word P15-P0 (etc) [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0014.html.txt:1:A Register Summary / AUDxLCH, AUDxLCL ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- AUDxLCH 0A0 W A( E ) Audio channel x location (high 3 bits, 5 bits if ECS) AUDxLCL 0A2 W A Audio channel x location (low 15 bits) This pair of registers contains the 18 bit starting address (location) of audio channel x (x=0,1,2,3) DMA data. This is not a pointer register and therefore needs to be reloaded only if a different memory location is to be outputted. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node01B6.html.txt:1:Glossary / amplitude modulation ]" border=0> In audio applications, a means of producing complex audio effects by using one audio channel to alter the amplitude of another. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0018.html.txt:1:A Register Summary / BEAMCON0 ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- BEAMCON0 1DC W A( E ) Beam counter control register (SHRES,PAL) [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0279.html.txt:1:PAL Index ]" border=0> PAL, 3 , 62 audio, 140 , 141 , 158-159 beam position, 216 blitter, 193 clock, 2 playfield, 49 , 52 , 57 , 58 serial baud rate, 255 sprites, 100 vertical blank, 219 video, 3 , 24 , 34 , 40-41 , 45 , 304 [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0045.html.txt:1:A Register Summary / VPOSR, VPOSW ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- VPOSR 004 R A( E ) Read vertical most significant bit (and frame flop) VPOSW 02A W A Write vertical most significant bit (and frame flop) BIT# 15,14,13,12,11,10,09,08,07,06,05,04,03,02,01,00 ----------------------------------------------- USE LOF-- -- -- -- -- -- --,-- -- -- -- -- -- -- V8 LOF=Long frame (auto toggle control bit in BPLCON0 ) [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node02E0.html.txt:1:Hard_examples/rotatebits.asm ]" border=0> ; ; rotatebits.asm ; ; Here we rotate bits. This code takes a single raster row of a ; bitplane, and `rotates' it into an array of 16-bit words, setting ; the specified bit of each word in the array according to the ; corresponding bit in the raster row. We use the line mode in ; conjunction with patterns to do this magic. Link this code with amiga.lib. ; ; Input: d0 contains the number of words in the raster row. d1 ; contains the number of the bit to set (0..15). a0 contains a ; pointer to the raster data, and a1 contains a pointer to the ; array we are filling; the array must be at least (d0)*16 words ; (or (d0)*32 bytes) long. ; ; include 'exec/types.i' include 'hardware/custom.i' include 'hardware/blit.i' include 'hardware/dmabits.i' include 'hardware/hw_examples.i' ; xref _custom ; xdef rotatebits ; ; ; Our entry point. ; rotatebits: lea _custom,a2 ; We need to access the custom registers tst d0 ; if no words, just return beq gone lea DMACONR(a2),a3 ; get the address of dmaconr moveq.l #DMAB_BLTDONE-8,d2 ; get the bit number BLTDONE btst d2,(a3) ; check to see if we're done wait1: btst d2,(a3) ; check again. bne wait1 ; not done? Keep waiting moveq.l #-30,d3 ; Line mode: aptr = 4Y-2X, Y=0; X=15 move.l d3,BLTAPT(a2) move.w #-60,BLTAMOD(a2) ; amod = 4Y-4X clr.w BLTBMOD(a2) ; bmod = 4Y move.w #2,BLTCMOD(a2) ; cmod = width of bitmap (2) move.w #2,BLTDMOD(a2) ; ditto ror.w #4,d1 ; grab the four bits of the bit number and.w #$f000,d1 ; mask them out or.w #$bca,d1 ; USEA, USEC, USED, F=AB+~AC move.w d1,BLTCON0(a2) ; stuff it move.w #$f049,BLTCON1(a2) ; BSH=15, SGN, LINE move.w #$8000,BLTADAT(a2) ; Initialize A dat for line move.w #$ffff,BLTAFWM(a2) ; Initialize masks move.w #$ffff,BLTALWM(a2) move.l a1,BLTCPT(a2) ; Initialize pointer move.l a1,BLTDPT(a2) lea BLTBDAT(a2),a4 ; For quick access, we grab these two lea BLTSIZE(a2),a5 ; addresses move.w #$402,d1 ; Stuff bltsize; width=2, height=16 move.w (a0)+,d3 ; Get next word bra inloop ; Go into the loop again: move.w (a0)+,d3 ; Grab another word btst d2,(a3) ; Check blit done wait2: btst d2,(a3) ; Check again bne wait2 ; oops, not ready, loop around inloop: move.w d3,(a4) ; stuff new word to make vertical move.w d1,(a5) ; start the blit subq.w #1,d0 ; is that the last word? bne again ; keep going if not gone: rts end [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0005.html.txt:1:1 / Components of the Amiga / Amiga Memory System ]" border=0> As mentioned previously, the custom chips have DMA access to RAM which allows them to perform graphics, audio, and I/O chores independently of the CPU. This shared memory that both the custom chips and the CPU can access directly is called Chip memory. The custom chips and the 680x0 CPU share Chip memory on a fully interleaved basis. Since the 680x0 only needs to access the Chip memory bus during each alternate clock cycle in order to run full speed, the rest of the time the Chip memory bus is free for other activities. The custom chips use the memory bus during these free cycles, effectively allowing the CPU to run at full speed most of the time. There are some occasions though when the custom chips steal memory cycles from the 680x0. In the higher resolution video modes, some or all of the cycles normally used for processor access are needed by the custom chips for video refresh. In that case, the Copper and the blitter in the custom chips steal time from the 680x0 for jobs they can do better than the 680x0. Thus, the system DMA channels are designed with maximum performance in mind. Even when such cycle stealing occurs, it only blocks the 680x0's access to the internal, shared memory. When using ROM or external memory, also known as Fast memory, the 680x0 always runs at full speed. The DMA capabilities of the custom chips vary depending on the version of the chips and the Amiga model. The original custom chip set found in the A1000 could access the first 512K of RAM. Most A1000s have only 512K of RAM so some of the Chip RAM is used up for operating system overhead. A later version of the custom chips found in early A500s and A2000s replaced the original Agnus chip (8361) with a newer version called Fat Agnus (8370/8371). The Fat Agnus chip has DMA access to 512K of Chip memory, just like the original Agnus, but also allows an additional 512K of internal slow memory or pseudo-fast memory located at ($00C0 0000). Since the slow memory can be used for operating system overhead, this allows all 512K of Chip memory to be used by the custom chips. The name slow memory comes from the fact that bus contention with the custom chips can still occur even though only the CPU can access the memory. Since slow memory is arbitrated by the same gate that controls Chip memory, the custom chips can block processor access to slow memory in the higher resolution video modes. The latest version of Agnus and the custom chips found in most A500s and A2000s is known as the Enhanced Chip Set or ECS. ECS Fat Agnus (8372A) can access up to one megabyte of Chip memory. It is pin compatible with the original Fat Agnus (8370/8371) found in earlier A500 and A2000 models. In addition, ECS Fat Agnus supports both the NTSC and PAL video standards on a single chip. In the A3000, the Enhanced Chip Set can access up to two megabytes of Chip memory. The amount of Chip memory is important since it determines how much graphics, audio, and disk data the custom chips can operate on without the 680x0 CPU. Table 1-1 summarizes the basic memory configurations of the Amiga. Chip RAM Maximum Total RAM Maximum (base model) Chip RAM (base model) Total RAM ------------ -------- ------------ --------- Amiga 1000 256K 512K 256K 9 MB Amiga 500 512K 1 MB 1 MB 9 MB Amiga 2000 512K 1 MB 1 MB 9 MB Amiga 3000 1 MB 2 MB 2 MB over 1 GB Table 1-1: Summary of Amiga Memory Configurations Another primary feature of the Amiga hardware is the ability to dynamically control which part of the Chip memory is used for the background display, audio, and sprites. The Amiga is not limited to a small, specific area of RAM for a frame buffer. Instead, the system allows display bitplanes, sprite processor control lists, coprocessor instruction lists, or audio channel control lists to be located anywhere within Chip memory. This same region of memory can be accessed by the bit blitter. This means, for example, that the user can store partial images at scattered areas of Chip memory and use these images for animation effects by rapidly replacing on screen material while saving and restoring background images. In fact, the Amiga includes firmware support for display definition and control as well as support for animated objects embedded within playfields. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node00D8.html.txt:1:5 Audio Hardware / Forming and Playing a Sound ]" border=0> This section shows you how to create a simple, steady sound and play it. Many basic concepts that apply to all sound generation on the Amiga are introduced in this section. To produce a steady tone, follow these basic steps: 1. Decide which channel to use. 2. Define the waveform and create the sample table in memory. 3. Set registers telling the system where to find the data and the length of the data. 4. Select the volume at which the tone is to be played. 5. Select the sampling period, or output rate of the data. 6. Select an audio channel and start up the DMA. Deciding Which Channel to Use Playing the Waveform Creating the Waveform Data Stopping the Audio Dma Telling the System About the Data Audio Summary Selecting the Volume Audio Example Selecting the Data Output Rate [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0035.html.txt:1:A Register Summary / HBSTOP, HBSTRT, HCENTER, HSSTOP, HSSTRT, HTOTAL ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- HBSTOP 1C6 W A( E ) Horizontal line position for HBLANK stop HBSTRT 1C4 W A( E ) Horizontal line position for HBLANK start HCENTER 1E2 W A( E ) Horizontal position for Vsync on interlace HSSTOP 1C2 W A( E ) Horizontal line position for HSYNC stop HSSTRT 1DE W A( E ) Horizontal sync start (VARHSY) HTOTAL 1C0 W A( E ) Highest number count, horiz. line (VARBEAMEN=1) [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0001.html.txt:1:Amiga® Hardware Reference Manual: Preface ]" border=0> The Amiga Technical Reference Series is the official guide to programming Amiga computers. This revised edition of the Amiga Hardware Reference Manual provides detailed information about the Amiga's graphics and audio hardware, and how the Amiga talks to the outside world through peripheral devices. This edition has been updated for version 2.0 of the Amiga operating system and covers the newest Amiga computer systems including the A3000. This book is intended for the following audiences: * Assembly language programmers who need a more direct way of interacting with the Amiga than the routines provided in the system software. * Designers who want to interface new peripherals to the Amiga. * Anyone who wants to know how the Amiga hardware works. Here is a brief overview of the contents: Chapter 1, Introduction . An overview of the hardware and survey of the Amiga's graphics and audio features. Chapter 2, Coprocessor Hardware . Using the Copper coprocessor to control the entire graphics and audio system; directing mid-screen modifications in graphics displays and directing register changes during the time between displays. Chapter 3, Playfield Hardware . Creating, displaying and scrolling the playfields, one of the basic display elements of the Amiga; how the Amiga produces multi-color, bitmapped displays. Chapter 4, Sprite Hardware . Using the eight sprite direct memory access (DMA) channels to make sprite movable objects; creating their data structures, displaying and moving them, reusing the DMA channels. Chapter 5, Audio Hardware . Overview of sampled sound; how to produce quality sound, simple and complex sounds, and modulated sounds. Chapter 6, Blitter Hardware . Using the blitter DMA channel to create animation effects and draw lines into playfields. Chapter 7, System Control Hardware . Using the control registers to define depth arrangement of graphics objects, detect collisions between graphics objects, control direct memory access, and control interrupts. Chapter 8, Interface Hardware . How the Amiga talks to the outside world through controller ports, keyboard, audio jacks and video connectors, serial and parallel interfaces; information about the disk controller and RAM expansion slot. Appendices. Alphabetical and address-order listings of all the graphics and audio system registers and the functions of their bits. Also included is a special section on the Amiga's Enhanced Chip Set (ECS), system memory maps, descriptions of internal and external connectors, specifications for the peripheral interface ports, keyboard, and an introduction to the Amiga's Zorro expansion bus with detailed specifications for hardware add-on designers. We suggest that you use this book according to your level of familiarity with the Amiga system. Here are some suggestions: * If this is your initial exposure to the Amiga, read chapter 1, which gives a survey of all the hardware features and a brief rundown of graphics and audio effects created by hardware interaction. * If you are already familiar with the system and want to acquaint yourself with how the various bits in the hardware registers govern the way the system functions, browse through chapters 2 through 8. Examples are included in these chapters. * For advanced users, the appendices give a concise summary of the entire register set and the uses of the individual bits. Once you are familiar with the effects of changes in the various bits, you may wish to refer more often to the appendices than to the explanatory chapters. The other manuals in this series are the Amiga User Interface Style Guide, an application design specification and reference work for Amiga programmers, the Amiga ROM Kernel Reference Manual: Includes and Autodocs, an alphabetically organized reference of ROM function summaries and Amiga system include files, the Amiga ROM Kernel Reference Manual: Libraries and the Amiga ROM Kernel Reference Manual: Devices with tutorial-style chapters on the use of each Amiga system library and device. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node002B.html.txt:1:A Register Summary / COPJMP1, COPJMP2 ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- COPJMP1 088 S A Copper restart at first location COPJMP2 08A S A Copper restart at second location These addresses are strobe addresses. When written to, they cause the Copper to jump indirect using the address contained in the first or second location registers described below. The Copper itself can write to these addresses, causing its own jump indirect. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0126.html.txt:1:6 Blitter Hardware / Zero Flag ]" border=0> A blitter zero flag is provided that can be tested to determine if the logic operation selected has resulted in zero bits for all destination bits, even if those destination bits are not written due to the D DMA channel being disabled. This feature is often useful for collision detection , by performing a logical "and" on two source images to test for overlap. If the images do not overlap, the zero flag will stay true. The Zero flag is only valid after the blitter has completed its operation and can be read from bit (13) DMAF_BLTNZERO of the DMACONR register. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node02CD.html.txt:1:Hard_examples/hires_playfield.asm ]" border=0> ; ; hires_payfield.asm ; ; This example sets up a high resolution, interlaced display with one ; bitplane. This example also relies on the include file hw_examples.i. ; LEA CUSTOM,a0 ; Address of custom chips MOVE.W #$9204,BPLCON0(a0) ; Hires, one bitplane, interlaced MOVE.W #0,BPLCON1(a0) ; Horizontal scroll value = 0 MOVE.W #80,BPL1MOD(a0) ; Modulo = 80 for odd bitplanes MOVE.W #80,BPL2MOD(a0) ; Ditto for even bitplanes MOVE.W #$003C,DDFSTRT(a0) ; Set data-fetch start for Hires MOVE.W #$00D4,DDFSTOP(a0) ; Set data-fetch stop MOVE.W #$2C81,DIWSTRT(a0) ; Set display window start MOVE.W #$F4C1,DIWSTOP(a0) ; Set display window stop ; ; Set up color registers ; MOVE.W #$000F,COLOR00(a0) ; Background color = blue MOVE.W #$0FFF,COLOR01(a0) ; Foreground color = white ; ; Set up bitplane at $20000 ; LEA $20000,a1 ; Point a1 at bitplane LEA CHARLIST(pc),a2 ; a2 points at character data MOVE.W #400,d1 ; Write 400 lines of data MOVE.W #20,d0 ; Write 20 long words per line L1: MOVE.L (a2),(a1)+ ; Write a long word DBRA d0,L1 ; Decrement counter and loop until full... ; MOVE.W #20,d0 ; Reset long word counter ADDQ.L #4,a2 ; Point at next word in char list CMPI.L #$FFFFFFFF,(a2) ; End of char list? BNE L2 LEA CHARLIST(pc),a2 ; Yes, reset a2 to beginning of list L2: DBRA d1,L1 ; Decrement line counter and loop until done... ; ; Start DMA ; MOVE.W #(DMAF_SETCLR!DMAF_RASTER!DMAF_MASTER),DMACON(a0) ; Enable bitplane DMA only, no Copper ; Because this example has no Copper list, it sits in a loop waiting ; for the vertical blanking interval. When it comes, you check the LOF ; ( long frame ) bit in VPOSR. If LOF = 0, this is a short frame and the ; bitplane pointers are set to point to $20050. If LOF = 1, then this is ; a long frame and the bitplane pointers are set to point to $20000. This ; keeps the long and short frames in the right relationship to each other. VLOOP: MOVE.W INTREQR(a0),d0 ; Read interrupt requests AND.W #$0020,d0 ; Mask off all but vertical blank BEQ VLOOP ; Loop until vertical blank comes MOVE.W #$0020,INTREQ(a0) ; Reset vertical interrupt MOVE.W VPOSR(a0),d0 ; Read LOF bit into d0 bit 15 BPL VL1 ; If LOF = 0, jump MOVE.L #$20000,BPL1PTH(a0) ; LOF = 1, point to $20000 BRA VLOOP ; Back to top VL1: MOVE.L #$20050,BPL1PTH(a0) ; LOF = 0, point to $20050 BRA VLOOP ; Back to top ; ; Character list ; CHARLIST: DC.L $18FC3DF0,$3C6666D8,$3C66C0CC,$667CC0CC DC.L $7E66C0CC,$C36666D8,$C3FC3DF0,$00000000 DC.L $FFFFFFFF [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node002A.html.txt:1:A Register Summary / COPINS ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- COPINS 08C W A Copper instruction fetch identify This is a dummy address that is generated by the Copper whenever it is loading instructions into its own instruction register. This actually occurs every Copper cycle except for the second (IR2) cycle of the MOVE instruction. The three types of instructions are shown below. MOVE Move immediate to destination. WAIT Wait until beam counter is equal to, or greater than. (keeps Copper off of bus until beam position has been reached). SKIP Skip if beam counter is equal to or greater than (skips following MOVE instruction unless beam position has been reached). MOVE WAIT UNTIL SKIP IF -------- ----------- ------------ BIT# IR1 IR2 IR1 IR2 IR1 IR2 ---- ---- ---- ---- ---- ---- ---- 15 X RD15 VP7 BFD * VP7 BFD * 14 X RD14 VP6 VE6 VP6 VE6 13 X RD13 VP5 VE5 VP5 VE5 12 X RD12 VP4 VE4 VP4 VE4 11 X RD11 VP3 VE3 VP3 VE3 10 X RD10 VP2 VE2 VP2 VE2 09 X RD09 VP1 VE1 VP1 VE1 08 DA8 RD08 VP0 VE0 VP0 VE0 07 DA7 RD07 HP8 HE8 HP8 HE8 06 DA6 RD06 HP7 HE7 HP7 HE7 05 DA5 RD05 HP6 HE6 HP6 HE6 04 DA4 RD04 HP5 HE5 HP5 HE5 03 DA3 RD03 HP4 HE4 HP4 HE4 02 DA2 RD02 HP3 HE3 HP3 HE3 01 DA1 RD01 HP2 HE2 HP2 HE2 00 0 RD00 1 0 1 1 IR1=First instruction register IR2=Second instruction register DA =Destination address for MOVE instruction. Fetched during IR1 time, used during IR2 time on RGA bus. RD =RAM data moved by MOVE instruction at IR2 time directly from RAM to the address given by the DA field. VP =Vertical beam position comparison bit. HP =Horizontal beam position comparison bit. VE =Enable comparison (mask bit). HE =Enable comparison (mask bit). * NOTE BFD=Blitter finished disable. When this bit is true, the Blitter Finished flag will have no effect on the Copper. When this bit is zero, the Blitter Finished flag must be true (in addition to the rest of the bit comparisons) before the Copper can exit from its wait state or skip over an instruction. Note that the V7 comparison cannot be masked. The Copper is basically a two-cycle machine that requests the bus only during odd memory cycles (4 memory cycles per instruction). This prevents collisions with display, audio, disk, refresh, and sprites, all of which use only even cycles. It therefore needs (and has) priority over only the blitter and microprocessor. There are only three types of instructions: MOVE immediate, WAIT until, and SKIP if. All instructions (except for WAIT) require two bus cycles (and two instruction words). Since only the odd bus cycles are requested, four memory cycle times are required per instruction (memory cycles are 280 ns.) There are two indirect jump registers, COP1LC and COP2LC . These are 18-bit pointer registers whose contents are used to modify the program counter for initialization or jumps. They are transferred to the program counter whenever strobe addresses COPJMP1 or COPJMP2 are written. In addition, COP1LC is automatically used at the beginning of each vertical blank time. It is important that one of the jump registers be initialized and its jump strobe address hit after power-up but before Copper DMA is initialized. This insures a determined startup address and state. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0044.html.txt:1:A Register Summary / VHPOSR, VHPOSW ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- VHPOSR 006 R A Read vertical and horizontal position of beam or lightpen VHPOSW 02C W A Write vertical and horizontal position of beam or lightpen BIT# 15,14,13,12,11,10,09,08,07,06,05,04,03,02,01,00 ----------------------------------------------- USE V7 V6 V5 V4 V3 V2 V1 V0,H8 H7 H6 H5 H4 H3 H2 H1 RESOLUTION = 1/160 of screen width (280 ns) [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node0072.html.txt:1:audio.device/Expunge ]" border=0> NAME EXPUNGE - indicate a desire to remove the Audio device FUNCTION The Expunge routine is called when a user issues a RemDevice call. By the time it is called, the device has already been removed from the device list, so no new opens will succeed. The existence of any other users of the device, as determined by the device open count being non-zero, will cause the Expunge to be deferred. When the device is not in use, or no longer in use, the Expunge is actually performed. [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node0094.html.txt:1:card.resource/CardMiscControl ]" border=0> NAME CardMiscControl -- Set/Clear miscellaneous control bits SYNOPSIS control_bits=CardMiscControl( handle, control_bits ); d0 a1 d1 UBYTE CardMiscControl( struct CardHandle *, UBYTE ); FUNCTION Used to set/clear miscellaneous control bits (generally for use with I/O cards). INPUTS handle - Same handle as that used when OwnCard() was called. control_bits - A mask value of control bits to be turned on/off. The bit values which might be usable are defined in card.h/i. For example, to enable digital audio, and disable hardware write-protect (if supported), you would call this function with these values -- CARDF_DISABLE_WP|CARDF_ENABLE_DIGAUDIO Then to turn off digital audio, but leave write-protect disable, you would use a value of -- CARDF_DISABLE_WP Finally too reenable write protect, call this function with a mask value of 0. RETURNS control_bits - The same mask value you called this function with if successful. If one, or more bits has been cleared in the return mask, this would indicate that the control bit is not being supported, or that the card has been removed by the user. For example, if you called this function with a mask value of -- CARDF_DISABLE_WP|CARDF_ENABLE_DIGAUDIO And this function returned a value of -- CARDF_DISABLE_WP This would indicate that it is not possible to enable digital audio (most likely because this feature has not been implemented). NOTES This function may be called from within a task, or from a level 1 or level 2 interrupt. !!!IMPORTANT!!! You should ALWAYS try to enable digital audio for I/O cards as this will also configure the card socket for the I/O interface (if supported). Not all cards will connect the write-enable line (e.g., some I/O cards). On some machines (e.g., the A600) it will not be possible to write to such cards unless you disable write-protection by using this function. !!!NEW!!! For card.resource V39 (check resource base for VERSION before using), new bits have been defined which let you enable/disable particular status change interrupts. See CardInterface() for defaults. These new bits are backwards compatable with V37 for which only the CARDB_DISABLE_WP, and CARDB_ENABLE_DIGAUDIO bits were defined. These new bits allow you to enable, or disable specific status change interrupts including BVD1/SC, BVD2/DA, and BSY/IRQ. The defaults for these status change interrupts are unchanged from V37, and WR (Write-protect) status change interrupts are always enabled as they use to be. An example of use: CARD_INTF_SETCLR!CARD_INTF_BVD1 Would enable BVD1/SC status change interrupts, and not change the enable/disable state for BVD2/DA or BSY/IRQ status change interrupts. If the change was made successfully, the CARD_INTB_BVD1 bit would be set in register D0 when this function returns. SEE ALSO CardInterface() , resources/card.h , resources/card.i [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node026D.html.txt:1:Interrupt Index ]" border=0> Interrupt, 26 , 35 , 35 , 207 , 217 8520, 251 audio, 147 , 148 , 153 , 157 , 164-165 , 220 beam synchronized, 3 blitter, 35 , 171 , 187 , 220 control registers, 217 copper, 25 , 32 , 216 , 219 disk, 220 , 245 , 250 external, 219 graphics, 33 interrupt enable bit, 218 interrupt lines, 217 maskable, 217 nonmaskable, 217 parallel, 259 priorities, 221 registers, 218 serial, 255 , 256 , 258 serial port, 220 setting and clearing bits, 218 vertical blanking, 219 [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node023E.html.txt:1:J Custom Chip Pin Allocation List / Fat Agnus Pin Assignment ]" border=0> PIN # DESIGNATION FUNCTION DEFINITION ----- ----------- ------------------ ---------- 01-14 RD15-RD2 Register bus lines 15 to 2 I/O 17 INT3* Blitter ready interrupt O 18 DMAL Request audio/disk DMA I 18 RD1 Register bus line 1 I/O 18 RST* Reset I 19 BLS* Blitter slowdown I 20 DBR* Data bus request O 21 RRW DRAM Write/Read O 22 PRW Processor Write/Read I 23 RGEN* RG Enable I 24 AS* Address Strobe I 25 RAMEN* RAM Enable I 26-33 RGA8-RGA1 Register address bus 8-1 O 34 28MHZ Master clock I 35 XCLK Alternate master clock I 36 XCLKEN* Master clock enable I 37 CDAC* Inverted shifted 7MHZ clk O 38 7MHZ 28MHZ clk divided by four O 39 CCKQ Color clock delay O 40 CCK Color clock O 41 TEST Test - access registers I (old Fat Agnus) NTSC/PAL Select video environment I (ECS Fat Agnus) 43-51 MA0-MA8 Output bus lines 0 to 8 O 52 LDS* Lower data strobe I 53 UDS* Upper data strobe I 54 CASL* Column addr strobe lower O 55 CASU* Column addr strobe upper O 56 RAS1* Row address strobe one O 57 RAS0* Row address strobe zero O 59-77 A19-A1 Address bus lines 19 to 1 I 78 LP* Light pen O 79 VSY* Vertical synch I/O 80 CSY* Composite video synch O 81 HSY* Horizontal synch I/O 84 RD0 Register bus line 0 I/O [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node009D.html.txt:1:card.resource/OwnCard ]" border=0> NAME OwnCard -- Own credit card registers, and memory SYNOPSIS return = OwnCard( handle ) d0 a1 struct CardHandle *OwnCard( struct CardHandle * ); FUNCTION This function is used to obtain immediate, or deferred ownership of a credit-card in the credit-card slot. Typically an EXEC STYLE DEVICE will be written to interface between an application, and a credit card in the slot. While applications, and libraries can attempt to own a credit-card in the card slot, the rest of this documentation assumes a device interface will be used. Because credit-cards can be inserted, or removed by the user at any time (otherwise known as HOT-INSERTION, and HOT-REMOVAL), the card.resource provides devices with a protocol which lets many devices bid for ownership of a newly inserted card. In general, devices should support HOT-REMOVAL, however there are legitimate cases where HOT-REMOVAL is not practical. For these cases this function allows you to own the resource using the CARDB_RESETREMOVE flag. If the card is removed before your device calls ReleaseCard() , the machine will RESET . INPUTS handle - pointer to a CardHandle structure. struct CardHandle { struct Node cah_CardNode; struct Interrupt *cah_CardRemoved; struct Interrupt *cah_CardInserted; struct Interrupt *cah_CardStatus; UBYTE cah_CardFlags; }; The following fields in the structure must be filled in by the application before calling OwnCard() - cah_CardNode.ln_Pri - See table below. The Node field is used by the resource to add your handle to a sorted list of CardHandle structures. This list is used by the resource to notify devices when the device owns the credit-card. Your device will only be notified (at most) one time per card insertion, and perhaps less often if some higher priority device on the notification list retains ownership of a card in the slot. Priority Comments -------------------------------------------------- >= 21 Reserved for future use 10-20 To be used by third party devices (e.g., I/O CARD manufacturers) which look for specific card tuples to identify credit-cards. 01-19 Reserved for future use 00 To be used by general purpose devices which have loose card specification requirements. CardHandle structure. cah_CardNode.ln_Name - Must be initialized to NULL, or name of device which owns this structure. cah_CardRemoved - Pointer to an initialized interrupt structure. Only the is_Data, and is_Code fields need to be initialized. This is the interrupt code which will be called when a credit-card which your device owns is removed. Once you receive this interrupt, all credit-card interface control registers are reset (e.g., programming voltage, access speed, etc.), and you should stop accessing the card as soon as possible. Because your code is called on interrupt time, you should do the least amount possible, and use little stack space. This pointer can be NULL if you have asked for reset on card-removal, and you never turn reset off. cah_ CardInserted - Pointer to an initialized interrupt structure. Only the is_Data, and is_Code fields need to be initialized. This is the code which will be called when your CardHandle owns the credit-card in the slot. Note that your code may be called on the context of an interrupt, or a task in FORBID, therefore you should do the least amount possible, and use little stack space. Note that it is possible to receive a card removed interrupt immediately before you receive this interrupt if the card is removed while your CardInserted interrupt is being called. Your device owns the credit-card until the card is manually removed by the user, or you release the card by calling ReleaseCard() . Your device should examine the card in the slot (e.g., look for specific tuples), and decide if the card is of a type your device understands. If not, release ownership of the card by calling ReleaseCard() so that other devices will be given a chance to examine the current card in the credit-card slot. cah_CardStatus - Pointer to an initialized interrupt structure. Only the is_Data, and is_Code fields need to be initialized. Note that your code will be called on the context of an interrupt, therefore you should do the least amount possible, and use little stack space. Note that it is possible to receive a card removed interrupt immediately before you receive this interrupt if the card is removed during this interrupt. If this pointer is NULL, you will not receive card status change interrupts. Your interrupt code will be called with a mask value in register D0, and a pointer to your data in A1. The mask value in D0 can be interpreted using the same bit definitions returned by ReadCardStatus() . Note that more than one bit may be set, and the mask only tells you what has changed, not the current state. Use ReadCardStatus() if you need to determine the current state of the status bits. Not all status change interrupts will necessarily be enabled on all systems. For example, on some systems BVD2/DA status change interrupts will not be enabled so that digital audio can occur without generating many interrupts. Status change interrupts are typically meant to be used for monitoring BSY/IRQ, WR, and BVD1/SC. Battery voltage low detection would best be done by a separate utility which periodically polls BVD1 & BVD2 by using the ReadCardStatus() function. Typically the mask value in D0 MUST be returned unchanged on exit from your code. The return value in D0 is then used to clear the source(s) of the interrupt. In the rare case that you need to keep a status change interrupt active, clear the appropriate bit(s) in D0 before returning via RTS. Clear no bits other than those defined as valid bits for ReadCardStatus()! !!!NEW FOR V39!!! See definition of CARDB_POSTSTATUS below. cah_CardFlags - Optional flags (all other bits must be 0). - CARDB_RESETREMOVE means you want the machine to reset if the credit-card in the slot is removed while you own the credit-card. - CARDB_IFAVAILABLE means you only want ownership of the credit-card in the slot if it is immediately available. If it is available, your CardHandle structure will be added to a list so that you can be notified via an interrupt when the credit-card is removed by the user. If the credit-card is not immediately available (either because there is no credit-card in the slot, or because some other device owns the credit-card), your CardHandle structure will NOT be added to the notification list. - CARDB_DELAYOWNERSHIP means you never want a successful return from OwnCard() even if the credit-card is available. Rather you will be notified of ownership via your cah_CardInserted interrupt. If you use this flag, OwnCard() will always return -1. This flag cannot be used with the CARDB_IFAVAILABLE flag. - CARDB_POSTSTATUS is new for V39 card.resource (check resource base VERSION before using). It is meant to be used by drivers which want to service the card hardware AFTER the status change interrupt has been cleared on the gate array. Previously a PORTS interrupt server had to be added to do this; this is somewhat more efficient, and easier to use. Your status change interrupt is first called with status change bits in register D0. You would examine these bits, and set a flag(s) for the POST callback. When you return from the status change interrupt, the interrupt on the gate array is cleared (based on what you return in register D0), and your status change interrupt is immediately called again, but this time with 0 in D0. The value you return in D0 for the POST callback case is ignored. ALL other fields are used by the resource, and no fields in the structure may be modified while the structure is in use by the resource. If you need to make changes, you must remove your CardHandle (see ReleaseCard() ), make the changes, and then call OwnCard() again. RESULTS 0 - indicates success, your device owns the credit card. -1 - indicates that the card cannot be owned (most likely because there is no card in the credit card slot). ptr - indicates failure. Returns pointer to the CardHandle structure which owns the credit card. NOTES This function should only be called from a task. CardHandle interrupts are called with a pointer to your data in A1, and a pointer to your code in A5. With the exception of status change interrupts, D0-D1, A0-A1, and A5-A6 may be treated as scratch registers. Status change interrupts are also called with meaningful data in D0, and expect D0 be preserved upon RTS from your code. No other registers are guaranteed to contain initialized data. All other registers must be preserved. SEE ALSO ReleaseCard() , ReadCardStatus() , resources/card.i, resources/card.h [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0047.html.txt:1:Amiga® Hardware Reference Manual: 2 Coprocessor Hardware ]" border=0> In this chapter, you will learn how to use the Amiga's graphics coprocessor (or Copper) and its simple instruction set to organize mid-screen register value modifications and pointer register set-up during the vertical blanking interval. The chapter shows how to organize Copper instructions into Copper lists, how to use Copper lists in interlaced mode, and how to use the Copper with the blitter. The Copper is discussed in this chapter in a general fashion. The chapters that deal with playfields, sprites, audio, and the blitter contain more specific suggestions for using the Copper. About the Copper Putting Together a Copper Instruction List What is a Copper Instruction? Starting and Stopping the Copper The MOVE Instruction Advanced Topics The WAIT Instruction Summary of Copper Instructions Using the Copper Registers [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node02D1.html.txt:1:Hard_examples/HAM_playfield.asm ]" border=0> ; ; HAM_playfield.asm ; ; The following example code generates a six-bitplane display with ; hold-and-modify mode turned on. All 32 color registers are loaded ; with black to prove that the colors are being generated by ; hold-and-modify. The equates are the usual and are not repeated here. ; First, set up the control registers. ; LEA CUSTOM,a0 ; Point a0 at custom chips MOVE.W #$6A00,BPLCON0(a0) ; Six bitplanes, hold-and-modify mode MOVE.W #0,BPLCON1(a0) ; Horizontal scroll = 0 MOVE.W #0,BPL1MOD(a0) ; Modulo for odd bitplanes = 0 MOVE.W #0,BPL2MOD(a0) ; Ditto for even bitplanes MOVE.W #$0038,DDFSTRT(a0) ; Set data-fetch start MOVE.W #$00D0,DDFSTOP(a0) ; Set data-fetch stop MOVE.W #$2C81,DIWSTRT(a0) ; Set display window start MOVE.W #$F4C1,DIWSTOP(a0) ; Set display window stop ; ; Set all color registers = black to prove that hold-and-modify mode is working. ; MOVE.W #32,d0 ; Initialize counter LEA CUSTOM+COLOR00,a1 ; Point a1 at first color register CREGLOOP: MOVE.W #$0000,(a1)+ ; Write black to a color register DBRA d0,CREGLOOP ; Decrement counter and loop til done... ; ; Fill six bitplanes with an easily recognizable pattern. ; ; NOTE: This is just for example use. Normally these bitplanes would ; need to be allocated from the system MEMF_CHIP memory pool. ; MOVE.W #2000,d0 ; 2000 longwords per bitplane MOVE.L #$21000,a1 ; Point a1 at bitplane 1 MOVE.L #$23000,a2 ; Point a2 at bitplane 2 MOVE.L #$25000,a3 ; Point a3 at bitplane 3 MOVE.L #$27000,a4 ; Point a4 at bitplane 4 MOVE.L #$29000,a5 ; Point a5 at bitplane 5 MOVE.L #$2B000,a6 ; Point a6 at bitplane 6 FPLLOOP: MOVE.L #$55555555,(a1)+ ; Fill bitplane 1 with $55555555 MOVE.L #$33333333,(a2)+ ; Fill bitplane 2 with $33333333 MOVE.L #$0F0F0F0F,(a3)+ ; Fill bitplane 3 with $0F0F0F0F MOVE.L #$00FF00FF,(a4)+ ; Fill bitplane 4 with $00FF00FF MOVE.L #$CF3CF3CF,(a5)+ ; Fill bitplane 5 with $CF3CF3CF MOVE.L #$3CF3CF3C,(a6)+ ; Fill bitplane 6 with $3CF3CF3C DBRA d0,FPLLOOP ; Decrement counter and loop til done... ; ; Set up a Copper list at $20000. ; ; NOTE: As with the bitplanes, the copper list location should be allocated ; from the system MEMF_CHIP memory pool. ; MOVE.L #$20000,a1 ; Point a1 at Copper list destination LEA COPPERL(pc),a2 ; Point a2 at Copper list image CLOOP: MOVE.L (a2),(a1)+ ; Move a long word... CMPI.L #$FFFFFFFE,(a2)+ ; Check for end of Copper list BNE CLOOP ; Loop until entire Copper list moved ; ; Point Copper at Copper list. ; MOVE.L #$20000,COP1LCH(a0) ; Load Copper jump register MOVE.W COPJMP1(a0),d0 ; Force load into Copper P.C. ; ; Start DMA. ; MOVE.W #$8380,DMACON(a0) ; Enable bitplane and Copper DMA BRA .....next stuff to do..... ; ; Copper list for six bitplanes. Bitplane 1 is at $21000; 2 is at $23000; ; 3 is at $25000; 4 is at $27000; 5 is at $29000; 6 is at $2B000. ; ; NOTE: These bitplane addresses are for example purposes only. ; See note above. ; COPPERL: DC.W BPL1PTH,$0002 ; Bitplane 1 pointer = $21000 DC.W BPL1PTL,$1000 DC.W BPL2PTH,$0002 ; Bitplane 2 pointer = $23000 DC.W BPL2PTL,$3000 DC.W BPL3PTH,$0002 ; Bitplane 3 pointer = $25000 DC.W BPL3PTL,$5000 DC.W BPL4PTH,$0002 ; Bitplane 4 pointer = $27000 DC.W BPL4PTL,$7000 DC.W BPL5PTH,$0002 ; Bitplane 5 pointer = $29000 DC.W BPL5PTL,$9000 DC.W BPL6PTH,$0002 ; Bitplane 6 pointer = $2B000 DC.W BPL6PTL,$B000 DC.W $FFFF,$FFFE ; Wait for the impossible, i.e., quit [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node003B.html.txt:1:A Register Summary / POTGO, POTGOR ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- POTGO 034 W P Pot port data write and start. POTGOR 016 R P Pot port data read (formerly called POTINP). This register controls a 4-bit bi-directional I/O port that shares the same four pins as the four pot counters above. BIT# FUNCT DESCRIPTION ---- --------------------------------------- 15 OUTRY Output enable for Paula pin 36 14 DATRY I/O data Paula pin 36 13 OUTRX Output enable for Paula pin 35 12 DATRX I/O data Paula pin 35 11 OUTLY Output enable for Paula pin 33 10 DATLY I/O data Paula pin 33 09 OUTLX Output enable for Paula pin 32 08 DATLX I/O data Paula pin 32 07-01 0 Reserved for chip ID code (presently 0) 00 START Start pots (dump capacitors, start counters) [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node0065.html.txt:1:audio.device/ADCMD_PERVOL ]" border=0> NAME ADCMD_PERVOL -- change the period and volume for writes in progress to audio channels FUNCTION ADCMD_PERVOL is a command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct and there is a write (CMD_WRITE) in progress, ADCMD_PERVOL loads a new volume and period immediately or at the end of the current cycle depending on the sync flag (ADIOF_SYNCCYCLE). If the allocation key in incorrect, ADCMD_PERVOL returns an error (ADIOERR_NOALLOCATION). ADCMD_PERVOL is synchronous and only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. Do not use ADCMD_PERVOL in interrupt code at interrupt level 5 or higher. INPUTS mn_ReplyPort- pointer to message port that receives I/O request if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to load period and volume (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for ADCMD_PERVOL io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ADIOF_SYNCCYCLE- (CLEAR) load period and volume immediately (SET) load period and volume at the end of the current cycle ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command ioa_Period - new sample period in 279.365 ns increments (124 thru 65536, anti-aliasing filter works below 300 to 500 depending on waveform) ioa_Volume - new volume (0 thru 64, linear) OUTPUTS io_Unit - bit map of channels that successfully loaded period and volume (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node002E.html.txt:1:A Register Summary / DIWHIGH, DIWSTOP, DIWSTRT ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- DIWHIGH 1E4 W A,D( E ) Display window - upper bits for start, stop DIWSTOP 090 W A Display window stop (lower right vertical-horizontal position) DIWSTRT 08E W A Display window start (upper left vertical-horizontal position) These registers control display window size and position by locating the upper left and lower right corners. BIT# 15,14,13,12,11,10,09,08,07,06,05,04,03,02,01,00 ----------------------------------------------- USE V7 V6 V5 V4 V3 V2 V1 V0 H7 H6 H5 H4 H3 H2 H1 H0 DIWSTRT is vertically restricted to the upper 2/3 of the display (V8=0) and horizontally restricted to the left 3/4 of the display (H8=0). DIWSTOP is vertically restricted to the lower 1/2 of the display (V8=/=V7) and horizontally restricted to the right 1/4 of the display (H8=1). [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node00DD.html.txt:1:5 / Forming and Playing a Sound / Selecting the Data Output Rate ]" border=0> The pitch of the sound produced by the waveform depends upon its frequency. To tell the system what frequency to use, you need to specify the sampling period. The sampling period specifies the number of system clock ticks , or timing intervals, that should elapse between each sample (byte of audio data) fed to the digital-to-analog converter in the audio channel. There is a period register for each audio channel. The value of the period register is used for count-down purposes; each time the register counts down to 0, another sample is retrieved from the waveform data set for output. In units, the period value represents clock ticks per sample. The minimum period value you should use is 124 ticks per sample NTSC (123 PAL) and the maximum is 65535. These limits apply to both PAL and NTSC machines. For high-quality sound, there are other constraints on the sampling period (see the section called Producing High-quality Sound ). The period is inversely proportional to the frequency. ------------------------------------------------------ A low period value corresponds to a higher frequency sound and a high period value corresponds to a lower frequency sound. Limitations on Selection of Sampling Period Specifying the Period Value [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0031.html.txt:1:A Register Summary / DSKDAT, DSKDATR ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- DSKDAT 026 W P Disk DMA data write DSKDATR 008 ER P Disk DMA data read (early read dummy address) This register is the disk DMA data buffer. It contains two bytes of data that are either sent (written) to or received (read) from the disk. The write mode is enabled by bit 14 of the LENGTH register. The DMA controller automatically transfers data to or from this register and RAM, and when the DMA data is finished (length=0) it causes a disk block interrupt. See interrupts below. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0170.html.txt:1:7 System Control Hardware / DMA Control ]" border=0> Many different direct memory access (DMA) functions occur during system operation. There is a read address as well as a write address to the DMA control register so you can tell which DMA channels are enabled. The address names for the DMA registers are as follows: DMACONR - Direct Memory Access Control - read-only. DMACON - Direct Memory Access Control - write-only. The contents of this register are shown in Table 7-6 (bit on if enabled). Bit Number Name Function ------ ---- -------- 15 SET/CLR The set/reset control bit. See description of bit 15 . 14 BBUSY Blitter busy status - read-only 13 BZERO Blitter zero status - read-only. Remains 1 if, during a blitter operation, the blitter output was always zero. 12, 11 Unassigned 10 BLTPRI Blitter priority. Also known as "blitter-nasty." When this is a 1, the blitter has full (instead of partial) priority over the 680x0. 9 DMAEN DMA enable. This is a master DMA enable bit. It enables the DMA for all of the channels at bits 8-0. 8 BPLEN Bitplane DMA enable 7 COPEN Coprocessor DMA enable 6 BLTEN Blitter DMA enable 5 SPREN Sprite DMA enable 4 DSKEN Disk DMA enable 3-0 AUDxEN Audio DMA enable for channels 3-0 (x = 3 - 0). Table 7-6: Contents of DMA Control Register For more information on using the DMA, see the following chapters: Copper Chapter 2: Coprocessor Hardware Bitplanes Chapter 3: Playfield Hardware Sprites Chapter 4: Sprite Hardware Audio Chapter 5: Audio Hardware Blitter Chapter 6: Blitter Hardware Disk Chapter 8: Interface Hardware Processor Access To Chip Memory ------------------------------- The Amiga chips access Chip memory directly via DMA, rather than utilizing traditional bus arbitration mechanisms. Therefore, processor supplied features for multiprocessor support, such as the 68000 TAS (test and set) instruction, cannot serve their intended purpose and are not supported by the Amiga architecture. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0212.html.txt:1:Glossary / Paula ]" border=0> One of the three main Amiga custom chips, Paula contains audio, disk, and interrupt circuitry. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node01D9.html.txt:1:Glossary / coprocessor ]" border=0> An extra processor that enhances system performance by doing a specialized task, such as graphics or math, very quickly. This frees the main processor to do other work. Every Amiga has at least three coprocessor chips named Paula, Agnus, and Denise to handle graphics and audio. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node01AE.html.txt:1:Amiga® Hardware Reference Manual: Glossary ]" border=0> A I address interlace mode Agnus interrupt aliasing distortion J Alt keys joystick Amiga keys L AmigaDOS light pen amplitude local bus amplitude modulation longword arbitration low asserted low resolution (Lores) atomic cycle M attach mode manual mode AUTOCONFIG(TM) master automatic mode MIDI B microsecond (us) backplane millisecond (ms) barrel shifter minterm baud rate modulo beam counters motherboard bitmap mouse bitplane multitasking bitplane animation N blanking interval nanosecond (ns) blitter negated burst non-interlaced mode bus cycle NTSC bus hogging nybble bus starvation O byte overscan area C P Chip RAM paddle controller clear PAL CLI parallel port clipping Paula clock PIC collision pitch color descriptor words pixels color indirection playfield color palette playfield object color register playfield animation color table pointer register Command Line Interface (Shell or CLI) polarity composite video potentiometer controller Q coordinates quantization noise copper R coprocessor RAM cursor keys raster cycle strobe read-only D request data resolution data fetch ROM delay S Denise sample depth sampling rate device sampling period Digital-to-Analog Converter (DAC) scroll Direct Memory Access (DMA) SCSI display field serial port display mode set display time Shell display window slave DMA slot DMA latency sprite dual-playfield mode strobe address E T Enhanced Chip Set (ECS) task equal-tempered scale termination Exec timbre F timeout Fast RAM transparent font tri-state frequency U frequency modulation UART G V genlock video priority grant video display H W HAM write-only hidden cycles word high Z high resolution (Hires) Zorro hold-and-modify (HAM) [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node00F2.html.txt:1:5 Audio Hardware / The Audio State Machine ]" border=0> For an explanation of the various states, refer to Figure 5-8. There is one audio state machine for each channel. The machine has eight states and is clocked at the clock constant rate (3.58 MHz NTSC). Three of the states are basically unused and just transfer back to the idle (000) state. One of the paths out of the idle state is designed for interrupt-driven operation (processor provides the data), and the other path is designed for DMA-driven operation (the "Agnus" special chip provides the data). In interrupt-driven operation, transfer to the main loop (states 010 and 011) occurs immediately after data is written by the processor. In the 010 state the upper byte is output, and in the 011 state the lower byte is output. Transitions such as 010->011->010 occur whenever the period counter counts down to one. The period counter is reloaded at these transitions. As long as the interrupt is cleared by the processor in time, the machine remains in the main loop. Otherwise, it enters the idle state. Interrupts are generated on every word transition (011->010). In DMA-driven operation, transition to the 001 state occurs and DMA requests are sent to Agnus as soon as DMA is turned on. Because of pipelining in Agnus, the first data word must be thrown away. State 101 is entered as soon as this word arrives; a request for the next data word has already gone out. When the data arrives, state 010 is entered and the main loop continues until the DMA is turned off. The length counter counts down once with each word that comes in. When it finishes, a DMA restart request goes to Agnus along with the regular DMA request. This tells Agnus to reset the pointer to the beginning of the table of data. Also, the length counter is reloaded and an interrupt request goes out soon after the length counter finishes (counts to one). The request goes out just as the last word of the waveform starts its output. DMA requests and restart requests are transferred to Agnus once each horizontal line, and the data comes back about 14 clock cycles later (the duration of a clock cycle is 280 ns). In attach mode, things run a little differently. In attach volume, requests occur as they do in normal operation (on the 011->010 transition). In attach period, a set of requests occurs on the 010->011 transition. When both attach period and attach volume are high, requests occur on both transitions. If the sampling rate is set much higher than the normal maximum sampling rate (approximately 29 KHz), the two samples in the buffer register will be repeated. If the filter on the Amiga is bypassed and the volume is set to the maximum ($40), this feature can be used to make modulated carriers up to 1.79 MHz. The modulation is placed in the memory map, with plus values in the even bytes and minus values in the odd bytes. The symbols used in the state diagram are explained in the following list. Upper-case names indicate external signals; lower-case names indicate local signals. AUDxON DMA on "x" indicates channel number (signal from DMACON ). AUDxIP Audio interrupt pending (input to channel from interrupt circuitry). AUDxIR Audio interrupt request (output from channel to interrupt circuitry) intreq1 Interrupt request that combines with intreq2 to form AUDxIR.. intreq2 Prepare for interrupt request. Request comes out after the next 011->010 transition in normal operation. AUDxDAT Audio data load signal. Loads 16 bits of data to audio channel. AUDxDR Audio DMA request to Agnus for one word of data. AUDxDSR Audio DMA request to Agnus to reset pointer to start of block. dmasen Restart request enable. percntrld Reload period counter from back-up latch typically written by processor with AUDxPER (can also be written by attach mode). percount Count period counter down one latch. perfin Period counter finished (value = 1). lencntrld Reload length counter from back-up latch. lencount Count length counter down one notch. lenfin Length counter finished (value = 1). volcntrld Reload volume counter from back-up latch. pbufld1 Load output buffer from holding latch written to by AUDxDAT. pbufld2 Like pbufld1, but only during 010->011 with attach period. AUDxAV Attach volume. Send data to volume latch of next channel instead of to D->A converter. AUDxAP Attach period. Send data to period latch of next channel instead of to the D->A converter. penhi Enable the high 8 bits of data to go to the D->A converter. napnav /AUDxAV * /AUDxAP + AUDxAV -- no attach stuff or else attach volume. Condition for normal DMA and interrupt requests. sq2,1,0 The name of the state flip-flops, MSB to LSB. Figure 5-8: Audio State Diagram ECS Audio. ---------- For information on the audio hardware in the Enhanced Chip Set, see the ECS register map in Appendix C. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node002C.html.txt:1:A Register Summary / DDFSTOP, DDFSTRT ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- DDFSTOP 094 W A Display data fetch stop (horiz. position) DDFSTRT 092 W A Display data fetch start (horiz. position) These registers control the horizontal timing of the beginning and end of the bitplane DMA display data fetch. The vertical bitplane DMA timing is identical to the display windows described above. The bitplane modulos are dependent on the bitplane horizontal size and on this data-fetch window size. Register bit assignment ------------------------- BIT# 15,14,13,12,11,10,09,08,07,06,05,04,03,02,01,00 ----------------------------------------------- USE X X X X X X X X H8 H7 H6 H5 H4 H3 X X (Always set X bits to 0 to maintain upward compatibility) The tables below show the start and stop timing for different register contents. DDFSTRT (left edge of display data fetch) ---------------------------------------- PURPOSE H8,H7,H6,H5,H4 ----------------- -------------- Extra wide (max) * 0 0 1 0 1 Wide 0 0 1 1 0 Normal 0 0 1 1 1 Narrow 0 1 0 0 0 DDFSTOP (right edge of display data fetch) ------------------------------------------ PURPOSE H8,H7,H6,H5,H4 ------------------ -------------- Narrow 1 1 0 0 1 Normal 1 1 0 1 0 Wide (max) 1 1 0 1 1 [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0043.html.txt:1:A Register Summary / VBSTOP, VBSTRT ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- VBSTOP 1CE W A( E ) Vertical line for VBLANK stop VBSTRT 1CC W A( E ) Vertical line for VBLANK start [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0013.html.txt:1:A Register Summary / AUDxDAT ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- AUDxDAT 0AA W P Audio channel x data This register is the audio channel x (x=0,1,2,3) DMA data buffer. It contains 2 bytes of data that are each 2's complement and are outputted sequentially (with digital-to-analog conversion) to the audio output pins. (LSB = 3 MV) The DMA controller automatically transfers data to this register from RAM. The processor can also write directly to this register. When the DMA data is finished (words outputted=length) and the data in this register has been used, an audio channel interrupt request is set. [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node04B7.html.txt:1:audio.device/Expunge ]" border=0> NAME EXPUNGE - indicate a desire to remove the Audio device FUNCTION The Expunge routine is called when a user issues a RemDevice call. By the time it is called, the device has already been removed from the device list, so no new opens will succeed. The existence of any other users of the device, as determined by the device open count being non-zero, will cause the Expunge to be deferred. When the device is not in use, or no longer in use, the Expunge is actually performed. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0277.html.txt:1:NTSC Index ]" border=0> NTSC, 62 , 100 , 100 audio, 140 , 141 , 158-159 blitter, 193 clock, 2 playfield, 49 , 52 , 57 , 58 serial baud rate, 255 sprites, 100 , 100 vertical blank, 219 video, 3 , 24 , 27 , 34 , 40-41 , 45 , 304 [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node04B0.html.txt:1:audio.device/CMD_FLUSH ]" border=0> NAME CMD_FLUSH -- cancel all pending I/O FUNCTION CMD_FLUSH is a standard command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct, CMD_FLUSH aborts all writes (CMD_WRITE) in progress or queued and any I/O requests waiting to synchronize with the end of the cycle (ADCMD_WAITCYCLE); otherwise, CMD_FLUSH returns an error (ADIOERR_NOALLOCATION). CMD_FLUSH is synchronous and only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. Do not use CMD_FLUSH in interrupt code at interrupt level 5 or higher. INPUTS mn_ReplyPort- pointer to message port that receives I/O request if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to flush (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for CMD_FLUSH io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channels successfully flushed (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node0194.html.txt:1:8 / / Timing / ADKCON and ADKCONR - Audio and Disk Control Register ]" border=0> ADKCON is the write-only address and ADKCONR is the read-only address for this register. Not all of the bits are dedicated to the disk. Bit 15 of this register allows independent setting or clearing of any bit or bits. If bit 15 is a one on a write, any ones in positions 0-14 will set the corresponding bit. If bit 15 is a zero, any ones will clear the corresponding bit. Table 8-8: ADKCON and ADKCONR Register Bit Number Name Function ------ ---- -------- 15 SET/CLR Control bit that allows setting or clearing of individual bits without affecting the rest of the register. If bit 15 is a 1, the specified bits are set. If bit 15 is a 0, the specified bits are cleared. 14 PRECOMP1 MSB of Precompensation specifier 13 PRECOMP0 LSB of Precompensation specifier Value of 00 selects none. Value of 01 selects 140 ns. Value of 10 selects 280 ns. Value of 11 selects 560 ns. 12 MFMPREC Value of 0 selects GCR Precompensation. Value of 1 selects MFM Precompensation. 10 WORDSYNC Value of 1 enables synchronizing and starting of DMA on disk read of a word. The word on which to synchronize must be written into the DSKSYNC address ($DFF07E). This capability is highly useful. 9 MSBSYNC Value of 1 enables sync on most significant bit of the input (usually used for GCR). 8 FAST Value of 1 selects two microseconds per bit cell (usually MFM). Data must be valid raw MFM. 0 selects four microseconds per bit (usually GCR). 7-0 These bits are used by the audio subsystem for volume and frequency modulation. The raw MFM data that must be presented to the disk controller will be twice as large as the unencoded data. The following table shows the relationship: 1 -> 01 0 -> 10 ;if following a 0 0 -> 00 ;if following a 1 With clever manipulation, the blitter can be used to encode and decode the MFM. In one common form of GCR recording, each data byte always has the most significant bit set to a 1. MSBSYNC, when a 1, tells the disk controller to look for this sync bit on every disk byte. When reading a GCR formatted disk, the software must use a translate table called a nybble-izer to assure that data written to the disk does not have too many consecutive 1's or 0's. [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node02D2.html.txt:1:Hard_examples/sprite_display.asm ]" border=0> ; ; sprite_display.asm ; ; This example displays the spaceship sprite at location V = 65, ; H = 128. Remember to include the file hw_examples.i. ; ; First, we set up a single bitplane. ; LEA CUSTOM,a0 ;Point a0 at custom chips MOVE.W #$1200,BPLCON0(a0) ;1 bitplane color is on MOVE.W #$0000,BPL1MOD(a0) ;Modulo = 0 MOVE.W #$0000,BPLCON1(a0) ;Horizontal scroll value = 0 MOVE.W #$0024,BPLCON2(a0) ;Sprites have priority over playfields MOVE.W #$0038,DDFSTRT(a0) ;Set data-fetch start MOVE.W #$00D0,DDFSTOP(a0) ;Set data-fetch stop ; Display window definitions. MOVE.W #$2C81,DIWSTRT(a0) ;Set display window start ;Vertical start in high byte. ;Horizontal start * 2 in low byte. MOVE.W #$F4C1,DIWSTOP(a0) ;Set display window stop ;Vertical stop in high byte. ;Horizontal stop * 2 in low byte. ; ; Set up color registers. ; MOVE.W #$0008,COLOR00(a0) ;Background color = dark blue MOVE.W #$0000,COLOR01(a0) ;Foreground color = black MOVE.W #$0FF0,COLOR17(a0) ;Color 17 = yellow MOVE.W #$00FF,COLOR18(a0) ;Color 18 = cyan MOVE.W #$0F0F,COLOR19(a0) ;Color 19 = magenta ; ; Move Copper list to $20000. ; MOVE.L #$20000,a1 ;Point A1 at Copper list destination LEA COPPERL(pc),a2 ;Point A2 at Copper list source CLOOP: MOVE.L (a2),(a1)+ ;Move a long word CMP.L #$FFFFFFFE,(a2)+ ;Check for end of list BNE CLOOP ;Loop until entire list is moved ; ; Move sprite to $25000. ; MOVE.L #$25000,a1 ;Point A1 at sprite destination LEA SPRITE(pc),a2 ;Point A2 at sprite source SPRLOOP: MOVE.L (a2),(a1)+ ;Move a long word CMP.L #$00000000,(a2)+ ;Check for end of sprite BNE SPRLOOP ;Loop until entire sprite is moved ; ; Now we write a dummy sprite to $30000, since all eight sprites are activated ; at the same time and we're only going to use one. The remaining sprites ; will point to this dummy sprite data. ; MOVE.L #$00000000,$30000 ;Write it ; ; Point Copper at Copper list. ; MOVE.L #$20000,COP1LC(a0) ; ; Fill bitplane with $FFFFFFFF. ; MOVE.L #$21000,a1 ;Point A1 at bitplane MOVE.W #1999,d0 ;2000-1(for dbf) long words = 8000 bytes FLOOP MOVE.L #$FFFFFFFF,(a1)+ ;Move a long word of $FFFFFFFF DBF d0,FLOOP ;Decrement, repeat until false. ; ; Start DMA. ; MOVE.W d0,COPJMP1(a0) ;Force load into Copper ; program counter MOVE.W #$83A0,DMACON(a0) ;Bitplane, Copper, and sprite DMA RTS ;..return to rest of program.. ; ; This is a Copper list for one bitplane, and 8 sprites. ; The bitplane lives at $21000. ; Sprite 0 lives at $25000; all others live at $30000 (the dummy sprite). ; COPPERL: DC.W BPL1PTH,$0002 ;Bitplane 1 pointer = $21000 DC.W BPL1PTL,$1000 DC.W SPR0PTH,$0002 ;Sprite 0 pointer = $25000 DC.W SPR0PTL,$5000 DC.W SPR1PTH,$0003 ;Sprite 1 pointer = $30000 DC.W SPR1PTL,$0000 DC.W SPR2PTH,$0003 ;Sprite 2 pointer = $30000 DC.W SPR2PTL,$0000 DC.W SPR3PTH,$0003 ;Sprite 3 pointer = $30000 DC.W SPR3PTL,$0000 DC.W SPR4PTH,$0003 ;Sprite 4 pointer = $30000 DC.W SPR4PTL,$0000 DC.W SPR5PTH,$0003 ;Sprite 5 pointer = $30000 DC.W SPR5PTL,$0000 DC.W SPR6PTH,$0003 ;Sprite 6 pointer = $30000 DC.W SPR6PTL,$0000 DC.W SPR7PTH,$0003 ;Sprite 7 pointer = $30000 DC.W SPR7PTL,$0000 DC.W $FFFF,$FFFE ;End of Copper list ; ; Sprite data for spaceship sprite. It appears on the screen at V=65 and H=128. ; SPRITE: DC.W $6D60,$7200 ;VSTART, HSTART, VSTOP DC.W $0990,$07E0 ;First pair of descriptor words DC.W $13C8,$0FF0 DC.W $23C4,$1FF8 DC.W $13C8,$0FF0 DC.W $0990,$07E0 DC.W $0000,$0000 ;End of sprite data [Back to Amiga Developer Docs ]
Hardware_Manual_guide/node003E.html.txt:1:A Register Summary / SERPER ]" border=0> Agnus/ Read/ Denise/ Register Address Write Paula Function -------- ------- ----- ------- -------- SERPER 032 W P Serial port period and control This register contains the control bit LONG referred to above, and a 15-bit number defining the serial port baud rate. If this number is N, then the baud rate is 1 bit every (N+1)*.2794 microseconds. BIT# SYM FUNCTION ----- ---- --------------- 15 LONG Defines serial receive as 9-bit word. 14-00 RATE Defines baud rate=1/((N+1)*.2794 microsec.) [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node04A7.html.txt:1:audio.device/ADCMD_FINISH ]" border=0> NAME ADCMD_FINISH -- abort writes in progress to audio channels FUNCTION ADCMD_FINISH is a command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct and there is a write (CMD_WRITE)in progress, ADCMD_FINISH aborts the current write immediately or at the end of the current cycle depending on the sync flag (ADIOF_SYNCCYCLE). If the allocation key is incorrect ADCMD_FINISH returns an error (ADIOERR_NOALLOCATION). ADCMD_FINISH is synchronous and only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. Do not use ADCMD_FINISH in interrupt code at interrupt level 5 or higher. INPUTS mn_ReplyPort- pointer to message port that receives I/O request if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to finish (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for ADCMD_FINISH io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ADIOF_SYNCCYCLE- (CLEAR) finish immediately (SET) finish at the end of current cycle ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channels successfully finished (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel [Back to Amiga Developer Docs ]
Libraries_Manual_guide/node054A.html.txt:1:D / Errors / Fails only on machines with Fast RAM ]" border=0> Data and buffers which will be accessed directly by the custom chips must be in Chip RAM. This includes bitplanes (use OpenScreen() or AllocRaster() ), audio samples, trackdisk buffers, and the graphic image data for sprites, pointers, bobs, images, gadgets, etc. Use compiler or linker flags to force Chip RAM loading of any initialized data needing to be in Chip RAM, or dynamically allocate Chip RAM and copy any initialization data there. [Back to Amiga Developer Docs ]
Libraries_Manual_guide/node0288.html.txt:1:17 Introduction to Exec / Dynamic Memory Allocation ]" border=0> The Amiga has a soft machine architecture, meaning that all tasks, including those that are part of its operating system, do not use fixed memory addresses. As a result, any program that needs to use a chunk of memory must allocate that memory from the operating system. There are two functions on the Amiga for simple memory allocation: AllocMem() and AllocVec() . The two functions accept the same parameters, a ULONG containing the size of the memory block in bytes followed by 32-bit specifier for memory attributes. Both functions return the address of a longword aligned memory block if they were successful or NULL if something went wrong. AllocVec() differs from AllocMem() in that it records the size of the memory block allocated so an application does not have to remember the size of a memory block it allocated. AllocVec() was introduced in Release 2, so it is not available to the 1.3 developer. Normally the bitmask of memory attributes passed to these functions will contain any of the following attributes (these flags are defined in memory.h >): MEMF_ANY This indicates that there is no requirement for either Fast or Chip memory. In this case, while there is Fast memory available, Exec will only allocate Fast memory. Exec will allocate Chip memory if there is not enough Fast memory. MEMF_CHIP This indicates the application wants a block of Chip memory, meaning it wants memory addressable by the Amiga custom chips. Chip memory is required for any data that will be accessed by custom chip DMA. This includes floppy disk buffers, screen memory, images that will be blitted, sprite data, copper lists, and audio data. If your application requires a block of Chip RAM, it must use this flag to allocate the Chip RAM. Otherwise, the application will fail on machines with expanded memory. MEMF_FAST This indicates a memory block outside of the range that the Amiga's custom chips can access. The "FAST" in MEMF_FAST has to do with the custom chips and the CPU trying to access the same memory at the same time. Because the custom chips and the CPU both have access to Chip RAM, the CPU may have to wait to access Chip RAM while some custom chip is reading or writing Chip RAM. In the case of Fast RAM, the custom chips do not have access to it, so the CPU does not have to contend with the custom chips access to Fast RAM, making CPU accesses to Fast RAM generally faster than CPU access to Chip RAM. Since the flag specifies memory that the custom chips cannot access, this flag is mutually exclusive with the MEMF_CHIP flag. If you specify the MEMF_FAST flag, your allocation will fail on Amigas that have only Chip memory. Use MEMF_ANY if you would prefer Fast memory. MEMF_PUBLIC This indicates that the memory should be accessible to other tasks. Although this flag doesn't do anything right now, using this flag will help ensure compatibility with possible future features of the OS (like virtual memory and memory protection). MEMF_CLEAR This indicates that the memory should be initialized with zeros. If an application does not specify any attributes when allocating memory, the system first looks for MEMF_FAST, then MEMF_CHIP. There are additional memory allocation flags for Release 2: MEM_LOCAL , MEMF_24BITDMA and MEMF_REVERSE . See the Exec Autodoc for AllocMem() in the Amiga ROM Kernel Reference Manual: Includes and Autodocs or the include file memory.h > for additional information on these flags. Use of these flags under earlier versions of the operating system will cause your allocation to fail. Make Sure You Have Memory. -------------------------- Always check the result of any memory allocation to be sure the type and amount of memory requested is available. Failure to do so will lead to trying to use an non-valid pointer. When an application is finished with a block of memory it allocated, it must return it to the operating system. There is a function to return memory for both the AllocMem() and the AllocVec() functions. FreeMem() releases memory allocated by AllocMem(). It takes two parameters, a pointer to a memory block and the size of the memory block. FreeVec() releases memory allocated by AllocVec() . It takes only one parameter, a pointer to a memory block allocated by AllocVec(). The following example shows how to allocate and deallocate memory. APTR my_mem; if (my_mem = AllocMem(100, MEMF_ANY)) { /* Your code goes here */ FreeMem(my_mem, 100); } else { /* couldn't get memory, exit with an error */ } [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node000E.html.txt:1:Autodocs 2.0 ]" border=0> Link Libraries -------------- amiga_lib.doc ddebug_lib.doc debug_lib.doc Shared Libraries ---------------- asl.doc icon.doc mathieeesingbas.doc commodities.doc iffparse.doc mathieeesingtrans.doc diskfont.doc intuition.doc mathtrans.doc dos.doc keymap.doc rexxsyslib.doc exec.doc layers.doc translator.doc expansion.doc mathffp.doc utility.doc gadtools.doc mathieeedoubbas.doc wb.doc graphics.doc mathieeedoubtrans.doc Devices ------- audio.doc gameport.doc narrator.doc serial.doc clipboard.doc input.doc parallel.doc timer.doc console.doc keyboard.doc printer.doc trackdisk.doc Resources --------- battclock.doc cia.doc filesysres.doc potgo.doc battmem.doc disk.doc misc.doc [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node006E.html.txt:1:audio.device/CMD_START ]" border=0> NAME CMD_START -- start device processing (like ^Q) FUNCTION CMD_START is a standard command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct and the channel was previously stopped (CMD_STOP), CMP_START immediately starts all writes (CMD_WRITE) to the channel. If the allocation key is incorrect, CMD_START returns an error (ADIOERR_NOALLOCATION). CMD_START starts multiple channels simultaneously to minimize distortion if the channels are playing the same waveform and their outputs are mixed. CMD_START is synchronous an d only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. D o not use CMD_START in interrupt code at interrupt level 5 or higher. INPUTS mn_ReplyPort- pointer to message port that receives I/O request after if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to start (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for CMD_START io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channels successfully started (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node022C.html.txt:1:exec.library/RemIntServer ]" border=0> NAME RemIntServer -- remove an interrupt server from a server chain SYNOPSIS RemIntServer(intNum, interrupt) D0 A1 void RemIntServer(ULONG,struct Interrupt *); FUNCTION This function removes an interrupt server node from the given server chain. If this server was the last one on this chain, interrupts for this chain are disabled. INPUTS intNum - the Paula interrupt bit (0..14) interrupt - pointer to an interrupt server node BUGS Before V36 Kickstart, the feature that disables the interrupt would not function. For most server chains this does not cause a problem. SEE ALSO AddIntServer() , hardware/intbits.h [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node0063.html.txt:1:audio.device/ADCMD_FREE ]" border=0> NAME ADCMD_FREE -- free audio channels for allocation FUNCTION ADCMD_FREE is a command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct, ADCMD_FREE does the following: . restores the channel to a known state (CMD_RESET), . changes the channels allocation key, and . makes the channel available for re-allocation. . If the channel is locked (ADCMD_LOCK) ADCMD_FREE unlocks it and clears the bit for the channel (io_Unit) in the lock I/O request. If the lock I/O request has no channel bits set ADCMD_FREE replies the lock I/O request, and . checks if there are allocation requests (ADCMD_ALLOCATE) waiting for the channel. Otherwise, ADCMD_FREE returns an error (ADIOERR_NOALLOCATION). ADCMD_FREE is synchronous and only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. Do not use ADCMD_FREE in interrupt code. INPUTS mn_ReplyPort- pointer to message port that receives I/O request if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to free (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for ADCMD_FREE io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channels successfully freed (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node0042.html.txt:1:Includes/devices/narrator.h ]" border=0> #ifndef DEVICES_NARRATOR_H #define DEVICES_NARRATOR_H /* ** $Filename: devices/narrator.h $ ** $Release: 2.04 Includes, V37.4 $ ** $Revision: 1.7 $ ** $Date: 91/03/12 $ ** ** V37 Narrator device C language include file ** ** Copyright 1990, 1991 Joseph Katz/Mark Barton. ** All rights reserved. ** ** This include file (narrator.h) may be freely distributed ** as long as the above copyright notice remains intact. ** */ #ifndef EXEC_IO_H #include "exec/io.h" #endif /* Device Options */ #define NDB_NEWIORB 0 /* Use new extended IORB */ #define NDB_WORDSYNC 1 /* Generate word sync messages */ #define NDB_SYLSYNC 2 /* Generate syllable sync messages */ #define NDF_NEWIORB (1 /* Error Codes */ #define ND_NoMem -2 /* Can't allocate memory */ #define ND_NoAudLib -3 /* Can't open audio device */ #define ND_MakeBad -4 /* Error in MakeLibrary call */ #define ND_UnitErr -5 /* Unit other than 0 */ #define ND_CantAlloc -6 /* Can't allocate audio channel(s) */ #define ND_Unimpl -7 /* Unimplemented command */ #define ND_NoWrite -8 /* Read for mouth without write first */ #define ND_Expunged -9 /* Can't open, deferred expunge bit set */ #define ND_PhonErr -20 /* Phoneme code spelling error */ #define ND_RateErr -21 /* Rate out of bounds */ #define ND_PitchErr -22 /* Pitch out of bounds */ #define ND_SexErr -23 /* Sex not valid */ #define ND_ModeErr -24 /* Mode not valid */ #define ND_FreqErr -25 /* Sampling frequency out of bounds */ #define ND_VolErr -26 /* Volume out of bounds */ #define ND_DCentErr -27 /* Degree of centralization out of bounds */ #define ND_CentPhonErr -28 /* Invalid central phon */ /* Input parameters and defaults */ #define DEFPITCH 110 /* Default pitch */ #define DEFRATE 150 /* Default speaking rate (wpm) */ #define DEFVOL 64 /* Default volume (full) */ #define DEFFREQ 22200 /* Default sampling frequency (Hz) */ #define MALE 0 /* Male vocal tract */ #define FEMALE 1 /* Female vocal tract */ #define NATURALF0 0 /* Natural pitch contours */ #define ROBOTICF0 1 /* Monotone pitch */ #define MANUALF0 2 /* Manual setting of pitch contours */ #define DEFSEX MALE /* Default sex */ #define DEFMODE NATURALF0 /* Default mode */ #define DEFARTIC 100 /* 100% articulation (normal) */ #define DEFCENTRAL 0 /* No centralization */ #define DEFF0PERT 0 /* No F0 Perturbation */ #define DEFF0ENTHUS 32 /* Default F0 enthusiasm (in 32nds) */ #define DEFPRIORITY 100 /* Default speaking priority */ /* Parameter bounds */ #define MINRATE 40 /* Minimum speaking rate */ #define MAXRATE 400 /* Maximum speaking rate */ #define MINPITCH 65 /* Minimum pitch */ #define MAXPITCH 320 /* Maximum pitch */ #define MINFREQ 5000 /* Minimum sampling frequency */ #define MAXFREQ 28000 /* Maximum sampling frequency */ #define MINVOL 0 /* Minimum volume */ #define MAXVOL 64 /* Maximum volume */ #define MINCENT 0 /* Minimum degree of centralization */ #define MAXCENT 100 /* Maximum degree of centralization */ /* Standard Write request */ struct narrator_rb { struct IOStdReq message; /* Standard IORB */ UWORD rate; /* Speaking rate (words/minute) */ UWORD pitch; /* Baseline pitch in Hertz */ UWORD mode; /* Pitch mode */ UWORD sex; /* Sex of voice */ UBYTE *ch_masks; /* Pointer to audio alloc maps */ UWORD nm_masks; /* Number of audio alloc maps */ UWORD volume; /* Volume. 0 (off) thru 64 */ UWORD sampfreq; /* Audio sampling freq */ UBYTE mouths; /* If non-zero, generate mouths */ UBYTE chanmask; /* Which ch mask used (internal)*/ UBYTE numchan; /* Num ch masks used (internal) */ UBYTE flags; /* New feature flags */ UBYTE F0enthusiasm; /* F0 excursion factor */ UBYTE F0perturb; /* Amount of F0 perturbation */ BYTE F1adj; /* F1 adjustment in ±5% steps */ BYTE F2adj; /* F2 adjustment in ±5% steps */ BYTE F3adj; /* F3 adjustment in ±5% steps */ BYTE A1adj; /* A1 adjustment in decibels */ BYTE A2adj; /* A2 adjustment in decibels */ BYTE A3adj; /* A3 adjustment in decibels */ UBYTE articulate; /* Transition time multiplier */ UBYTE centralize; /* Degree of vowel centralization */ char *centphon; /* Pointer to central ASCII phon */ BYTE AVbias; /* AV bias */ BYTE AFbias; /* AF bias */ BYTE priority; /* Priority while speaking */ BYTE pad1; /* For alignment */ }; /* Standard Read request */ struct mouth_rb { struct narrator_rb voice; /* Speech IORB */ UBYTE width; /* Width (returned value) */ UBYTE height; /* Height (returned value) */ UBYTE shape; /* Internal use, do not modify */ UBYTE sync; /* Returned sync events */ }; #endif /* DEVICES_NARRATOR_H */ [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node0073.html.txt:1:audio.device/OpenDevice ]" border=0> NAME OpenDevice - open the audio device SYNOPSIS error = OpenDevice("audio.device", unitNumber, iORequest, flags); FUNCTION The OpenDevice routine grants access to the audio device. It takes an I/O audio request block (iORequest) and if it can successfully open the audio device, it loads the device pointer (io_Device) and the allocation key (ioa_AllocKey); otherwise, it returns an error (IOERR_OPENFAIL). OpenDevice increments the open count keeping the device from being expunged (Expunge). If the length (ioa_Length) is non-zero, OpenDevice tries to allocate (ADCMD_ALLOCATE) audio channels from a array of channel combination options (ioa_Data). If the allocation succeeds, the allocated channel combination is loaded into the unit field (ioa_Unit); otherwise, OpenDevice returns an error (ADIOERR_ALLOCFAILED). OpenDevice does not wait for allocation to succeed and closes (CloseDevice) the audio device if it fails. To allocate channels, OpenDevice also requires a properly initialized reply port (mn_ReplyPort) with an allocated signal bit. INPUTS unitNumber- not used iORequest - pointer to audio request block (struct IOAudio) ln_Pri - allocation precedence (-128 thru 127), only necessary for allocation (non-zero length) mn_ReplyPort- pointer to message port for allocation, only necessary for allocation (non-zero length) ioa_AllocKey- allocation key; zero to generate new key. Otherwise, it must be set by (or copied from I/O block that is set by) previous OpenDevice function or ADCMD_ALLOCATE command (non-zero length) ioa_Data - pointer to channel combination options (byte array, bits 0 thru 3 correspond to channels 0 thru 3), only necessary for allocation (non-zero length) ioa_Length - length of the channel combination option array (0 thru 16), zero for no allocation flags - not used OUTPUTS iORequest - pointer to audio request block (struct IOAudio) io_Device - pointer to device node if OpenDevice succeeds, otherwise -1 io_Unit - bit map of successfully allocated channels (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error IOERR_OPENFAIL - open failed ADIOERR_ALLOCFAILED - allocation failed, no open ioa_AllocKey- allocation key, set to a unique number if passed a zero and OpenDevice succeeds error - copy of io_Error [Back to Amiga Developer Docs ]
Libraries_Manual_guide/node0420.html.txt:1:32 / / RigidDiskBlock and Alternate Filesystems / RigidDiskBlock ]" border=0> This is the current specification for the RigidDiskBlock: rdb_ID == 'RDSK' rdb_SummedLongs == 64 rdb_ChkSum block checksum (longword sum to zero) rdb_HostID SCSI Target ID of host This is the initiator ID of the creator of this RigidDiskBlock. It is intended that modification of the RigidDiskBlock, or of any of the blocks pointed to by it, by another initiator (other than the one specified here) be allowed only after a suitable warning. The user is then expected to perform an audio lock out ("Hey, is anyone else setting up SCSI stuff on this bus?"). The rdb_HostID may become something other than the initiator ID when connected to a real network: that is an area for future standardization. rdb_BlockBytes size of disk blocks Under pre-V36 filesystem, this must be 512 for a disk with any AmigaDOS partitions on it. Present filesystem supports 256, 512, 1024, etc. rdb_Flags longword of flags: RDBF._LAST no disks exist to be configured after this one on this controller (SCSI bus). RDBF._LASTLUN no LUNs exist to be configured greater than this one at this SCSI Target ID RDBF._LASTTID no Target IDs exist to be configured greater than this one on this SCSI bus RDBF._NORESELECT don't bother trying to perform reselection when talking to this drive RDBF._DISKID rdb_Disk... identification variables below contain valid data. RDBF._CTRLRID rdb_Controller... identification variables below contain valid data. RDBF._SYNCH drive supports scsi synchronous mode CAN BE DANGEROUS TO USE IF IT DOESN'T! These fields point to other blocks on the disk which are not a part of any filesystem. All block pointers referred to are block numbers on the drive. rdb_BadBlockList optional bad block list A singly linked list of blocks of type PartitionBlock rdb_PartitionList optional first partition block A singly linked list of blocks of type PartitionBlock rdb_FileSysHeaderList optional file system header block A singly linked list of blocks of type FileSysHeaderBlock rdb_DriveInit optional drive-specific init code A singly linked list of blocks of type LoadSegBlock containing initialization code. Called as DriveInit(lun,rdb,ior)(d0/a0/a1). rdb_Reserved1[6] set to $ffffffffs These are reserved for future block lists. Since NULL for block lists is $ffffffff, these reserved entries must be set to $ffffffff. These fields describe the physical layout of the drive. rdb_Cylinders number of drive cylinders rdb_Sectors sectors per track rdb_Heads number of drive heads rdb_Interleave interleave This drive interleave is independent from, and unknown to, the DOS's understanding of interleave as set in the partition's environment vector. rdb_Park landing zone cylinder rdb_Reserved2[3] set to zeros These fields are intended for ST506 disks. They are generally unused for SCSI devices and set to zero. rdb_WritePreComp starting cylinder: write precompensation rdb_ReducedWrite starting cylinder: reduced write current rdb_StepRate drive step rate rdb_Reserved3[5] set to zeros These fields are used while partitions are set up to constrain the partitionable area and help describe the relationship between the drive's logical and physical layout. rdb_RDBlocksLo low block of the range allocated for blocks described here. Replacement blocks for bad blocks may also live in this range. rdb_RDBlocksHi high block of this range (inclusive) rdb_LoCylinder low cylinder of partitionable disk area Blocks described by this include file will generally be found in cylinders below this one. rdb_HiCylinder high cylinder of partitionable data area Usually rdb_Cylinders-1. rdb_CylBlocks number of blocks available per cylinder This may be rdb_Sectors*rdb_Heads, but a SCSI disk that, for example, reserves one block per cylinder for bad block mapping would use rdb_Sectors*rdb_Heads-1. rdb_AutoParkSeconds number of seconds to wait before parking drive heads automatically. If zero, this feature is not desired. rdb_HighRDSKBlock highest block used by these drive definitions Must be less than or equal to rdb_RDBBlocksHi. All replacements for bad blocks should be between rdb_HighRDSKBlock+1 and rdb_RDBBlocksHi (inclusive). rdb_Reserved4 set to zeros These fields are of the form available from a SCSI Identify command. Their purpose is to help the user identify the disk during setup. Entries exist for both controller and disk for non-embedded SCSI disks. rdb_DiskVendor vendor name of the disk rdb_DiskProduct product name of the disk rdb_DiskRevision revision code of the disk rdb_ControllerVendor vendor name of the disk controller rdb_ControllerProduct product name of the disk controller rdb_ControllerRevision revision code of the disk controller rdb_Reserved5[10] set to zeros [Back to Amiga Developer Docs ]
Libraries_Manual_guide/node05ED.html.txt:1:lib_examples/timersoftint.c ]" border=0> ;/* timersoftint.c - Execute me to compile me with SAS C 5.10 LC -b1 -d0 -cfistq -v -y -j73 timersoftint.c Blink FROM LIB:c.o,timersoftint.o TO timersoftint LIBRARY LIB:LC.lib,LIB:Amiga.lib quit ; */ /* timersoftint.c - Timer device software interrupt message port example. */ #include #include #include #include #include #include #include #include #ifdef LATTICE int CXBRK(void) { return(0); } /* Disable Lattice CTRL/C handling */ void chkabort(void) { return; } /* really */ #endif #define MICRO_DELAY 1000 #define OFF 0 #define ON 1 #define STOPPED 2 struct TSIData { ULONG tsi_Counter; ULONG tsi_Flag; struct MsgPort *tsi_Port; }; struct TSIData *tsidata; void tsoftcode(void); /* Prototype for our software interrupt code */ void main(void) { struct MsgPort *port; struct Interrupt *softint; struct timerequest *tr; ULONG endcount; /* Allocate message port, data & interrupt structures. Don't use CreatePort() */ /* or CreateMsgPort() since they allocate a signal (don't need that) for a */ /* PA_SIGNAL type port. We need PA_SOFTINT. */ if (tsidata = AllocMem(sizeof(struct TSIData), MEMF_PUBLIC|MEMF_CLEAR)) { if(port = AllocMem(sizeof(struct MsgPort), MEMF_PUBLIC|MEMF_CLEAR)) { NewList(&(port->mp_MsgList)); /* Initialize message list */ if (softint = AllocMem(sizeof(struct Interrupt), MEMF_PUBLIC|MEMF_CLEAR)) { /* Set up the (software)interrupt structure. Note that this task runs at */ /* priority 0. Software interrupts may only be priority -32, -16, 0, +16, */ /* +32. Also not that the correct node type for a software interrupt is */ /* NT_INTERRUPT. (NT_SOFTINT is an internal Exec flag). This is the same */ /* setup as that for a software interrupt which you Cause(). If our */ /* interrupt code was in assembler, you could initialize is_Data here to */ /* contain a pointer to shared data structures. An assembler software */ /* interrupt routine would receive the is_Data in A1. */ softint->is_Code = tsoftcode; /* The software interrupt routine */ softint->is_Data = tsidata; softint->is_Node.ln_Pri = 0; port->mp_Node.ln_Type = NT_MSGPORT; /* Set up the PA_SOFTINT message port */ port->mp_Flags = PA_SOFTINT; /* (no need to make this port public). */ port->mp_SigTask = (struct Task *)softint; /* pointer to interrupt structure */ /* Allocate timerequest */ if (tr = (struct timerequest *) CreateExtIO(port, sizeof(struct timerequest))) { /* Open timer.device. NULL is success. */ if (!(OpenDevice("timer.device", UNIT_MICROHZ, (struct IORequest *)tr, 0))) { tsidata->tsi_Flag = ON; /* Init data structure to share globally. */ tsidata->tsi_Port = port; /* Send of the first timerequest to start. IMPORTANT: Do NOT */ /* BeginIO() to any device other than audio or timer from */ /* within a software or hardware interrupt. The BeginIO() code */ /* may allocate memory, wait or perform other functions which */ /* are illegal or dangerous during interrupts. */ printf("starting softint. CTRL-C to break...\n"); tr->tr_node.io_Command = TR_ADDREQUEST; /* Initial iorequest to start */ tr->tr_time.tv_micro = MICRO_DELAY; /* software interrupt. */ BeginIO((struct IORequest *)tr); Wait(SIGBREAKF_CTRL_C); endcount = tsidata->tsi_Counter; printf("timer softint counted %ld milliseconds.\n", endcount); printf("Stopping timer...\n"); tsidata->tsi_Flag = OFF; while (tsidata->tsi_Flag != STOPPED) Delay(10); CloseDevice((struct IORequest *)tr); } else printf("couldn't open timer.device\n"); DeleteExtIO(tr); } else printf("couldn't create timerequest\n"); FreeMem(softint, sizeof(struct Interrupt)); } FreeMem(port, sizeof(struct MsgPort)); } FreeMem(tsidata, sizeof(struct TSIData)); } } void tsoftcode(void) { struct timerequest *tr; /* Remove the message from the port. */ tr = (struct timerequest *)GetMsg(tsidata->tsi_Port); /* Keep on going if main() hasn't set flag to OFF. */ if ((tr) && (tsidata->tsi_Flag == ON)) { /* increment counter and re-send timerequest--IMPORTANT: This */ /* self-perpetuating technique of calling BeginIO() during a software */ /* interrupt may only be used with the audio and timer device. */ tsidata->tsi_Counter++; tr->tr_node.io_Command = TR_ADDREQUEST; tr->tr_time.tv_micro = MICRO_DELAY; BeginIO((struct IORequest *)tr); } /* Tell main() we're out of here. */ else tsidata->tsi_Flag = STOPPED; } [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node037D.html.txt:1:exec.library/SetIntVector ]" border=0> NAME SetIntVector -- set a new handler for a system interrupt vector SYNOPSIS oldInterrupt = SetIntVector(intNumber, interrupt) D0 D0 A1 struct Interrupt *SetIntVector(ULONG, struct Interrupt *); FUNCTION This function provides a mechanism for setting the system interrupt vectors. These are non-sharable; setting a new interrupt handler disconnects the old one. Installed handlers are responsible for processing, enabling and clearing the interrupt. Note that interrupts may have been left in any state by the previous code. The IS_CODE and IS_DATA pointers of the Interrupt structure will be copied into a private place by Exec. A pointer to the previously installed Interrupt structure is returned. When the system calls the specified interrupt code, the registers are setup as follows: D0 - scratch D1 - scratch (on entry: active interrupts -> equals INTENA & INTREQ) A0 - scratch (on entry: pointer to base of custom chips for fast indexing) A1 - scratch (on entry: Interrupt's IS_DATA pointer) A5 - jump vector register (scratch on call) A6 - Exec library base pointer (scratch on call) all other registers must be preserved INPUTS intNum - the Paula interrupt bit number (0..14). Only non-chained interrupts should be set. Use AddIntServer() for server chains. interrupt - a pointer to an Interrupt structure containing the handler's entry point and data segment pointer. A NULL interrupt pointer will remove the current interrupt and set illegal values for IS_CODE and IS_DATA. By convention, the LN_NAME of the interrupt structure must point a descriptive string so that other users may identify who currently has control of the interrupt. RESULT A pointer to the prior interrupt structure which had control of this interrupt. SEE ALSO AddIntServer() ,exec/interrupts.i,hardware/intbits.i [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node04AB.html.txt:1:audio.device/ADCMD_SETPREC ]" border=0> NAME ADCMD_SETPREC -- set the allocation precedence for audio channels FUNCTION ADCMD_SETPREC is a command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct, ADCMD_SETPREC sets the allocation precedence to a new value (ln_Pri) and checks if there are allocation requests (ADCMD_ALLOCATE) waiting for the channel which now have higher precedence; otherwise, ADCMD_SETPREC returns an error (ADIOERR_NOALLOCATION). ADCMD_SETPREC is synchronous and only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. Do not use ADCMD_SETPREC in interrupt code. INPUTS ln_Pri - new allocation precedence (-128 thru 127) mn_ReplyPort- pointer to message port that receives I/O request if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to set precedence (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for ADCMD_SETPREC io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channels that successfully set precedence (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node04AD.html.txt:1:audio.device/BeginIO ]" border=0> NAME BeginIO - dispatch a device command SYNOPSIS BeginIO(iORequest); A1 FUNCTION BeginIO has the responsibility of dispatching all device commands. Immediate commands are always called directly, and all other commands are queued to make them single threaded. INPUTS iORequest -- pointer to the I/O Request for this command [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node0067.html.txt:1:audio.device/ADCMD_WAITCYCLE ]" border=0> NAME ADCMD_WAITCYCLE -- wait for an audio channel to complete the current cycle of a write FUNCTION ADCMD_WAITCYCLE is a command for a single audio channel (io_Unit). If the allocation key (ioa_AllocKey) is correct and there is a write (CMD_WRITE) in progress on selected channel, ADCMD_WAITCYCLE does not reply (mn_ReplyPort) until the end of the current cycle. If there is no write is progress, ADCMD_WAITCYCLE replies immediately. If the allocation key is incorrect, ADCMD_WAITCYCLE returns an error (ADIOERR_NOALLOCATION). ADCMD_WAITCYCLE returns an error (IOERR_ABORTED) if it is canceled (AbortIO) or the channel is stolen (ADCMD_ALLOCATE). ADCMD_WAITCYCLE is only asynchronous if it is waiting for a cycle to complete, in which case it clears the quick flag (IOF_QUICK); otherwise, it is synchronous and only replies if the quick flag (IOF_QUICK) is clear. Do not use ADCMD_WAITCYCLE in interrupt code at interrupt level 5 or higher. INPUTS mn_ReplyPort- pointer to message port that receives I/O request, if the quick flag (IOF_QUICK) is clear, or if a write is in progress on the selected channel and a cycle has completed io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channel to wait for cycle (bits 0 thru 3 correspond to channels 0 thru 3), if more then one bit is set lowest bit number channel is used io_Command - command number for CMD_WAITCYCLE io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request (SET) only reply I/O request if a write is in progress on the selected channel and a cycle has completed ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channel that successfully waited for cycle (bits 0 thru 3 correspond to channels 0 thru 3) io_Flags - IOF_QUICK flag cleared if a write is in progress on the selected channel io_Error - error number: 0 - no error IOERR_ABORTED - canceled (AbortIO) or channel stolen ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node005F.html.txt:1:audio.doc ]" border=0> AbortIO() ADCMD_ALLOCATE ADCMD_FINISH ADCMD_FREE ADCMD_LOCK ADCMD_PERVOL ADCMD_SETPREC ADCMD_WAITCYCLE BeginIO() CloseDevice() CMD_CLEAR CMD_FLUSH CMD_READ CMD_RESET CMD_START CMD_STOP CMD_UPDATE CMD_WRITE Expunge() OpenDevice() [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node010E.html.txt:1:Includes/resources/misc.h ]" border=0> #ifndef RESOURCES_MISC_H #define RESOURCES_MISC_H /* ** $Filename: resources/misc.h $ ** $Release: 2.04 Includes, V37.4 $ ** $Revision: 36.13 $ ** $Date: 90/05/06 $ ** ** Unit number definitions for "misc.resource" ** ** (C) Copyright 1985-1999 Amiga, Inc. ** All Rights Reserved */ #ifndef EXEC_TYPES_H #include "exec/types.h" #endif /* EXEC_TYPES_H */ #ifndef EXEC_LIBRARIES_H #include "exec/libraries.h" #endif /* EXEC_LIBRARIES_H */ /* * Unit number definitions. Ownership of a resource grants low-level * bit access to the hardware registers. You are still obligated to follow * the rules for shared access of the interrupt system (see * exec.library/SetIntVector or cia.resource as appropriate). */ #define MR_SERIALPORT 0 /* Amiga custom chip serial port registers (SERDAT,SERDATR,SERPER,ADKCON, and interrupts) */ #define MR_SERIALBITS 1 /* Serial control bits (DTR,CTS, etc.) */ #define MR_PARALLELPORT 2 /* The 8 bit parallel data port (CIAAPRA & CIAADDRA only!) */ #define MR_PARALLELBITS 3 /* All other parallel bits & interrupts (BUSY,ACK,etc.) */ /* * Library vector offset definitions */ #define MR_ALLOCMISCRESOURCE (LIB_BASE) /* -6 */ #define MR_FREEMISCRESOURCE (LIB_BASE-LIB_VECTSIZE) /* -12 */ #define MISCNAME "misc.resource" #endif /* RESOURCES_MISC_H */ [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node0093.html.txt:1:card.resource/CardInterface ]" border=0> NAME CardInterface -- Determine the type of card interface. SYNOPSIS return = CardInterface() d0 ULONG CardInterface( void ); FUNCTION This function is used to determine the type of credit-card (hardware) interface available. For the most part the card.resource hides the hardware details from devices within its function calls. However should we need to provide a work-around because of differences, or limitations imposed by future interface hardware, this function must be used to identify which interface is available. RETURN A ULONG value as defined in card.h/i. NOTES In general only I/O devices (e.g., a device which interfaces with a modem card) would need to provide work-arounds, or alternative code. An example would be a change in the way interrupt requests from the card are handled. Specific details will be provided as need in the future. I/O devices) should abort properly if this function returns a value which is unknown. Current implementations (see card.h/i) - CARD_INTERFACE_AMIGA_0 ------------------------------------------------------------- The card slot can be configured for use as an I/O interface by using the CardMiscControl() function. The card slot inhibits writes to cards which do not negate the WP status bit. This can be overridden by using the CardMiscControl() function. Changes in the interrupt request line are latched by a gate-array, and have to be obtained via the status change mechanism provided when you call the OwnCard() function. The interrupt is cleared when you return from the status change interrupt. A level 2 interrupt is generated. Usually you will want to clear the interrupt on the card at this time, and Signal() a task. The IRQ line is the same as the RDY/BSY line. Changes in BVD1, WP, and RDY/BSY are also latched by the gate-array, and are obtainable via the status change mechanism provided by the OwnCard() function. A level 2 interrupt is generated. Changes in BVD2 (also used for digital audio) have to be monitored via polling. Generally this will cause no problem. Monitoring changes in BVD1 & BVD2 to monitor for low battery condition can be handled by a low priority tool which periodically checks the condition of both lines using the ReadCardStatus() function. As of card.resource V39 (check VERSION in resource base), the CardMiscControl() function can be used to enable/disable status change interrupts for changes in BVD1, BVD2, and the RDY/BSY status line. Status change interrupts for WR (Write-protect enable/disable) are always enabled. The default state of enabled/disabled status change interrupts noted above are unchanged, and automatically reset to the defaults when a card is removed, or when even a task releases ownership of the card. Some PC oriented eight (8) bit cards may require you read odd-byte I/O address registers at the corresponding even-byte address plus 64K. There is sufficient I/O address space provided that exceeding I/O address space should not be a problem. Your code should wait at least 1 millisecond for Vpp to stabilize after voltage change (see CardProgramVoltage() ). SEE ALSO CardMiscControl() , resources/card.i, resources/card.h [Back to Amiga Developer Docs ]
Libraries_Manual_guide/node0093.html.txt:1:P Index ]" border=0> ParentChunk(), 789 , 810 ParseIFF(), 344 , 782 , 810 ParseIX(), 746 PA_SOFTINT, 527 Paula, 11 , 517 PC, 518 Pens --> Performance - loss of, 920 , 920 Permit(), 110 , 470 , 480 , 520 PFBA, 545 - in dual playfield mode, 547 PGA_Freedom, 392 , 394 Philosophy, 23 Pixel width, 548 PlaneOnOff - in Image structure, 226 , using, 230 PlanePick - in Image structure, 226 , using, 230 PLANEPTR, 552 Pointer --> Pointer Relative - requester, 206 POINTREL, 205-206 , 210 , 212 , 213 PolyDraw(), 589 , 611 Polygons, 589 PopChunk(), 787 , 810 POPPUBSCREEN, 52 , 83 Port, 499 - named, 502 , rendezvous at, 502 PORTS, 519 , 525 , 526 PORTS Interrupts, 519 , 525 Position --> PRED, 498 PREDRAWN, 212 , 213 , 214 Preemptive Task Scheduling, 518 Preferences --> Preferences structure (1.3), 333 PrefHeader structure, 337 PrinterGfxPrefs structure, 339 PrinterTxtPrefs structure, 340 printf(), 887 PrintIText(), 224 , 224 , 240 , 240 , 243 , 244 Private class, 293 Privilege violation, 474 Process, 430 Process structure, 430 , 434 - pr_WindowPtr, 219 Processes, 466 Processor - interrupt priority levels, 471 Productivity Mode, 537 , 561 Programming guidelines, 13 PROPBORDERLESS, 140 , 147 PropChunk(), 344 , 783 , 810 propgclass, 297 PropInfo structure, 147 PROPNEWLOOK, 140 , 147 PSNF_PRIVATE, 54 Public class, 293 Public memory, 431 , 456 Public Screen --> PUBLICSCREEN, 108 PubScreenNode Structure --> PubScreenStatus(), 53 , 76 PushChunk(), 787 , 810 putchar(), 887 PutDefDiskObject(), 353 PutDiskObject(), 353 PutMsg(), 503 , 520 puts(), 887 [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node04AE.html.txt:1:audio.device/CloseDevice ]" border=0> NAME CloseDevice - terminate access to the audio device SYNOPSIS CloseDevice(iORequest); A1 FUNCTION The CloseDevice routine notifies the audio device that it will no longer be used. It takes an I/O audio request block (IOAudio) and clears the device pointer (io_Device). If there are any channels allocated with the same allocation key (ioa_AllocKey), CloseDevice frees (ADCMD_FREE) them. CloseDevice decrements the open count, and if it falls to zero and an expunge (Expunge) is pending, the device is expunged. INPUTS iORequest - pointer to audio request block (struct IOAudio) io_Device - pointer to device node, must be set by (or copied from I/O block set by) open (OpenDevice) io_Unit - bit map of channels to free (ADCMD_FREE) (bits 0 thru 3 correspond to channels 0 thru 3) ioa_AllocKey- allocation key, used to free channels OUTPUTS iORequest - pointer to audio request block (struct IOAudio) io_Device - set to -1 io_Unit - set to zero [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node00AD.html.txt:1:cd.device/CD_PLAYMSF ]" border=0> NAME CD_PLAYMSF -- Play a selected portion of CD audio (MSF form). IO REQUEST io_Device preset by the call to OpenDevice() io_Unit preset by the call to OpenDevice() io_Command CD_PLAYMSF io_Data NULL io_Length length of play io_Offset starting position RESULTS io_Error 0 for success, or an error code as defined in FUNCTION This command causes the drive to start playing CD audio from the specified position until the specified length has passed. io_Offset specifies the starting position. io_Length contains the amount of time to play. All data is specified in MSF format. A DoIO() will not return until the requested number of sectors have been played. A SendIO() will return as soon as the PLAY has been started. At this time other commands can be sent (like CD_PAUSE). To stop a play before the specified length has been reached, use AbortIO() . EXAMPLE /* Play two minutes, ten seconds of audio starting at 20 minutes, */ /* 58 seconds, and 10 frames. */ ior->io_Command = CD_PLAYMSF; /* Play CD audio */ ior->io_Offset = 0x00143A0A; /* $14=20, $3A=58, $0A=10 */ ior->io_Length = 0x00020A00; /* $02=02, $0A=10, $00=00 */ DoIO (ior); NOTES BUGS SEE ALSO CD_PLAYTRACK , CD_PAUSE , CD_SEARCH , CD_ATTENUATE [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node04B2.html.txt:1:audio.device/CMD_RESET ]" border=0> NAME CMD_RESET -- restore device to a known state FUNCTION CMD_RESET is a standard command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct, CMD_RESET: . clears the hardware audio registers and attach bits, . sets the audio interrupt vector, . cancels all pending I/O (CMD_FLUSH), and . un-stops the channel if it is stopped (CMD_STOP), Otherwise, CMD_RESET returns an error (ADIOERR_NOALLOCATION). CMD_RESET is synchronous and only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. Do not use CMD_RESET in interrupt code at interrupt level 5 or higher. INPUTS mn_ReplyPort- pointer to message port that receives I/O request if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to reset (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for CMD_RESET io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channels to successfully reset (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel [Back to Amiga Developer Docs ]
Libraries_Manual_guide/node0016.html.txt:1:1 / Programming in the Amiga Environment / The Custom Chips ]" border=0> The most important feature of the Amiga's hardware design is the set of custom chips that perform specialized tasks independently of the CPU. Each of the custom chips (named Paula, Agnus, and Denise) is dedicated to a particular job: Paula (8364) Audio, floppy disk, serial, interrupts Agnus (8361/8370/8372) Copper (video coprocessor), blitter, DMA control Denise (8362) Color registers, color DACs (Digital to Analog Converters) and sprites The custom chips can perform work independently of the CPU because they have DMA, or Direct Memory Access, capability. DMA means the custom chips can access special areas of memory by themselves without any CPU involvement. (On computer systems without DMA, the CPU must do some or all of the memory handling for support chips.) The Amiga's custom chips make multitasking especially effective because they can handle things like rendering graphics and playing sound independently, giving the CPU more time to handle the overhead of task-switching and other important jobs. Custom Chip Revisions Two Kinds of Memory [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node0061.html.txt:1:audio.device/ADCMD_ALLOCATE ]" border=0> ADCMD_ALLOCATE -- allocate a set of audio channels FUNCTION ADCMD_ALLOCATE is a command that allocates multiple audio channels. ADCMD_ALLOCATE takes an array of possible channel combinations (ioa_Data) and an allocation precedence (ln_Pri) and tries to allocate one of the combinations of channels. If the channel combination array is zero length (ioa_Length), the allocation succeeds; otherwise, ADCMD_ALLOCATE checks each combination, one at a time, in the specified order, to find one combination that does not require ADCMD_ALLOCATE to steal allocated channels. If it must steal allocated channels, it uses the channel combination that steals the lowest precedence channels. ADCMD_ALLOCATE cannot steal a channel of equal or greater precedence than the allocation precedence (ln_Pri). If it fails to allocate any channel combination and the no-wait flag (ADIOF_NOWAIT) is set ADCMD_ALLOCATE returns a zero in the unit field of the I/O request (io_Unit) and an error (IOERR_ALLOCFAILED). If the no-wait flag is clear, it places the I/O request in a list that tries to allocate again whenever ADCMD_FREE frees channels or ADCMD_SETPREC lowers the channels' precedences. If the allocation is successful, ADCMD_ALLOCATE checks if any channels are locked (ADCMD_LOCK) and if so, replies (ReplyMsg) the lock I/O request with an error (ADIOERR_CHANNELSTOLEN). Then it places the allocation I/O request in a list waiting for the locked channels to be freed. When all the allocated channels are un-locked, ADCMD_ALLOCATE: . resets (CMD_RESET) the allocated channels, . generates a new allocation key (ioa_AllocKey), if it is zero, . copies the allocation key into each of the allocated channels . copies the allocation precedence into each of the allocated channels, and . copies the channel bit map into the unit field of the I/O request. If channels are allocated with a non-zero allocation key, ADCMD_ALLOCATE allocates with that same key; otherwise, it generates a new and unique key. ADCMD_ALLOCATE is synchronous: . if the allocation succeeds and there are no locked channels to be stolen, or . if the allocation fails and the no-wait flag is set. In either case, ADCMD_ALLOCATE only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear; otherwise, the allocation is asynchronous, so it clears the quick flag and replies the I/O request after the allocation is finished. If channels are stolen, all audio device commands return an error (IOERR_NOALLOCATION) when the former user tries to use them again. Do not use ADCMD_ALLOCATE in interrupt code. If you decide to store directly to the audio hardware registers, you must either lock the channels you've allocated, or set the precedence to maximum (ADALLOC_MAXPREC) to prevent the channels from being stolen. Under all circumstances, unless channels are stolen, you must free (ADCMD_FREE) all allocated channels when you are finished using them. INPUTS ln_Pri - allocation precedence (-128 thru 127) mn_ReplyPort- pointer to message port that receives I/O request after the allocation completes is asynchronous or quick flag (ADIOF_QUICK) is set io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Command - command number for ADCMD_ALLOCATE io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request (SET) only reply I/O request only if asynchronous (see above text) ADIOF_NOWAIT- (CLEAR) if allocation fails, wait till is succeeds (SET) if allocation fails, return error (ADIOERR_ALLOCFAILED) ioa_AllocKey- allocation key, zero to generate new key; otherwise, it must be set by (or copied from I/O block set by) OpenDevice function or previous ADCMD_ALLOCATE command ioa_Data - pointer to channel combination options (byte array, bits 0 thru 3 correspond to channels 0 thru 3) ioa_Length - length of the channel combination option array (0 thru 16, 0 always succeeds) OUTPUTS io_Unit - bit map of successfully allocated channels (bits 0 thru 3 correspond to channels 0 thru 3) io_Flags - IOF_QUICK flag cleared if asynchronous (see above text) io_Error - error number: 0 - no error ADIOERR_ALLOCFAILED - allocation failed ioa_AllocKey- allocation key, set to a unique number if passed a zero and command succeeds [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node0038.html.txt:1:Includes/devices/audio.h ]" border=0> #ifndef DEVICES_AUDIO_H #define DEVICES_AUDIO_H /* ** $Filename: devices/audio.h $ ** $Release: 2.04 Includes, V37.4 $ ** $Revision: 36.3 $ ** $Date: 90/08/29 $ ** ** audio.device include file ** ** (C) Copyright 1985-1999 Amiga, Inc. ** All Rights Reserved */ #ifndef EXEC_IO_H #include "exec/io.h" #endif #define AUDIONAME "audio.device" #define ADHARD_CHANNELS 4 #define ADALLOC_MINPREC -128 #define ADALLOC_MAXPREC 127 #define ADCMD_FREE (CMD_NONSTD+0) #define ADCMD_SETPREC (CMD_NONSTD+1) #define ADCMD_FINISH (CMD_NONSTD+2) #define ADCMD_PERVOL (CMD_NONSTD+3) #define ADCMD_LOCK (CMD_NONSTD+4) #define ADCMD_WAITCYCLE (CMD_NONSTD+5) #define ADCMD_ALLOCATE 32 #define ADIOB_PERVOL 4 #define ADIOF_PERVOL (1 #define ADIOB_SYNCCYCLE 5 #define ADIOF_SYNCCYCLE (1 #define ADIOB_NOWAIT 6 #define ADIOF_NOWAIT (1 #define ADIOB_WRITEMESSAGE 7 #define ADIOF_WRITEMESSAGE (1 #define ADIOERR_NOALLOCATION -10 #define ADIOERR_ALLOCFAILED -11 #define ADIOERR_CHANNELSTOLEN -12 struct IOAudio { struct IORequest ioa_Request; WORD ioa_AllocKey; UBYTE *ioa_Data; ULONG ioa_Length; UWORD ioa_Period; UWORD ioa_Volume; UWORD ioa_Cycles; struct Message ioa_WriteMsg; }; #endif /* DEVICES_AUDIO_H */ [Back to Amiga Developer Docs ]
Libraries_Manual_guide/node0018.html.txt:1:1 / / The Custom Chips / Two Kinds of Memory ]" border=0> To keep the Amiga running efficiently, the Amiga has two memory buses and two kinds of memory. Chip memory is memory that both the CPU and custom chips can access. Fast memory is memory that only the CPU (and certain expansion cards) can access. Since Chip memory is shared, CPU access may be slowed down if the custom chips are doing heavy-duty processing. CPU access to Fast memory is never slowed down by contention with the custom chips. The distinction between Chip memory and Fast memory is very important for Amiga programmers to keep in mind because any data accessed directly by the custom chips such as video display data, audio data or sprite data must be in Chip memory. _________________________________________________________________ | | | What Every Amiga Programmer Should Know: | | ---------------------------------------- | | The Amiga has two kinds of memory: Chip memory and Fast memory. | | Use the right kind. | |_________________________________________________________________| [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node0070.html.txt:1:audio.device/CMD_UPDATE ]" border=0> NAME CMD_UPDATE -- force dirty buffers out FUNCTION CMD_UPDATE is a standard command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct, CMD_UPDATE does nothing; otherwise, CMD_UPDATE returns an error (ADIOERR_NOALLOCATION). CMD_UPDATE is synchronous and only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. INPUTS mn_ReplyPort- pointer to message port that receives I/O request after if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to update (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for CMD_UPDATE io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channels successfully updated (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node04B3.html.txt:1:audio.device/CMD_START ]" border=0> NAME CMD_START -- start device processing (like ^Q) FUNCTION CMD_START is a standard command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct and the channel was previously stopped (CMD_STOP), CMP_START immediately starts all writes (CMD_WRITE) to the channel. If the allocation key is incorrect, CMD_START returns an error (ADIOERR_NOALLOCATION). CMD_START starts multiple channels simultaneously to minimize distortion if the channels are playing the same waveform and their outputs are mixed. CMD_START is synchronous an d only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. D o not use CMD_START in interrupt code at interrupt level 5 or higher. INPUTS mn_ReplyPort- pointer to message port that receives I/O request after if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to start (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for CMD_START io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channels successfully started (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node04A5.html.txt:1:audio.device/AbortIO ]" border=0> NAME AbortIO - abort a device command SYNOPSIS AbortIO(iORequest); A1 FUNCTION AbortIO tries to abort a device command. It is allowed to be unsuccessful. If the Abort is successful, the io_Error field of the iORequest contains an indication that IO was aborted. INPUTS iORequest -- pointer to the I/O Request for the command to abort [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node046F.html.txt:1:lowlevel.library/SystemControlA ]" border=0> NAME SystemControlA - Method for selectively disabling OS features. (V40) SystemControl - varargs stub for SystemControlA(). SYNOPSIS failTag = SystemControlA(tagList); D0 A1 ULONG SystemControlA(struct TagItem *); failTag = SystemControl(firstTag, ...); ULONG SystemControl(Tag, ...); FUNCTION This function is used to alter the operation of the system. Some of the alterations involve controlling what are normally regarded as system resources. In order to minimize confusion only one task is allowed to control any part of the system resources. This prevents the possiblity of two tasks fighting, each controlling a part of the system. If a tag is identified as task exclusive, it means that only one task can hold (set to TRUE) that tag. If another task attempts to set the same tag to TRUE, the call to SystemControl() will fail. It is important to remember that SystemControl() can fail. This is a low level function and certain tags do not fit the normal Amiga multitasking model. INPUTS tagList - pointer to an array of tags listing the features of the system to be enabled/disabled. TAGS SCON_TakeOverSys (BOOL) TRUE - Takes over the CPU to ensure that a program gets every ounce of CPU time (with the exception of crucial interrupts). When in this mode, the CPU will belong completely to the program. Task switching will be disabled and the program will get all CPU cycles. This means any calls to the OS that involve multitasking in some way will not execute correctly. Other tasks will not run until this tag is used with FALSE. However, during a Wait() on a signal, multitasking will automatically be turned back on until the signal is received. Once received, multitasking will again be disabled and the CPU will be exclusive to the owning program. FALSE - Relinquishes the CPU and reenables multitasking. This tag is task exculsive. This tag nests. A task may take over the CPU several times before relinquishing it. SCON_KillReq (BOOL) TRUE - Disables system requesters. These are the reasons for NOT disabling system requesters: 1- No calls in the program will cause a system requester. 2- The only thing that could cause a requester to appear is the lack of a CD in the drive and SCON_CDReboot is set to CDReboot_On, therefore a requester can't appear. 3- The only disk I/O is via a CD with SCON_CDReboot set to CDReboot_On and/or nonvolatile.library. When requesters should not be disabled. GAME PROGRAMS: No DOS calls are used after loading; or SCON_CDReboot is CDReboot_On; and nonvolatile.library is used for loading and saving user data. This fits the above case since; After loading either DOS calls are not used fitting reason 1, or the game is accessing the CD and has SCON_CDReboot set to CDReboot_On fitting reason 2. The game accesses high scores, game position, etc through nonvolatile.library, fitting reason 3. FALSE - Enables requesters for the program. This tag nests. Tasks may disable requesters several times before enabling them. However, there must be a matching number of calls. SCON_CDReboot (ULONG) CDReboot_On - Ejecting the CD will cause a reboot of the system. Use this only if the program cannot deal with error conditions. CDReboot_Off - Ejecting the CD will not cause a reboot of the system. Use this if the program needs to insert CDs while running. CDReboot_Default - Restore the default reboot behavior for this system. This should be used upon exit, if this tag had been used to change the reboot behaviour. For the CD32 this value is synonomous with CDReboot_On. For Amiga computers this value is synonomous with CDReboot_Off. Note that the default reboot behavior differs depending on the platform. If a program requires a specific behavior it must use this function to set the behavior. For example, a CD audio mixer would use this tag with the data CDReboot_Off. This will allow the changing of audio CDs on the game machine as well as Amiga computers. If, however, there is no error detection code at all this tag should be used with the data CDReboot_On. It is hoped that no program will require CDReboot_On. If all programs check for error condition and recover gracefully such a call should never be necessary. With the default behavior the CD32 will always reset on disk ejects, and programs run from Amiga computers will not reset. Thus, leaving the default will increase the market for a program to include both types of platforms. This tag does not nest. SCON_StopInput (BOOL) - When TRUE, stops input.device from using any CPU cycles. Also prevents input.device from passing along any events from either the keyboard and/or port 0. This tag is task exclusive. This tag is NOT reversible. Attempting to reverse will result in confused/garbled input events. SCON_AddCreateKeys (ULONG) - Starts creating rawkey codes for the joystick/game controller on the given unit. The unit value is checked for validity and must be either 0 or 1. Each different unit used results in some code added to the VBlank interrupt chain. This tag nests. The tag SCON_RemCreateKeys is used to undo this tag. Tasks may create rawkey codes several times before stopping them. Note that when operating in an Intuition window, the controller's blue button is the equivilent of the mouse menu button. Therefore, Intuition will be capturing most blue button events. If notificiation of these events is important, review the documentation for WFLG_RMBTRAP in the intuition.library/OpenWindow() autodoc. SCON_RemCreateKeys (ULONG) - stops rawkey codes for the joystick/game controller on the given unit. The unit value is checked for validity and must be either 0 or 1. RESULT failTag - zero if all tags succeeded. A non-zero return indicates a tag that has failed. It is possible that other tags may fail as well. If any tag fails there will be no change in the system due to other tags. SEE ALSO [Back to Amiga Developer Docs ]
Libraries_Manual_guide/node0303.html.txt:1:26 / Introduction / Sequence of Events During an Interrupt ]" border=0> Before useful interrupt handling code can be executed, a considerable amount of hardware and software activity must occur. Each interrupt must propagate through several hardware and software interfaces before application code is finally dispatched: * A hardware device decides to cause an interrupt and sends a signal to the interrupt control portions of the 4703 (Paula) custom chip. * The 4703 interrupt control logic notices this new signal and performs two primary operations. First, it records that the interrupt has been requested by setting a flag bit in the INTREQ register. Second, it examines the INTENA register to determine whether the corresponding interrupt and the interrupt master are enabled. If both are enabled, the 4703 generates an interrupt request by placing the priority level of the request onto the three 68000 interrupt control input lines (IPL0, IPL1, IPL2). * These three signals correspond to seven interrupt priority levels in the 68000. If the priority of the new interrupt is greater than the current processor priority, an interrupt sequence is initiated. The priority level of the new interrupt is used to index into the top seven words of the processor address space. The odd byte (a vector number) of the indexed word is fetched and then shifted left by two to create an offset into the processor's auto-vector interrupt table. The vector offsets used are in the range of $064 to $07C. These are labeled as interrupt autovectors in the 68000 manual. The auto-vector table appears in low memory on a 68000 system, but its location for other 68000 family processors is determined by the processor's CPU Vector Base Register (VBR). VBR can be accessed from supervisor mode with the MOVEC instruction. * The processor then switches into supervisor mode (if it is not already in that mode), and saves copies of the status register and program counter (PC) onto the top of the system stack (additional information may be saved by processors other than the 68000). The processor priority is then raised to the level of the active interrupt. * From the low memory vector address (calculated in step three above), a 32-bit autovector address is fetched and loaded into the program counter. This is an entry point into Exec's interrupt dispatcher. * Exec must now further decode the interrupt by examining the INTREQ and INTENA 4703 chip registers. Once the active interrupt has been determined, Exec indexes into an ExecBase array to fetch the interrupt's handler entry point and handler data pointer addresses. * Exec now turns control over to the interrupt handler by calling it as if it were a subroutine. This handler may deal with the interrupt directly or may propagate control further by invoking interrupt server chain processing. You can see from the above discussion that the interrupt autovectors should never be altered by the user. If you wish to provide your own system interrupt handler, you must use the Exec SetIntVector() function. You should not change the contents of any autovector location. Task multiplexing usually occurs as the result of an interrupt. When an interrupt has finished and the processor is about to return to user mode, Exec determines whether task-scheduling attention is required. If a task was signaled during interrupt processing, the task scheduler will be invoked. Because Exec uses preemptive task scheduling, it can be said that the interrupt subsystem is the heart of task multiplexing. If, for some reason, interrupts do not occur, a task might execute forever because it cannot be forced to relinquish the CPU. Table 26-1: Interrupts by Priority Exec Hardware Pseodo- Priority Priority Description Label Type -------- -------- ----------- ----- ---- ____ | 1 Serial transmit buffer empty TBE H | 1 ----| 2 disk block complete DSKBLK H | | 3 software interrupt SOFTINT H |---- 2 ----| 4 external INT2 & CIAA PORTS S |---- | 5 graphics coprocessor COPER S | 3 ----| 6 vertical blank interval VERTB S | | 7 blitter finished BLIT H |---- | 8 audio channel 2 AUD2 H | | 9 audio channel 0 AUD0 H 4 ----| | 10 audio channel 3 AUD3 H | | 11 audio channel 1 AUD1 H |---- | 12 Serial receive buffer full RBF H 5 ----| | 13 disk sync pattern found DSKSYNC H |---- | 14 external INT6 & CIAB EXTER S 6 ----| | 15 special (master enable) INTEN - |---- 7 ----|____ -- non-maskable interrupt NMI S [Back to Amiga Developer Docs ]
Libraries_Manual_guide/node0490.html.txt:1:Amiga® RKM Libraries: 36 Translator Library ]" border=0> This chapter describes the translator library which, together with the narrator device, provides the Amiga's text-to-speech capability. To fully understand how speech is produced on the Amiga, you should also read the " Narrator Device " chapter of the Amiga ROM Kernel Reference Manual: Devices. The translator library provides a single function, Translate() , that converts an English language string into a phonetic string. You may then pass this phonetic string to the narrator device which will say the string using the Amiga's audio hardware. The two subsystems may also be used individually. You don't have to use the narrator to say the phonetic strings; you could use them instead for phonetic analysis or some other special purpose. Opening the Translator Library Closing the Translator Library Using the Translate Function Additional Notes About Translate [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node04C8.html.txt:1:narrator.device/OpenDevice ]" border=0> NAME OpenDevice - opens the narrator device. SYNOPSIS error = OpenDevice("narrator.device", unit, IORequest , flags); D0 A0 D0 A1 D1 FUNCTION The OpenDevice routine grants access to the narrator device. OpenDevice checks the unit number, and if non-zero, returns an error (ND_UnitErr). If this is the first time the driver has been opened, OpenDevice will attempt to open the audio device and allocate the driver's static buffers. If either of these operations fail, an error is returned. See the .h and .i include files for possible error return codes. Next, OpenDevice (done for all opens, not just the first one) initializes various fields in the user's IORequest block (see below). If users wish to use non-default values for these parms, the values must be set after the open is done. OpenDevice also assigns a pseudo unit number to the IORB for use in synchronizing read and write requests. See the read command for more details. Finally, OpenDevice stores the device node pointer in the IORequest block and clears the delayed expunge bit. ***** NEW FOR V37 NARRATOR ***** Several new fields in the IORequest block have been added for V37 narrator. These fields are initialized when the device is opened if the NDB_NEWIORB bit is set in the flags field of the user's IORequest block. Note that NDB_NEWIORB is set in the IORequest block, NOT in the "flags" input parm to the OpenDevice call. INPUTS device - "narrator.device" unit - 0 IORequest - Pointer to the user's IORequest block flags - 0 RESULTS The narrator device will initialize the IORequest block as follows (assume IORB points to the IOrequest block): IORB->rate = 150; /* Speaking rate in words/minute */ IORB->pitch = 110; /* Baseline pitch in Hertz */ IORB->mode = NATURALF0; /* Pitch (F0) mode */ IORB->sex = MALE; /* Sex of voice */ IORB->volume = 64 /* Volume, full on */ IORB->sampfreq = 22200 /* Audio sampling freq */ IORB->mouths = 0 /* Don't generate sync events */ and if the NDB_NEWIORB bit is set: IORB->F0enthusiasm = 0 /* F0 excursion factor */ IORB->F0perturb = 32 /* F0 perturbation (in 32nds) */ IORB->F1adj = 0 /* F1 adjustment in ±5% steps */ IORB->F2adj = 0 /* F2 adjustment in ±5% steps */ IORB->F3adj = 0 /* F3 adjustment in ±5% steps */ IORB->A1adj = 0 /* A1 adjustment in decibels */ IORB->A2adj = 0 /* A2 adjustment in decibels */ IORB->A3adj = 0 /* A3 adjustment in decibels */ IORB->articulate = 100 /* Transition time multiplier */ IORB->centralize = 0 /* Degree of vowel centralization */ IORB->centphon = "" /* Pointer to central ASCII phon */ IORB->AVbias = 0 /* AV bias */ IORB->AFbias = 0 /* AF bias */ IORB->priority = 100 /* Priority while speaking */ SEE ALSO The include files contain the complete IORequest block definition, default settings, and error return codes. Exec input/output documentation. [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node04A9.html.txt:1:audio.device/ADCMD_LOCK ]" border=0> NAME ADCMD_LOCK -- prevent audio channels from being stolen FUNCTION ADCMD_LOCK is a command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct, ADCMD_LOCK locks the channel, preventing subsequent allocations (ADCMD_ALLOCATE or OpenDevice) from stealing the channel. Otherwise, ADCMD_LOCK returns an error (ADIOERR_NOALLOCATION) and will not lock any channels. Unlike setting the precedence (ADCMD_SETPREC, ADCMD_ALLOCATE or OpenDevice) to maximum (ADALLOC_MAXPREC) which would cause all subsequent allocations to fail, ADCMD_LOCK causes all higher precedence allocations, even no-wait (ADIOF_NOWAIT) allocations, to wait until the channels are un-locked. Locked channels can only be unlocked by freeing them (ADCMD_FREE), which clears the channel select bits (io_Unit). ADCMD_LOCK does not reply the I/O request (mn_ReplyPort) until all the channels it locks are freed, unless a higher precedence allocation attempts to steal one the locked channels. If a steal occurs, ADCMD_LOCK replies and returns an error (ADIOERR_CHANNELSTOLEN). If the lock is replied (mn_ReplyPort) with this error, the channels should be freed as soon as possible. To avoid a possible deadlock, never make the freeing of stolen channels dependent on another allocations completion. ADCMD_LOCK is only asynchronous if the allocation key is correct, in which case it clears the quick flag (IOF_QUICK); otherwise, it is synchronous and only replies if the quick flag (IOF_QUICK) is clear. Do not use ADCMD_LOCK in interrupt code. INPUTS mn_ReplyPort- pointer to message port that receives I/O request if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to lock (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for ADCMD_LOCK io_Flags - flags, must be cleared ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of successfully locked channels (bits 0 thru 3 correspond to channels 0 thru 3) not freed (ADCMD_FREE) io_Flags - IOF_QUICK flag cleared if the allocation key is correct (no ADIOERR_NOALLOCATION error) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel ADIOERR_CHANNELSTOLEN- allocation attempting to steal locked channel [Back to Amiga Developer Docs ]
Libraries_Manual_guide/node0537.html.txt:1:D / Errors / Audio--Corrupted Samples ]" border=0> The bit data for audio samples must be in Chip RAM. Check your compiler manual for directives or flags which will place your audio sample data in Chip RAM. Or dynamically allocate Chip RAM and copy or load the audio sample there. [Back to Amiga Developer Docs ]
Libraries_Manual_guide/node0565.html.txt:1:E / Release 2 Changes That Can Affect Compatibility / Audio Device ]" border=0> * Now not initialized until used. This means low memory open failure is possible. Check your return values from OpenDevice() . This also means audio.device cannot be opened during 2.0 Strap unless InitResident() ed first. If OpenDevice() of audio.device fails during strap, you must FindResident() /InitResident() audio.device, and then try OpenDevice() again. There will be a small memory loss (until reboot) generated by the first opener of audio.device or narrator.device (memory used in building of audio.device's base). [Back to Amiga Developer Docs ]
Libraries_Manual_guide/node001A.html.txt:1:1 Introduction to Libraries / General Amiga Development Guidelines ]" border=0> In the earlier sections of this chapter, the basic environment of the Amiga operating system was discussed. This section presents specific guidelines that all Amiga programmers must follow. Some of these guidelines are for advanced programmers or apply only to code written in assembly language. * Check for memory loss . Arrange your Workbench screen so that you have a Shell available and can start your program without rearranging any windows. In the Shell window type Avail flush several times (the flush option requires the Release 2 version of the Avail command). Note the total amount of free memory. Run your program (do not rearrange any windows other than those created by the program) and then exit. At the Shell, type Avail flush several times again. Compare the total amount of free memory with the earlier figure. They should be the same. Any difference indicates that your application is not freeing some memory it used or is not closing a disk-loaded library, device or font it opened. Note that under Release 2, a small amount of memory loss is normal if your application is the first to use the audio or narrator device. * Use all of the program debugging and stress tools that are available when writing and testing your code. New debugging tools such as Enforcer, MungWall, and Scratch can help find uninitialized pointers, attempted use of freed memory and misuse of scratch registers or condition codes (even in programs that appear to work perfectly). * Always make sure you actually get any system resource that you ask for. This applies to memory, windows, screens, file handles, libraries, devices, ports, etc. Where an error value or return is possible, ensure that there is a reasonable failure path. Many poorly written programs will appear to be reliable, until some error condition (such as memory full or a disk problem) causes the program to continue with an invalid or null pointer, or branch to untested error handling code. * Always clean up after yourself. This applies for both normal program exit and program termination due to error conditions. Anything that was opened must be closed, anything allocated must be deallocated. It is generally correct to do closes and deallocations in reverse order of the opens and allocations. Be sure to check your development language manual and startup code; some items may be closed or deallocated automatically for you, especially in abort conditions. If you write in the C language, make sure your code handles Ctrl-C properly. * Remember that memory, peripheral configurations, and ROMs differ between models and between individual systems. Do not make assumptions about memory address ranges, storage device names, or the locations of system structures or code. Never call ROM routines directly. Beware of any example code you find that calls routines at addresses in the $F0 0000 - $FF FFFF range. These are ROM routines and they will move with every OS release. The only supported interface to system ROM code is through the library, device, and resource calls. * Never assume library bases or structures will exist at any particular memory location. The only absolute address in the system is $0000 0004, which contains a pointer to the Exec library base. Do not modify or depend on the format of private system structures. This includes the poking of copper lists, memory lists, and library bases. * Never assume that programs can access hardware resources directly. Most hardware is controlled by system software that will not respond well to interference from other programs. Shared hardware requires programs to use the proper sharing protocols. Use the defined interface; it is the best way to ensure that your software will continue to operate on future models of the Amiga. * Never access shared data structures directly without the proper mutual exclusion ( locking ). Remember that other tasks may be accessing the same structures. * The system does not monitor the size of a program's stack . (Your compiler may have an option to do this for you.) Take care that your program does not cause stack overflow and provide extra stack space for the possibility that some functions may use up additional stack space in future versions of the OS. * Never use a polling loop to test signal bits. If your program waits for external events like menu selection or keystrokes, do not bog down the multitasking system by busy-waiting in a loop. Instead, let your task go to sleep by Wait()ing on its signal bits. For example: signals = (ULONG)Wait( (1 UserPort->mp_SigBit) | (1 mp_SigBit) ); This turns the signal bit number for each port into a mask, then combines them as the argument for the Exec library Wait() function. When your task wakes up, handle all of the messages at each port where the mp_SigBit is set. There may be more than one message per port, or no messages at the port. Make sure that you ReplyMsg() to all messages that are not replies themselves. If you have no signal bits to Wait() on, use Delay() or WaitTOF() to provide a measured delay. * Tasks (and processes) execute in 680x0 user mode. Supervisor mode is reserved for interrupts, traps, and task dispatching. Take extreme care if your code executes in supervisor mode. Exceptions while in supervisor mode are deadly. * Most system functions require a particular execution environment. All DOS functions and any functions that might call DOS (such as the opening of a disk-resident library, font, or device) can only be executed from a process . A task is not sufficient. Most other ROM kernel functions may be executed from tasks. Only a few may be executed from interrupts. * Never disable interrupts or multitasking for long periods. If you use Forbid() or Disable() , you should be aware that execution of any system function that performs the Wait() function will temporarily suspend the Forbid() or Disable() state, and allow multitasking and interrupts to occur. Such functions include almost all forms of DOS and device I/O, including common stdio functions like printf() . * Never tie up system resources unless it is absolutely necessary. For example, if your program does not require constant use of the printer, open the printer device only when you need it. This will allow other tasks to use the printer while your program is running. You must provide a reasonable error response if a resource is not available when you need it. * All data for the custom chips must reside in Chip memory (type MEMF_CHIP ). This includes bitplanes, sound samples, trackdisk buffers, and images for sprites, bobs, pointers, and gadgets. The AllocMem() call takes a flag for specifying the type of memory. A program that specifies the wrong type of memory may appear to run correctly because many Amigas have only Chip memory. (On all models of the Amiga, the first 512K of memory is Chip memory. In later models, Chip memory may occupy up to the first one or two megabytes). However, once expansion memory has been added to an Amiga (type MEMF_FAST ), any memory allocations will be made in the expansion memory area by default. Hence, a program can run correctly on an unexpanded Amiga which has only Chip memory while crashing on an Amiga which has expanded memory. A developer with only Chip memory may fail to notice that memory was incorrectly specified. Most compilers have options to mark specific data structures or object modules so that they will load into Chip RAM . Some older compilers provide the Atom utility for marking object modules. If this method is unacceptable, use the AllocMem() call to dynamically allocate Chip memory, and copy your data there. When making allocations that do not require Chip memory , do not explicitly ask for Fast memory . Instead ask for memory type MEMF_PUBLIC or 0L as appropriate. If Fast memory is available, you will get it. * Never use software delay loops! Under the multitasking operating system, the time spent in a loop can be better used by other tasks. Even ignoring the effect it has on multitasking, timing loops are inaccurate and will wait different amounts of time depending on the specific model of Amiga computer. The timer device provides precision timing for use under the multitasking system and it works the same on all models of the Amiga. The AmigaDOS Delay() function or the graphics library WaitTOF() function provide a simple interface for longer delays. The 8520 I/O chips provide timers for developers who are bypassing the operating system (see the Amiga Hardware Reference Manual for more information). * Always obey structure conventions! · All non-byte fields must be word-aligned. Longwords should be longword-aligned for performance. · All address pointers should be 32 bits (not 24 bits). Never use the upper byte for data. · Fields that are not defined to contain particular initial values must be initialized to zero. This includes pointer fields. · All reserved or unused fields must be initialized to zero for future compatibility. · Data structures to be accessed by the custom chips , public data structures (such as a task control block), and structures which must be longword aligned must not be allocated on a program's stack. · Dynamic allocation of structures with AllocMem() provides longword aligned memory of a specified type with optional initialization to zero, which is useful in the allocation of structures. For 68010/68020/68030/68040 Compatibility Hardware Programming Guidelines Additional Assembler Development Guidelines [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node04B5.html.txt:1:audio.device/CMD_UPDATE ]" border=0> NAME CMD_UPDATE -- force dirty buffers out FUNCTION CMD_UPDATE is a standard command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct, CMD_UPDATE does nothing; otherwise, CMD_UPDATE returns an error (ADIOERR_NOALLOCATION). CMD_UPDATE is synchronous and only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. INPUTS mn_ReplyPort- pointer to message port that receives I/O request after if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to update (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for CMD_UPDATE io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channels successfully updated (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel [Back to Amiga Developer Docs ]
Libraries_Manual_guide/node000C.html.txt:1:1 / / Multitasking / What the System Doesn't Do For You ]" border=0> The Amiga operating system handles most of the housekeeping needed for multitasking , but this does not mean that applications don't have to worry about multitasking at all. The current generation of Amiga systems do not have hardware memory protection, so there is nothing to stop a task from using memory it has not legally acquired. An errant task can easily corrupt some other task by accidentally overwriting its instructions or data. Amiga programmers need to be extra careful with memory; one bad memory pointer can cause the machine to crash (debugging utilities such as MungWall and Enforcer will prevent this). In fact, Amiga programmers need to be careful with every system resource, not just memory. All system resources from audio channels to the floppy disk drives are shared among tasks. Before using a resource, you must ask the system for access to the resource. This may fail if the resource is already being used by another task. Once you have control of a resource, no other task can use it, so give it up as soon as you are finished. When your program exits, you must give everything back whether it's memory, access to a file, or an I/O port. You are responsible for this, the system will not do it for you automatically. ______________________________________________________________________ | | | What Every Amiga Programmer Should Know: | | ---------------------------------------- | | The Amiga is a multitasking computer. Keep in mind that other | | tasks are running at the same time as your application. Always ask | | the system for control of any resource you need; some other task may | | already be using it. Give it back as soon as you are done; another | | task may want to use it. This applies to just about every computing | | activity your application can perform. | |______________________________________________________________________| [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node05A8.html.txt:1:Text_Autodocs/audio.doc ]" border=0> TABLE OF CONTENTS audio.device/AbortIO audio.device/ADCMD_ALLOCATE audio.device/ADCMD_FINISH audio.device/ADCMD_FREE audio.device/ADCMD_LOCK audio.device/ADCMD_PERVOL audio.device/ADCMD_SETPREC audio.device/ADCMD_WAITCYCLE audio.device/BeginIO audio.device/CloseDevice audio.device/CMD_CLEAR audio.device/CMD_FLUSH audio.device/CMD_READ audio.device/CMD_RESET audio.device/CMD_START audio.device/CMD_STOP audio.device/CMD_UPDATE audio.device/CMD_WRITE audio.device/Expunge audio.device/OpenDevice audio.device/AbortIO audio.device/AbortIO NAME AbortIO - abort a device command SYNOPSIS AbortIO(iORequest); A1 FUNCTION AbortIO tries to abort a device command. It is allowed to be unsuccessful. If the Abort is successful, the io_Error field of the iORequest contains an indication that IO was aborted. INPUTS iORequest -- pointer to the I/O Request for the command to abort audio.device/ADCMD_ALLOCATE audio.device/ADCMD_ALLOCATE ADCMD_ALLOCATE -- allocate a set of audio channels FUNCTION ADCMD_ALLOCATE is a command that allocates multiple audio channels. ADCMD_ALLOCATE takes an array of possible channel combinations (ioa_Data) and an allocation precedence (ln_Pri) and tries to allocate one of the combinations of channels. If the channel combination array is zero length (ioa_Length), the allocation succeeds; otherwise, ADCMD_ALLOCATE checks each combination, one at a time, in the specified order, to find one combination that does not require ADCMD_ALLOCATE to steal allocated channels. If it must steal allocated channels, it uses the channel combination that steals the lowest precedence channels. ADCMD_ALLOCATE cannot steal a channel of equal or greater precedence than the allocation precedence (ln_Pri). If it fails to allocate any channel combination and the no-wait flag (ADIOF_NOWAIT) is set ADCMD_ALLOCATE returns a zero in the unit field of the I/O request (io_Unit) and an error (IOERR_ALLOCFAILED). If the no-wait flag is clear, it places the I/O request in a list that tries to allocate again whenever ADCMD_FREE frees channels or ADCMD_SETPREC lowers the channels' precedences. If the allocation is successful, ADCMD_ALLOCATE checks if any channels are locked (ADCMD_LOCK) and if so, replies (ReplyMsg) the lock I/O request with an error (ADIOERR_CHANNELSTOLEN). Then it places the allocation I/O request in a list waiting for the locked channels to be freed. When all the allocated channels are un-locked, ADCMD_ALLOCATE: . resets (CMD_RESET) the allocated channels, . generates a new allocation key (ioa_AllocKey), if it is zero, . copies the allocation key into each of the allocated channels . copies the allocation precedence into each of the allocated channels, and . copies the channel bit map into the unit field of the I/O request. If channels are allocated with a non-zero allocation key, ADCMD_ALLOCATE allocates with that same key; otherwise, it generates a new and unique key. ADCMD_ALLOCATE is synchronous: . if the allocation succeeds and there are no locked channels to be stolen, or . if the allocation fails and the no-wait flag is set. In either case, ADCMD_ALLOCATE only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear; otherwise, the allocation is asynchronous, so it clears the quick flag and replies the I/O request after the allocation is finished. If channels are stolen, all audio device commands return an error (IOERR_NOALLOCATION) when the former user tries to use them again. Do not use ADCMD_ALLOCATE in interrupt code. If you decide to store directly to the audio hardware registers, you must either lock the channels you've allocated, or set the precedence to maximum (ADALLOC_MAXPREC) to prevent the channels from being stolen. Under all circumstances, unless channels are stolen, you must free (ADCMD_FREE) all allocated channels when you are finished using them. INPUTS ln_Pri - allocation precedence (-128 thru 127) mn_ReplyPort- pointer to message port that receives I/O request after the allocation completes is asynchronous or quick flag (ADIOF_QUICK) is set io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Command - command number for ADCMD_ALLOCATE io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request (SET) only reply I/O request only if asynchronous (see above text) ADIOF_NOWAIT- (CLEAR) if allocation fails, wait till is succeeds (SET) if allocation fails, return error (ADIOERR_ALLOCFAILED) ioa_AllocKey- allocation key, zero to generate new key; otherwise, it must be set by (or copied from I/O block set by) OpenDevice function or previous ADCMD_ALLOCATE command ioa_Data - pointer to channel combination options (byte array, bits 0 thru 3 correspond to channels 0 thru 3) ioa_Length - length of the channel combination option array (0 thru 16, 0 always succeeds) OUTPUTS io_Unit - bit map of successfully allocated channels (bits 0 thru 3 correspond to channels 0 thru 3) io_Flags - IOF_QUICK flag cleared if asynchronous (see above text) io_Error - error number: 0 - no error ADIOERR_ALLOCFAILED - allocation failed ioa_AllocKey- allocation key, set to a unique number if passed a zero and command succeeds audio.device/ADCMD_FINISH audio.device/ADCMD_FINISH NAME ADCMD_FINISH -- abort writes in progress to audio channels FUNCTION ADCMD_FINISH is a command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct and there is a write (CMD_WRITE)in progress, ADCMD_FINISH aborts the current write immediately or at the end of the current cycle depending on the sync flag (ADIOF_SYNCCYCLE). If the allocation key is incorrect ADCMD_FINISH returns an error (ADIOERR_NOALLOCATION). ADCMD_FINISH is synchronous and only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. Do not use ADCMD_FINISH in interrupt code at interrupt level 5 or higher. INPUTS mn_ReplyPort- pointer to message port that receives I/O request if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to finish (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for ADCMD_FINISH io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ADIOF_SYNCCYCLE- (CLEAR) finish immediately (SET) finish at the end of current cycle ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channels successfully finished (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel audio.device/ADCMD_FREE audio.device/ADCMD_FREE NAME ADCMD_FREE -- free audio channels for allocation FUNCTION ADCMD_FREE is a command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct, ADCMD_FREE does the following: . restores the channel to a known state (CMD_RESET), . changes the channels allocation key, and . makes the channel available for re-allocation. . If the channel is locked (ADCMD_LOCK) ADCMD_FREE unlocks it and clears the bit for the channel (io_Unit) in the lock I/O request. If the lock I/O request has no channel bits set ADCMD_FREE replies the lock I/O request, and . checks if there are allocation requests (ADCMD_ALLOCATE) waiting for the channel. Otherwise, ADCMD_FREE returns an error (ADIOERR_NOALLOCATION). ADCMD_FREE is synchronous and only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. Do not use ADCMD_FREE in interrupt code. INPUTS mn_ReplyPort- pointer to message port that receives I/O request if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to free (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for ADCMD_FREE io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channels successfully freed (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel audio.device/ADCMD_LOCK audio.device/ADCMD_LOCK NAME ADCMD_LOCK -- prevent audio channels from being stolen FUNCTION ADCMD_LOCK is a command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct, ADCMD_LOCK locks the channel, preventing subsequent allocations (ADCMD_ALLOCATE or OpenDevice) from stealing the channel. Otherwise, ADCMD_LOCK returns an error (ADIOERR_NOALLOCATION) and will not lock any channels. Unlike setting the precedence (ADCMD_SETPREC, ADCMD_ALLOCATE or OpenDevice) to maximum (ADALLOC_MAXPREC) which would cause all subsequent allocations to fail, ADCMD_LOCK causes all higher precedence allocations, even no-wait (ADIOF_NOWAIT) allocations, to wait until the channels are un-locked. Locked channels can only be unlocked by freeing them (ADCMD_FREE), which clears the channel select bits (io_Unit). ADCMD_LOCK does not reply the I/O request (mn_ReplyPort) until all the channels it locks are freed, unless a higher precedence allocation attempts to steal one the locked channels. If a steal occurs, ADCMD_LOCK replies and returns an error (ADIOERR_CHANNELSTOLEN). If the lock is replied (mn_ReplyPort) with this error, the channels should be freed as soon as possible. To avoid a possible deadlock, never make the freeing of stolen channels dependent on another allocations completion. ADCMD_LOCK is only asynchronous if the allocation key is correct, in which case it clears the quick flag (IOF_QUICK); otherwise, it is synchronous and only replies if the quick flag (IOF_QUICK) is clear. Do not use ADCMD_LOCK in interrupt code. INPUTS mn_ReplyPort- pointer to message port that receives I/O request if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to lock (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for ADCMD_LOCK io_Flags - flags, must be cleared ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of successfully locked channels (bits 0 thru 3 correspond to channels 0 thru 3) not freed (ADCMD_FREE) io_Flags - IOF_QUICK flag cleared if the allocation key is correct (no ADIOERR_NOALLOCATION error) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel ADIOERR_CHANNELSTOLEN- allocation attempting to steal locked channel audio.device/ADCMD_PERVOL audio.device/ADCMD_PERVOL NAME ADCMD_PERVOL -- change the period and volume for writes in progress to audio channels FUNCTION ADCMD_PERVOL is a command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct and there is a write (CMD_WRITE) in progress, ADCMD_PERVOL loads a new volume and period immediately or at the end of the current cycle depending on the sync flag (ADIOF_SYNCCYCLE). If the allocation key in incorrect, ADCMD_PERVOL returns an error (ADIOERR_NOALLOCATION). ADCMD_PERVOL is synchronous and only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. Do not use ADCMD_PERVOL in interrupt code at interrupt level 5 or higher. INPUTS mn_ReplyPort- pointer to message port that receives I/O request if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to load period and volume (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for ADCMD_PERVOL io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ADIOF_SYNCCYCLE- (CLEAR) load period and volume immediately (SET) load period and volume at the end of the current cycle ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command ioa_Period - new sample period in 279.365 ns increments (124 thru 65536, anti-aliasing filter works below 300 to 500 depending on waveform) ioa_Volume - new volume (0 thru 64, linear) OUTPUTS io_Unit - bit map of channels that successfully loaded period and volume (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel audio.device/ADCMD_SETPREC audio.device/ADCMD_SETPREC NAME ADCMD_SETPREC -- set the allocation precedence for audio channels FUNCTION ADCMD_SETPREC is a command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct, ADCMD_SETPREC sets the allocation precedence to a new value (ln_Pri) and checks if there are allocation requests (ADCMD_ALLOCATE) waiting for the channel which now have higher precedence; otherwise, ADCMD_SETPREC returns an error (ADIOERR_NOALLOCATION). ADCMD_SETPREC is synchronous and only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. Do not use ADCMD_SETPREC in interrupt code. INPUTS ln_Pri - new allocation precedence (-128 thru 127) mn_ReplyPort- pointer to message port that receives I/O request if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to set precedence (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for ADCMD_SETPREC io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channels that successfully set precedence (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel audio.device/ADCMD_WAITCYCLE audio.device/ADCMD_WAITCYCLE NAME ADCMD_WAITCYCLE -- wait for an audio channel to complete the current cycle of a write FUNCTION ADCMD_WAITCYCLE is a command for a single audio channel (io_Unit). If the allocation key (ioa_AllocKey) is correct and there is a write (CMD_WRITE) in progress on selected channel, ADCMD_WAITCYCLE does not reply (mn_ReplyPort) until the end of the current cycle. If there is no write is progress, ADCMD_WAITCYCLE replies immediately. If the allocation key is incorrect, ADCMD_WAITCYCLE returns an error (ADIOERR_NOALLOCATION). ADCMD_WAITCYCLE returns an error (IOERR_ABORTED) if it is canceled (AbortIO) or the channel is stolen (ADCMD_ALLOCATE). ADCMD_WAITCYCLE is only asynchronous if it is waiting for a cycle to complete, in which case it clears the quick flag (IOF_QUICK); otherwise, it is synchronous and only replies if the quick flag (IOF_QUICK) is clear. Do not use ADCMD_WAITCYCLE in interrupt code at interrupt level 5 or higher. INPUTS mn_ReplyPort- pointer to message port that receives I/O request, if the quick flag (IOF_QUICK) is clear, or if a write is in progress on the selected channel and a cycle has completed io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channel to wait for cycle (bits 0 thru 3 correspond to channels 0 thru 3), if more then one bit is set lowest bit number channel is used io_Command - command number for CMD_WAITCYCLE io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request (SET) only reply I/O request if a write is in progress on the selected channel and a cycle has completed ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channel that successfully waited for cycle (bits 0 thru 3 correspond to channels 0 thru 3) io_Flags - IOF_QUICK flag cleared if a write is in progress on the selected channel io_Error - error number: 0 - no error IOERR_ABORTED - canceled (AbortIO) or channel stolen ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel audio.device/BeginIO audio.device/BeginIO NAME BeginIO - dispatch a device command SYNOPSIS BeginIO(iORequest); A1 FUNCTION BeginIO has the responsibility of dispatching all device commands. Immediate commands are always called directly, and all other commands are queued to make them single threaded. INPUTS iORequest -- pointer to the I/O Request for this command audio.device/CloseDevice audio.device/CloseDevice NAME CloseDevice - terminate access to the audio device SYNOPSIS CloseDevice(iORequest); A1 FUNCTION The CloseDevice routine notifies the audio device that it will no longer be used. It takes an I/O audio request block (IOAudio) and clears the device pointer (io_Device). If there are any channels allocated with the same allocation key (ioa_AllocKey), CloseDevice frees (ADCMD_FREE) them. CloseDevice decrements the open count, and if it falls to zero and an expunge (Expunge) is pending, the device is expunged. INPUTS iORequest - pointer to audio request block (struct IOAudio) io_Device - pointer to device node, must be set by (or copied from I/O block set by) open (OpenDevice) io_Unit - bit map of channels to free (ADCMD_FREE) (bits 0 thru 3 correspond to channels 0 thru 3) ioa_AllocKey- allocation key, used to free channels OUTPUTS iORequest - pointer to audio request block (struct IOAudio) io_Device - set to -1 io_Unit - set to zero audio.device/CMD_CLEAR audio.device/CMD_CLEAR NAME CMD_CLEAR -- throw away internal caches FUNCTION CMD_CLEAR is a standard command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct, CMD_CLEAR does nothing; otherwise, CMD_CLEAR returns an error (ADIOERR_NOALLOCATION). CMD_CLEAR is synchronous and only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. INPUTS mn_ReplyPort- pointer to message port that receives I/O request after if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to clear (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for CMD_CLEAR io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channels successfully cleared (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel audio.device/CMD_FLUSH audio.device/CMD_FLUSH NAME CMD_FLUSH -- cancel all pending I/O FUNCTION CMD_FLUSH is a standard command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct, CMD_FLUSH aborts all writes (CMD_WRITE) in progress or queued and any I/O requests waiting to synchronize with the end of the cycle (ADCMD_WAITCYCLE); otherwise, CMD_FLUSH returns an error (ADIOERR_NOALLOCATION). CMD_FLUSH is synchronous and only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. Do not use CMD_FLUSH in interrupt code at interrupt level 5 or higher. INPUTS mn_ReplyPort- pointer to message port that receives I/O request if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to flush (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for CMD_FLUSH io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channels successfully flushed (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel audio.device/CMD_READ audio.device/CMD_READ NAME CMD_READ -- normal I/O entry point FUNCTION CMD_READ is a standard command for a single audio channel (io_Unit). If the allocation key (ioa_AllocKey) is correct, CMD_READ returns a pointer (io_Data) to the I/O block currently writing (CMD_WRITE) on the selected channel; otherwise, CMD_READ returns an error (ADIOERR_NOALLOCATION). If there is no write in progress, CMD_READ returns zero. CMD_READ is synchronous and only replies (mn_ReplyPort) if the quick bit (IOF_QUICK) is clear. INPUTS mn_ReplyPort- pointer to message port that receives I/O request after if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channel to read (bit 0 thru 3 corresponds to channel 0 thru 3), if more then one bit is set lowest bit number channel read io_Command - command number for CMD_READ io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channel successfully read (bit 0 thru 3 corresponds to channel 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel ioa_Data - pointer to I/O block for current write, zero if none is progress audio.device/CMD_RESET audio.device/CMD_RESET NAME CMD_RESET -- restore device to a known state FUNCTION CMD_RESET is a standard command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct, CMD_RESET: . clears the hardware audio registers and attach bits, . sets the audio interrupt vector, . cancels all pending I/O (CMD_FLUSH), and . un-stops the channel if it is stopped (CMD_STOP), Otherwise, CMD_RESET returns an error (ADIOERR_NOALLOCATION). CMD_RESET is synchronous and only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. Do not use CMD_RESET in interrupt code at interrupt level 5 or higher. INPUTS mn_ReplyPort- pointer to message port that receives I/O request if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to reset (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for CMD_RESET io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channels to successfully reset (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel audio.device/CMD_START audio.device/CMD_START NAME CMD_START -- start device processing (like ^Q) FUNCTION CMD_START is a standard command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct and the channel was previously stopped (CMD_STOP), CMP_START immediately starts all writes (CMD_WRITE) to the channel. If the allocation key is incorrect, CMD_START returns an error (ADIOERR_NOALLOCATION). CMD_START starts multiple channels simultaneously to minimize distortion if the channels are playing the same waveform and their outputs are mixed. CMD_START is synchronous an d only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. D o not use CMD_START in interrupt code at interrupt level 5 or higher. INPUTS mn_ReplyPort- pointer to message port that receives I/O request after if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to start (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for CMD_START io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channels successfully started (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel audio.device/CMD_STOP audio.device/CMD_STOP NAME CMD_STOP -- stop device processing (like ^S) FUNCTION CMD_STOP is a standard command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct, CMD_STOP immediately stops any writes (CMD_WRITE) in progress; otherwise, CMD_STOP returns an error (ADIOERR_NOALLOCATION). CMD_WRITE queues up writes to a stopped channel until CMD_START starts the channel or CMD_RESET resets the channel. CMD_STOP is synchronous and only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. Do not use CMD_STOP in interrupt code at interrupt level 5 or higher. INPUTS mn_ReplyPort- pointer to message port that receives I/O request after if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to stop (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for CMD_STOP io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channels successfully stopped (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel audio.device/CMD_UPDATE audio.device/CMD_UPDATE NAME CMD_UPDATE -- force dirty buffers out FUNCTION CMD_UPDATE is a standard command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct, CMD_UPDATE does nothing; otherwise, CMD_UPDATE returns an error (ADIOERR_NOALLOCATION). CMD_UPDATE is synchronous and only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. INPUTS mn_ReplyPort- pointer to message port that receives I/O request after if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to update (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for CMD_UPDATE io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channels successfully updated (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel audio.device/CMD_WRITE audio.device/CMD_WRITE NAME CMD_WRITE -- normal I/O entry point FUNCTION CMD_WRITE is a standard command for a single audio channel (io_Unit). If the allocation key (ioa_AllocKey) is correct, CMD_WRITE plays a sound using the selected channel; otherwise, it returns an error (ADIOERR_NOALLOCATION). CMD_WRITE queues up requests if there is another write in progress or if the channel is stopped (CMD_STOP). When the write actually starts; if the ADIOF_PERVOL flag is set, CMD_WRITE loads volume (ioa_Volume) and period (ioa_Period), and if the ADIOF_WRITEMESSAGE flag is set, CMD_WRITE replies the write message (ioa_WriteMsg). CMD_WRITE returns an error (IOERR_ABORTED) if it is canceled (AbortIO) or the channel is stolen (ADCMD_ALLOCATE). CMD_WRITE is only asynchronous if there is no error, in which case it clears the quick flag (IOF_QUICK) and replies the I/O request (mn_ReplyPort) after it finishes writting; otherwise, it is synchronou s and only replies if the quick flag (IOF_QUICK) is clear. Do not use CMD_WRITE in interrupt code at interrupt level 5 or higher. INPUTS mn_ReplyPort- pointer to message port that receives I/O request after the write completes io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channel to write (bit 0 thru 3 corresponds to channel 0 thru 3), if more then one bit is set lowest bit number channel is written io_Command - command number for CMD_WRITE io_Flags - flags, must be cleared if not used: ADIOF_PERVOL - (SET) load volume and period ADIOF_WRITEMESSAGE - (SET) reply message at write start ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command ioa_Data - pointer to waveform array (signed bytes (-128 thru 127) in custom chip addressable ram and word aligned) ioa_Length - length of the wave array in bytes (2 thru 131072, must be even number) ioa_Period - sample period in 279.365 ns increments (124 thru 65536, anti-aliasing filter works below 300 to 500 depending on waveform), if enabled by ADIOF_PERVOL ioa_Volume - volume (0 thru 64, linear), if enabled by ADIOF_PERVOL ioa_Cycles - number of times to repeat array (0 thru 65535, 0 for infinite) ioa_WriteMsg- message replied at start of write, if enabled by ADIOF_WRITEMESSAGE OUTPUTS io_Unit - bit map of channel successfully written (bit 0 thru 3 corresponds to channel 0 thru 3) io_Flags - IOF_QUICK flag cleared if there is no error io_Error - error number: 0 - no error IOERR_ABORTED - canceled (AbortIO) or channel stolen ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel BUGS If CMD_WRITE starts the write immediately after stopping a previous write, you must set the ADIOF_PERVOL flag or else the new data pointer (ioa_Data) and length (ioa_Length) may not be loaded. audio.device/Expunge audio.device/Expunge NAME EXPUNGE - indicate a desire to remove the Audio device FUNCTION The Expunge routine is called when a user issues a RemDevice call. By the time it is called, the device has already been removed from the device list, so no new opens will succeed. The existence of any other users of the device, as determined by the device open count being non-zero, will cause the Expunge to be deferred. When the device is not in use, or no longer in use, the Expunge is actually performed. audio.device/OpenDevice audio.device/OpenDevice NAME OpenDevice - open the audio device SYNOPSIS error = OpenDevice("audio.device", unitNumber, iORequest, flags); FUNCTION The OpenDevice routine grants access to the audio device. It takes an I/O audio request block (iORequest) and if it can successfully open the audio device, it loads the device pointer (io_Device) and the allocation key (ioa_AllocKey); otherwise, it returns an error (IOERR_OPENFAIL). OpenDevice increments the open count keeping the device from being expunged (Expunge). If the length (ioa_Length) is non-zero, OpenDevice tries to allocate (ADCMD_ALLOCATE) audio channels from a array of channel combination options (ioa_Data). If the allocation succeeds, the allocated channel combination is loaded into the unit field (ioa_Unit); otherwise, OpenDevice returns an error (ADIOERR_ALLOCFAILED). OpenDevice does not wait for allocation to succeed and closes (CloseDevice) the audio device if it fails. To allocate channels, OpenDevice also requires a properly initialized reply port (mn_ReplyPort) with an allocated signal bit. INPUTS unitNumber- not used iORequest - pointer to audio request block (struct IOAudio) ln_Pri - allocation precedence (-128 thru 127), only necessary for allocation (non-zero length) mn_ReplyPort- pointer to message port for allocation, only necessary for allocation (non-zero length) ioa_AllocKey- allocation key; zero to generate new key. Otherwise, it must be set by (or copied from I/O block that is set by) previous OpenDevice function or ADCMD_ALLOCATE command (non-zero length) ioa_Data - pointer to channel combination options (byte array, bits 0 thru 3 correspond to channels 0 thru 3), only necessary for allocation (non-zero length) ioa_Length - length of the channel combination option array (0 thru 16), zero for no allocation flags - not used OUTPUTS iORequest - pointer to audio request block (struct IOAudio) io_Device - pointer to device node if OpenDevice succeeds, otherwise -1 io_Unit - bit map of successfully allocated channels (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error IOERR_OPENFAIL - open failed ADIOERR_ALLOCFAILED - allocation failed, no open ioa_AllocKey- allocation key, set to a unique number if passed a zero and OpenDevice succeeds error - copy of io_Error [Back to Amiga Developer Docs ]
Libraries_Manual_guide/node02A8.html.txt:1:20 / Memory Functions / Memory Attributes ]" border=0> When asking the system for memory, an application can ask for memory with certain attributes. The currently supported flags are listed below. Flags marked "V37" are new memory attributes for Release 2. Allocations which specify these new bits may fail on earlier systems. MEMF_ANY This indicates that there is no requirement for either Fast or Chip memory. In this case, while there is Fast memory available, Exec will only allocate Fast memory. Exec will allocate Chip memory if there is not enough Fast memory. MEMF_CHIP This indicates the application wants a block of chip memory, meaning it wants memory addressable by the Amiga custom chips. Chip memory is required for any data that will be accessed by custom chip DMA. This includes screen memory, images that will be blitted, sprite data, copper lists, and audio data, and pre-V37 floppy disk buffers. If this flag is not specified when allocating memory for these types of data, your code will fail on machines with expanded memory. MEMF_FAST This indicates a memory block outside of the range that the special purpose chips can access. "FAST" means that the special-purpose chips do not have access to the memory and thus cannot cause processor bus contention, therefore processor access will likely be faster. Since the flag specifies memory that the custom chips cannot access, this flag is mutually exclusive with the MEMF_CHIP flag. If you specify the MEMF_FAST flag, your allocation will fail on any Amiga that has only CHIP memory. Use MEMF_ANY if you would prefer FAST memory. MEMF_PUBLIC This indicates that the memory should be accessible to other tasks. Although this flag doesn't do anything right now, using this flag will help ensure compatibility with possible future features of the OS (like virtual memory and memory protection). MEMF_CLEAR This indicates that the memory should be initialized with zeros. MEMF_LOCAL (V37) This indicates memory which is located on the motherboard which is not initialized on reset. MEMF_24BITDMA (V37) This indicates that the memory should be allocated within the 24 bit address space, so that the memory can be used in Zorro-II expansion device DMA transactions. This bit is for use by Zorro-II DMA devices only. It is not for general use by applications. MEMF_REVERSE (V37) Indicates that the memory list should be searched backwards for the highest address memory chunk which can be used for the memory allocation. If an application does not specify any attributes when allocating memory, the system tries to satisfy the request with the first memory available on the system memory lists, which is MEMF_FAST if available, followed by MEMF_CHIP. Make Sure You Have Memory. -------------------------- Always check the result of any memory allocation to be sure the type and amount of memory requested is available. Failure to do so will lead to trying to use an non-valid pointer. [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node0003.html.txt:1:devices ]" border=0> audio.h gameport.h keymap.h prtgfx.h audio.i gameport.i keymap.i prtgfx.i bootblock.h hardblocks.h narrator.h scsidisk.h bootblock.i hardblocks.i narrator.i scsidisk.i clipboard.h input.h parallel.h serial.h clipboard.i input.i parallel.i serial.i console.h inputevent.h printer.h timer.h console.i inputevent.i printer.i timer.i conunit.h keyboard.h prtbase.h trackdisk.h conunit.i keyboard.i prtbase.i trackdisk.i [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node00CB.html.txt:1:Includes/hardware/dmabits.i ]" border=0> IFND HARDWARE_DMABITS_I HARDWARE_DMABITS_I SET 1 ** ** $Filename: hardware/dmabits.i $ ** $Release: 2.04 Includes, V37.4 $ ** $Revision: 36.2 $ ** $Date: 90/07/10 $ ** ** include file for defining dma control stuff ** ** (C) Copyright 1985-1999 Amiga, Inc. ** All Rights Reserved ** * write definitions for dmaconw DMAF_SETCLR EQU $8000 DMAF_AUDIO EQU $000F * 4 bit mask DMAF_AUD0 EQU $0001 DMAF_AUD1 EQU $0002 DMAF_AUD2 EQU $0004 DMAF_AUD3 EQU $0008 DMAF_DISK EQU $0010 DMAF_SPRITE EQU $0020 DMAF_BLITTER EQU $0040 DMAF_COPPER EQU $0080 DMAF_RASTER EQU $0100 DMAF_MASTER EQU $0200 DMAF_BLITHOG EQU $0400 DMAF_ALL EQU $01FF * all dma channels * read definitions for dmaconr * bits 0-8 correspnd to dmaconw definitions DMAF_BLTDONE EQU $4000 DMAF_BLTNZERO EQU $2000 DMAB_SETCLR EQU 15 DMAB_AUD0 EQU 0 DMAB_AUD1 EQU 1 DMAB_AUD2 EQU 2 DMAB_AUD3 EQU 3 DMAB_DISK EQU 4 DMAB_SPRITE EQU 5 DMAB_BLITTER EQU 6 DMAB_COPPER EQU 7 DMAB_RASTER EQU 8 DMAB_MASTER EQU 9 DMAB_BLITHOG EQU 10 DMAB_BLTDONE EQU 14 DMAB_BLTNZERO EQU 13 ENDC ; HARDWARE_DMABITS_I [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node0046.html.txt:1:Includes/devices/narrator.i ]" border=0> IFND DEVICES_NARRATOR_I DEVICES_NARRATOR_I SET 1 ** ** $Filename: devices/narrator.i $ ** $Release: 2.04 Includes, V37.4 $ ** $Revision: 1.7 $ ** $Date: 91/03/12 $ ** ** V37 Narrator device ASM include file ** ** Copyright 1990, 1991 Joseph Katz/Mark Barton. ** All rights reserved. ** ** This include file (narrator.i) may be freely distributed ** as long as the above copyright notice remains intact. ** IFND EXEC_IO_I INCLUDE "exec/io.i" ENDC * ;------ Default values, user parms, and general constants DEFPITCH EQU 110 ;DEFAULT PITCH DEFRATE EQU 150 ;DEFAULT RATE DEFVOL EQU 64 ;DEFAULT VOLUME (FULL) DEFFREQ EQU 22200 ;DEFAULT SAMPLING FREQUENCY NATURALF0 EQU 0 ;NATURAL F0 CONTOURS ROBOTICF0 EQU 1 ;MONOTONE PITCH MANUALF0 EQU 2 ;MANUAL SETTING OF PITCH MALE EQU 0 ;MALE SPEAKER FEMALE EQU 1 ;FEMALE SPEAKER DEFSEX EQU MALE ;DEFAULT SEX DEFMODE EQU NATURALF0 ;DEFAULT MODE DEFARTIC EQU 100 ;DEFAULT ARTICULATION 100% DEFCENTRAL EQU 0 ;DEFAULT PERCENTAGE OF CENTRALIZATION=0 DEFF0PERT EQU 0 ;DEFAULT F0 PERTURBATION DEFF0ENTHUS EQU 32 ;DEFAULT F0 ENTHUSIASM (in 32nds) DEFPRIORITY EQU 100 ;DEFAULT SPEAKING PRIORITY * ;------ Parameter bounds MINRATE EQU 40 ;MINIMUM SPEAKING RATE MAXRATE EQU 400 ;MAXIMUM SPEAKING RATE MINPITCH EQU 65 ;MINIMUM PITCH MAXPITCH EQU 320 ;MAXIMUM PITCH MINFREQ EQU 5000 ;MINIMUM SAMPLING FREQUENCY MAXFREQ EQU 28000 ;MAXIMUM SAMPLING FREQUENCY MINVOL EQU 0 ;MINIMUM VOLUME MAXVOL EQU 64 ;MAXIMUM VOLUME MINCENT EQU 0 ;MINIMUM DEGREE OF CENTRALIZATION MAXCENT EQU 100 ;MAXIMUM DEGREE OF CENTRALIZATION * ;------ Driver error codes ND_NotUsed EQU -1 ; ND_NoMem EQU -2 ;Can't allocate memory ND_NoAudLib EQU -3 ;Can't open audio device ND_MakeBad EQU -4 ;Error in MakeLibrary call ND_UnitErr EQU -5 ;Unit other than 0 ND_CantAlloc EQU -6 ;Can't allocate the audio channel ND_Unimpl EQU -7 ;Unimplemented command ND_NoWrite EQU -8 ;Read for mouth shape without write ND_Expunged EQU -9 ;Can't open, deferred expunge bit set ND_PhonErr EQU -20 ;Phoneme code spelling error ND_RateErr EQU -21 ;Rate out of bounds ND_PitchErr EQU -22 ;Pitch out of bounds ND_SexErr EQU -23 ;Sex not valid ND_ModeErr EQU -24 ;Mode not valid ND_FreqErr EQU -25 ;Sampling freq out of bounds ND_VolErr EQU -26 ;Volume out of bounds ND_DCentErr EQU -27 ;Degree of centralization out of bounds ND_CentPhonErr EQU -28 ;Invalid central phon * ;------ Bit/field definitions of "flags" field of IORB. NDB_NEWIORB EQU 0 ;Use new IORB flag NDB_WORDSYNC EQU 1 ;Generate word sync messages NDB_SYLSYNC EQU 2 ;Generate syllable sync messages NDF_NEWIORB EQU (1 [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node04B6.html.txt:1:audio.device/CMD_WRITE ]" border=0> NAME CMD_WRITE -- normal I/O entry point FUNCTION CMD_WRITE is a standard command for a single audio channel (io_Unit). If the allocation key (ioa_AllocKey) is correct, CMD_WRITE plays a sound using the selected channel; otherwise, it returns an error (ADIOERR_NOALLOCATION). CMD_WRITE queues up requests if there is another write in progress or if the channel is stopped (CMD_STOP). When the write actually starts; if the ADIOF_PERVOL flag is set, CMD_WRITE loads volume (ioa_Volume) and period (ioa_Period), and if the ADIOF_WRITEMESSAGE flag is set, CMD_WRITE replies the write message (ioa_WriteMsg). CMD_WRITE returns an error (IOERR_ABORTED) if it is canceled (AbortIO) or the channel is stolen (ADCMD_ALLOCATE). CMD_WRITE is only asynchronous if there is no error, in which case it clears the quick flag (IOF_QUICK) and replies the I/O request (mn_ReplyPort) after it finishes writting; otherwise, it is synchronou s and only replies if the quick flag (IOF_QUICK) is clear. Do not use CMD_WRITE in interrupt code at interrupt level 5 or higher. INPUTS mn_ReplyPort- pointer to message port that receives I/O request after the write completes io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channel to write (bit 0 thru 3 corresponds to channel 0 thru 3), if more then one bit is set lowest bit number channel is written io_Command - command number for CMD_WRITE io_Flags - flags, must be cleared if not used: ADIOF_PERVOL - (SET) load volume and period ADIOF_WRITEMESSAGE - (SET) reply message at write start ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command ioa_Data - pointer to waveform array (signed bytes (-128 thru 127) in custom chip addressable ram and word aligned) ioa_Length - length of the wave array in bytes (2 thru 131072, must be even number) ioa_Period - sample period in 279.365 ns increments (124 thru 65536, anti-aliasing filter works below 300 to 500 depending on waveform), if enabled by ADIOF_PERVOL ioa_Volume - volume (0 thru 64, linear), if enabled by ADIOF_PERVOL ioa_Cycles - number of times to repeat array (0 thru 65535, 0 for infinite) ioa_WriteMsg- message replied at start of write, if enabled by ADIOF_WRITEMESSAGE OUTPUTS io_Unit - bit map of channel successfully written (bit 0 thru 3 corresponds to channel 0 thru 3) io_Flags - IOF_QUICK flag cleared if there is no error io_Error - error number: 0 - no error IOERR_ABORTED - canceled (AbortIO) or channel stolen ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel BUGS If CMD_WRITE starts the write immediately after stopping a previous write, you must set the ADIOF_PERVOL flag or else the new data pointer (ioa_Data) and length (ioa_Length) may not be loaded. [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node01DA.html.txt:1:exec.library/AddIntServer ]" border=0> NAME AddIntServer -- add an interrupt server to a system server chain SYNOPSIS AddIntServer(intNum, interrupt) D0-0:4 A1 void AddIntServer(ULONG, struct Interrupt *); FUNCTION This function adds a new interrupt server to a given server chain. The node is located on the chain in a priority dependent position. If this is the first server on a particular chain, interrupts will be enabled for that chain. Each link in the chain will be called in priority order until the chain ends or one of the servers returns with the 68000's Z condition code clear (indicating non-zero). Servers on the chain should return with the Z flag clear if the interrupt was specifically for that server, and no one else. VERTB servers should always return Z set. (Take care with High Level Language servers, the language may not have a mechanism for reliably setting the Z flag on exit). Servers are called with the following register conventions: D0 - scratch D1 - scratch A0 - scratch A1 - server is_Data pointer (scratch) A5 - jump vector register (scratch) A6 - scratch all other registers must be preserved INPUTS intNum - the Paula interrupt bit number (0 through 14). Processor level seven interrupts (NMI) are encoded as intNum 15. The PORTS, COPER, VERTB, EXTER and NMI interrupts are set up as server chains. interrupt - pointer to an Interrupt structure. By convention, the LN_NAME of the interrupt structure must point a descriptive string so that other users may identify who currently has control of the interrupt. WARNING Some compilers or assemblers may optimize code in unexpected ways, affecting the conditions codes returned from the function. Watch out for a "MOVEM" instruction (which does not affect the condition codes) turning into "MOVE" (which does). BUGS The graphics library's VBLANK server, and some user code, currently assume that address register A0 will contain a pointer to the custom chips. If you add a server at a priority of 10 or greater, you must compensate for this by providing the expected value ($DFF000). SEE ALSO RemIntServer() , SetIntVector() , hardware/intbits.i,exec/interrupts.i [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node006F.html.txt:1:audio.device/CMD_STOP ]" border=0> NAME CMD_STOP -- stop device processing (like ^S) FUNCTION CMD_STOP is a standard command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct, CMD_STOP immediately stops any writes (CMD_WRITE) in progress; otherwise, CMD_STOP returns an error (ADIOERR_NOALLOCATION). CMD_WRITE queues up writes to a stopped channel until CMD_START starts the channel or CMD_RESET resets the channel. CMD_STOP is synchronous and only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. Do not use CMD_STOP in interrupt code at interrupt level 5 or higher. INPUTS mn_ReplyPort- pointer to message port that receives I/O request after if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to stop (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for CMD_STOP io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channels successfully stopped (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node006C.html.txt:1:audio.device/CMD_READ ]" border=0> NAME CMD_READ -- normal I/O entry point FUNCTION CMD_READ is a standard command for a single audio channel (io_Unit). If the allocation key (ioa_AllocKey) is correct, CMD_READ returns a pointer (io_Data) to the I/O block currently writing (CMD_WRITE) on the selected channel; otherwise, CMD_READ returns an error (ADIOERR_NOALLOCATION). If there is no write in progress, CMD_READ returns zero. CMD_READ is synchronous and only replies (mn_ReplyPort) if the quick bit (IOF_QUICK) is clear. INPUTS mn_ReplyPort- pointer to message port that receives I/O request after if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channel to read (bit 0 thru 3 corresponds to channel 0 thru 3), if more then one bit is set lowest bit number channel read io_Command - command number for CMD_READ io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channel successfully read (bit 0 thru 3 corresponds to channel 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel ioa_Data - pointer to I/O block for current write, zero if none is progress [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node00CE.html.txt:1:Includes/hardware/intbits.h ]" border=0> #ifndef HARDWARE_INTBITS_H #define HARDWARE_INTBITS_H /* ** $Filename: hardware/intbits.h $ ** $Release: 2.04 Includes, V37.4 $ ** $Revision: 36.2 $ ** $Date: 90/07/10 $ ** ** bits in the interrupt enable (and interrupt request) register ** ** (C) Copyright 1985-1999 Amiga, Inc. ** All Rights Reserved */ #define INTB_SETCLR (15) /* Set/Clear control bit. Determines if bits */ /* written with a 1 get set or cleared. Bits */ /* written with a zero are allways unchanged */ #define INTB_INTEN (14) /* Master interrupt (enable only ) */ #define INTB_EXTER (13) /* External interrupt */ #define INTB_DSKSYNC (12) /* Disk re-SYNChronized */ #define INTB_RBF (11) /* serial port Receive Buffer Full */ #define INTB_AUD3 (10) /* Audio channel 3 block finished */ #define INTB_AUD2 (9) /* Audio channel 2 block finished */ #define INTB_AUD1 (8) /* Audio channel 1 block finished */ #define INTB_AUD0 (7) /* Audio channel 0 block finished */ #define INTB_BLIT (6) /* Blitter finished */ #define INTB_VERTB (5) /* start of Vertical Blank */ #define INTB_COPER (4) /* Coprocessor */ #define INTB_PORTS (3) /* I/O Ports and timers */ #define INTB_SOFTINT (2) /* software interrupt request */ #define INTB_DSKBLK (1) /* Disk Block done */ #define INTB_TBE (0) /* serial port Transmit Buffer Empty */ #define INTF_SETCLR (1 #define INTF_INTEN (1 #define INTF_EXTER (1 #define INTF_DSKSYNC (1 #define INTF_RBF (1 #define INTF_AUD3 (1 #define INTF_AUD2 (1 #define INTF_AUD1 (1 #define INTF_AUD0 (1 #define INTF_BLIT (1 #define INTF_VERTB (1 #define INTF_COPER (1 #define INTF_PORTS (1 #define INTF_SOFTINT (1 #define INTF_DSKBLK (1 #define INTF_TBE (1 [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node00A2.html.txt:1:cd.device/CD_ADDFRAMEINT ]" border=0> NAME CD_ADDFRAMEINT -- add a CD-frame software interrupt handler. IO REQUEST io_Device preset by the call to OpenDevice() io_Unit preset by the call to OpenDevice() io_Command CD_ADDFRAMEINT io_Length sizeof(struct Interrupt) io_Data pointer to Interrupt structure RESULTS io_Error 0 for success, or an error code as defined in FUNCTION This command lets you add a software interrupt handler to the disk device that gets invoked whenever a new frame is encountered while CD audio is being played. You must pass in a properly initialized Exec Interrupt structure and be prepared to deal with frame interrupts immediately. The interrupt is generated by the exec Cause function, so you must preserve A6. To set up the handler, an Interrupt structure must be initialized. This structure is supplied in io_Data of the CD_ADDFRAMEINT command. The handler then gets linked into the handler chain and gets invoked whenever a frame event occurs. You must eventually remove the handler before you exit. This command only returns when the handler is removed. That is, the device holds onto the IO request until the CD_REMFRAMEINT command is executed with that same IO request. Hence, you must use SendIO() with this command. NOTES The interrupt handler can be added before or after a play command is sent. Interrupts will only be generated while CD audio is playing. Interrupts will not be generated when audio is paused. SEE ALSO CD_REMFRAMEINT , , , exec.library/Cause() [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node0062.html.txt:1:audio.device/ADCMD_FINISH ]" border=0> NAME ADCMD_FINISH -- abort writes in progress to audio channels FUNCTION ADCMD_FINISH is a command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct and there is a write (CMD_WRITE)in progress, ADCMD_FINISH aborts the current write immediately or at the end of the current cycle depending on the sync flag (ADIOF_SYNCCYCLE). If the allocation key is incorrect ADCMD_FINISH returns an error (ADIOERR_NOALLOCATION). ADCMD_FINISH is synchronous and only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. Do not use ADCMD_FINISH in interrupt code at interrupt level 5 or higher. INPUTS mn_ReplyPort- pointer to message port that receives I/O request if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to finish (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for ADCMD_FINISH io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ADIOF_SYNCCYCLE- (CLEAR) finish immediately (SET) finish at the end of current cycle ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channels successfully finished (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node00AC.html.txt:1:cd.device/CD_PLAYLSN ]" border=0> NAME CD_PLAYLSN -- Play a selected portion of CD audio (LSN form). IO REQUEST io_Device preset by the call to OpenDevice() io_Unit preset by the call to OpenDevice() io_Command CD_PLAYLSN io_Data NULL io_Length length of play io_Offset starting position RESULTS io_Error 0 for success, or an error code as defined in FUNCTION This command causes the drive to start playing CD audio from the specified position until the specified length has passed. io_Offset specifies the starting position. io_Length contains the amount of time to play. All data is specified in LSN format. A DoIO() will not return until the requested number of sectors have been played. A SendIO() will return as soon as the PLAY has been started. At this time other commands can be sent (like CD_PAUSE). To stop a play before the specified length has been reached, use AbortIO() . EXAMPLE /* Play two minutes, ten seconds of audio starting at 20 minutes, */ /* 58 seconds, and 10 frames. */ ior->io_Command = CD_PLAYLSN; /* Play CD audio */ ior->io_Offset = 94360; /* 20*(60*75) + 58*75 + 10 */ ior->io_Length = 9750; /* 02*(60*75) + 10*75 + 00 */ DoIO (ior); NOTES BUGS SEE ALSO CD_PLAYTRACK , CD_PAUSE , CD_SEARCH , CD_ATTENUATE [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node0060.html.txt:1:audio.device/AbortIO ]" border=0> NAME AbortIO - abort a device command SYNOPSIS AbortIO(iORequest); A1 FUNCTION AbortIO tries to abort a device command. It is allowed to be unsuccessful. If the Abort is successful, the io_Error field of the iORequest contains an indication that IO was aborted. INPUTS iORequest -- pointer to the I/O Request for the command to abort [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node0064.html.txt:1:audio.device/ADCMD_LOCK ]" border=0> NAME ADCMD_LOCK -- prevent audio channels from being stolen FUNCTION ADCMD_LOCK is a command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct, ADCMD_LOCK locks the channel, preventing subsequent allocations (ADCMD_ALLOCATE or OpenDevice) from stealing the channel. Otherwise, ADCMD_LOCK returns an error (ADIOERR_NOALLOCATION) and will not lock any channels. Unlike setting the precedence (ADCMD_SETPREC, ADCMD_ALLOCATE or OpenDevice) to maximum (ADALLOC_MAXPREC) which would cause all subsequent allocations to fail, ADCMD_LOCK causes all higher precedence allocations, even no-wait (ADIOF_NOWAIT) allocations, to wait until the channels are un-locked. Locked channels can only be unlocked by freeing them (ADCMD_FREE), which clears the channel select bits (io_Unit). ADCMD_LOCK does not reply the I/O request (mn_ReplyPort) until all the channels it locks are freed, unless a higher precedence allocation attempts to steal one the locked channels. If a steal occurs, ADCMD_LOCK replies and returns an error (ADIOERR_CHANNELSTOLEN). If the lock is replied (mn_ReplyPort) with this error, the channels should be freed as soon as possible. To avoid a possible deadlock, never make the freeing of stolen channels dependent on another allocations completion. ADCMD_LOCK is only asynchronous if the allocation key is correct, in which case it clears the quick flag (IOF_QUICK); otherwise, it is synchronous and only replies if the quick flag (IOF_QUICK) is clear. Do not use ADCMD_LOCK in interrupt code. INPUTS mn_ReplyPort- pointer to message port that receives I/O request if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to lock (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for ADCMD_LOCK io_Flags - flags, must be cleared ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of successfully locked channels (bits 0 thru 3 correspond to channels 0 thru 3) not freed (ADCMD_FREE) io_Flags - IOF_QUICK flag cleared if the allocation key is correct (no ADIOERR_NOALLOCATION error) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel ADIOERR_CHANNELSTOLEN- allocation attempting to steal locked channel [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node0000.html.txt:1:Autodocs Table of Contents ]" border=0> Modules amigaguide amigaguide_dtc amiga_lib animation_dtc arexx_cl asl audio battclock battmem bevel_ic bitmap_ic bullet button_gc cardres cd checkbox_gc chooser_gc cia clicktab_gc clipboard colorwheel_gc commodities console datatypes ddebug_lib debug_lib disk diskfont dos drawlist_ic exec expansion filesysres fuelgauge_gc gadtools gameport getfile_gc getfont_gc getscreenmode_gc glyph_ic gradientslider_gc graphics icon iffparse input integer_gc intuition keyboard keymap label_ic layers layout_gc listbrowser_gc locale lowlevel mathffp mathieeedoubbas mathieeedoubtrans mathieeesingbas mathieeesingtrans mathtrans misc narrator nonvolatile page_gc palette_gc parallel penmap_ic picture_dtc port-handler potgo printer queue-handler radiobutton_gc reaction_lib realtime resource rexxsyslib scroller_gc serial sound_dtc speedbar_gc string_gc text_dtc timer trackdisk translator utility wb window_cl Indices Library Function Index Device Command Index C Structure Index [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node0071.html.txt:1:audio.device/CMD_WRITE ]" border=0> NAME CMD_WRITE -- normal I/O entry point FUNCTION CMD_WRITE is a standard command for a single audio channel (io_Unit). If the allocation key (ioa_AllocKey) is correct, CMD_WRITE plays a sound using the selected channel; otherwise, it returns an error (ADIOERR_NOALLOCATION). CMD_WRITE queues up requests if there is another write in progress or if the channel is stopped (CMD_STOP). When the write actually starts; if the ADIOF_PERVOL flag is set, CMD_WRITE loads volume (ioa_Volume) and period (ioa_Period), and if the ADIOF_WRITEMESSAGE flag is set, CMD_WRITE replies the write message (ioa_WriteMsg). CMD_WRITE returns an error (IOERR_ABORTED) if it is canceled (AbortIO) or the channel is stolen (ADCMD_ALLOCATE). CMD_WRITE is only asynchronous if there is no error, in which case it clears the quick flag (IOF_QUICK) and replies the I/O request (mn_ReplyPort) after it finishes writting; otherwise, it is synchronous and only replies if the quick flag (IOF_QUICK) is clear. Do not use CMD_WRITE in interrupt code at interrupt level 5 or higher. INPUTS mn_ReplyPort- pointer to message port that receives I/O request after the write completes io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channel to write (bit 0 thru 3 corresponds to channel 0 thru 3), if more then one bit is set lowest bit number channel is written io_Command - command number for CMD_WRITE io_Flags - flags, must be cleared if not used: ADIOF_PERVOL - (SET) load volume and period ADIOF_WRITEMESSAGE - (SET) reply message at write start ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command ioa_Data - pointer to waveform array (signed bytes (-128 thru 127) in custom chip addressable ram and word aligned) ioa_Length - length of the wave array in bytes (2 thru 131072, must be even number) ioa_Period - sample period in 279.365 ns increments (124 thru 65536, anti-aliasing filter works below 300 to 500 depending on waveform), if enabled by ADIOF_PERVOL ioa_Volume - volume (0 thru 64, linear), if enabled by ADIOF_PERVOL ioa_Cycles - number of times to repeat array (0 thru 65535, 0 for infinite) ioa_WriteMsg- message replied at start of write, if enabled by ADIOF_WRITEMESSAGE OUTPUTS io_Unit - bit map of channel successfully written (bit 0 thru 3 corresponds to channel 0 thru 3) io_Flags - IOF_QUICK flag cleared if there is no error io_Error - error number: 0 - no error IOERR_ABORTED - canceled (AbortIO) or channel stolen ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel BUGS If CMD_WRITE starts the write immediately after stopping a previous write, you must set the ADIOF_PERVOL flag or else the new data pointer (ioa_Data) and length (ioa_Length) may not be loaded. [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node05E4.html.txt:1:include/devices/cd.h ]" border=0> #ifndef DEVICES_CD_H #define DEVICES_CD_H /* ** $VER: cd.h 1.11 (12.8.1993) ** Includes Release 44.1 ** ** cd.device include file ** ** (C) Copyright 1992-1999 Amiga, Inc. ** All Rights Reserved */ #include #include /************************************************************************** * * * CD Commands * * * **************************************************************************/ #define CD_RESET 1 #define CD_READ 2 #define CD_WRITE 3 #define CD_UPDATE 4 #define CD_CLEAR 5 #define CD_STOP 6 #define CD_START 7 #define CD_FLUSH 8 #define CD_MOTOR 9 #define CD_SEEK 10 #define CD_FORMAT 11 #define CD_REMOVE 12 #define CD_CHANGENUM 13 #define CD_CHANGESTATE 14 #define CD_PROTSTATUS 15 #define CD_GETDRIVETYPE 18 #define CD_GETNUMTRACKS 19 #define CD_ADDCHANGEINT 20 #define CD_REMCHANGEINT 21 #define CD_GETGEOMETRY 22 #define CD_EJECT 23 #define CD_INFO 32 #define CD_CONFIG 33 #define CD_TOCMSF 34 #define CD_TOCLSN 35 #define CD_READXL 36 #define CD_PLAYTRACK 37 #define CD_PLAYMSF 38 #define CD_PLAYLSN 39 #define CD_PAUSE 40 #define CD_SEARCH 41 #define CD_QCODEMSF 42 #define CD_QCODELSN 43 #define CD_ATTENUATE 44 #define CD_ADDFRAMEINT 45 #define CD_REMFRAMEINT 46 /************************************************************************** * * * Device Driver Error Codes * * * **************************************************************************/ #define CDERR_OPENFAIL (-1) /* device/unit failed to open */ #define CDERR_ABORTED (-2) /* request terminated early */ #define CDERR_NOCMD (-3) /* command not supported by device */ #define CDERR_BADLENGTH (-4) /* invalid length (IO_LENGTH/IO_OFFSET) */ #define CDERR_BADADDRESS (-5) /* invalid address (IO_DATA misaligned) */ #define CDERR_UNITBUSY (-6) /* device opens ok, but unit is busy */ #define CDERR_SELFTEST (-7) /* hardware failed self-test */ #define CDERR_NotSpecified 20 /* general catchall */ #define CDERR_NoSecHdr 21 /* couldn't even find a sector */ #define CDERR_BadSecPreamble 22 /* sector looked wrong */ #define CDERR_BadSecID 23 /* ditto */ #define CDERR_BadHdrSum 24 /* header had incorrect checksum */ #define CDERR_BadSecSum 25 /* data had incorrect checksum */ #define CDERR_TooFewSecs 26 /* couldn't find enough sectors */ #define CDERR_BadSecHdr 27 /* another "sector looked wrong" */ #define CDERR_WriteProt 28 /* can't write to a protected disk */ #define CDERR_NoDisk 29 /* no disk in the drive */ #define CDERR_SeekError 30 /* couldn't find track 0 */ #define CDERR_NoMem 31 /* ran out of memory */ #define CDERR_BadUnitNum 32 /* asked for a unit > NUMUNITS */ #define CDERR_BadDriveType 33 /* not a drive cd.device understands */ #define CDERR_DriveInUse 34 /* someone else allocated the drive */ #define CDERR_PostReset 35 /* user hit reset; awaiting doom */ #define CDERR_BadDataType 36 /* data on disk is wrong type */ #define CDERR_InvalidState 37 /* invalid cmd under current conditions */ #define CDERR_Phase 42 /* illegal or unexpected SCSI phase */ #define CDERR_NoBoard 50 /* open failed for non-existant board */ /************************************************************************** * * * Configuration * * * * The drive is configured by TagList items defined as follows: * * * **************************************************************************/ #define TAGCD_PLAYSPEED 0x0001 #define TAGCD_READSPEED 0x0002 #define TAGCD_READXLSPEED 0x0003 #define TAGCD_SECTORSIZE 0x0004 #define TAGCD_XLECC 0x0005 #define TAGCD_EJECTRESET 0x0006 /************************************************************************** * * * Information * * * * Information/Status structure describes current speed settings * * for read and play commands, sector size, audio attenuation * * precision, and drive status. * * * **************************************************************************/ struct CDInfo { /* Default */ UWORD PlaySpeed; /* Audio play speed (75) */ UWORD ReadSpeed; /* Data-rate of CD_READ command (Max) */ UWORD ReadXLSpeed; /* Data-rate of CD_READXL command (75) */ UWORD SectorSize; /* Number of bytes per sector (2048) */ UWORD XLECC; /* CDXL ECC enabled/disabled */ UWORD EjectReset; /* Reset on eject enabled/disabled */ UWORD Reserved1[4]; /* Reserved for future expansion */ UWORD MaxSpeed; /* Maximum speed drive can handle (75, 150) */ UWORD AudioPrecision; /* 0 = no attenuator, 1 = mute only, */ /* other = (# levels - 1) */ UWORD Status; /* See flags below */ UWORD Reserved2[4]; /* Reserved for future expansion */ }; /* Flags for Status */ #define CDSTSB_CLOSED 0 /* Drive door is closed */ #define CDSTSB_DISK 1 /* A disk has been detected */ #define CDSTSB_SPIN 2 /* Disk is spinning (motor is on) */ #define CDSTSB_TOC 3 /* Table of contents read. Disk is valid. */ #define CDSTSB_CDROM 4 /* Track 1 contains CD-ROM data */ #define CDSTSB_PLAYING 5 /* Audio is playing */ #define CDSTSB_PAUSED 6 /* Pause mode (pauses on play command) */ #define CDSTSB_SEARCH 7 /* Search mode (Fast Forward/Fast Reverse) */ #define CDSTSB_DIRECTION 8 /* Search direction (0 = Forward, 1 = Reverse) */ #define CDSTSF_CLOSED 0x0001 #define CDSTSF_DISK 0x0002 #define CDSTSF_SPIN 0x0004 #define CDSTSF_TOC 0x0008 #define CDSTSF_CDROM 0x0010 #define CDSTSF_PLAYING 0x0020 #define CDSTSF_PAUSED 0x0040 #define CDSTSF_SEARCH 0x0080 #define CDSTSF_DIRECTION 0x0100 /* Modes for CD_SEARCH */ #define CDMODE_NORMAL 0 /* Normal play at current play speed */ #define CDMODE_FFWD 1 /* Fast forward play (skip-play forward)*/ #define CDMODE_FREV 2 /* Fast reverse play (skip-play reverse)*/ /************************************************************************** * * * Position Information * * * * Position information can be described in two forms: MSF and LSN * * form. MSF (Minutes, Seconds, Frames) form is a time encoding. * * LSN (Logical Sector Number) form is frame (sector) count. * * The desired form is selected using the io_Flags field of the * * IOStdReq structure. The flags and the union are described * * below. * * * **************************************************************************/ struct RMSF { UBYTE Reserved; /* Reserved (always zero) */ UBYTE Minute; /* Minutes (0-72ish) */ UBYTE Second; /* Seconds (0-59) */ UBYTE Frame; /* Frame (0-74) */ }; union LSNMSF { struct RMSF MSF; /* Minute, Second, Frame */ ULONG LSN; /* Logical Sector Number */ }; /************************************************************************** * * * CD Transfer Lists * * * * A CDXL node is a double link node; however only single linkage * * is used by the device driver. If you wish to construct a * * transfer list manually, it is only neccessary to define the * * mln_Succ pointer of the MinNode. You may also use the Exec * * list functions by defining a List or MinList structure and by * * using the AddHead/AddTail functions to create the list. This * * will create a double-linked list. Although a double-linked * * list is not required by the device driver, you may wish use it * * for your own purposes. Don't forget to initialize the * * the List/MinList before using it! * * * **************************************************************************/ struct CDXL { struct MinNode Node; /* double linkage */ char *Buffer; /* data destination (word aligned) */ LONG Length; /* must be even # bytes */ LONG Actual; /* bytes transferred */ APTR IntData; /* interrupt server data segment */ VOID (*IntCode)(); /* interrupt server code entry */ }; /************************************************************************** * * * CD Table of Contents * * * * The CD_TOC command returns an array of CDTOC entries. * * Entry zero contains summary information describing how many * * tracks the disk has and the play-time of the disk. * * Entries 1 through N (N = Number of tracks on disk) contain * * information about the track. * * * **************************************************************************/ struct TOCSummary { UBYTE FirstTrack; /* First track on disk (always 1) */ UBYTE LastTrack; /* Last track on disk */ union LSNMSF LeadOut; /* Beginning of lead-out track (end of disk) */ }; struct TOCEntry { UBYTE CtlAdr; /* Q-Code info */ UBYTE Track; /* Track number */ union LSNMSF Position; /* Start position of this track */ }; union CDTOC { struct TOCSummary Summary; /* First entry (0) is summary information */ struct TOCEntry Entry; /* Entries 1-N are track entries */ }; /************************************************************************** * * * Q-Code Packets * * * * Q-Code packets are only returned when audio is playing. * * Currently, only position packets are returned (ADR_POSITION) * * The other ADR_ types are almost never encoded on the disk * * and are of little use anyway. To avoid making the QCode * * structure a union, these other ADR_ structures are not defined. * * * **************************************************************************/ struct QCode { UBYTE CtlAdr; /* Data type / QCode type */ UBYTE Track; /* Track number */ UBYTE Index; /* Track subindex number */ UBYTE Zero; /* The "Zero" byte of Q-Code packet */ union LSNMSF TrackPosition; /* Position from start of track */ union LSNMSF DiskPosition; /* Position from start of disk */ }; #define CTLADR_CTLMASK 0xF0 /* Control field */ #define CTL_CTLMASK 0xD0 /* To be ANDed with CtlAdr before compared */ #define CTL_2AUD 0x00 /* 2 audio channels without preemphasis */ #define CTL_2AUDEMPH 0x10 /* 2 audio channels with preemphasis */ #define CTL_4AUD 0x80 /* 4 audio channels without preemphasis */ #define CTL_4AUDEMPH 0x90 /* 4 audio channels with preemphasis */ #define CTL_DATA 0x40 /* CD-ROM Data */ #define CTL_COPYMASK 0x20 /* To be ANDed with CtlAdr before compared */ #define CTL_COPY 0x20 /* When true, this audio/data can be copied */ #define CTLADR_ADRMASK 0x0F /* Address field */ #define ADR_POSITION 0x01 /* Q-Code is position information */ #define ADR_UPC 0x02 /* Q-Code is UPC information (not used) */ #define ADR_ISRC 0x03 /* Q-Code is ISRC (not used) */ #define ADR_HYBRID 0x05 /* This disk is a hybrid disk */ #endif [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node0565.html.txt:1:sound.datatype/sound.datatype ]" border=0> NAME sound.datatype -- root data type for sounds. FUNCTION The sound.datatype is the super-class for any sound related classes. METHODS OM_NEW -- Create a new sound object. OM_GET -- Obtain the value of an attribute. OM_SET -- Set the values of multiple attributes. OM_UPDATE -- Update the values of multiple attributes. OM_DISPOSE -- Dispose of a sound object. GM_LAYOUT -- Layout the object and notify the application of the title and size. GM_HITTEST -- Determine if the object has been hit with the mouse. GM_GOACTIVE -- Tell the object to go active. On SELECTDOWN, the sound will start playing. GM_HANDLEINPUT -- Handle input. Currently input (other than SELECTDOWN) doesn't affect the sound. GM_RENDER -- Cause the graphic to render. Currently the graphic for the sound is just a static icon. DTM_TRIGGER -- Cause an event to occur. Currently the only trigger event is STM_PLAY, which will cause the sound to start playing. NOTE: Subclasses which support streaming data access may support more than just the STM_PLAY event. DTM_COPY -- Copy the entire sound to the clipboard as 8SVX. NOTE: Up to and including V40 sound.datatype never stored a valid VoiceHeader with the file. This was fixed in V44. Subclasses which support streaming data access may not support this method. DTM_WRITE -- Write the entire sound to a file as 8SVX. NOTE: Up to and including V40 sound.datatype never stored a valid VoiceHeader with the file. This was fixed in V44. Subclasses which support streaming data access may not support this method. TAGS SDTA_VoiceHeader (struct VoiceHeader *) -- Set and get the base information for the sound. VoiceHeader is defined in . NOTE: Up to and including V40 sound.datatype never returned a valid VoiceHeader for OM_GET and the VoiceHeader data was ignored in the OM_NEW/OM_SET cases. This was fixed in V44. Applicability is (ISG). SDTA_Sample (BYTE *) -- Set and get the sound data. Starting with V40 the sample data does not need to be in CHIP memory. Starting with V44 the sample data does not need to start on a WORD-aligned address. Setting SDTA_Sample to NULL will stop sound replay if sound.datatype was started playing with a non-NULL SDTA_Sample parameter. The SDTA_Sample parameter selects mono playback on any sound channel that is currently available. NOTE: For streaming sound playback, SDTA_LeftSample, SDTA_RightSample, and SDTA_Sample will all be NULL (V44). Applicability is (ISG). SDTA_SampleLength (ULONG) -- Length of the sound data in bytes. Starting with V44 the sample data does not need to be an even number of bytes. Setting SDTA_SampleLength to 0 will stop sound replay. Applicability is (ISG). SDTA_Period (UWORD) -- Set and get the period of the sound (in timing intervals per sample). This attribute can be used to affect a playing sound. Please note that the Amiga audio hardware does not reliably support playback periods shorter than 124; sound.datatype will limit the period to valid intervals (V44). Default for this tag is 394. Applicability is (ISG). SDTA_Volume (UWORD) -- Set and get the volume of the sound. This attribute can be used to affect a playing sound. Valid range is from 0 to 64. Default for this tag is 64. Applicability is (ISG). SDTA_Cycles (UWORD) -- Set and get the number of cycles the sound will be played. Default for this tag is 1. Applicability is (ISG). The following tags are new for V40. SDTA_SignalTask (struct Task *) -- Task to signal when the is complete, or if SDTA_Continuous is TRUE, when the next buffer is needed. Default for this tag is NULL. Applicability is (IS). SDTA_SignalBit (ULONG) -- Signal mask to use with SDTA_SignalTask or 0 to disable. NOTE: Due to a bug in sound.datatype V40 SDTA_SignalBit was actually implemented as a signal mask as opposed to a bit number. The documentation now reflects this. If you intend to use a signal bit number instead of the mask, use the new V44 tag SDTA_SignalBitNumber below. Default for this tag is 0. Applicability is (IS). SDTA_Continuous (BOOL) -- Used to indicate that the sound datatype will be fed a continuous stream of data. Default for this tag is FALSE. Applicability is (I). The following tags are new for V44. SDTA_SignalBitMask (ULONG) -- Signal mask to use with SDTA_SignalTask or 0 to disable. This tag is an alias for SDTA_SignalBit. Default for this tag is 0. Applicability is (IS). SDTA_SignalBitNumber (BYTE) -- Signal bit to use with SDTA_SignalTask or -1 to disable. Default for this tag is -1. Applicability is (IS). SDTA_SamplesPerSec (UWORD) -- Set and get the replay frequency of a sound (in Hz). This attribute can be used to affect a playing sound. Unlike the SDTA_Period tag, which serves the same purpose, this tag automatically takes the system clock value into account. Please note that the Amiga audio hardware does not reliably support playback rates beyond 28,000 samples per second; sound.datatype will limit the replay frequency to valid intervals. Applicability is (ISG). SDTA_ReplayPeriod (struct timeval *) -- Get the replay period, i.e. the time it takes for the complete sound to be played. If the sample size has not been set yet, the timeval tv_sec and tv_micro members will be set to 0. If the sample is to be played continuously, both timeval members will be set to 0xFFFFFFFF. Applicability is (G). SDTA_Pan (BYTE) -- Set the stereo panning; this must be set to a number in the range of -64..64. A value of -64 will pan the sound to the left channel, silencing the right channel; a value of 64 will pan the sound to the right channel and silence the left channel. To center playback, use a panning value of 0. The panning value only takes effect if a stereo sound is being played. Default for this tag is 0. Applicability is (IS). SDTA_FreeSampleData (BOOL) -- This tag controls whether sound.datatype will call FreeVec() on the sample data attached to an object. If the SDTA_Continuous attribute was set to TRUE, sound.datatype will never free any data attached to an object. It is safe to attach the same sample to more than one channel as sound.datatype will make sure that no sample data is freed twice. Default for this tag is FALSE. Applicability is (IS). SDTA_LeftSample (BYTE *) -- Set and get the left channel sound data. The sample data does not need to be in CHIP memory and does not need to start on a WORD-aligned address. Setting SDTA_LeftSample to NULL will stop sound replay if sound.datatype was started playing with a non-NULL SDTA_LeftSample parameter. The SDTA_LeftSample parameter alone selects mono playback on any left sound channel that is currently available. Used together with the SDTA_RightSample parameter, stereo playback on any available stereo channels is selected. The SDTA_LeftSample parameter takes precedence over the the SDTA_Sample parameter. NOTE: For streaming sound playback, SDTA_LeftSample, SDTA_RightSample, and SDTA_Sample will all be NULL (V44). Applicability is (ISG). SDTA_RightSample (BYTE *) -- Set and get the right channel sound data . The sample data does not need to be in CHIP memory and does not need to start on a WORD-aligned address. Setting SDTA_RightSample to NULL will stop sound replay if sound.datatype was started playing with a non-NULL SDTA_RightSample parameter. The SDTA_RightSample parameter alone selects mono playback on any right sound channel that is currently available. Used together with the SDTA_LeftSample parameter, stereo playback on any available stereo channels is selected. The SDTA_RightSample parameter takes precedence over the the SDTA_Sample parameter. NOTE: For streaming sound playback, SDTA_LeftSample, SDTA_RightSample, and SDTA_Sample will all be NULL (V44). Applicability is (ISG). SDTA_SyncSampleChange (BOOL) -- If SDTA_Continuous was set to TRUE, sound.datatype will expect a continuous stream of data to be played. By specifying "SDTA_SyncSampleChange,TRUE" you request that new sound data will be played only if the old data has been played completely (otherwise, playback would restart immediately with the new sound). If playback is currently in progress, the Task to change the sample data will be made to wait until playback of the old sound has finished. Default for this tag is FALSE. Applicability is (IS). DTA_Immediate (BOOL) -- Select and query whether playback should start immediately after the object has passed the layout process. Default for this tag is FALSE. Applicability is (ISG). DTA_Repeat (BOOL) -- Select and query whether playback should loop indefinitely, regardless of the current SDTA_Cycles settings. Default for this tag is FALSE. Applicability is (ISG). NOTES You cannot switch between mono and stereo playback on the fly while the sound is still playing. First, stop the sound, then change the SDTA_Sample/SDTA_LeftSample/SDTA_LeftSample attributes. The sound.datatype implementation has been cleaned up for V44 to allow for streaming subclasses to be written. Such subclasses will always return NULL when their SDTA_LeftSample, SDTA_RightSample and SDTA_Sample attributes are queried. However, they will never return 0 for the SDTA_SampleLength and SDTA_SamplesPerSec attributes since these can be used to calculate the length of the entire sample. Streaming subclasses will respond to the DTM_TRIGGER method, to start, stop playback, etc. but may not support any other methods which rely upon the entire sample to reside in memory. [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node0111.html.txt:1:Includes/resources/misc.i ]" border=0> IFND RESOURCES_MISC_I RESOURCES_MISC_I SET 1 ** ** $Filename: resources/misc.i $ ** $Release: 2.04 Includes, V37.4 $ ** $Revision: 36.12 $ ** $Date: 90/05/06 $ ** ** Unit number definitions for "misc.resource" ** ** (C) Copyright 1985-1999 Amiga, Inc. ** All Rights Reserved ** IFND EXEC_TYPES_I INCLUDE "exec/types.i" ENDC !EXEC_TYPES_I IFND EXEC_LIBRARIES_I INCLUDE "exec/libraries.i" ENDC !EXEC_LIBRARIES_I * * Unit number definitions. Ownership of a resource grants low-level * bit access to the hardware registers. You are still obligated to follow * the rules for shared access of the interrupt system. (see * exec.library/SetIntVector or cia.resource as appropriate). * MR_SERIALPORT EQU 0 ;Amiga custom chip serial port registers & interrupts ;(SERDAT,SERDATR,SERPER,ADKCON, and interrupts) MR_SERIALBITS EQU 1 ;Serial control bits (DTR,CTS, etc.) MR_PARALLELPORT EQU 2 ;The 8 bit parallel data port ;(CIAAPRA & CIAADDRA only!) MR_PARALLELBITS EQU 3 ;All other parallel bits & interrupts (BUSY,ACK,etc.) * * Library vector offset definitions * LIBINIT LIB_BASE LIBDEF MR_ALLOCMISCRESOURCE ;-6 LIBDEF MR_FREEMISCRESOURCE ;-12 * * Name of misc.resource * MISCNAME MACRO DC.B 'misc.resource',0 CNOP 0,2 ENDM ENDC ;RESOURCE_MISC_I [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node00AE.html.txt:1:cd.device/CD_PLAYTRACK ]" border=0> NAME CD_PLAYTRACK -- Play one or more tracks of CD audio. IO REQUEST io_Device preset by the call to OpenDevice() io_Unit preset by the call to OpenDevice() io_Command CD_PLAYTRACK io_Data NULL io_Length number of tracks to play io_Offset start playing at beginning of this track RESULTS io_Error 0 for success, or an error code as defined in FUNCTION This command causes the drive to play the specified audio track(s). The command will return when the audio has completed. io_Offset specifies the track number (starting from 1). io_Length specifies the number of tracks to play (0 is invalid). EXAMPLE ior->io_Command = CD_PLAYTRACK; /* Play audio tracks */ ior->io_Offset = STARTTRACK; /* Start with this track */ ior->io_Length = 3; /* Play three tracks */ DoIO(ior); NOTES PLAY commands are asynchronous with many other CD commands. Using a separate I/O request, other commands can be sent to the device that can change the behavior of the PLAY command. BUGS SEE ALSO CD_PLAYMSF , CD_PLAYLSN , CD_PAUSE , CD_SEARCH , CD_ATTENUATE [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node04C7.html.txt:1:narrator.device/CMD_WRITE ]" border=0> NAME CMD_WRITE - Send speech request to the narrator device SYNOPSIS Standard device command. FUNCTION Sends a phonetic string to the narrator device to be spoken and, optionally, is used to direct the narrator device to return mouth shape changes, and word and syllable sync events in response to read requests from the user. The phonetic string consists of ASCII characters representing the individual phonemes. Refer to the narrator device chapter of the libraries and devices volume of the ROM Kernel Manual for detailed information. INPUTS User IORequest block (struct narrator_rb as defined in .h file). The OpenDevice call will initialize the IORequest block to a "standard male" voice. If you want to change any parms, do so after the OpenDevice call and before the DoIO (or SendIO/WaitIO). For a complete description of the narrator_rb structure, see the narrator.h or .i include file. Note that the OpenDevice call does not initialize all the fields needed by the narrator device. The IORequest fields which must be set by the user before issuing the write request are: io_Command - Set to CMD_WRITE io_Data - Pointer to phonetic string io_Length - Length of phonetic string ch_masks - Array of audio channel selection masks (see audio device documentation for description of this field) nm_masks - Number of audio channel selection masks ****** NEW FOR V37 NARRATOR flags - The bit NDB_NEWIORB must be set in the flags field if any of the new features of the V37 narrator are used In addition to producing synthetic speech, the narrator device also provides features for synchronizing the speech to animation or other user defined events. There are three types of events that the user can request. They are mouth shape changes, start of new word, and start of new syllable. Mouth shape changes are requested by setting the mouths field of the IORequest block to a non-zero value. Word and syllable sync events are requested by setting the NDB_WORDSYNC and/or NDB_SYLSYNC bits in the flags field of the IORequest block. Note that word and syllable sync only work in V37 and later versions of the narrator device. RESULTS The narrator device range checks and performs other validity checks for all input parms. If any input is in error, the device sets the io_Error field of the IORequest block to an appropriate value (see include files for error codes). If everything is in order, the narrator device will produce the speech and clear the io_Error field. The io_Actual field is set to the length of the input string that was actually processed. If the return code indicates a phoneme error (ND_PhonErr), io_Actual is the NEGATIVE of the position in the input string where the error occured. SEE ALSO Read command. Audio device documentation. Exec input/output documentation. [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node007F.html.txt:1:Includes/exec/alerts.h ]" border=0> #ifndef EXEC_ALERTS_H #define EXEC_ALERTS_H /* ** $Filename: exec/alerts.h $ ** $Release: 2.04 Includes, V37.4 $ ** $Revision: 36.18 $ ** $Date: 91/01/12 $ ** ** Alert numbers, as displayed by system crashes. ** ** (C) Copyright 1985-1999 Amiga, Inc. ** All Rights Reserved */ /********************************************************************* * * Format of the alert error number: * * +-+-------------+----------------+--------------------------------+ * |D| SubSysId | General Error | SubSystem Specific Error | * +-+-------------+----------------+--------------------------------+ * 1 7 bits 8 bits 16 bits * * D: DeadEnd alert * SubSysId: indicates ROM subsystem number. * General Error: roughly indicates what the error was * Specific Error: indicates more detail **********************************************************************/ /********************************************************************* * * General Alerts * * For example: timer.device cannot open math.library would be 0x05038015 * * Alert(AN_TimerDev|AG_OpenLib|AO_MathLib); * *********************************************************************/ /*------ alert types */ #define AT_DeadEnd 0x80000000 #define AT_Recovery 0x00000000 /*------ general purpose alert codes */ #define AG_NoMemory 0x00010000 #define AG_MakeLib 0x00020000 #define AG_OpenLib 0x00030000 #define AG_OpenDev 0x00040000 #define AG_OpenRes 0x00050000 #define AG_IOError 0x00060000 #define AG_NoSignal 0x00070000 #define AG_BadParm 0x00080000 #define AG_CloseLib 0x00090000 /* usually too many closes */ #define AG_CloseDev 0x000A0000 /* or a mismatched close */ #define AG_ProcCreate 0x000B0000 /* Process creation failed */ /*------ alert objects: */ #define AO_ExecLib 0x00008001 #define AO_GraphicsLib 0x00008002 #define AO_LayersLib 0x00008003 #define AO_Intuition 0x00008004 #define AO_MathLib 0x00008005 #define AO_DOSLib 0x00008007 #define AO_RAMLib 0x00008008 #define AO_IconLib 0x00008009 #define AO_ExpansionLib 0x0000800A #define AO_DiskfontLib 0x0000800B #define AO_UtilityLib 0x0000800C #define AO_AudioDev 0x00008010 #define AO_ConsoleDev 0x00008011 #define AO_GamePortDev 0x00008012 #define AO_KeyboardDev 0x00008013 #define AO_TrackDiskDev 0x00008014 #define AO_TimerDev 0x00008015 #define AO_CIARsrc 0x00008020 #define AO_DiskRsrc 0x00008021 #define AO_MiscRsrc 0x00008022 #define AO_BootStrap 0x00008030 #define AO_Workbench 0x00008031 #define AO_DiskCopy 0x00008032 #define AO_GadTools 0x00008033 #define AO_Unknown 0x00008035 /********************************************************************* * * Specific Alerts: * *********************************************************************/ /*------ exec.library */ #define AN_ExecLib 0x01000000 #define AN_ExcptVect 0x01000001 /* 68000 exception vector checksum (obs.) */ #define AN_BaseChkSum 0x01000002 /* Execbase checksum (obs.) */ #define AN_LibChkSum 0x01000003 /* Library checksum failure */ #define AN_MemCorrupt 0x81000005 /* Corrupt memory list detected in FreeMem */ #define AN_IntrMem 0x81000006 /* No memory for interrupt servers */ #define AN_InitAPtr 0x01000007 /* InitStruct() of an APTR source (obs.) */ #define AN_SemCorrupt 0x01000008 /* A semaphore is in an illegal state at ReleaseSempahore() */ #define AN_FreeTwice 0x01000009 /* Freeing memory already freed */ #define AN_BogusExcpt 0x8100000A /* illegal 68k exception taken (obs.) */ #define AN_IOUsedTwice 0x0100000B /* Attempt to reuse active IORequest */ #define AN_MemoryInsane 0x0100000C /* Sanity check on memory list failed during AvailMem(MEMF_LARGEST) */ #define AN_IOAfterClose 0x0100000D /* IO attempted on closed IORequest */ #define AN_StackProbe 0x0100000E /* Stack appears to extend out of range */ #define AN_BadFreeAddr 0x0100000F /* Memory header not located. [ Usually an invalid address passed to FreeMem() ] */ /*------ graphics.library */ #define AN_GraphicsLib 0x02000000 #define AN_GfxNoMem 0x82010000 /* graphics out of memory */ #define AN_GfxNoMemMspc 0x82010001 /* MonitorSpec alloc, no memory */ #define AN_LongFrame 0x82010006 /* long frame, no memory */ #define AN_ShortFrame 0x82010007 /* short frame, no memory */ #define AN_TextTmpRas 0x02010009 /* text, no memory for TmpRas */ #define AN_BltBitMap 0x8201000A /* BltBitMap, no memory */ #define AN_RegionMemory 0x8201000B /* regions, memory not available */ #define AN_MakeVPort 0x82010030 /* MakeVPort, no memory */ #define AN_GfxNewError 0x0200000C #define AN_GfxFreeError 0x0200000D #define AN_GfxNoLCM 0x82011234 /* emergency memory not available */ #define AN_ObsoleteFont 0x02000401 /* unsupported font description used */ /*------ layers.library */ #define AN_LayersLib 0x03000000 #define AN_LayersNoMem 0x83010000 /* layers out of memory */ /*------ intuition.library */ #define AN_Intuition 0x04000000 #define AN_GadgetType 0x84000001 /* unknown gadget type */ #define AN_BadGadget 0x04000001 /* Recovery form of AN_GadgetType */ #define AN_CreatePort 0x84010002 /* create port, no memory */ #define AN_ItemAlloc 0x04010003 /* item plane alloc, no memory */ #define AN_SubAlloc 0x04010004 /* sub alloc, no memory */ #define AN_PlaneAlloc 0x84010005 /* plane alloc, no memory */ #define AN_ItemBoxTop 0x84000006 /* item box top #define AN_OpenScreen 0x84010007 /* open screen, no memory */ #define AN_OpenScrnRast 0x84010008 /* open screen, raster alloc, no memory */ #define AN_SysScrnType 0x84000009 /* open sys screen, unknown type */ #define AN_AddSWGadget 0x8401000A /* add SW gadgets, no memory */ #define AN_OpenWindow 0x8401000B /* open window, no memory */ #define AN_BadState 0x8400000C /* Bad State Return entering Intuition */ #define AN_BadMessage 0x8400000D /* Bad Message received by IDCMP */ #define AN_WeirdEcho 0x8400000E /* Weird echo causing incomprehension */ #define AN_NoConsole 0x8400000F /* couldn't open the Console Device */ /*------ math.library */ #define AN_MathLib 0x05000000 /*------ dos.library */ #define AN_DOSLib 0x07000000 #define AN_StartMem 0x07010001 /* no memory at startup */ #define AN_EndTask 0x07000002 /* EndTask didn't */ #define AN_QPktFail 0x07000003 /* Qpkt failure */ #define AN_AsyncPkt 0x07000004 /* Unexpected packet received */ #define AN_FreeVec 0x07000005 /* Freevec failed */ #define AN_DiskBlkSeq 0x07000006 /* Disk block sequence error */ #define AN_BitMap 0x07000007 /* Bitmap corrupt */ #define AN_KeyFree 0x07000008 /* Key already free */ #define AN_BadChkSum 0x07000009 /* Invalid checksum */ #define AN_DiskError 0x0700000A /* Disk Error */ #define AN_KeyRange 0x0700000B /* Key out of range */ #define AN_BadOverlay 0x0700000C /* Bad overlay */ #define AN_BadInitFunc 0x0700000D /* Invalid init packet for cli/shell */ #define AN_FileReclosed 0x0700000E /* A filehandle was closed more than once */ /*------ ramlib.library */ #define AN_RAMLib 0x08000000 #define AN_BadSegList 0x08000001 /* no overlays in library seglists */ /*------ icon.library */ #define AN_IconLib 0x09000000 /*------ expansion.library */ #define AN_ExpansionLib 0x0A000000 #define AN_BadExpansionFree 0x0A000001 /* freeed free region */ /*------ diskfont.library */ #define AN_DiskfontLib 0x0B000000 /*------ audio.device */ #define AN_AudioDev 0x10000000 /*------ console.device */ #define AN_ConsoleDev 0x11000000 #define AN_NoWindow 0x11000001 /* Console can't open initial window */ /*------ gameport.device */ #define AN_GamePortDev 0x12000000 /*------ keyboard.device */ #define AN_KeyboardDev 0x13000000 /*------ trackdisk.device */ #define AN_TrackDiskDev 0x14000000 #define AN_TDCalibSeek 0x14000001 /* calibrate: seek error */ #define AN_TDDelay 0x14000002 /* delay: error on timer wait */ /*------ timer.device */ #define AN_TimerDev 0x15000000 #define AN_TMBadReq 0x15000001 /* bad request */ #define AN_TMBadSupply 0x15000002 /* power supply -- no 50/60Hz ticks */ /*------ cia.resource */ #define AN_CIARsrc 0x20000000 /*------ disk.resource */ #define AN_DiskRsrc 0x21000000 #define AN_DRHasDisk 0x21000001 /* get unit: already has disk */ #define AN_DRIntNoAct 0x21000002 /* interrupt: no active unit */ /*------ misc.resource */ #define AN_MiscRsrc 0x22000000 /*------ bootstrap */ #define AN_BootStrap 0x30000000 #define AN_BootError 0x30000001 /* boot code returned an error */ /*------ Workbench */ #define AN_Workbench 0x31000000 #define AN_NoFonts 0xB1000001 #define AN_WBBadStartupMsg1 0x31000001 #define AN_WBBadStartupMsg2 0x31000002 #define AN_WBBadIOMsg 0x31000003 #define AN_WBInitPotionAllocDrawer 0xB1010004 #define AN_WBCreateWBMenusCreateMenus1 0xB1010005 #define AN_WBCreateWBMenusCreateMenus2 0xB1010006 #define AN_WBLayoutWBMenusLayoutMenus 0xB1010007 #define AN_WBAddToolMenuItem 0xB1010008 #define AN_WBReLayoutToolMenu 0xB1010009 #define AN_WBinitTimer 0xB101000A #define AN_WBInitLayerDemon 0xB101000B #define AN_WBinitWbGels 0xB101000C #define AN_WBInitScreenAndWindows1 0xB101000D #define AN_WBInitScreenAndWindows2 0xB101000E #define AN_WBInitScreenAndWindows3 0xB101000F #define AN_WBMAlloc 0xB1010010 /*------ DiskCopy */ #define AN_DiskCopy 0x32000000 /*------ toolkit for Intuition */ #define AN_GadTools 0x33000000 /*------ System utility library */ #define AN_UtilityLib 0x34000000 /*------ For use by any application that needs it */ #define AN_Unknown 0x35000000 #endif /* EXEC_ALERTS_H */ [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node0332.html.txt:1:exec.library/AllocMem ]" border=0> NAME AllocMem -- allocate memory given certain requirements SYNOPSIS memoryBlock = AllocMem(byteSize, attributes) D0 D0 D1 void *AllocMem(ULONG, ULONG); FUNCTION This is the memory allocator to be used by system code and applications. It provides a means of specifying that the allocation should be made in a memory area accessible to the chips, or accessible to shared system code. Memory is allocated based on requirements and options. Any "requirement" must be met by a memory allocation, any "option" will be applied to the block regardless. AllocMem will try all memory spaces until one is found with the proper requirements and room for the memory request. INPUTS byteSize - the size of the desired block in bytes. (The operating system will automatically round this number to a multiple of the system memory chunk size) attributes - requirements If no flags are set, the system will return the best available memory block. For expanded systems, the fast memory pool is searched first. MEMF_CHIP: If the requested memory will be used by the Amiga custom chips, this flag *must* be set. Only certain parts of memory are reachable by the special chip sets' DMA circuitry. Chip DMA includes screen memory, images that are blitted, audio data, copper lists, sprites and Pre-V36 trackdisk.device buffers. MEMF_FAST: This is non-chip memory. If no flag is set MEMF_FAST is taken as the default. DO NOT SPECIFY MEMF_FAST unless you know exactly what you are doing! If MEMF_FAST is set, AllocMem() will fail on machines that only have chip memory! This flag may not be set when MEMF_CHIP is set. MEMF_PUBLIC: Memory that must not be mapped, swapped, or otherwise made non-addressable. ALL MEMORY THAT IS REFERENCED VIA INTERRUPTS AND/OR BY OTHER TASKS MUST BE EITHER PUBLIC OR LOCKED INTO MEMORY! This includes both code and data. MEMF_LOCAL: This is memory that will not go away after the CPU RESET instruction. Normally, autoconfig memory boards become unavailable after RESET while motherboard memory may still be available. This memory type is now automatically set in V36. Pre-V36 systems may not have this memory type and AllocMem() will then fail. MEMF_24BITDMA: This is memory that is within the address range of 24-bit DMA devices. (Zorro-II) This is required if you run a Zorro-II DMA device on a machine that has memory beyond the 24-bit addressing limit of Zorro-II. This memory type is now automatically set in V36. Pre-V36 systems may not have this memory type and AllocMem() will then fail. options MEMF_CLEAR: The memory will be initialized to all zeros. MEMF_REVERSE: This allocates memory from the top of the memory pool. It searches the pools in the same order, such that FAST memory will be found first. However, the memory will be allocated from the highest address available in the pool. This option is new as of V36. RESULT memoryBlock - a pointer to the newly allocated memory block. If there are no free memory regions large enough to satisfy the request, zero will be returned. The pointer must be checked for zero before the memory block may be used! WARNING The result of any memory allocation MUST be checked, and a viable error handling path taken. ANY allocation may fail if memory has been filled. EXAMPLES AllocMem(64,0L) - Allocate the best available memory AllocMem(25,MEMF_CLEAR) - Allocate the best available memory, and clear it before returning. AllocMem(128,MEMF_CHIP) - Allocate chip memory AllocMem(128,MEMF_CHIP|MEMF_CLEAR) - Allocate cleared chip memory AllocMem(821,MEMF_CHIP|MEMF_PUBLIC|MEMF_CLEAR) - Allocate cleared, public, chip memory. NOTE If the free list is corrupt, the system will panic with alert AN_MemCorrupt, $01000005. This function may not be called from interrupts. A DOS process will have its pr_Result2 field set to ERROR_NO_FREE_STORE if the memory allocation fails. SEE ALSO FreeMem [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node00A3.html.txt:1:cd.device/CD_ATTENUATE ]" border=0> NAME CD_ATTENUATE -- Attenuate CD audio volume (immediately or gradually) IO REQUEST io_Device preset by the call to OpenDevice() io_Unit preset by the call to OpenDevice() io_Command CD_ATTENUATE io_Data NULL io_Length duration of volume fade in frames io_Offset target volume level (0 - 0x7FFF) (-1 = status only) RESULTS io_Error Returns an error if drive does not support attenuation io_Actual current volume level (fade may be monitored) FUNCTION This command will ramp the CD audio volume up or down from its current value to the value contained in io_Offset. The range is 0 (silence) to 0x7FFF (full volume). If -1 is specified as the target, the attenuation will not be modified; the current attenuation value will be returned in io_Actual. io_Length contains the duration of the fade. In seconds, this is io_Length divided by the current frame rate (usually 75). Note that this command returns before the fade has completed. Thus, once started, a fade cannot be aborted. You can, however, send a new CD_ATTENUATE command, which will immediately override any fade currently in progress. An io_Length of zero means attenuate immediately. If a gradual attenuation command is sent before the play command, the fade will begin as soon as the play command is sent. EXAMPLE NOTES This command has no effect on Amiga audio volume, only CD audio. If the drive does not support volume attenuation, but does support mute, a value of under $0800 should be considered mute, and equal to or above should be full volume. If chunky attenuation is supported, the drive should do the best it can. If the drive does not support volume attenuation at all, an error should be returned. Even if only mute is supported, if gradual attenuation is requested, the device should still emulate the fade command and mute based on the $0800 boundary. BUGS SEE ALSO CD_INFO [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node00D1.html.txt:1:Includes/hardware/intbits.i ]" border=0> IFND HARDWARE_INTBITS_I HARDWARE_INTBITS_I SET 1 ** ** $Filename: hardware/intbits.i $ ** $Release: 2.04 Includes, V37.4 $ ** $Revision: 36.2 $ ** $Date: 90/07/10 $ ** ** bits in the interrupt enable (and interrupt request) register ** ** (C) Copyright 1985-1999 Amiga, Inc. ** All Rights Reserved ** INTB_SETCLR EQU (15) ;Set/Clear control bit. Determines if bits ;written with a 1 get set or cleared. Bits ;written with a zero are allways unchanged. INTB_INTEN EQU (14) ;Master interrupt (enable only ) INTB_EXTER EQU (13) ;External interrupt INTB_DSKSYNC EQU (12) ;Disk re-SYNChronized INTB_RBF EQU (11) ;serial port Receive Buffer Full INTB_AUD3 EQU (10) ;Audio channel 3 block finished INTB_AUD2 EQU (9) ;Audio channel 2 block finished INTB_AUD1 EQU (8) ;Audio channel 1 block finished INTB_AUD0 EQU (7) ;Audio channel 0 block finished INTB_BLIT EQU (6) ;Blitter finished INTB_VERTB EQU (5) ;start of Vertical Blank INTB_COPER EQU (4) ;Coprocessor INTB_PORTS EQU (3) ;I/O Ports and timers INTB_SOFTINT EQU (2) ;software interrupt request INTB_DSKBLK EQU (1) ;Disk Block done INTB_TBE EQU (0) ;serial port Transmit Buffer Empty INTF_SETCLR EQU (1 [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node01E7.html.txt:1:exec.library/AllocMem ]" border=0> NAME AllocMem -- allocate memory given certain requirements SYNOPSIS memoryBlock = AllocMem(byteSize, attributes) D0 D0 D1 void *AllocMem(ULONG, ULONG); FUNCTION This is the memory allocator to be used by system code and applications. It provides a means of specifying that the allocation should be made in a memory area accessible to the chips, or accessible to shared system code. Memory is allocated based on requirements and options. Any "requirement" must be met by a memory allocation, any "option" will be applied to the block regardless. AllocMem will try all memory spaces until one is found with the proper requirements and room for the memory request. INPUTS byteSize - the size of the desired block in bytes. (The operating system will automatically round this number to a multiple of the system memory chunk size) attributes - requirements If no flags are set, the system will return the best available memory block. For expanded systems, the fast memory pool is searched first. MEMF_CHIP: If the requested memory will be used by the Amiga custom chips, this flag *must* be set. Only certain parts of memory are reachable by the special chip sets' DMA circuitry. Chip DMA includes screen memory, images that are blitted, audio data, copper lists, sprites and Pre-V36 trackdisk.device buffers. MEMF_FAST: This is non-chip memory. If no flag is set MEMF_FAST is taken as the default. DO NOT SPECIFY MEMF_FAST unless you know exactly what you are doing! If MEMF_FAST is set, AllocMem() will fail on machines that only have chip memory! This flag may not be set when MEMF_CHIP is set. MEMF_PUBLIC: Memory that must not be mapped, swapped, or otherwise made non-addressable. ALL MEMORY THAT IS REFERENCED VIA INTERRUPTS AND/OR BY OTHER TASKS MUST BE EITHER PUBLIC OR LOCKED INTO MEMORY! This includes both code and data. MEMF_LOCAL: This is memory that will not go away after the CPU RESET instruction. Normally, autoconfig memory boards become unavailable after RESET while motherboard memory may still be available. This memory type is now automatically set in V36. Pre-V36 systems may not have this memory type and AllocMem() will then fail. MEMF_24BITDMA: This is memory that is within the address range of 24-bit DMA devices. (Zorro-II) This is required if you run a Zorro-II DMA device on a machine that has memory beyond the 24-bit addressing limit of Zorro-II. This memory type is now automatically set in V36. Pre-V36 systems may not have this memory type and AllocMem() will then fail. MEMF_KICK: This memory is memory that EXEC was able to access during/before the KickMem and KickTags are processed. This means that if you wish to use these, you should allocate memory with this flag. This flag is automaticly set by EXEC in V39. Pre-V39 systems may not have this memory type and AllocMem() will then fail. Also, *DO NOT* ever add memory the system with this flag set. EXEC will set the flag as needed if the memory matches the needs of EXEC. options MEMF_CLEAR: The memory will be initialized to all zeros. MEMF_REVERSE: This allocates memory from the top of the memory pool. It searches the pools in the same order, such that FAST memory will be found first. However, the memory will be allocated from the highest address available in the pool. This option is new as of V36. Note that this option has a bug in pre-V39 systems. MEMF_NO_EXPUNGE This will prevent an expunge to happen on a failed memory allocation. This option is new to V39 and will be ignored in V37. If a memory allocation with this flag set fails, the allocator will not cause any expunge operations. (See AddMemHandler() ) RESULT memoryBlock - a pointer to the newly allocated memory block. If there are no free memory regions large enough to satisfy the request, zero will be returned. The pointer must be checked for zero before the memory block may be used! The memory block returned is long word aligned. WARNING The result of any memory allocation MUST be checked, and a viable error handling path taken. ANY allocation may fail if memory has been filled. EXAMPLES AllocMem(64,0L) - Allocate the best available memory AllocMem(25,MEMF_CLEAR) - Allocate the best available memory, and clear it before returning. AllocMem(128,MEMF_CHIP) - Allocate chip memory AllocMem(128,MEMF_CHIP|MEMF_CLEAR) - Allocate cleared chip memory AllocMem(821,MEMF_CHIP|MEMF_PUBLIC|MEMF_CLEAR) - Allocate cleared, public, chip memory. NOTE If the free list is corrupt, the system will panic with alert AN_MemCorrupt, $01000005. This function may not be called from interrupts. A DOS process will have its pr_Result2 field set to ERROR_NO_FREE_STORE if the memory allocation fails. SEE ALSO FreeMem() [Back to Amiga Developer Docs ]
AmigaMail_Vol2_guide/node01D3.html.txt:1:VI-1/interplay.c ]" border=0> ;/* interplay.c -- execute me to compile me sc DATA=NEAR NMINC STRMERGE NOSTKCHK IGNORE=73 interplay.c slink FROM LIB:c.o + interplay.o TO interplay LIBRARY lib:sc.lib+lib:amiga.lib quit */ /* (c) Copyright 1993-1999 Amiga, Inc. All rights reserved. */ /* The information contained herein is subject to change without */ /* notice, and is provided "as is" without warranty of any kind, */ /* either expressed or implied. The entire risk as to the use of */ /* this information is assumed by the user. */ /* Interlay.c - Run from Shell (CLI) only. Given two file names of IFF ** 8SVX 8-bit sampled audio data, plays the data from both files using just ** one channel. This demonstrates how virtual audio channels can be ** implemented. ** ** The program supports two different methods for virtual voices. Method 1 ** (the default method) interleaves bytes from each file so that the data words ** fed into the Amiga's audio hardware contain one byte each from the given ** files. The samples are then played back at twice their normal speed. Since ** each sample only gets half of the playback bandwidth, the speed sounds ** correct. To the listener, it sounds as if both samples are playing ** simultaneously even though only one channel is used. ** ** Normally the maximum playback rate with the Amiga's audio hardware is about ** 28K bytes/sec. Since interleaving requires doubling the nominal sampling ** rate, it will only work with audio data created at a sampling rate of 14K ** bytes/sec or less. ** ** Method 2, takes one byte from each file, sums them and divides by two. ** The resulting byte value is sent to the Amiga's audio hardware. No speed ** increase is required for this technique, however some noise is introduced ** by the averaging of the byte values. To use method 2, inlcude the SUM ** keyword as the last argument typed on the command line. Examples: ** ** interplay talk.8svx music.8svx SUM (Uses method 2, averaging) ** interplay talk.8svx music.8svx (Uses method 1, interleaving) ** interplay talk.8svx (Normal single file 8SVX playback) ** ** For an example of conventional IFF 8SVX audio see the "Amiga ROM Kernel ** Reference Manual: Devices", 3rd edition (ISBN 0-201-56775-X), page 28 and ** page 515. */ #include #include #include #include #include #include #include #include #include #include #include #include #include /* This is the dos.h file from SAS/C not Commodore */ #ifdef SASC int CXBRK(VOID) { return(0); }; int chkabort(VOID) { return(0); }; #endif #define BUF_SIZE 1024 /* Prototypes for functions defined in this program */ struct IOAudio *SiezeChannel( VOID ); VOID ReleaseChannel( struct IOAudio * ); char *Parse8svx(char *, struct InterPlay * ); VOID EndParse( struct InterPlay * ); VOID FillAudio(struct InterPlay *, struct IOAudio * ); struct InterPlay /* This is the main structure used for */ { /* storage of playback state info. */ ULONG sample_done; /* 0=Keep playing, 1=all done playing. */ UBYTE *sample_byte; /* Pointer for going through the data. */ UBYTE *sample_loc; /* Start of 8SVX BODY data in memory. */ ULONG sample_size; /* and total size of file for freeing.*/ struct InterPlay *next_iplay; /* Link to second data set. NULL means */ /* no second file name was given. */ LONG offsetBody; /* Offset into the file of BODY Chunk. */ UWORD sample_speed; /* Value for audio period register. */ BOOL USE_SUMMING; /* TRUE means use averaging, */ }; /* FALSE means use interleaving. */ /* Version string for AmigaDOS VERSION command. */ UBYTE versiontag[] = "$VER: Interplay 1.0 (2.2.93)"; /*----------------------------------------- ** ** main() ** **----------------------------------------- */ VOID main(int argc, char **argv) { struct InterPlay mainplay,otherplay; /* Two instances of the InterPlay */ /* structure, one for each file. */ struct IOAudio *pIOA_1=NULL, *pIOA_2=NULL, /* Two IOAudio pointers, plus one */ *pIOA =NULL; /* for switching back and forth */ struct MsgPort *mport1=NULL, /* during double-buffering. */ *mport2=NULL, /* Two MsgPort pointers, plus one */ *mport =NULL; /* for switching back and forth. */ struct Message *msg; /* For the GetMsg() call. */ LONG aswitch = 0L; /* Double-buffering logical switch. */ static BYTE chip playbuffer1[BUF_SIZE]; /* Two buffers, one for each IOAudio */ static BYTE chip playbuffer2[BUF_SIZE]; /* request. Play out of one while */ /* the other is being set up. */ char *errormsg; /* For error returns */ ULONG wakemask=0L; /* For Wait() call */ /* Give an AmigaDOS style help message */ if( (argc == 2) && !strcmp(argv[1],"?\0") ) printf("8SVX-FILES/M,SUM/S\n"); else if(argc>=2) /* OK got at least one argument. */ { /* Get an audio channel at the highest priority */ if( pIOA_1=SiezeChannel() ) { mport1 = pIOA_1->ioa_Request.io_Message.mn_ReplyPort; pIOA_1->ioa_Data = playbuffer1; /* Get a 2nd MsgPort and 2nd IOAudio structure for double-buffering */ pIOA_2 = AllocMem(sizeof(struct IOAudio),MEMF_PUBLIC | MEMF_CLEAR ); mport2 = CreatePort(0,0); if( pIOA_2 && mport2 ) { /* The 2 IOAudio requests should be initialized the same */ /* except for the buffer and the reply port they use. */ *pIOA_2 = *pIOA_1; pIOA_2->ioa_Request.io_Message.mn_ReplyPort = mport2; pIOA_2->ioa_Data = playbuffer2; /* Default is to use interleaving, not averaging */ mainplay.USE_SUMMING = FALSE; /* Parse the 8SVX file and fill in the InterPlay structure */ errormsg = Parse8svx( argv[1] , &mainplay ); /* If a second file name was given by the user then this is */ /* an interleave request, so parse the 2nd 8SVX file. */ if( argc>=3 && !errormsg ) { errormsg = Parse8svx( argv[2] , &otherplay ); mainplay.next_iplay = &otherplay; /* If the SUM keyword was given in the command line, set the */ /* SUMMING flag so that averaging, not interleaving, is used.*/ if( (argc == 4) && ( !strcmp(argv[3],"SUM\0") || !strcmp(argv[3],"sum\0") ) ) mainplay.USE_SUMMING = TRUE; } else otherplay.sample_done = 1; if(!errormsg) /* File names given parsed OK? */ { /* Fill up the buffer for the first request. */ FillAudio( &mainplay, pIOA_1); /* Is there enough data to double-buffer ? */ if(!mainplay.sample_done || !otherplay.sample_done) { /* OK, enough data to double-buffer; fill up 2nd request */ FillAudio( &mainplay, pIOA_2 ); BeginIO((struct IORequest *) pIOA_1 ); BeginIO((struct IORequest *) pIOA_2 ); /* Initial state of double-buffering variables */ aswitch=0; pIOA=pIOA_2; mport=mport1; /*---------------------*/ /* M A I N L O O P */ /*---------------------*/ while(!mainplay.sample_done || !otherplay.sample_done) { wakemask=Wait( (1 mp_SigBit) | SIGBREAKF_CTRL_C ); if( wakemask & SIGBREAKF_CTRL_C ) { otherplay.sample_done = 1; mainplay.sample_done = 1; } while((msg=GetMsg(mport))==NULL){} /* Toggle double-buffering variables */ if (aswitch) {aswitch=0;pIOA=pIOA_2;mport=mport1;} else {aswitch=1;pIOA=pIOA_1;mport=mport2;} FillAudio( &mainplay, pIOA ); BeginIO((struct IORequest *) pIOA ); } wakemask=Wait( 1 mp_SigBit ); while((msg=GetMsg(mport))==NULL){} if (aswitch) {aswitch=0;pIOA=pIOA_2;mport=mport1;} else {aswitch=1;pIOA=pIOA_1;mport=mport2;} wakemask=Wait( 1 mp_SigBit ); while((msg=GetMsg(mport))==NULL){} } else { /* Only enough data to fill up one buffer */ BeginIO((struct IORequest *) pIOA_1 ); wakemask=Wait( 1 mp_SigBit ); while((msg=GetMsg(mport1))==NULL){} } } else /* One or the other of the files had a problem in Parse8svx() */ printf(errormsg); /* Free the memory used for the 8SVX files in Parse8svx() */ if(mainplay.next_iplay) EndParse( &otherplay ); EndParse( &mainplay ); } else printf("Couldn't get memory for a second IOAudio and MsgPort\n"); /* Free the ports and memory used by the 2 IOAudio requests */ if(mport2) DeletePort(mport2); if(pIOA_2) FreeMem( pIOA_2, sizeof(struct IOAudio) ); ReleaseChannel(pIOA_1); } else printf("Couldn't get a channel on the audio device\n"); } else printf("Enter one or two 8SVX filenames.\n"); } /*---------------------------------------------------------------------- ** struct IOAudio *res = SiezeChannel( VOID ) ** ** Allocates any channel at the highest priority. Once allocated, ** the hardware registers of the given channel can be hit directly ** without interfering with normal audio.device operation. ** ** Retruns NULL on failure ** or returns the address of the IOAudio used to get the channel. ** If the call to this function succeeds, ReleaseChannel() should ** be called later to free the channel and memory used for the IOAudio. **----------------------------------------------------------------------- */ struct IOAudio * SiezeChannel( VOID ) { struct IOAudio *myAIOreq=NULL; struct MsgPort *myAIOreply=NULL; UBYTE chans[] = {1,2,4,8}; /* Try to get one channel, any channel */ BYTE dev = -1; myAIOreq=(struct IOAudio *)AllocMem(sizeof(struct IOAudio),MEMF_PUBLIC ); if(myAIOreq) { myAIOreply=CreatePort(0,0); if(myAIOreply) { myAIOreq->ioa_Request.io_Message.mn_ReplyPort = myAIOreply; myAIOreq->ioa_Request.io_Message.mn_Node.ln_Pri = 127; myAIOreq->ioa_Request.io_Command = ADCMD_ALLOCATE; myAIOreq->ioa_AllocKey = 0; myAIOreq->ioa_Data = chans; myAIOreq->ioa_Length = sizeof(chans); dev=OpenDevice("audio.device",0L,(struct IORequest *)myAIOreq,0L); if(! dev) return( myAIOreq ); /* Successful exit */ DeletePort( myAIOreply ); } FreeMem( myAIOreq, sizeof(struct IOAudio) ); } return( NULL ); } /*--------------------------------------------------------------- ** VOID ReleaseChannel(struct IOAudio *rel ); ** ** Frees the channel and any asociated memory allocated earlier ** with SiezeChannel(). **--------------------------------------------------------------- */ VOID ReleaseChannel(struct IOAudio *rel) { if(rel) { CloseDevice( (struct IORequest *) rel ); if(rel->ioa_Request.io_Message.mn_ReplyPort) { DeletePort(rel->ioa_Request.io_Message.mn_ReplyPort); } FreeMem( rel, sizeof(struct IOAudio) ); } } /*-------------------------------------------------------------------- ** ** char *Parse8svx( char *filename, struct InterPlay *play_state) ** ** Pass this function the name of an 8svx file. It opens the file and ** finds the VHDR and BODY Chunks. Playback information is stored ** in the InterPlay structure. ** ** A NULL return indicates the parse was completely successful. ** A non-NULL return means the file cannot be played back for ** some reason. In that case the return value is a pointer to ** an error message explaining what went wrong. ** ** After calling Parse8svx(), End Parse() should be called ** to free any memory used. ** **---------------------------------------------------------------------- */ char * Parse8svx(char *fname, struct InterPlay *play) { BYTE iobuffer[12]; LONG rdcount=0L; Chunk *pChunk=NULL; GroupHeader *pGH=NULL; Voice8Header *pV8Head = NULL; char *error = NULL; BPTR filehandle=NULL; BOOL NO_BODY = TRUE; BOOL NO_VHDR = TRUE; /* Under normal operation, this function leaves the file positioned */ /* at the BODY Chunk. However, for some degenerate 8SVX files, one */ /* additional seek is needed at the end. In that case this field */ /* (play->offsetBody) will be changed to the seek offset. */ play->offsetBody = 0; play->sample_loc = NULL; /* Set to non-NULL if memory is allocated */ play->next_iplay = NULL; /* Default is no successors, no interleave */ play->sample_done= 0L; /* Will be set to 1 when playback is done */ filehandle= NULL; /* Set to non-NULL if the file opens */ NO_BODY=TRUE; NO_VHDR=TRUE; /* This section just makes sure that the first 12 bytes of the */ /* file conform to the IFF FORM specification, sub-type 8SVX. */ filehandle = Open( fname, MODE_OLDFILE ); if(filehandle) { /* Next, read the first 12 bytes to check the type */ rdcount =Read( filehandle, iobuffer, 12L ); if(rdcount==12L) { /* Make sure it is an IFF FORM type */ pGH = (GroupHeader *)iobuffer; if(pGH->ckID == FORM) { /* Make sure it is an 8SVX sub-type */ if(pGH->grpSubID != ID_8SVX) error="Not an 8SVX file\n"; } else error="Not an IFF FORM\n"; } else error="Read error or file too short1\n"; } else error="Couldn't open that file. Try another.\n"; /* Read through all Chunks until BODY and VHDR */ /* Chunks are found or until an error occurs. */ while( !error && (NO_BODY || NO_VHDR) ) { /* Read the first 8 bytes of the Chunk to get the type and size */ rdcount =Read( filehandle, iobuffer, 8L ); if(rdcount==8L) { pChunk=(Chunk *)iobuffer; switch(pChunk->ckID) { case ID_VHDR: /* AllocMem() ckSize rounded up and read */ /* the VHDR, filling in the InterPlay */ if(pChunk->ckSize & 1L) pChunk->ckSize++; pV8Head = AllocMem(pChunk->ckSize, MEMF_PUBLIC); if(pV8Head) { rdcount=Read(filehandle,pV8Head,pChunk->ckSize); if(rdcount==pChunk->ckSize ) { if(pV8Head->sCompression==sCmpNone) { /* Set the playback speed */ play->sample_speed = (UWORD) (3579545L / pV8Head->samplesPerSec); /* Set up start, end of sample data */ play->sample_size = pV8Head->oneShotHiSamples + pV8Head->repeatHiSamples; } else error="Can't read compressed file\n"; } else error="Read problem in header\n"; FreeMem(pV8Head, pChunk->ckSize ); } else error="Couldn't get header memory\n"; NO_VHDR = FALSE; break; case ID_BODY: /* Technically, a VHDR could come after a BODY.*/ /* This is a pretty unlikely occurence though. */ if(NO_VHDR) { if(pChunk->ckSize & 1L) pChunk->ckSize++; rdcount = Seek(filehandle, pChunk->ckSize, OFFSET_CURRENT); if(rdcount==-1) error="Problem during BODY-skipping seek\n"; else play->offsetBody=rdcount; } NO_BODY = FALSE; break; default: /* Ignore other Chunks, skipping over them */ if(pChunk->ckSize & 1L) pChunk->ckSize++; rdcount = Seek(filehandle, pChunk->ckSize, OFFSET_CURRENT); if(rdcount==-1) error="Problem during chunk-skipping seek\n"; break; } } else error = "Read error or file too short2\n"; } if(!error) { /* In case the VHDR came after the BODY, seek back to the BODY */ if(play->offsetBody) { rdcount = Seek(filehandle, play->offsetBody, OFFSET_BEGINNING); if(rdcount==-1) error="Couldn't seek to BODY\n"; } /* OK now get the BODY data into a memory block */ play->sample_loc = AllocMem( play->sample_size, MEMF_PUBLIC ); if(play->sample_loc) { rdcount = Read(filehandle, play->sample_loc, play->sample_size); if(rdcount!=play->sample_size) error = "Error during BODY read\n"; else play->sample_byte=play->sample_loc; } else error="Couldn't get memory for BODY Chunk\n"; } if(filehandle) Close(filehandle); return(error); } /*--------------------------------------------------------------- ** ** VOID EndParse( struct InterPlay * ); ** ** This function simply frees any memory used by an earlier ** call to Parse8svx(). ** **--------------------------------------------------------------- */ VOID EndParse( struct InterPlay *play ) { if(play->sample_loc) FreeMem(play->sample_loc, play->sample_size ); } /*----------------------------------------------------------------------------- ** ** VOID FillAudio(struct InterPlay *, struct IOAudio * ); ** ** This function gets 512 bytes each from 2 BODY buffers and interleaves ** the bytes in the audio playback buffer. **------------------------------------------------------------------------------ */ VOID FillAudio(struct InterPlay *inplay, struct IOAudio *ioa ) { struct InterPlay *play1,*play2; ULONG remainder1,remainder2,x; UWORD speedfac; WORD value; if(ioa->ioa_Request.io_Command != CMD_WRITE) /* For 1st time callers only */ { /* When two files are played at once, their speeds must match. Use */ /* whichever speed is fastest. Interleaved requests also require the */ /* speed to be doubled (period is halved). However, the period */ /* cannot be lower than 124 or audio DMA bandwidth will be exceeded. */ speedfac = inplay->sample_speed; if(inplay->next_iplay) { if(inplay->next_iplay->sample_speed sample_speed) speedfac = inplay->next_iplay->sample_speed; if ( !(inplay->USE_SUMMING) ) speedfac /= 2; } if(speedfac ioa_Request.io_Command = CMD_WRITE; ioa->ioa_Request.io_Flags = ADIOF_PERVOL; ioa->ioa_Volume = 63; ioa->ioa_Period = speedfac; ioa->ioa_Length = BUF_SIZE; ioa->ioa_Cycles = 1; } if(inplay->next_iplay) { play1=inplay; play2=inplay->next_iplay; remainder1 = play1->sample_size - (play1->sample_byte - play1->sample_loc); remainder2 = play2->sample_size - (play2->sample_byte - play2->sample_loc); if(play1->USE_SUMMING) { /* ** AVERAGING LOGIC for playing TWO samples on ONE channel */ for(x=0; x sample_byte) ); play1->sample_byte++; } else if( x==remainder1 ) play1->sample_done=1; if( x sample_byte) ); play2->sample_byte++; } else if( x==remainder2 ) play2->sample_done=1; *(ioa->ioa_Data + x) = (UBYTE) (value/2); } } else { /* ** INTERLEAVE LOGIC for playing TWO samples on ONE channel */ /* If there are more bytes in the 1st sample data file, place them in */ /* the EVEN positions in the playback buffer of this IOAudio request. */ for(x=0; (x ioa_Data + x) = *(play1->sample_byte); play1->sample_byte++; } /* If there are no more bytes then mark the 1st sample as done */ if(x sample_done=1L; while(x ioa_Data + x) = 0; x+=2; } /* If there are more bytes in the 2nd sample data file, place them in */ /* the ODD positions in the playback buffer of this IOAudio request. */ for(x=1; (x ioa_Data + x) = *(play2->sample_byte); play2->sample_byte++; } /* If there are no more bytes then mark the 2nd sample as done */ if(x sample_done=1L; while(x ioa_Data + x) = 0; x+=2; } } } else { /* ** REGULAR LOGIC for playing a single sample on a single channel. */ remainder1= inplay->sample_size - (inplay->sample_byte-inplay->sample_loc); if(remainder1 > BUF_SIZE) { CopyMem(inplay->sample_byte,ioa->ioa_Data,BUF_SIZE); inplay->sample_byte+=BUF_SIZE; } else { CopyMem(inplay->sample_byte,ioa->ioa_Data,remainder1); ioa->ioa_Length=remainder1; inplay->sample_done=1L; } } } [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node065C.html.txt:1:include/hardware/intbits.h ]" border=0> #ifndef HARDWARE_INTBITS_H #define HARDWARE_INTBITS_H /* ** $VER: intbits.h 39.1 (18.9.1992) ** Includes Release 44.1 ** ** bits in the interrupt enable (and interrupt request) register ** ** (C) Copyright 1985-1999 Amiga, Inc. ** All Rights Reserved */ #define INTB_SETCLR (15) /* Set/Clear control bit. Determines if bits */ /* written with a 1 get set or cleared. Bits */ /* written with a zero are allways unchanged */ #define INTB_INTEN (14) /* Master interrupt (enable only ) */ #define INTB_EXTER (13) /* External interrupt */ #define INTB_DSKSYNC (12) /* Disk re-SYNChronized */ #define INTB_RBF (11) /* serial port Receive Buffer Full */ #define INTB_AUD3 (10) /* Audio channel 3 block finished */ #define INTB_AUD2 (9) /* Audio channel 2 block finished */ #define INTB_AUD1 (8) /* Audio channel 1 block finished */ #define INTB_AUD0 (7) /* Audio channel 0 block finished */ #define INTB_BLIT (6) /* Blitter finished */ #define INTB_VERTB (5) /* start of Vertical Blank */ #define INTB_COPER (4) /* Coprocessor */ #define INTB_PORTS (3) /* I/O Ports and timers */ #define INTB_SOFTINT (2) /* software interrupt request */ #define INTB_DSKBLK (1) /* Disk Block done */ #define INTB_TBE (0) /* serial port Transmit Buffer Empty */ #define INTF_SETCLR (1L [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node05F7.html.txt:1:include/datatypes/datatypes.h ]" border=0> #ifndef DATATYPES_DATATYPES_H #define DATATYPES_DATATYPES_H /* ** $VER: datatypes.h 39.6 (22.4.1993) ** Includes Release 44.1 ** ** Copyright © 1991-1999 Amiga, Inc. ** All Rights Reserved */ /*****************************************************************************/ #ifndef EXEC_TYPES_H #include #endif #ifndef EXEC_LISTS_H #include #endif #ifndef EXEC_NODES_H #include #endif #ifndef EXEC_LIBRARIES_H #include #endif #ifndef LIBRARIES_IFFPARSE_H #include #endif #ifndef DOS_DOS_H #include #endif /*****************************************************************************/ #define ID_DTYP MAKE_ID('D','T','Y','P') /*****************************************************************************/ #define ID_DTHD MAKE_ID('D','T','H','D') struct DataTypeHeader { STRPTR dth_Name; /* Descriptive name of the data type */ STRPTR dth_BaseName; /* Base name of the data type */ STRPTR dth_Pattern; /* Match pattern for file name. */ WORD *dth_Mask; /* Comparision mask */ ULONG dth_GroupID; /* Group that the DataType is in */ ULONG dth_ID; /* ID for DataType (same as IFF FORM type) */ WORD dth_MaskLen; /* Length of comparision mask */ WORD dth_Pad; /* Unused at present (must be 0) */ UWORD dth_Flags; /* Flags */ UWORD dth_Priority; /* Priority */ }; #define DTHSIZE sizeof(struct DataTypeHeader) /*****************************************************************************/ /* Basic type */ #define DTF_TYPE_MASK 0x000F #define DTF_BINARY 0x0000 #define DTF_ASCII 0x0001 #define DTF_IFF 0x0002 #define DTF_MISC 0x0003 /* Set if case is important */ #define DTF_CASE 0x0010 /* Reserved for system use */ #define DTF_SYSTEM1 0x1000 /***************************************************************************** * * GROUP ID and ID * * This is used for filtering out objects that you don't want. For * example, you could make a filter for the ASL file requester so * that it only showed the files that were pictures, or even to * narrow it down to only show files that were ILBM pictures. * * Note that the Group ID's are in lower case, and always the first * four characters of the word. * * For ID's; If it is an IFF file, then the ID is the same as the * FORM type. If it isn't an IFF file, then the ID would be the * first four characters of name for the file type. * *****************************************************************************/ /* System file, such as; directory, executable, library, device, font, etc. */ #define GID_SYSTEM MAKE_ID ('s','y','s','t') /* Formatted or unformatted text */ #define GID_TEXT MAKE_ID ('t','e','x','t') /* Formatted text with graphics or other DataTypes */ #define GID_DOCUMENT MAKE_ID ('d','o','c','u') /* Sound */ #define GID_SOUND MAKE_ID ('s','o','u','n') /* Musical instruments used for musical scores */ #define GID_INSTRUMENT MAKE_ID ('i','n','s','t') /* Musical score */ #define GID_MUSIC MAKE_ID ('m','u','s','i') /* Still picture */ #define GID_PICTURE MAKE_ID ('p','i','c','t') /* Animated picture */ #define GID_ANIMATION MAKE_ID ('a','n','i','m') /* Animation with audio track */ #define GID_MOVIE MAKE_ID ('m','o','v','i') /*****************************************************************************/ /* A code chunk contains an embedded executable that can be loaded * with InternalLoadSeg. */ #define ID_CODE MAKE_ID('D','T','C','D') /* DataTypes comparision hook context (Read-Only). This is the * argument that is passed to a custom comparision routine. */ struct DTHookContext { /* Libraries that are already opened for your use */ struct Library *dthc_SysBase; struct Library *dthc_DOSBase; struct Library *dthc_IFFParseBase; struct Library *dthc_UtilityBase; /* File context */ BPTR dthc_Lock; /* Lock on the file */ struct FileInfoBlock *dthc_FIB; /* Pointer to a FileInfoBlock */ BPTR dthc_FileHandle; /* Pointer to the file handle (may be NULL) */ struct IFFHandle *dthc_IFF; /* Pointer to an IFFHandle (may be NULL) */ STRPTR dthc_Buffer; /* Buffer */ ULONG dthc_BufferLength; /* Length of the buffer */ }; /*****************************************************************************/ #define ID_TOOL MAKE_ID('D','T','T','L') struct Tool { UWORD tn_Which; /* Which tool is this */ UWORD tn_Flags; /* Flags */ STRPTR tn_Program; /* Application to use */ }; #define TSIZE sizeof(struct Tool) /* defines for tn_Which */ #define TW_INFO 1 #define TW_BROWSE 2 #define TW_EDIT 3 #define TW_PRINT 4 #define TW_MAIL 5 /* defines for tn_Flags */ #define TF_LAUNCH_MASK 0x000F #define TF_SHELL 0x0001 #define TF_WORKBENCH 0x0002 #define TF_RX 0x0003 /*****************************************************************************/ #define ID_TAGS MAKE_ID('D','T','T','G') /*****************************************************************************/ #ifndef DATATYPE #define DATATYPE struct DataType { struct Node dtn_Node1; /* Reserved for system use */ struct Node dtn_Node2; /* Reserved for system use */ struct DataTypeHeader *dtn_Header; /* Pointer to the DataTypeHeader */ struct List dtn_ToolList; /* List of tool nodes */ STRPTR dtn_FunctionName; /* Name of comparision routine */ struct TagItem *dtn_AttrList; /* Object creation tags */ ULONG dtn_Length; /* Length of the memory block */ }; #endif #define DTNSIZE sizeof(struct DataType) /*****************************************************************************/ struct ToolNode { struct Node tn_Node; /* Embedded node */ struct Tool tn_Tool; /* Embedded tool */ ULONG tn_Length; /* Length of the memory block */ }; #define TNSIZE sizeof(struct ToolNode) /*****************************************************************************/ #ifndef ID_NAME #define ID_NAME MAKE_ID('N','A','M','E') #endif /*****************************************************************************/ /* Text ID's */ #define DTERROR_UNKNOWN_DATATYPE 2000 #define DTERROR_COULDNT_SAVE 2001 #define DTERROR_COULDNT_OPEN 2002 #define DTERROR_COULDNT_SEND_MESSAGE 2003 /* New for V40 */ #define DTERROR_COULDNT_OPEN_CLIPBOARD 2004 #define DTERROR_Reserved 2005 #define DTERROR_UNKNOWN_COMPRESSION 2006 #define DTERROR_NOT_ENOUGH_DATA 2007 #define DTERROR_INVALID_DATA 2008 /* New for V44 */ #define DTERROR_NOT_AVAILABLE 2009 /* Offset for types */ #define DTMSG_TYPE_OFFSET 2100 /*****************************************************************************/ #endif /* DATATYPES_DATATYPES_H */ [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node0012.html.txt:1:Text_Autodocs 2.0 ]" border=0> Link Libraries -------------- amiga_lib.doc ddebug_lib.doc debug_lib.doc Shared Libraries ---------------- asl.doc icon.doc mathieeesingbas.doc commodities.doc iffparse.doc mathieeesingtrans.doc diskfont.doc intuition.doc mathtrans.doc dos.doc keymap.doc rexxsyslib.doc exec.doc layers.doc translator.doc expansion.doc mathffp.doc utility.doc gadtools.doc mathieeedoubbas.doc wb.doc graphics.doc mathieeedoubtrans.doc Devices ------- audio.doc gameport.doc narrator.doc serial.doc clipboard.doc input.doc parallel.doc timer.doc console.doc keyboard.doc printer.doc trackdisk.doc Resources --------- battclock.doc cia.doc filesysres.doc potgo.doc battmem.doc disk.doc misc.doc [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node007C.html.txt:1:Includes/exec/execbase.i ]" border=0> IFND EXEC_EXECBASE_I EXEC_EXECBASE_I SET 1 ** ** $Filename: exec/execbase.i $ ** $Release: 2.04 Includes, V37.4 $ ** $Revision: 36.16 $ ** $Date: 91/10/10 $ ** ** Definition of the exec.library base structure. ** ** (C) Copyright 1985-1999 Amiga, Inc. ** All Rights Reserved ** IFND EXEC_TYPES_I INCLUDE "exec/types.i" ENDC ; EXEC_TYPES_I IFND EXEC_LISTS_I INCLUDE "exec/lists.i" ENDC ; EXEC_LISTS_I IFND EXEC_INTERRUPTS_I INCLUDE "exec/interrupts.i" ENDC ; EXEC_INTERRUPTS_I IFND EXEC_LIBRARIES_I INCLUDE "exec/libraries.i" ENDC ; EXEC_LIBRARIES_I ** Definition of the Exec library base structure (pointed to by location 4). ** Most fields are not to be viewed or modified by user programs. Use ** extreme caution. ** STRUCTURE ExecBase,LIB_SIZE ; Standard library node ******* Static System Variables ********************************************* UWORD SoftVer ; kickstart release number (obs.) WORD LowMemChkSum ; checksum of 68000 trap vectors ULONG ChkBase ; system base pointer complement APTR ColdCapture ; coldstart soft capture vector APTR CoolCapture ; coolstart soft capture vector APTR WarmCapture ; warmstart soft capture vector APTR SysStkUpper ; system stack base (upper bound) APTR SysStkLower ; top of system stack (lower bound) ULONG MaxLocMem ; top of chip memory APTR DebugEntry ; global debugger entry point APTR DebugData ; global debugger data segment APTR AlertData ; alert data segment APTR MaxExtMem ; top of extended mem, or null if none WORD ChkSum ; for all of the above (minus 2) ******* Interrupt Related ******************************************** LABEL IntVects STRUCT IVTBE,IV_SIZE STRUCT IVDSKBLK,IV_SIZE STRUCT IVSOFTINT,IV_SIZE STRUCT IVPORTS,IV_SIZE STRUCT IVCOPER,IV_SIZE STRUCT IVVERTB,IV_SIZE STRUCT IVBLIT,IV_SIZE STRUCT IVAUD0,IV_SIZE STRUCT IVAUD1,IV_SIZE STRUCT IVAUD2,IV_SIZE STRUCT IVAUD3,IV_SIZE STRUCT IVRBF,IV_SIZE STRUCT IVDSKSYNC,IV_SIZE STRUCT IVEXTER,IV_SIZE STRUCT IVINTEN,IV_SIZE STRUCT IVNMI,IV_SIZE ******* Dynamic System Variables ************************************* APTR ThisTask ; pointer to current task (readable) ULONG IdleCount ; idle counter ULONG DispCount ; dispatch counter UWORD Quantum ; time slice quantum UWORD Elapsed ; current quantum ticks UWORD SysFlags ; misc internal system flags BYTE IDNestCnt ; interrupt disable nesting count BYTE TDNestCnt ; task disable nesting count UWORD AttnFlags ; special attention flags (readable) UWORD AttnResched ; rescheduling attention APTR ResModules ; pointer to resident module array APTR TaskTrapCode ; default task trap routine APTR TaskExceptCode ; default task exception code APTR TaskExitCode ; default task exit code ULONG TaskSigAlloc ; preallocated signal mask UWORD TaskTrapAlloc ; preallocated trap mask ******* System List Headers (private!) ******************************** STRUCT MemList,LH_SIZE STRUCT ResourceList,LH_SIZE STRUCT DeviceList,LH_SIZE STRUCT IntrList,LH_SIZE STRUCT LibList,LH_SIZE STRUCT PortList,LH_SIZE STRUCT TaskReady,LH_SIZE STRUCT TaskWait,LH_SIZE STRUCT SoftInts,SH_SIZE*5 ******* Other Globals ****************************************************** STRUCT LastAlert,4*4 ;------ these next two variables are provided to allow ;------ system developers to have a rough idea of the ;------ period of two externally controlled signals -- ;------ the time between vertical blank interrupts and the ;------ external line rate (which is counted by CIA A's ;------ "time of day" clock). In general these values ;------ will be 50 or 60, and may or may not track each ;------ other. These values replace the obsolete AFB_PAL ;------ and AFB_50HZ flags. UBYTE VBlankFrequency ;(readable) UBYTE PowerSupplyFrequency ;(readable) STRUCT SemaphoreList,LH_SIZE ;------ these next two are to be able to kickstart into user ram. ;------ KickMemPtr holds a singly linked list of MemLists which ;------ will be removed from the memory list via AllocAbs. If ;------ all the AllocAbs's succeeded, then the KickTagPtr will ;------ be added to the rom tag list. APTR KickMemPtr ; ptr to queue of mem lists APTR KickTagPtr ; ptr to rom tag queue APTR KickCheckSum ; checksum for mem and tags ******* V36 Exec additions start here *************************************** UWORD ex_Pad0 ULONG ex_LaunchPoint ; Private to Launch/Switch APTR ex_RamLibPrivate ;* The next ULONG contains the system "E" clock frequency, ;* expressed in Hertz. The E clock is used as a timebase for ;* the Amiga's 8520 I/O chips. (E is connected to "02"). ;* Typical values are 715909 for NTSC, or 709379 for PAL. ;* ULONG ex_EClockFrequency ;(readable) ULONG ex_CacheControl ;Private to the CacheControl call ULONG ex_TaskID ;Next available task ID ULONG ex_PuddleSize ULONG ex_PoolThreshold STRUCT ex_PublicPool,MLN_SIZE APTR ex_MMULock ;Private STRUCT ex_Reserved,12 LABEL SYSBASESIZE ******* Bit defines for AttnFlags (see above) ******************************* * Processors and Co-processors: BITDEF AF,68010,0 ; also set for 68020 BITDEF AF,68020,1 ; also set for 68030 BITDEF AF,68030,2 ; also set for 68040 BITDEF AF,68040,3 BITDEF AF,68881,4 ; also set for 68882 BITDEF AF,68882,5 BITDEF AF,FPU40,6 ; Set if 68040 FPU ; ; The AFB_FPU40 bit is set when a working 68040 FPU ; is in the system. If this bit is set and both the ; AFB_68881 and AFB_68882 bits are not set, then the 68040 ; math emulation code has not been loaded and only 68040 ; FPU instructions are available. This bit is valid *ONLY* ; if the AFB_68040 bit is set. ; ; BITDEF AF,RESERVED8,8 ; BITDEF AF,RESERVED9,9 BITDEF AF,PRIVATE,15 ; Just what it says ******* Selected bit definitions for Cache manipulation calls ************** BITDEF CACR,EnableI,0 ;Enable instruction cache BITDEF CACR,FreezeI,1 ;Freeze instruction cache BITDEF CACR,ClearI,3 ;Clear instruction cache BITDEF CACR,IBE,4 ;Instruction burst enable BITDEF CACR,EnableD,8 ;68030 Enable data cache BITDEF CACR,FreezeD,9 ;68030 Freeze data cache BITDEF CACR,ClearD,11 ;68030 Clear data cache BITDEF CACR,DBE,12 ;68030 Data burst enable BITDEF CACR,WriteAllocate,13 ;68030 Write-Allocate mode (must ;always be set) BITDEF CACR,CopyBack,31 ;Master enable for copyback caches BITDEF DMA,Continue,1 ;Continuation flag for CachePreDMA BITDEF DMA,NoModify,2 ;Set if DMA does not update memory ENDC ; EXEC_EXECBASE_I [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node054F.html.txt:1:2.0 Function Index ]" border=0> --background-- (filesysres.resource) --background-- (timer.device) AbleICR() (cia.resource) AbortIO() (audio.device) AbortIO() (exec.library) AbortIO() (narrator.device) AbortIO() (serial.device) AbortIO() (timer.device) AbortPkt() (dos.library) ActivateCxObj() (commodities.library) ActivateGadget() (intuition.library) ActivateWindow() (intuition.library) ADCMD_ALLOCATE (audio.device) ADCMD_FINISH (audio.device) ADCMD_FREE (audio.device) ADCMD_LOCK (audio.device) ADCMD_PERVOL (audio.device) ADCMD_SETPREC (audio.device) ADCMD_WAITCYCLE (audio.device) AddAnimOb() (graphics.library) AddAppIconA() (wb.library) AddAppMenuItemA() (wb.library) AddAppWindowA() (wb.library) AddBob() (graphics.library) AddBootNode() (expansion.library) AddBuffers() (dos.library) AddClass() (intuition.library) AddConfigDev() (expansion.library) AddDevice() (exec.library) AddDosEntry() (dos.library) AddDosNode() (expansion.library) AddFont() (graphics.library) AddFreeList() (icon.library) AddGadget() (intuition.library) AddGList() (intuition.library) AddHead() (exec.library) AddICRVector() (cia.resource) AddIEvents() (commodities.library) AddIntServer() (exec.library) AddLibrary() (exec.library) AddMemList() (exec.library) AddPart() (dos.library) AddPort() (exec.library) AddResource() (exec.library) AddSegment() (dos.library) AddSemaphore() (exec.library) AddTail() (exec.library) AddTask() (exec.library) AddTime() (timer.device) AddTOF() (amiga_lib.library) AddVSprite() (graphics.library) afp() (amiga_lib.library) Alert() (exec.library) AllocAbs() (exec.library) AllocAslRequest() (asl.library) Allocate() (exec.library) AllocateTagItems() (utility.library) AllocConfigDev() (expansion.library) AllocDosObject() (dos.library) AllocEntry() (exec.library) AllocExpansionMem() (expansion.library) AllocFileRequest() (asl.library) AllocIFF() (iffparse.library) AllocLocalItem() (iffparse.library) AllocMem() (exec.library) AllocMiscResource() (misc.resource) AllocPotBits() (potgo.resource) AllocRaster() (graphics.library) AllocRemember() (intuition.library) AllocSignal() (exec.library) AllocTrap() (exec.library) AllocUnit() (disk.resource) AllocVec() (exec.library) Amiga2Date() (utility.library) AndRectRegion() (graphics.library) AndRegionRegion() (graphics.library) Animate() (graphics.library) AreaCircle() (graphics.library) AreaDraw() (graphics.library) AreaEllipse() (graphics.library) AreaEnd() (graphics.library) AreaMove() (graphics.library) ArgArrayDone() (amiga_lib.library) ArgArrayInit() (amiga_lib.library) ArgInt() (amiga_lib.library) ArgString() (amiga_lib.library) arnd() (amiga_lib.library) AskFont() (graphics.library) AskKeyMapDefault() (keymap.library) AskSoftStyle() (graphics.library) AslRequest() (asl.library) AssignAdd() (dos.library) AssignLate() (dos.library) AssignLock() (dos.library) AssignPath() (dos.library) AttachCxObj() (commodities.library) AttemptLockDosList() (dos.library) AttemptLockLayerRom() (graphics.library) AttemptSemaphore() (exec.library) AutoRequest() (intuition.library) AvailFonts() (diskfont.library) AvailMem() (exec.library) BeginIO() (amiga_lib.library) BeginIO() (audio.device) BeginIO() (serial.device) BeginRefresh() (intuition.library) BeginUpdate() (layers.library) BehindLayer() (layers.library) BitMapScale() (graphics.library) BltBitMap() (graphics.library) BltBitMapRastPort() (graphics.library) BltClear() (graphics.library) BltMaskBitMapRastPort() (graphics.library) BltPattern() (graphics.library) BltTemplate() (graphics.library) BuildEasyRequestArgs() (intuition.library) BuildSysRequest() (intuition.library) BumpRevision() (icon.library) CacheClearE() (exec.library) CacheClearU() (exec.library) CacheControl() (exec.library) CachePostDMA() (exec.library) CachePreDMA() (exec.library) CallHook() (amiga_lib.library) CallHookA() (amiga_lib.library) CallHookPkt() (utility.library) Cause() (exec.library) CBD_CHANGEHOOK (clipboard.device) CBD_CURRENTREADID (clipboard.device) CBD_CURRENTWRITEID (clipboard.device) CBD_POST (clipboard.device) CBump() (graphics.library) CDInputHandler() (console.device) CD_ASKDEFAULTKEYMAP (console.device) CD_ASKKEYMAP (console.device) CD_SETDEFAULTKEYMAP (console.device) CD_SETKEYMAP (console.device) CEND (graphics.library) ChangeMode() (dos.library) ChangeSprite() (graphics.library) ChangeWindowBox() (intuition.library) CheckDate() (utility.library) CheckIO() (exec.library) CheckRexxMsg() (amiga_lib.library) CheckSignal() (dos.library) CINIT (graphics.library) ClearCxObjError() (commodities.library) ClearDMRequest() (intuition.library) ClearEOL() (graphics.library) ClearMenuStrip() (intuition.library) ClearPointer() (intuition.library) ClearRectRegion() (graphics.library) ClearRegion() (graphics.library) ClearRexxMsg() (rexxsyslib.library) ClearScreen() (graphics.library) Cli() (dos.library) CliInitNewcli() (dos.library) CliInitRun() (dos.library) ClipBlit() (graphics.library) CloneTagItems() (utility.library) Close() (dos.library) CloseClipboard() (iffparse.library) CloseDevice() (audio.device) CloseDevice() (exec.library) CloseDevice() (narrator.device) CloseDevice() (serial.device) CloseFont() (graphics.library) CloseIFF() (iffparse.library) CloseLibrary() (exec.library) CloseMonitor() (graphics.library) CloseScreen() (intuition.library) CloseWindow() (intuition.library) CloseWorkBench() (intuition.library) CMD_CLEAR (audio.device) CMD_CLEAR (console.device) CMD_CLEAR (keyboard.device) CMD_CLEAR (parallel.device) CMD_CLEAR (serial.device) CMD_CLEAR (trackdisk.device) CMD_FLUSH (audio.device) CMD_FLUSH (narrator.device) CMD_FLUSH (parallel.device) CMD_FLUSH (printer.device) CMD_FLUSH (serial.device) CMD_INVALID (printer.device) CMD_READ (audio.device) CMD_READ (clipboard.device) CMD_READ (console.device) CMD_READ (narrator.device) CMD_READ (parallel.device) CMD_READ (serial.device) CMD_READ (trackdisk.device) CMD_RESET (audio.device) CMD_RESET (narrator.device) CMD_RESET (parallel.device) CMD_RESET (printer.device) CMD_RESET (serial.device) CMD_START (audio.device) CMD_START (narrator.device) CMD_START (parallel.device) CMD_START (printer.device) CMD_START (serial.device) CMD_STOP (audio.device) CMD_STOP (narrator.device) CMD_STOP (parallel.device) CMD_STOP (printer.device) CMD_STOP (serial.device) CMD_UPDATE (audio.device) CMD_UPDATE (clipboard.device) CMD_UPDATE (trackdisk.device) CMD_WRITE (audio.device) CMD_WRITE (clipboard.device) CMD_WRITE (console.device) CMD_WRITE (narrator.device) CMD_WRITE (parallel.device) CMD_WRITE (printer.device) CMD_WRITE (serial.device) CMD_WRITE (trackdisk.device) CMOVE (graphics.library) CmpTime() (timer.device) CoerceMethod() (amiga_lib.library) CoerceMethodA() (amiga_lib.library) ColdReboot() (exec.library) CollectionChunk() (iffparse.library) CollectionChunks() (iffparse.library) CompareDates() (dos.library) ConfigBoard() (expansion.library) CopyMem() (exec.library) CopyMemQuick() (exec.library) CopySBitMap() (graphics.library) CreateArgstring() (rexxsyslib.library) CreateBehindHookLayer() (layers.library) CreateBehindLayer() (layers.library) CreateContext() (gadtools.library) CreateCxObj() (commodities.library) CreateDir() (dos.library) CreateExtIO() (amiga_lib.library) CreateGadgetA() (gadtools.library) CreateIORequest() (exec.library) CreateMenusA() (gadtools.library) CreateMsgPort() (exec.library) CreateNewProc() (dos.library) CreatePort() (amiga_lib.library) CreateProc() (dos.library) CreateRexxMsg() (rexxsyslib.library) CreateStdIO() (amiga_lib.library) CreateTask() (amiga_lib.library) CreateUpfrontHookLayer() (layers.library) CreateUpfrontLayer() (layers.library) CurrentChunk() (iffparse.library) CurrentDir() (dos.library) CurrentTime() (intuition.library) CWAIT (graphics.library) CxBroker() (commodities.library) CxCustom() (amiga_lib.library) CxDebug() (amiga_lib.library) CxFilter() (amiga_lib.library) CxMsgData() (commodities.library) CxMsgID() (commodities.library) CxMsgType() (commodities.library) CxObjError() (commodities.library) CxObjType() (commodities.library) CxSender() (amiga_lib.library) CxSignal() (amiga_lib.library) CxTranslate() (amiga_lib.library) Date2Amiga() (utility.library) DateStamp() (dos.library) DateToStr() (dos.library) dbf() (amiga_lib.library) DDoFmt() (ddebug_lib.library) Deallocate() (exec.library) Debug() (exec.library) Delay() (dos.library) DeleteArgstring() (rexxsyslib.library) DeleteCxObj() (commodities.library) DeleteCxObjAll() (commodities.library) DeleteDiskObject() (icon.library) DeleteExtIO() (amiga_lib.library) DeleteFile() (dos.library) DeleteIORequest() (exec.library) DeleteLayer() (layers.library) DeleteMsgPort() (exec.library) DeletePort() (amiga_lib.library) DeleteRexxMsg() (rexxsyslib.library) DeleteStdIO() (amiga_lib.library) DeleteTask() (amiga_lib.library) DeleteVar() (dos.library) DeviceProc() (dos.library) DGetChar() (ddebug_lib.library) DGetNum() (ddebug_lib.library) Disable() (exec.library) DisownBlitter() (graphics.library) DisplayAlert() (intuition.library) DisplayBeep() (intuition.library) DisposeCxMsg() (commodities.library) DisposeFontContents() (diskfont.library) DisposeLayerInfo() (layers.library) DisposeObject() (intuition.library) DisposeRegion() (graphics.library) DivertCxMsg() (commodities.library) DMayGetChar() (ddebug_lib.library) DoCollision() (graphics.library) DoIO() (exec.library) DoMethod() (amiga_lib.library) DoMethodA() (amiga_lib.library) DoPkt() (dos.library) DoSuperMethod() (amiga_lib.library) DoSuperMethodA() (amiga_lib.library) DoubleClick() (intuition.library) DPutChar() (ddebug_lib.library) DPutFmt() (ddebug_lib.library) DPutStr() (ddebug_lib.library) Draw() (graphics.library) DrawBevelBoxA() (gadtools.library) DrawBorder() (intuition.library) DrawEllipse() (graphics.library) DrawGList() (graphics.library) DrawImage() (intuition.library) DrawImageState() (intuition.library) DupLock() (dos.library) DupLockFromFH() (dos.library) EasyRequestArgs() (intuition.library) Enable() (exec.library) EndNotify() (dos.library) EndRefresh() (intuition.library) EndRequest() (intuition.library) EndUpdate() (layers.library) Enqueue() (exec.library) EnqueueCxObj() (commodities.library) EntryHandler() (iffparse.library) EraseImage() (intuition.library) EraseRect() (graphics.library) ErrorReport() (dos.library) ExAll() (dos.library) Examine() (dos.library) ExamineFH() (dos.library) Execute() (dos.library) Exit() (dos.library) ExitHandler() (iffparse.library) ExNext() (dos.library) Expunge() (audio.device) ExtendFont() (graphics.library) FastRand() (amiga_lib.library) FattenLayerInfo() (layers.library) Fault() (dos.library) FGetC() (dos.library) FGets() (dos.library) FilePart() (dos.library) FillRexxMsg() (rexxsyslib.library) FilterTagChanges() (utility.library) FilterTagItems() (utility.library) FindArg() (dos.library) FindCliProc() (dos.library) FindCollection() (iffparse.library) FindConfigDev() (expansion.library) FindDisplayInfo() (graphics.library) FindDosEntry() (dos.library) FindLocalItem() (iffparse.library) FindName() (exec.library) FindPort() (exec.library) FindProp() (iffparse.library) FindPropContext() (iffparse.library) FindResident() (exec.library) FindSegment() (dos.library) FindSemaphore() (exec.library) FindTagItem() (utility.library) FindTask() (exec.library) FindToolType() (icon.library) FindVar() (dos.library) Flood() (graphics.library) Flush() (dos.library) FontExtent() (graphics.library) Forbid() (exec.library) Format() (dos.library) fpa() (amiga_lib.library) FPutC() (dos.library) FPuts() (dos.library) FRead() (dos.library) FreeArgs() (dos.library) FreeAslRequest() (asl.library) FreeClass() (intuition.library) FreeColorMap() (graphics.library) FreeConfigDev() (expansion.library) FreeCopList() (graphics.library) FreeCprList() (graphics.library) FreeDeviceProc() (dos.library) FreeDiskObject() (icon.library) FreeDosEntry() (dos.library) FreeDosObject() (dos.library) FreeEntry() (exec.library) FreeExpansionMem() (expansion.library) FreeFileRequest() (asl.library) FreeFreeList() (icon.library) FreeGadgets() (gadtools.library) FreeGBuffers() (graphics.library) FreeIEvents() (amiga_lib.library) FreeIFF() (iffparse.library) FreeLocalItem() (iffparse.library) FreeMem() (exec.library) FreeMenus() (gadtools.library) FreeMiscResource() (misc.resource) FreePotBits() (potgo.resource) FreeRaster() (graphics.library) FreeRemember() (intuition.library) FreeScreenDrawInfo() (intuition.library) FreeSignal() (exec.library) FreeSprite() (graphics.library) FreeSysRequest() (intuition.library) FreeTagItems() (utility.library) FreeTrap() (exec.library) FreeUnit() (disk.resource) FreeVec() (exec.library) FreeVisualInfo() (gadtools.library) FreeVPortCopLists() (graphics.library) FWrite() (dos.library) GadgetMouse() (intuition.library) GetArgStr() (dos.library) GetAttr() (intuition.library) GetCC() (exec.library) GetColorMap() (graphics.library) GetConsoleTask() (dos.library) GetCurrentBinding() (expansion.library) GetCurrentDirName() (dos.library) GetDefaultPubScreen() (intuition.library) GetDefDiskObject() (icon.library) GetDefPrefs() (intuition.library) GetDeviceProc() (dos.library) GetDiskObject() (icon.library) GetDiskObjectNew() (icon.library) GetDisplayInfoData() (graphics.library) GetFileSysTask() (dos.library) GetGBuffers() (graphics.library) GetMsg() (exec.library) GetPrefs() (intuition.library) GetProgramDir() (dos.library) GetProgramName() (dos.library) GetPrompt() (dos.library) GetRexxVar() (amiga_lib.library) GetRGB4() (graphics.library) GetScreenData() (intuition.library) GetScreenDrawInfo() (intuition.library) GetSprite() (graphics.library) GetSysTime() (timer.device) GetTagData() (utility.library) GetUnit() (disk.resource) GetUnitID() (disk.resource) GetVar() (dos.library) GetVisualInfoA() (gadtools.library) GetVPModeID() (graphics.library) GfxAssociate() (graphics.library) GfxFree() (graphics.library) GfxLookUP() (graphics.library) GfxNew() (graphics.library) GiveUnit() (disk.resource) GoodID() (iffparse.library) GoodType() (iffparse.library) GPD_ASKCTYPE (gameport.device) GPD_ASKTRIGGER (gameport.device) GPD_READEVENT (gameport.device) GPD_SETCTYPE (gameport.device) GPD_SETTRIGGER (gameport.device) GT_BeginRefresh() (gadtools.library) GT_EndRefresh() (gadtools.library) GT_FilterIMsg() (gadtools.library) GT_GetIMsg() (gadtools.library) GT_PostFilterIMsg() (gadtools.library) GT_RefreshWindow() (gadtools.library) GT_ReplyIMsg() (gadtools.library) GT_SetGadgetAttrsA() (gadtools.library) HookEntry() (amiga_lib.library) HookEntry() (iffparse.library) HotKey() (amiga_lib.library) IDtoStr() (iffparse.library) IEEEDPAbs() (mathieeedoubbas.library) IEEEDPAcos() (mathieeedoubtrans.library) IEEEDPAdd() (mathieeedoubbas.library) IEEEDPAsin() (mathieeedoubtrans.library) IEEEDPAtan() (mathieeedoubtrans.library) IEEEDPCeil() (mathieeedoubbas.library) IEEEDPCmp() (mathieeedoubbas.library) IEEEDPCos() (mathieeedoubtrans.library) IEEEDPCosh() (mathieeedoubtrans.library) IEEEDPDiv() (mathieeedoubbas.library) IEEEDPExp() (mathieeedoubtrans.library) IEEEDPFieee() (mathieeedoubtrans.library) IEEEDPFix() (mathieeedoubbas.library) IEEEDPFloor() (mathieeedoubbas.library) IEEEDPFlt() (mathieeedoubbas.library) IEEEDPLog() (mathieeedoubtrans.library) IEEEDPLog10() (mathieeedoubtrans.library) IEEEDPMul() (mathieeedoubbas.library) IEEEDPNeg() (mathieeedoubbas.library) IEEEDPPow() (mathieeedoubtrans.library) IEEEDPSin() (mathieeedoubtrans.library) IEEEDPSincos() (mathieeedoubtrans.library) IEEEDPSinh() (mathieeedoubtrans.library) IEEEDPSqrt() (mathieeedoubtrans.library) IEEEDPSub() (mathieeedoubbas.library) IEEEDPTan() (mathieeedoubtrans.library) IEEEDPTanh() (mathieeedoubtrans.library) IEEEDPTieee() (mathieeedoubtrans.library) IEEEDPTst() (mathieeedoubbas.library) IEEESPAbs() (mathieeesingbas.library) IEEESPAcos() (mathieeesingtrans.library) IEEESPAdd() (mathieeesingbas.library) IEEESPAsin() (mathieeesingtrans.library) IEEESPAtan() (mathieeesingtrans.library) IEEESPCeil() (mathieeesingbas.library) IEEESPCmp() (mathieeesingbas.library) IEEESPCos() (mathieeesingtrans.library) IEEESPCosh() (mathieeesingtrans.library) IEEESPDiv() (mathieeesingbas.library) IEEESPExp() (mathieeesingtrans.library) IEEESPFieee() (mathieeesingtrans.library) IEEESPFix() (mathieeesingbas.library) IEEESPFloor() (mathieeesingbas.library) IEEESPFlt() (mathieeesingbas.library) IEEESPLog() (mathieeesingtrans.library) IEEESPLog10() (mathieeesingtrans.library) IEEESPMul() (mathieeesingbas.library) IEEESPNeg() (mathieeesingbas.library) IEEESPPow() (mathieeesingtrans.library) IEEESPSin() (mathieeesingtrans.library) IEEESPSincos() (mathieeesingtrans.library) IEEESPSinh() (mathieeesingtrans.library) IEEESPSqrt() (mathieeesingtrans.library) IEEESPSub() (mathieeesingbas.library) IEEESPTan() (mathieeesingtrans.library) IEEESPTanh() (mathieeesingtrans.library) IEEESPTieee() (mathieeesingtrans.library) IEEESPTst() (mathieeesingbas.library) IND_ADDHANDLER (input.device) IND_REMHANDLER (input.device) IND_SETMPORT (input.device) IND_SETMTRIG (input.device) IND_SETMTYPE (input.device) IND_SETPERIOD (input.device) IND_SETTHRESH (input.device) IND_WRITEEVENT (input.device) Info() (dos.library) Inhibit() (dos.library) InitArea() (graphics.library) InitBitMap() (graphics.library) InitCode() (exec.library) InitGels() (graphics.library) InitGMasks() (graphics.library) InitIFF() (iffparse.library) InitIFFasClip() (iffparse.library) InitIFFasDOS() (iffparse.library) InitLayers() (layers.library) InitMasks() (graphics.library) InitRastPort() (graphics.library) InitRequester() (intuition.library) InitResident() (exec.library) InitSemaphore() (exec.library) InitStruct() (exec.library) InitTmpRas() (graphics.library) InitView() (graphics.library) InitVPort() (graphics.library) Input() (dos.library) Insert() (exec.library) InsertCxObj() (commodities.library) InstallClipRegion() (layers.library) InstallLayerHook() (layers.library) InternalLoadSeg() (dos.library) InternalUnLoadSeg() (dos.library) IntuiTextLength() (intuition.library) InvertKeyMap() (commodities.library) InvertString() (amiga_lib.library) IoErr() (dos.library) IsFileSystem() (dos.library) IsInteractive() (dos.library) IsRexxMsg() (rexxsyslib.library) ItemAddress() (intuition.library) KBD_ADDRESETHANDLER (keyboard.device) KBD_READEVENT (keyboard.device) KBD_READMATRIX (keyboard.device) KBD_REMRESETHANDLER (keyboard.device) KBD_RESETHANDLERDONE (keyboard.device) KCmpStr() (ddebug_lib.library) KCmpStr() (debug_lib.library) KGetChar() (debug_lib.library) KGetNum() (debug_lib.library) KMayGetChar() (debug_lib.library) KPrintF() (debug_lib.library) KPutChar() (debug_lib.library) KPutStr() (debug_lib.library) LayoutMenuItemsA() (gadtools.library) LayoutMenusA() (gadtools.library) LengthArgstring() (rexxsyslib.library) LoadRGB4() (graphics.library) LoadSeg() (dos.library) LoadView() (graphics.library) LocalItemData() (iffparse.library) Lock() (dos.library) LockDosList() (dos.library) LockIBase() (intuition.library) LockLayer() (layers.library) LockLayerInfo() (layers.library) LockLayerRom() (graphics.library) LockLayers() (layers.library) LockPubScreen() (intuition.library) LockPubScreenList() (intuition.library) LockRecord() (dos.library) LockRecords() (dos.library) LockRexxBase() (rexxsyslib.library) MakeClass() (intuition.library) MakeDosEntry() (dos.library) MakeDosNode() (expansion.library) MakeFunctions() (exec.library) MakeLibrary() (exec.library) MakeLink() (dos.library) MakeScreen() (intuition.library) MakeVPort() (graphics.library) MapANSI() (keymap.library) MapRawKey() (keymap.library) MapTags() (utility.library) MatchEnd() (dos.library) MatchFirst() (dos.library) MatchNext() (dos.library) MatchPattern() (dos.library) MatchPatternNoCase() (dos.library) MatchToolValue() (icon.library) MaxCli() (dos.library) ModeNotAvailable() (graphics.library) ModifyIDCMP() (intuition.library) ModifyProp() (intuition.library) Move() (graphics.library) MoveLayer() (layers.library) MoveLayerInFrontOf() (layers.library) MoveScreen() (intuition.library) MoveSizeLayer() (layers.library) MoveSprite() (graphics.library) MoveWindow() (intuition.library) MoveWindowInFrontOf() (intuition.library) MrgCop() (graphics.library) NameFromFH() (dos.library) NameFromLock() (dos.library) NewFontContents() (diskfont.library) NewLayerInfo() (layers.library) NewList() (amiga_lib.library) NewLoadSeg() (dos.library) NewModifyProp() (intuition.library) NewObject() (intuition.library) NewRegion() (graphics.library) NewScaledDiskFont() (diskfont.library) NextDisplayInfo() (graphics.library) NextDosEntry() (dos.library) NextObject() (intuition.library) NextPubScreen() (intuition.library) NextTagItem() (utility.library) ObtainBattSemaphore() (battmem.resource) ObtainConfigBinding() (expansion.library) ObtainGIRPort() (intuition.library) ObtainSemaphore() (exec.library) ObtainSemaphoreList() (exec.library) ObtainSemaphoreShared() (exec.library) OffGadget() (intuition.library) OffMenu() (intuition.library) OldOpenLibrary() (exec.library) OnGadget() (intuition.library) OnMenu() (intuition.library) Open() (dos.library) OpenClipboard() (iffparse.library) OpenDevice() (audio.device) OpenDevice() (console.device) OpenDevice() (exec.library) OpenDevice() (narrator.device) OpenDevice() (parallel.device) OpenDevice() (serial.device) OpenDiskFont() (diskfont.library) OpenFont() (graphics.library) OpenFromLock() (dos.library) OpenIFF() (iffparse.library) OpenLibrary() (exec.library) OpenMonitor() (graphics.library) OpenResource() (exec.library) OpenScreen() (intuition.library) OpenScreenTagList() (intuition.library) OpenWindow() (intuition.library) OpenWindowTagList() (intuition.library) OpenWorkBench() (intuition.library) OrRectRegion() (graphics.library) OrRegionRegion() (graphics.library) Output() (dos.library) OwnBlitter() (graphics.library) PackBoolTags() (utility.library) ParentChunk() (iffparse.library) ParentDir() (dos.library) ParentOfFH() (dos.library) ParseIFF() (iffparse.library) ParseIX() (commodities.library) ParsePattern() (dos.library) ParsePatternNoCase() (dos.library) PathPart() (dos.library) PDCMD_QUERY (parallel.device) PDCMD_SETPARAMS (parallel.device) PeekQualifier() (input.device) Permit() (exec.library) PointInImage() (intuition.library) PolyDraw() (graphics.library) PopChunk() (iffparse.library) PRD_DUMPRPORT (printer.device) PRD_PRTCOMMAND (printer.device) PRD_QUERY (printer.device) PRD_RAWWRITE (printer.device) printf() (amiga_lib.library) PrintFault() (dos.library) PrintIText() (intuition.library) Procure() (exec.library) PropChunk() (iffparse.library) PropChunks() (iffparse.library) PubScreenStatus() (intuition.library) PushChunk() (iffparse.library) PutDefDiskObject() (icon.library) PutDiskObject() (icon.library) PutMsg() (exec.library) PutStr() (dos.library) PWrite() (printer.device) QBlit() (graphics.library) QBSBlit() (graphics.library) QueryOverscan() (intuition.library) RangeRand() (amiga_lib.library) RawDoFmt() (exec.library) RawKeyConvert() (console.device) Read() (dos.library) ReadArgs() (dos.library) ReadBattClock() (battclock.resource) ReadBattMem() (battmem.resource) ReadChunkBytes() (iffparse.library) ReadChunkRecords() (iffparse.library) ReadEClock() (timer.device) ReadExpansionByte() (expansion.library) ReadExpansionRom() (expansion.library) ReadItem() (dos.library) ReadLink() (dos.library) ReadPixel() (graphics.library) ReadPixelArray8() (graphics.library) ReadPixelLine8() (graphics.library) ReadUnitID() (disk.resource) RectFill() (graphics.library) RefreshGadgets() (intuition.library) RefreshGList() (intuition.library) RefreshTagItemClones() (utility.library) RefreshWindowFrame() (intuition.library) Relabel() (dos.library) ReleaseBattSemaphore() (battmem.resource) ReleaseConfigBinding() (expansion.library) ReleaseGIRPort() (intuition.library) ReleaseSemaphore() (exec.library) ReleaseSemaphoreList() (exec.library) RemakeDisplay() (intuition.library) RemAssignList() (dos.library) RemBob() (graphics.library) RemConfigDev() (expansion.library) RemDevice() (exec.library) RemDosEntry() (dos.library) RemFont() (graphics.library) RemHead() (exec.library) RemIBob() (graphics.library) RemICRVector() (cia.resource) RemIntServer() (exec.library) RemLibrary() (exec.library) Remove() (exec.library) RemoveAppIcon() (wb.library) RemoveAppMenuItem() (wb.library) RemoveAppWindow() (wb.library) RemoveClass() (intuition.library) RemoveCxObj() (commodities.library) RemoveGadget() (intuition.library) RemoveGList() (intuition.library) RemPort() (exec.library) RemResource() (exec.library) RemSegment() (dos.library) RemSemaphore() (exec.library) RemTail() (exec.library) RemTask() (exec.library) RemTOF() (amiga_lib.library) RemVSprite() (graphics.library) Rename() (dos.library) ReplyMsg() (exec.library) ReplyPkt() (dos.library) ReportMouse() (intuition.library) Request() (intuition.library) RequestFile() (asl.library) ResetBattClock() (battclock.resource) ResetMenuStrip() (intuition.library) RethinkDisplay() (intuition.library) RouteCxMsg() (commodities.library) RunCommand() (dos.library) SameDevice() (dos.library) SameLock() (dos.library) ScalerDiv() (graphics.library) ScreenToBack() (intuition.library) ScreenToFront() (intuition.library) ScrollLayer() (layers.library) ScrollRaster() (graphics.library) ScrollVPort() (graphics.library) SDCMD_BREAK (serial.device) SDCMD_QUERY (serial.device) SDCMD_SETPARAMS (serial.device) SDivMod32() (utility.library) Seek() (dos.library) SelectInput() (dos.library) SelectOutput() (dos.library) SendIO() (exec.library) SendPkt() (dos.library) SetAPen() (graphics.library) SetArgStr() (dos.library) SetAttrsA() (intuition.library) SetBPen() (graphics.library) SetCollision() (graphics.library) SetComment() (dos.library) SetConsoleTask() (dos.library) SetCurrentBinding() (expansion.library) SetCurrentDirName() (dos.library) SetCxObjPri() (commodities.library) SetDefaultPubScreen() (intuition.library) SetDMRequest() (intuition.library) SetDrMd() (graphics.library) SetEditHook() (intuition.library) SetExcept() (exec.library) SetFileDate() (dos.library) SetFileSize() (dos.library) SetFileSysTask() (dos.library) SetFilter() (commodities.library) SetFilterIX() (commodities.library) SetFont() (graphics.library) SetFunction() (exec.library) SetGadgetAttrsA() (intuition.library) SetICR() (cia.resource) SetIntVector() (exec.library) SetIoErr() (dos.library) SetKeyMapDefault() (keymap.library) SetLocalItemPurge() (iffparse.library) SetMenuStrip() (intuition.library) SetMode() (dos.library) SetMouseQueue() (intuition.library) SetOPen() (graphics.library) SetPointer() (intuition.library) SetPrefs() (intuition.library) SetProgramDir() (dos.library) SetProgramName() (dos.library) SetPrompt() (dos.library) SetProtection() (dos.library) SetPubScreenModes() (intuition.library) SetRast() (graphics.library) SetRexxVar() (amiga_lib.library) SetRGB4() (graphics.library) SetRGB4CM() (graphics.library) SetSignal() (exec.library) SetSoftStyle() (graphics.library) SetSR() (exec.library) SetSuperAttrs() (amiga_lib.library) SetTaskPri() (exec.library) SetTranslate() (commodities.library) SetVar() (dos.library) SetVBuf() (dos.library) SetWindowTitles() (intuition.library) ShowTitle() (intuition.library) Signal() (exec.library) SizeLayer() (layers.library) SizeWindow() (intuition.library) SMult32() (utility.library) SortGList() (graphics.library) SPAbs() (mathffp.library) SPAcos() (mathtrans.library) SPAdd() (mathffp.library) SPAsin() (mathtrans.library) SPAtan() (mathtrans.library) SPCeil() (mathffp.library) SPCmp() (mathffp.library) SPCos() (mathtrans.library) SPCosh() (mathtrans.library) SPDiv() (mathffp.library) SPExp() (mathtrans.library) SPFieee() (mathtrans.library) SPFix() (mathffp.library) SPFloor() (mathffp.library) SPFlt() (mathffp.library) SplitName() (dos.library) SPLog() (mathtrans.library) SPLog10() (mathtrans.library) SPMul() (mathffp.library) SPNeg() (mathffp.library) SPPow() (mathtrans.library) sprintf() (amiga_lib.library) SPSin() (mathtrans.library) SPSincos() (mathtrans.library) SPSinh() (mathtrans.library) SPSqrt() (mathtrans.library) SPSub() (mathffp.library) SPTan() (mathtrans.library) SPTanh() (mathtrans.library) SPTieee() (mathtrans.library) SPTst() (mathffp.library) StackSwap() (exec.library) StartNotify() (dos.library) stdio() (amiga_lib.library) StopChunk() (iffparse.library) StopChunks() (iffparse.library) StopOnExit() (iffparse.library) StoreItemInContext() (iffparse.library) StoreLocalItem() (iffparse.library) Stricmp() (utility.library) StripFont() (graphics.library) Strnicmp() (utility.library) StrToDate() (dos.library) StrToLong() (dos.library) SubTime() (timer.device) SumKickData() (exec.library) SumLibrary() (exec.library) SuperState() (exec.library) Supervisor() (exec.library) SwapBitsRastPortClipRect() (layers.library) SyncSBitMap() (graphics.library) SysReqHandler() (intuition.library) SystemTagList() (dos.library) TagInArray() (utility.library) TD_ADDCHANGEINT (trackdisk.device) TD_CHANGENUM (trackdisk.device) TD_CHANGESTATE (trackdisk.device) TD_EJECT (trackdisk.device) TD_FORMAT (trackdisk.device) TD_GETDRIVETYPE (trackdisk.device) TD_GETGEOMETRY (trackdisk.device) TD_GETNUMTRACKS (trackdisk.device) TD_MOTOR (trackdisk.device) TD_PROTSTATUS (trackdisk.device) TD_RAWREAD (trackdisk.device) TD_RAWWRITE (trackdisk.device) TD_REMCHANGEINT (trackdisk.device) TD_SEEK (trackdisk.device) Text() (graphics.library) TextExtent() (graphics.library) TextFit() (graphics.library) TextLength() (graphics.library) ThinLayerInfo() (layers.library) TimeDelay() (amiga_lib.library) ToLower() (utility.library) ToUpper() (utility.library) Translate() (translator.library) TR_ADDREQUEST (timer.device) TR_GETSYSTIME (timer.device) TR_SETSYSTIME (timer.device) TypeOfMem() (exec.library) UDivMod32() (utility.library) UMult32() (utility.library) UnGetC() (dos.library) UnLoadSeg() (dos.library) UnLock() (dos.library) UnLockDosList() (dos.library) UnlockIBase() (intuition.library) UnlockLayer() (layers.library) UnlockLayerInfo() (layers.library) UnlockLayerRom() (graphics.library) UnlockLayers() (layers.library) UnlockPubScreen() (intuition.library) UnlockPubScreenList() (intuition.library) UnLockRecord() (dos.library) UnLockRecords() (dos.library) UnlockRexxBase() (rexxsyslib.library) UpfrontLayer() (layers.library) UserState() (exec.library) Vacate() (exec.library) VBeamPos() (graphics.library) VFPrintf() (dos.library) VFWritef() (dos.library) VideoControl() (graphics.library) ViewAddress() (intuition.library) ViewPortAddress() (intuition.library) VPrintf() (dos.library) Wait() (exec.library) WaitBlit() (graphics.library) WaitBOVP() (graphics.library) WaitForChar() (dos.library) WaitIO() (exec.library) WaitPkt() (dos.library) WaitPort() (exec.library) WaitTOF() (graphics.library) WBenchToBack() (intuition.library) WBenchToFront() (intuition.library) WeighTAMatch() (graphics.library) WhichLayer() (layers.library) WindowLimits() (intuition.library) WindowToBack() (intuition.library) WindowToFront() (intuition.library) Write() (dos.library) WriteBattClock() (battclock.resource) WriteBattMem() (battmem.resource) WriteChars() (dos.library) WriteChunkBytes() (iffparse.library) WriteChunkRecords() (iffparse.library) WriteExpansionByte() (expansion.library) WritePixel() (graphics.library) WritePixelArray8() (graphics.library) WritePixelLine8() (graphics.library) WritePotgo() (potgo.resource) XorRectRegion() (graphics.library) XorRegionRegion() (graphics.library) ZipWindow() (intuition.library) [Back to Amiga Developer Docs ]
Includes_and_Autodocs_3._guide/node0561.html.txt:1:serial.device/SDCMD_BREAK ]" border=0> NAME Break -- send a break signal over the serial line FUNCTION This command sends a break signal (serial line held low for an extended period) out the serial port. For the built-in port, This is accomplished by setting the UARTBRK bit of regisrer ADKCON. After a duration (user specifiable via setparams, default 250000 microseconds) the bit is reset and the signal discontinued. If the QUEUEDBRK bit of io_SerFlags is set in the io_Request block, the request is placed at the back of the write-request queue and executed in turn. If the QUEUEDBRK bit is not set, the break is started immediately, control returns to the caller, and the timer discontinues the signal after the duration is completed. Be aware that calling BREAK may affect other commands such as ABORT, FLUSH, STOP, START, etc... IO REQUEST io_Message mn_ReplyPort initialized io_Device set by OpenDevice io_Unit set by OpenDevice io_Command SDCMD_BREAK io_Flags set/reset IO_QUICK per above description RESULTS Error -- if the Break succeded, then Error will be null. If the Break failed, then the Error will be non-zero. [Back to Amiga Developer Docs ]
AmigaMail_Vol2_guide/node014E.html.txt:1:REW, PLAY, PAUSE, FF, STOP ]" border=0> These keys are mapped by the A570 ROM to the F1 through F5 keys on the Amiga keyboard. The Audio Control Panel uses these equivalents to play CD audio discs. If a title detects a keypress on F1 through F5, it should react as if the user had pressed the corresponding remote control button. Certain titles ported from the Amiga to the CDTV may have already established alternate uses of the F1 through F5 keys on the keyboard. Any such application that retains its mapping of the F1 through F5 keys for its A570 version should clearly document these alternate key mappings in its manual. [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node055B.html.txt:1:2.0 IncludeXREF: I ]" border=0> id_BytesPerBlock long int in struct InfoData +0x0014 dos/dos.h : *125 id_DiskState long int in struct InfoData +0x0008 dos/dos.h : *122 id_DiskType long int in struct InfoData +0x0018 dos/dos.h : *126 id_InUse long int in struct InfoData +0x0020 dos/dos.h : *128 id_NumBlocks long int in struct InfoData +0x000c dos/dos.h : *123 id_NumBlocksUsed long int in struct InfoData +0x0010 dos/dos.h : *124 id_NumSoftErrors long int in struct InfoData +0x0000 dos/dos.h : *120 id_UnitNumber long int in struct InfoData +0x0004 dos/dos.h : *121 id_VolumeNode long int in struct InfoData +0x001c dos/dos.h : *127 ie_Class unsigned char in struct InputEvent +0x0004 devices/inputevent.h : *201 ie_Code unsigned short int in struct InputEvent +0x0006 devices/inputevent.h : *203 ie_EventAddress #define ie_position.ie_addr devices/inputevent.h : *223 ie_NextEvent pointer to struct InputEvent in struct InputEvent +0x0000 devices/inputevent.h : *200 ie_Prev1DownCode #define ie_position.ie_dead.ie_prev1DownCode devices/inputevent.h : *224 ie_Prev1DownQual #define ie_position.ie_dead.ie_prev1DownQual devices/inputevent.h : *225 ie_Prev2DownCode #define ie_position.ie_dead.ie_prev2DownCode devices/inputevent.h : *226 ie_Prev2DownQual #define ie_position.ie_dead.ie_prev2DownQual devices/inputevent.h : *227 ie_Qualifier unsigned short int in struct InputEvent +0x0008 devices/inputevent.h : *204 ie_SubClass unsigned char in struct InputEvent +0x0005 devices/inputevent.h : *202 ie_TimeStamp struct timeval(size 0x0008 bytes) in struct InputEvent +0x000e devices/inputevent.h : *218 ie_X #define ie_position.ie_xy.ie_x devices/inputevent.h : *221 ie_Y #define ie_position.ie_xy.ie_y devices/inputevent.h : *222 ie_addr pointer to void in union (no tag) +0x0000 devices/inputevent.h : *210 ie_dead struct (no tag) (size 0x0004 bytes) in union (no tag) +0x0000 devices/inputevent.h : *216 ie_position union (no tag) (size 0x0004 bytes) in struct InputEvent +0x000a devices/inputevent.h : *217 ie_prev1DownCode unsigned char in struct (no tag) +0x0000 devices/inputevent.h : *212 ie_prev1DownQual unsigned char in struct (no tag) +0x0001 devices/inputevent.h : *213 ie_prev2DownCode unsigned char in struct (no tag) +0x0002 devices/inputevent.h : *214 ie_prev2DownQual unsigned char in struct (no tag) +0x0003 devices/inputevent.h : *215 ie_x short int in struct (no tag) +0x0000 devices/inputevent.h : *207 ie_xy struct (no tag) (size 0x0004 bytes) in union (no tag) +0x0000 devices/inputevent.h : *209 ie_y short int in struct (no tag) +0x0002 devices/inputevent.h : *208 iepp_Position struct (no tag) (size 0x0004 bytes) in struct IEPointerPixel +0x0004 devices/inputevent.h : *93 iepp_Screen pointer to struct Screen in struct IEPointerPixel +0x0000 devices/inputevent.h : *89 iept_Pressure short int in struct IEPointerTablet +0x0008 devices/inputevent.h : *118 iept_Range struct (no tag) (size 0x0004 bytes) in struct IEPointerTablet +0x0000 devices/inputevent.h : *112 iept_Value struct (no tag) (size 0x0004 bytes) in struct IEPointerTablet +0x0004 devices/inputevent.h : *116 iff_Depth long int in struct IFFHandle +0x0008 libraries/iffparse.h : *38 iff_Flags unsigned long int in struct IFFHandle +0x0004 libraries/iffparse.h : *37 iff_Stream unsigned long int in struct IFFHandle +0x0000 libraries/iffparse.h : *36 impDraw structure tag size 0x0018 intuition/imageclass.h : *152 impErase structure tag (size 0x0010 bytes)in struct impErase intuition/imageclass.h : *172 impFrameBox structure tag size 0x0014 intuition/imageclass.h : *139 impHitTest structure tag (size 0x000c bytes)in struct impHitTest intuition/imageclass.h : *188 imp_ContentsBox pointer to struct IBox in struct impFrameBox +0x0004 intuition/imageclass.h : *141 imp_Dimensions struct (no tag) (size 0x0004 bytes) in struct impDraw +0x0014 intuition/imageclass.h : *167 imp_Dimensions struct (no tag) (size 0x0004 bytes) in struct impErase +0x000c intuition/imageclass.h : *184 imp_Dimensions struct (no tag) (size 0x0004 bytes) in struct impHitTest +0x0008 intuition/imageclass.h : *199 imp_DrInfo pointer to struct DrawInfo in struct impFrameBox +0x000c intuition/imageclass.h : *143 imp_DrInfo pointer to struct DrawInfo in struct impDraw +0x0010 intuition/imageclass.h : *161 imp_FrameBox pointer to struct IBox in struct impFrameBox +0x0008 intuition/imageclass.h : *142 imp_FrameFlags unsigned long int in struct impFrameBox +0x0010 intuition/imageclass.h : *144 imp_Offset struct (no tag) (size 0x0004 bytes) in struct impDraw +0x0008 intuition/imageclass.h : *158 imp_Offset struct (no tag) (size 0x0004 bytes) in struct impErase +0x0008 intuition/imageclass.h : *178 imp_Point struct (no tag) (size 0x0004 bytes) in struct impHitTest +0x0004 intuition/imageclass.h : *193 imp_RPort pointer to struct RastPort in struct impDraw +0x0004 intuition/imageclass.h : *154 imp_RPort pointer to struct RastPort in struct impErase +0x0004 intuition/imageclass.h : *174 imp_State unsigned long int in struct impDraw +0x000c intuition/imageclass.h : *160 intena unsigned short int in struct Custom +0x009a hardware/custom.h : *94 intenar unsigned short int in struct Custom +0x001c hardware/custom.h : *42 intreq unsigned short int in struct Custom +0x009c hardware/custom.h : *95 intreqr unsigned short int in struct Custom +0x001e hardware/custom.h : *43 io_Actual unsigned long int in struct IOStdReq +0x0020 exec/io.h : *36 io_Actual unsigned long int in struct IOClipReq +0x0020 devices/clipboard.h : *50 io_Baud unsigned long int in struct IOExtSer +0x003c devices/serial.h : *65 io_BrkTime unsigned long int in struct IOExtSer +0x0040 devices/serial.h : *66 io_ClipID long int in struct IOClipReq +0x0030 devices/clipboard.h : *54 io_ColorMap pointer to struct ColorMap in struct IODRPReq +0x0024 devices/printer.h : *164 io_Command unsigned short int in struct IORequest +0x001c exec/io.h : *24 io_Command unsigned short int in struct IOStdReq +0x001c exec/io.h : *33 io_Command unsigned short int in struct IOClipReq +0x001c devices/clipboard.h : *47 io_Command unsigned short int in struct IOPrtCmdReq +0x001c devices/printer.h : *146 io_Command unsigned short int in struct IODRPReq +0x001c devices/printer.h : *160 io_CtlChar unsigned long int in struct IOExtSer +0x0030 devices/serial.h : *62 io_Data pointer to void in struct IOStdReq +0x0028 exec/io.h : *38 io_Data pointer to unsigned char in struct IOClipReq +0x0028 devices/clipboard.h : *52 io_DestCols long int in struct IODRPReq +0x0034 devices/printer.h : *170 io_DestRows long int in struct IODRPReq +0x0038 devices/printer.h : *171 io_Device pointer to struct Device in struct IORequest +0x0014 exec/io.h : *22 io_Device pointer to struct Device in struct IOStdReq +0x0014 exec/io.h : *31 io_Device pointer to struct Device in struct IOClipReq +0x0014 devices/clipboard.h : *45 io_Device pointer to struct Device in struct IOPrtCmdReq +0x0014 devices/printer.h : *144 io_Device pointer to struct Device in struct IODRPReq +0x0014 devices/printer.h : *158 io_Error char in struct IORequest +0x001f exec/io.h : *26 io_Error char in struct IOStdReq +0x001f exec/io.h : *35 io_Error char in struct IOClipReq +0x001f devices/clipboard.h : *49 io_Error char in struct IOPrtCmdReq +0x001f devices/printer.h : *148 io_Error char in struct IODRPReq +0x001f devices/printer.h : *162 io_ExtFlags unsigned long int in struct IOExtSer +0x0038 devices/serial.h : *64 io_Flags unsigned char in struct IORequest +0x001e exec/io.h : *25 io_Flags unsigned char in struct IOStdReq +0x001e exec/io.h : *34 io_Flags unsigned char in struct IOClipReq +0x001e devices/clipboard.h : *48 io_Flags unsigned char in struct IOPrtCmdReq +0x001e devices/printer.h : *147 io_Flags unsigned char in struct IODRPReq +0x001e devices/printer.h : *161 io_Length unsigned long int in struct IOStdReq +0x0024 exec/io.h : *37 io_Length unsigned long int in struct IOClipReq +0x0024 devices/clipboard.h : *51 io_Message struct Message(size 0x0014 bytes) in struct IORequest +0x0000 exec/io.h : *21 io_Message struct Message(size 0x0014 bytes) in struct IOStdReq +0x0000 exec/io.h : *30 io_Message struct Message(size 0x0014 bytes) in struct IOClipReq +0x0000 devices/clipboard.h : *44 io_Message struct Message(size 0x0014 bytes) in struct IOPrtCmdReq +0x0000 devices/printer.h : *143 io_Message struct Message(size 0x0014 bytes) in struct IODRPReq +0x0000 devices/printer.h : *157 io_Modes unsigned long int in struct IODRPReq +0x0028 devices/printer.h : *165 io_Offset unsigned long int in struct IOStdReq +0x002c exec/io.h : *39 io_Offset unsigned long int in struct IOClipReq +0x002c devices/clipboard.h : *53 io_PExtFlags unsigned long int in struct IOExtPar +0x0030 devices/parallel.h : *52 io_PTermArray struct IOPArray(size 0x0008 bytes) in struct IOExtPar +0x0036 devices/parallel.h : *55 io_ParFlags unsigned char in struct IOExtPar +0x0035 devices/parallel.h : *54 io_Parm0 unsigned char in struct IOPrtCmdReq +0x0022 devices/printer.h : *150 io_Parm1 unsigned char in struct IOPrtCmdReq +0x0023 devices/printer.h : *151 io_Parm2 unsigned char in struct IOPrtCmdReq +0x0024 devices/printer.h : *152 io_Parm3 unsigned char in struct IOPrtCmdReq +0x0025 devices/printer.h : *153 io_PrtCommand unsigned short int in struct IOPrtCmdReq +0x0020 devices/printer.h : *149 io_RBufLen unsigned long int in struct IOExtSer +0x0034 devices/serial.h : *63 io_RastPort pointer to struct RastPort in struct IODRPReq +0x0020 devices/printer.h : *163 io_ReadLen unsigned char in struct IOExtSer +0x004c devices/serial.h : *68 io_SerFlags unsigned char in struct IOExtSer +0x004f devices/serial.h : *71 io_Special unsigned short int in struct IODRPReq +0x003c devices/printer.h : *172 io_SrcHeight unsigned short int in struct IODRPReq +0x0032 devices/printer.h : *169 io_SrcWidth unsigned short int in struct IODRPReq +0x0030 devices/printer.h : *168 io_SrcX unsigned short int in struct IODRPReq +0x002c devices/printer.h : *166 io_SrcY unsigned short int in struct IODRPReq +0x002e devices/printer.h : *167 io_Status unsigned char in struct IOExtPar +0x0034 devices/parallel.h : *53 io_Status unsigned short int in struct IOExtSer +0x0050 devices/serial.h : *72 io_StopBits unsigned char in struct IOExtSer +0x004e devices/serial.h : *70 io_TermArray struct IOTArray(size 0x0008 bytes) in struct IOExtSer +0x0044 devices/serial.h : *67 io_Unit pointer to struct Unit in struct IORequest +0x0018 exec/io.h : *23 io_Unit pointer to struct Unit in struct IOStdReq +0x0018 exec/io.h : *32 io_Unit pointer to struct ClipboardUnitPartial in struct IOClipReq +0x0018 devices/clipboard.h : *46 io_Unit pointer to struct Unit in struct IOPrtCmdReq +0x0018 devices/printer.h : *145 io_Unit pointer to struct Unit in struct IODRPReq +0x0018 devices/printer.h : *159 io_WriteLen unsigned char in struct IOExtSer +0x004d devices/serial.h : *69 ioa_AllocKey short int in struct IOAudio +0x0020 devices/audio.h : *49 ioa_Cycles unsigned short int in struct IOAudio +0x002e devices/audio.h : *54 ioa_Data pointer to unsigned char in struct IOAudio +0x0022 devices/audio.h : *50 ioa_Length unsigned long int in struct IOAudio +0x0026 devices/audio.h : *51 ioa_Period unsigned short int in struct IOAudio +0x002a devices/audio.h : *52 ioa_Request struct IORequest(size 0x0020 bytes) in struct IOAudio +0x0000 devices/audio.h : *48 ioa_Volume unsigned short int in struct IOAudio +0x002c devices/audio.h : *53 ioa_WriteMsg struct Message(size 0x0014 bytes) in struct IOAudio +0x0030 devices/audio.h : *55 iobArea array [204] of char in struct IoBuff +0x0034 rexx/rexxio.h : *32 iobBct long int in struct IoBuff +0x0030 rexx/rexxio.h : *31 iobDFH long int in struct IoBuff +0x0028 rexx/rexxio.h : *29 iobLock pointer to void in struct IoBuff +0x002c rexx/rexxio.h : *30 iobNode struct RexxRsrc(size 0x0020 bytes) in struct IoBuff +0x0000 rexx/rexxio.h : *26 iobRct long int in struct IoBuff +0x0024 rexx/rexxio.h : *28 iobRpt pointer to void in struct IoBuff +0x0020 rexx/rexxio.h : *27 iotd_Count unsigned long int in struct IOExtTD +0x0030 devices/trackdisk.h : *121 iotd_Req struct IOStdReq(size 0x0030 bytes) in struct IOExtTD +0x0000 devices/trackdisk.h : *120 iotd_SecLabel unsigned long int in struct IOExtTD +0x0034 devices/trackdisk.h : *122 is_Code pointer to function returning void in struct Interrupt +0x0012 exec/interrupts.h : *27 is_Data pointer to void in struct Interrupt +0x000e exec/interrupts.h : *26 is_Node struct Node(size 0x000e bytes) in struct Interrupt +0x0000 exec/interrupts.h : *25 is_Node struct Node(size 0x000e bytes) in struct Isrvstr +0x0000 graphics/graphint.h : *22 itof macro (1 argument) libraries/mathffp.h : *33 libraries/mathieeedp.h : *33 iv_Code pointer to function returning void in struct IntVector +0x0004 exec/interrupts.h : *33 iv_Data pointer to void in struct IntVector +0x0000 exec/interrupts.h : *32 iv_Node pointer to struct Node in struct IntVector +0x0008 exec/interrupts.h : *34 ix_Class unsigned char in struct InputXpression +0x0001 libraries/commodities.h : *175 ix_Code unsigned short int in struct InputXpression +0x0002 libraries/commodities.h : *177 ix_CodeMask unsigned short int in struct InputXpression +0x0004 libraries/commodities.h : *179 ix_QualMask unsigned short int in struct InputXpression +0x0008 libraries/commodities.h : *185 ix_QualSame unsigned short int in struct InputXpression +0x000a libraries/commodities.h : *189 ix_Qualifier unsigned short int in struct InputXpression +0x0006 libraries/commodities.h : *183 ix_Version unsigned char in struct InputXpression +0x0000 libraries/commodities.h : *174 IA_APATSIZE #define IA_APatSize = 0x80020011 intuition/iobsolete.h : *246 IA_APATTERN #define IA_APattern = 0x80020010 intuition/iobsolete.h : *245 IA_APatSize #define (IA_Dummy + 0x11) = 0x80020011 intuition/imageclass.h : *63 IA_APattern #define (IA_Dummy + 0x10) = 0x80020010 intuition/imageclass.h : *62 IA_BGPEN #define IA_BGPen = 0x80020006 intuition/iobsolete.h : *240 IA_BGPen #define (IA_Dummy + 0x06) = 0x80020006 intuition/imageclass.h : *41 IA_DATA #define IA_Data = 0x80020007 intuition/iobsolete.h : *241 IA_DOUBLEEMBOSS #define IA_DoubleEmboss = 0x80020016 intuition/iobsolete.h : *251 IA_Data #define (IA_Dummy + 0x07) = 0x80020007 intuition/imageclass.h : *43 IA_DoubleEmboss #define (IA_Dummy + 0x16) = 0x80020016 intuition/imageclass.h : *68 IA_Dummy #define (TAG_USER + 0x20000) = 0x80020000 intuition/imageclass.h : *34 IA_EDGESONLY #define IA_EdgesOnly = 0x80020017 intuition/iobsolete.h : *252 IA_EdgesOnly #define (IA_Dummy + 0x17) = 0x80020017 intuition/imageclass.h : *69 IA_FGPEN #define IA_FGPen = 0x80020005 intuition/iobsolete.h : *239 IA_FGPen #define (IA_Dummy + 0x05) = 0x80020005 intuition/imageclass.h : *39 IA_FONT #define IA_Font = 0x80020013 intuition/iobsolete.h : *248 IA_Font #define (IA_Dummy + 0x13) = 0x80020013 intuition/imageclass.h : *65 IA_HEIGHT #define IA_Height = 0x80020004 intuition/iobsolete.h : *238 IA_HIGHLIGHTPEN #define IA_HighlightPen = 0x8002000a intuition/iobsolete.h : *254 IA_Height #define (IA_Dummy + 0x04) = 0x80020004 intuition/imageclass.h : *38 IA_HighlightPen #define (IA_Dummy + 0x0A) = 0x8002000a intuition/imageclass.h : *86 IA_LEFT #define IA_Left = 0x80020001 intuition/iobsolete.h : *235 IA_LINEWIDTH #define IA_LineWidth = 0x80020008 intuition/iobsolete.h : *242 IA_Left #define (IA_Dummy + 0x01) = 0x80020001 intuition/imageclass.h : *35 IA_LineWidth #define (IA_Dummy + 0x08) = 0x80020008 intuition/imageclass.h : *47 IA_MODE #define IA_Mode = 0x80020012 intuition/iobsolete.h : *247 IA_Mode #define (IA_Dummy + 0x12) = 0x80020012 intuition/imageclass.h : *64 IA_OUTLINE #define IA_Outline = 0x80020014 intuition/iobsolete.h : *249 IA_Outline #define (IA_Dummy + 0x14) = 0x80020014 intuition/imageclass.h : *66 IA_PENS #define IA_Pens = 0x8002000e intuition/iobsolete.h : *243 IA_Pens #define (IA_Dummy + 0x0E) = 0x8002000e intuition/imageclass.h : *48 IA_RECESSED #define IA_Recessed = 0x80020015 intuition/iobsolete.h : *250 IA_RESOLUTION #define IA_Resolution = 0x8002000f intuition/iobsolete.h : *244 IA_Recessed #define (IA_Dummy + 0x15) = 0x80020015 intuition/imageclass.h : *67 IA_Resolution #define (IA_Dummy + 0x0F) = 0x8002000f intuition/imageclass.h : *55 IA_SHADOWPEN #define IA_ShadowPen = 0x80020009 intuition/iobsolete.h : *253 IA_ShadowPen #define (IA_Dummy + 0x09) = 0x80020009 intuition/imageclass.h : *85 IA_TOP #define IA_Top = 0x80020002 intuition/iobsolete.h : *236 IA_Top #define (IA_Dummy + 0x02) = 0x80020002 intuition/imageclass.h : *36 IA_WIDTH #define IA_Width = 0x80020003 intuition/iobsolete.h : *237 IA_Width #define (IA_Dummy + 0x03) = 0x80020003 intuition/imageclass.h : *37 IAddress pointer to void in struct IntuiMessage +0x001c intuition/intuition.h : *695 IBox structure tag size 0x0008 intuition/intuition.h : *783 intuition/cghooks.h : 49, 72, 73 intuition/imageclass.h : 141, 142 ICA_Dummy #define (TAG_USER+0x40000L) = 0x80040000 intuition/icclass.h : *28 ICA_MAP #define (ICA_Dummy + 2) = 0x80040002 intuition/icclass.h : *31 ICA_TARGET #define (ICA_Dummy + 1) = 0x80040001 intuition/icclass.h : *29 ICCLASS #define "icclass" intuition/classusr.h : *53 ICM_CHECKLOOP #define (0x0404L) = 0x00000404 intuition/icclass.h : *23 ICM_CLEARLOOP #define (0x0403L) = 0x00000403 intuition/icclass.h : *22 ICM_Dummy #define (0x0401L) = 0x00000401 intuition/icclass.h : *20 ICM_SETLOOP #define (0x0402L) = 0x00000402 intuition/icclass.h : *21 ICONNAME #define "icon.library" workbench/icon.h : *15 ICSPECIAL_CODE #define (ICA_Dummy + 3) = 0x80040003 intuition/icclass.h : *33 ICTARGET_IDCMP #define (~0L) = 0xffffffff intuition/icclass.h : *48 IClass structure tag size 0x0034 intuition/classes.h : *28, 31, 70 IDCMPFlags unsigned long int in struct Window +0x0052 intuition/intuition.h : *855 IDCMPFlags unsigned long int in struct NewWindow +0x000a intuition/intuition.h : *981 IDCMPFlags unsigned long int in struct ExtNewWindow +0x000a intuition/intuition.h : *1050 IDCMPUPDATE #define IDCMP_IDCMPUPDATE = 0x00800000 intuition/iobsolete.h : *137 IDCMPWindow pointer to struct Window in struct IntuiMessage +0x002c intuition/intuition.h : *713 IDCMP_ACTIVEWINDOW #define 0x00040000 = 0x00040000 intuition/intuition.h : *742 IDCMP_CHANGEWINDOW #define 0x02000000 = 0x02000000 intuition/intuition.h : *752 IDCMP_CLOSEWINDOW #define 0x00000200 = 0x00000200 intuition/intuition.h : *733 IDCMP_DELTAMOVE #define 0x00100000 = 0x00100000 intuition/intuition.h : *744 IDCMP_DISKINSERTED #define 0x00008000 = 0x00008000 intuition/intuition.h : *739 IDCMP_DISKREMOVED #define 0x00010000 = 0x00010000 intuition/intuition.h : *740 IDCMP_GADGETDOWN #define 0x00000020 = 0x00000020 intuition/intuition.h : *729 IDCMP_GADGETUP #define 0x00000040 = 0x00000040 intuition/intuition.h : *730 IDCMP_IDCMPUPDATE #define 0x00800000 = 0x00800000 intuition/intuition.h : *748 IDCMP_INACTIVEWINDOW #define 0x00080000 = 0x00080000 intuition/intuition.h : *743 IDCMP_INTUITICKS #define 0x00400000 = 0x00400000 intuition/intuition.h : *746 IDCMP_LONELYMESSAGE #define 0x80000000 = 0x80000000 intuition/intuition.h : *761 IDCMP_MENUHELP #define 0x01000000 = 0x01000000 intuition/intuition.h : *750 IDCMP_MENUPICK #define 0x00000100 = 0x00000100 intuition/intuition.h : *732 IDCMP_MENUVERIFY #define 0x00002000 = 0x00002000 intuition/intuition.h : *737 IDCMP_MOUSEBUTTONS #define 0x00000008 = 0x00000008 intuition/intuition.h : *727 IDCMP_MOUSEMOVE #define 0x00000010 = 0x00000010 intuition/intuition.h : *728 IDCMP_NEWPREFS #define 0x00004000 = 0x00004000 intuition/intuition.h : *738 IDCMP_NEWSIZE #define 0x00000002 = 0x00000002 intuition/intuition.h : *725 IDCMP_RAWKEY #define 0x00000400 = 0x00000400 intuition/intuition.h : *734 IDCMP_REFRESHWINDOW #define 0x00000004 = 0x00000004 intuition/intuition.h : *726 IDCMP_REQCLEAR #define 0x00001000 = 0x00001000 intuition/intuition.h : *736 IDCMP_REQSET #define 0x00000080 = 0x00000080 intuition/intuition.h : *731 IDCMP_REQVERIFY #define 0x00000800 = 0x00000800 intuition/intuition.h : *735 IDCMP_SIZEVERIFY #define 0x00000001 = 0x00000001 intuition/intuition.h : *724 IDCMP_VANILLAKEY #define 0x00200000 = 0x00200000 intuition/intuition.h : *745 IDCMP_WBENCHMESSAGE #define 0x00020000 = 0x00020000 intuition/intuition.h : *741 IDNAME_BADBLOCK #define 0x42414442 = 0x42414442 devices/hardblocks.h : *125 IDNAME_FILESYSHEADER #define 0x46534844 = 0x46534844 devices/hardblocks.h : *182 IDNAME_LOADSEG #define 0x4C534547 = 0x4c534547 devices/hardblocks.h : *195 IDNAME_PARTITION #define 0x50415254 = 0x50415254 devices/hardblocks.h : *144 IDNAME_RIGIDDISK #define 0x5244534B = 0x5244534b devices/hardblocks.h : *92 IDNestCnt char in struct ExecBase +0x0126 exec/execbase.h : *70 IDS_BUSY #define (3L) = 0x00000003 intuition/imageclass.h : *129 IDS_DISABLED #define (2L) = 0x00000002 intuition/imageclass.h : *128 IDS_INACTIVEDISABLED #define (7L) = 0x00000007 intuition/imageclass.h : *133 IDS_INACTIVENORMAL #define (5L) = 0x00000005 intuition/imageclass.h : *131 IDS_INACTIVESELECTED #define (6L) = 0x00000006 intuition/imageclass.h : *132 IDS_INDETERMINANT #define IDS_INDETERMINATE = 0x00000004 intuition/imageclass.h : *136 IDS_INDETERMINATE #define (4L) = 0x00000004 intuition/imageclass.h : *130 IDS_NORMAL #define (0L) = 0x00000000 intuition/imageclass.h : *126 IDS_SELECTED #define (1L) = 0x00000001 intuition/imageclass.h : *127 ID_CAT #define MAKE_ID('C','A','T',' ') = 0x43415420 libraries/iffparse.h : *150 ID_DOS_DISK #define (0x444F5300L) = 0x444f5300 dos/dos.h : *140 ID_FFS_DISK #define (0x444F5301L) = 0x444f5301 dos/dos.h : *141 ID_FORM #define MAKE_ID('F','O','R','M') = 0x464f524d libraries/iffparse.h : *148 ID_KICKSTART_DISK #define (0x4B49434BL) = 0x4b49434b dos/dos.h : *143 ID_LIST #define MAKE_ID('L','I','S','T') = 0x4c495354 libraries/iffparse.h : *149 ID_MSDOS_DISK #define (0x4d534400L) = 0x4d534400 dos/dos.h : *144 ID_NOT_REALLY_DOS #define (0x4E444F53L) = 0x4e444f53 dos/dos.h : *142 ID_NO_DISK_PRESENT #define (-1) = 0xffffffff dos/dos.h : *138 ID_NULL #define MAKE_ID(' ',' ',' ',' ') = 0x20202020 libraries/iffparse.h : *152 ID_PROP #define MAKE_ID('P','R','O','P') = 0x50524f50 libraries/iffparse.h : *151 ID_UNREADABLE_DISK #define (0x42414400L) = 0x42414400 dos/dos.h : *139 ID_VALIDATED #define 82 = 0x00000052 dos/dos.h : *135 ID_VALIDATING #define 81 = 0x00000051 dos/dos.h : *134 ID_WRITE_PROTECTED #define 80 = 0x00000050 dos/dos.h : *133 IECLASS_ACTIVEWINDOW #define 0x11 = 0x00000011 devices/inputevent.h : *55 IECLASS_CHANGEWINDOW #define 0x15 = 0x00000015 devices/inputevent.h : *63 IECLASS_CLOSEWINDOW #define 0x0B = 0x0000000b devices/inputevent.h : *43 IECLASS_DISKINSERTED #define 0x10 = 0x00000010 devices/inputevent.h : *53 IECLASS_DISKREMOVED #define 0x0F = 0x0000000f devices/inputevent.h : *51 IECLASS_EVENT #define 0x03 = 0x00000003 devices/inputevent.h : *29 IECLASS_GADGETDOWN #define 0x07 = 0x00000007 devices/inputevent.h : *35 IECLASS_GADGETUP #define 0x08 = 0x00000008 devices/inputevent.h : *37 IECLASS_INACTIVEWINDOW #define 0x12 = 0x00000012 devices/inputevent.h : *57 IECLASS_MAX #define 0x15 = 0x00000015 devices/inputevent.h : *66 devices/conunit.h : 99 IECLASS_MENUHELP #define 0x14 = 0x00000014 devices/inputevent.h : *61 IECLASS_MENULIST #define 0x0A = 0x0000000a devices/inputevent.h : *41 IECLASS_NEWPOINTERPOS #define 0x13 = 0x00000013 devices/inputevent.h : *59 IECLASS_NEWPREFS #define 0x0E = 0x0000000e devices/inputevent.h : *49 IECLASS_NULL #define 0x00 = 0x00000000 devices/inputevent.h : *23 IECLASS_POINTERPOS #define 0x04 = 0x00000004 devices/inputevent.h : *31 IECLASS_RAWKEY #define 0x01 = 0x00000001 devices/inputevent.h : *25 IECLASS_RAWMOUSE #define 0x02 = 0x00000002 devices/inputevent.h : *27 IECLASS_REFRESHWINDOW #define 0x0D = 0x0000000d devices/inputevent.h : *47 IECLASS_REQUESTER #define 0x09 = 0x00000009 devices/inputevent.h : *39 IECLASS_SIZEWINDOW #define 0x0C = 0x0000000c devices/inputevent.h : *45 IECLASS_TIMER #define 0x06 = 0x00000006 devices/inputevent.h : *33 IECODE_ASCII_DEL #define 0x7F = 0x0000007f devices/inputevent.h : *136 IECODE_ASCII_FIRST #define 0x20 = 0x00000020 devices/inputevent.h : *134 IECODE_ASCII_LAST #define 0x7E = 0x0000007e devices/inputevent.h : *135 IECODE_C0_FIRST #define 0x00 = 0x00000000 devices/inputevent.h : *132 IECODE_C0_LAST #define 0x1F = 0x0000001f devices/inputevent.h : *133 IECODE_C1_FIRST #define 0x80 = 0x00000080 devices/inputevent.h : *137 IECODE_C1_LAST #define 0x9F = 0x0000009f devices/inputevent.h : *138 IECODE_COMM_CODE_FIRST #define 0x78 = 0x00000078 devices/inputevent.h : *128 IECODE_COMM_CODE_LAST #define 0x7F = 0x0000007f devices/inputevent.h : *129 IECODE_KEY_CODE_FIRST #define 0x00 = 0x00000000 devices/inputevent.h : *126 IECODE_KEY_CODE_LAST #define 0x77 = 0x00000077 devices/inputevent.h : *127 IECODE_LATIN1_FIRST #define 0xA0 = 0x000000a0 devices/inputevent.h : *139 IECODE_LATIN1_LAST #define 0xFF = 0x000000ff devices/inputevent.h : *140 IECODE_LBUTTON #define 0x68 = 0x00000068 devices/inputevent.h : *143 IECODE_MBUTTON #define 0x6A = 0x0000006a devices/inputevent.h : *145 IECODE_NEWACTIVE #define 0x01 = 0x00000001 devices/inputevent.h : *149 IECODE_NEWSIZE #define 0x02 = 0x00000002 devices/inputevent.h : *150 IECODE_NOBUTTON #define 0xFF = 0x000000ff devices/inputevent.h : *146 IECODE_RBUTTON #define 0x69 = 0x00000069 devices/inputevent.h : *144 IECODE_REFRESH #define 0x03 = 0x00000003 devices/inputevent.h : *151 IECODE_REQCLEAR #define 0x00 = 0x00000000 devices/inputevent.h : *158 IECODE_REQSET #define 0x01 = 0x00000001 devices/inputevent.h : *156 IECODE_UP_PREFIX #define 0x80 = 0x00000080 devices/inputevent.h : *125 IEEEDPACos function returning "LONG" libraries/mathieeedp.h : *57 IEEEDPASin function returning "LONG" libraries/mathieeedp.h : *58 IEEEDPAbs function returning "LONG" libraries/mathieeedp.h : *70 IEEEDPAdd function returning "LONG" libraries/mathieeedp.h : *72 IEEEDPAtan function returning "LONG" libraries/mathieeedp.h : *56 IEEEDPCeil function returning "LONG" libraries/mathieeedp.h : *77 IEEEDPCos function returning "LONG" libraries/mathieeedp.h : *57 IEEEDPCosh function returning "LONG" libraries/mathieeedp.h : *63 IEEEDPDiv function returning "LONG" libraries/mathieeedp.h : *75 IEEEDPExp function returning "LONG" libraries/mathieeedp.h : *59 IEEEDPFieee function returning "LONG" libraries/mathieeedp.h : *65 IEEEDPFloor function returning "LONG" libraries/mathieeedp.h : *76 IEEEDPFlt function returning "LONG" libraries/mathieeedp.h : *69 IEEEDPLog function returning "LONG" libraries/mathieeedp.h : *59 IEEEDPLog10 function returning "LONG" libraries/mathieeedp.h : *61 IEEEDPMul function returning "LONG" libraries/mathieeedp.h : *74 IEEEDPNeg function returning "LONG" libraries/mathieeedp.h : *71 IEEEDPPow function returning "LONG" libraries/mathieeedp.h : *61 IEEEDPSin function returning "LONG" libraries/mathieeedp.h : *58 IEEEDPSincos function returning "LONG" libraries/mathieeedp.h : *62 IEEEDPSinh function returning "LONG" libraries/mathieeedp.h : *63 IEEEDPSqrt function returning "LONG" libraries/mathieeedp.h : *60 IEEEDPSub function returning "LONG" libraries/mathieeedp.h : *73 IEEEDPTan function returning "LONG" libraries/mathieeedp.h : *56 IEEEDPTanh function returning "LONG" libraries/mathieeedp.h : *63 IEEEDPTieee function returning "LONG" libraries/mathieeedp.h : *64 IEPointerPixel structure tag size 0x0008 devices/inputevent.h : *88 IEPointerTablet structure tag (size 0x000a bytes)in struct IEPointerTablet devices/inputevent.h : *108 IEQUALIFIERB_CAPSLOCK #define 2 = 0x00000002 devices/inputevent.h : *182 IEQUALIFIERB_CONTROL #define 3 = 0x00000003 devices/inputevent.h : *183 IEQUALIFIERB_INTERRUPT #define 10 = 0x0000000a devices/inputevent.h : *190 IEQUALIFIERB_LALT #define 4 = 0x00000004 devices/inputevent.h : *184 IEQUALIFIERB_LCOMMAND #define 6 = 0x00000006 devices/inputevent.h : *186 IEQUALIFIERB_LEFTBUTTON #define 14 = 0x0000000e devices/inputevent.h : *194 IEQUALIFIERB_LSHIFT #define 0 = 0x00000000 devices/inputevent.h : *180 IEQUALIFIERB_MIDBUTTON #define 12 = 0x0000000c devices/inputevent.h : *192 IEQUALIFIERB_MULTIBROADCAST #define 11 = 0x0000000b devices/inputevent.h : *191 IEQUALIFIERB_NUMERICPAD #define 8 = 0x00000008 devices/inputevent.h : *188 IEQUALIFIERB_RALT #define 5 = 0x00000005 devices/inputevent.h : *185 IEQUALIFIERB_RBUTTON #define 13 = 0x0000000d devices/inputevent.h : *193 IEQUALIFIERB_RCOMMAND #define 7 = 0x00000007 devices/inputevent.h : *187 IEQUALIFIERB_RELATIVEMOUSE #define 15 = 0x0000000f devices/inputevent.h : *195 IEQUALIFIERB_REPEAT #define 9 = 0x00000009 devices/inputevent.h : *189 IEQUALIFIERB_RSHIFT #define 1 = 0x00000001 devices/inputevent.h : *181 IEQUALIFIER_CAPSLOCK #define 0x0004 = 0x00000004 devices/inputevent.h : *165 IEQUALIFIER_CONTROL #define 0x0008 = 0x00000008 devices/inputevent.h : *166 IEQUALIFIER_INTERRUPT #define 0x0400 = 0x00000400 devices/inputevent.h : *173 IEQUALIFIER_LALT #define 0x0010 = 0x00000010 devices/inputevent.h : *167 IEQUALIFIER_LCOMMAND #define 0x0040 = 0x00000040 devices/inputevent.h : *169 IEQUALIFIER_LEFTBUTTON #define 0x4000 = 0x00004000 devices/inputevent.h : *177 IEQUALIFIER_LSHIFT #define 0x0001 = 0x00000001 devices/inputevent.h : *163 IEQUALIFIER_MIDBUTTON #define 0x1000 = 0x00001000 devices/inputevent.h : *175 IEQUALIFIER_MULTIBROADCAST #define 0x0800 = 0x00000800 devices/inputevent.h : *174 IEQUALIFIER_NUMERICPAD #define 0x0100 = 0x00000100 devices/inputevent.h : *171 IEQUALIFIER_RALT #define 0x0020 = 0x00000020 devices/inputevent.h : *168 IEQUALIFIER_RBUTTON #define 0x2000 = 0x00002000 devices/inputevent.h : *176 IEQUALIFIER_RCOMMAND #define 0x0080 = 0x00000080 devices/inputevent.h : *170 IEQUALIFIER_RELATIVEMOUSE #define 0x8000 = 0x00008000 devices/inputevent.h : *178 IEQUALIFIER_REPEAT #define 0x0200 = 0x00000200 devices/inputevent.h : *172 IEQUALIFIER_RSHIFT #define 0x0002 = 0x00000002 devices/inputevent.h : *164 IESUBCLASS_COMPATIBLE #define 0x00 = 0x00000000 devices/inputevent.h : *72 IESUBCLASS_PIXEL #define 0x01 = 0x00000001 devices/inputevent.h : *74 IESUBCLASS_TABLET #define 0x02 = 0x00000002 devices/inputevent.h : *76 IEvent pointer to struct InputEvent in struct SGWork +0x0014 intuition/sghooks.h : *42 IFFCMD_CLEANUP #define 1 = 0x00000001 libraries/iffparse.h : *189 IFFCMD_ENTRY #define 5 = 0x00000005 libraries/iffparse.h : *193 IFFCMD_EXIT #define 6 = 0x00000006 libraries/iffparse.h : *194 IFFCMD_INIT #define 0 = 0x00000000 libraries/iffparse.h : *188 IFFCMD_PURGELCI #define 7 = 0x00000007 libraries/iffparse.h : *195 IFFCMD_READ #define 2 = 0x00000002 libraries/iffparse.h : *190 IFFCMD_SEEK #define 4 = 0x00000004 libraries/iffparse.h : *192 IFFCMD_WRITE #define 3 = 0x00000003 libraries/iffparse.h : *191 IFFERR_EOC #define -2L = 0xfffffffe libraries/iffparse.h : *130 IFFERR_EOF #define -1L = 0xffffffff libraries/iffparse.h : *129 IFFERR_MANGLED #define -8L = 0xfffffff8 libraries/iffparse.h : *136 IFFERR_NOHOOK #define -11L = 0xfffffff5 libraries/iffparse.h : *139 IFFERR_NOMEM #define -4L = 0xfffffffc libraries/iffparse.h : *132 IFFERR_NOSCOPE #define -3L = 0xfffffffd libraries/iffparse.h : *131 IFFERR_NOTIFF #define -10L = 0xfffffff6 libraries/iffparse.h : *138 IFFERR_READ #define -5L = 0xfffffffb libraries/iffparse.h : *133 IFFERR_SEEK #define -7L = 0xfffffff9 libraries/iffparse.h : *135 IFFERR_SYNTAX #define -9L = 0xfffffff7 libraries/iffparse.h : *137 IFFERR_WRITE #define -6L = 0xfffffffa libraries/iffparse.h : *134 IFFF_FSEEK #define (1L libraries/iffparse.h : *48 IFFF_READ #define 0L = 0x00000000 libraries/iffparse.h : *45 IFFF_RESERVED #define 0xFFFF0000L = 0xffff0000 libraries/iffparse.h : *50 IFFF_RSEEK #define (1L libraries/iffparse.h : *49 IFFF_RWBITS #define (IFFF_READ | IFFF_WRITE) = 0x00000001 libraries/iffparse.h : *47 IFFF_WRITE #define 1L = 0x00000001 libraries/iffparse.h : *46 IFFHandle structure tag size 0x000c libraries/iffparse.h : *35 IFFLCI_COLLECTION #define MAKE_ID('c','o','l','l') = 0x636f6c6c libraries/iffparse.h : *158 IFFLCI_ENTRYHANDLER #define MAKE_ID('e','n','h','d') = 0x656e6864 libraries/iffparse.h : *159 IFFLCI_EXITHANDLER #define MAKE_ID('e','x','h','d') = 0x65786864 libraries/iffparse.h : *160 IFFLCI_PROP #define MAKE_ID('p','r','o','p') = 0x70726f70 libraries/iffparse.h : *157 IFFPARSE_RAWSTEP #define 2L = 0x00000002 libraries/iffparse.h : *167 IFFPARSE_SCAN #define 0L = 0x00000000 libraries/iffparse.h : *165 IFFPARSE_STEP #define 1L = 0x00000001 libraries/iffparse.h : *166 IFFSCC_CLEANUP #define IFFCMD_CLEANUP = 0x00000001 libraries/iffparse.h : *199 IFFSCC_INIT #define IFFCMD_INIT = 0x00000000 libraries/iffparse.h : *198 IFFSCC_READ #define IFFCMD_READ = 0x00000002 libraries/iffparse.h : *200 IFFSCC_SEEK #define IFFCMD_SEEK = 0x00000004 libraries/iffparse.h : *202 IFFSCC_WRITE #define IFFCMD_WRITE = 0x00000003 libraries/iffparse.h : *201 IFFSIZE_UNKNOWN #define -1L = 0xffffffff libraries/iffparse.h : *182 IFFSLI_PROP #define 3L = 0x00000003 libraries/iffparse.h : *174 IFFSLI_ROOT #define 1L = 0x00000001 libraries/iffparse.h : *172 IFFSLI_TOP #define 2L = 0x00000002 libraries/iffparse.h : *173 IFFStreamCmd structure tag size 0x000c libraries/iffparse.h : *56 IFF_IFFPARSE_H #define libraries/iffparse.h : *2 IFF_RETURN2CLIENT #define -12L = 0xfffffff4 libraries/iffparse.h : *140 IFont pointer to struct TextFont in struct Window +0x0080 intuition/intuition.h : *895 IGNORE_DIMENSIONS #define 0x0000 = 0x00000000 intuition/preferences.h : *247 IMAGECLASS #define "imageclass" intuition/classusr.h : *43 IMAGE_ATTRIBUTES #define (IA_Dummy) = 0x80020000 intuition/iobsolete.h : *234 IMAGE_NEGATIVE #define 0x01 = 0x00000001 intuition/preferences.h : *173 IMAGE_POSITIVE #define 0x00 = 0x00000000 intuition/preferences.h : *172 IMPORT #define extern exec/types.h : *21 IM_BGPEN macro (1 argument) intuition/imageclass.h : *31 IM_BOX macro (1 argument) intuition/imageclass.h : *29 IM_DRAW #define 0x202L = 0x00000202 intuition/imageclass.h : *115 IM_DRAWFRAME #define 0x206L = 0x00000206 intuition/imageclass.h : *120 IM_ERASE #define 0x204L = 0x00000204 intuition/imageclass.h : *117 IM_ERASEFRAME #define 0x209L = 0x00000209 intuition/imageclass.h : *123 IM_FGPEN macro (1 argument) intuition/imageclass.h : *30 IM_FRAMEBOX #define 0x207L = 0x00000207 intuition/imageclass.h : *121 IM_HITFRAME #define 0x208L = 0x00000208 intuition/imageclass.h : *122 IM_HITTEST #define 0x203L = 0x00000203 intuition/imageclass.h : *116 IM_ITEM #define (NM_ITEM | MENU_IMAGE) = 0x00000082 libraries/gadtools.h : *140 IM_MOVE #define 0x205L = 0x00000205 intuition/imageclass.h : *118 IM_SUB #define (NM_SUB | MENU_IMAGE) = 0x00000083 libraries/gadtools.h : *141 INACTIVEWINDOW #define IDCMP_INACTIVEWINDOW = 0x00080000 intuition/iobsolete.h : *133 INCLUDE_VERSION #define 36 = 0x00000024 exec/types.h : *17 IND_ADDHANDLER #define (CMD_NONSTD+0) = 0x00000009 devices/input.h : *19 IND_REMHANDLER #define (CMD_NONSTD+1) = 0x0000000a devices/input.h : *20 IND_SETMPORT #define (CMD_NONSTD+5) = 0x0000000e devices/input.h : *24 IND_SETMTRIG #define (CMD_NONSTD+7) = 0x00000010 devices/input.h : *26 IND_SETMTYPE #define (CMD_NONSTD+6) = 0x0000000f devices/input.h : *25 IND_SETPERIOD #define (CMD_NONSTD+4) = 0x0000000d devices/input.h : *23 IND_SETTHRESH #define (CMD_NONSTD+3) = 0x0000000c devices/input.h : *22 IND_WRITEEVENT #define (CMD_NONSTD+2) = 0x0000000b devices/input.h : *21 INITBYTE macro (2 arguments) exec/initializers.h : *17 INITLONG macro (2 arguments) exec/initializers.h : *21 INITSTRUCT macro (4 arguments) exec/initializers.h : *25 INITWORD macro (2 arguments) exec/initializers.h : *18 INREQUEST #define WFLG_INREQUEST = 0x00004000 intuition/iobsolete.h : *162 INST_DATA macro (2 arguments) intuition/classes.h : *48 INTB_AUD0 #define (7) = 0x00000007 hardware/intbits.h : *25 INTB_AUD1 #define (8) = 0x00000008 hardware/intbits.h : *24 INTB_AUD2 #define (9) = 0x00000009 hardware/intbits.h : *23 INTB_AUD3 #define (10) = 0x0000000a hardware/intbits.h : *22 INTB_BLIT #define (6) = 0x00000006 hardware/intbits.h : *26 INTB_COPER #define (4) = 0x00000004 hardware/intbits.h : *28 INTB_DSKBLK #define (1) = 0x00000001 hardware/intbits.h : *31 INTB_DSKSYNC #define (12) = 0x0000000c hardware/intbits.h : *20 INTB_EXTER #define (13) = 0x0000000d hardware/intbits.h : *19 INTB_INTEN #define (14) = 0x0000000e hardware/intbits.h : *18 INTB_NMI #define 15 = 0x0000000f exec/interrupts.h : *46 INTB_PORTS #define (3) = 0x00000003 hardware/intbits.h : *29 INTB_RBF #define (11) = 0x0000000b hardware/intbits.h : *21 INTB_SETCLR #define (15) = 0x0000000f hardware/intbits.h : *15 INTB_SOFTINT #define (2) = 0x00000002 hardware/intbits.h : *30 INTB_TBE #define (0) = 0x00000000 hardware/intbits.h : *32 INTB_VERTB #define (5) = 0x00000005 hardware/intbits.h : *27 INTEGERIDCMP #define (IDCMP_GADGETUP) = 0x00000040 libraries/gadtools.h : *68 INTEGER_KIND #define 3 = 0x00000003 libraries/gadtools.h : *37 INTEGER_SCALING #define 0x0100 = 0x00000100 intuition/preferences.h : *253 INTERHEIGHT #define 4 = 0x00000004 libraries/gadtools.h : *88 INTERLACE #define 4 = 0x00000004 graphics/display.h : *24 INTERWIDTH #define 8 = 0x00000008 libraries/gadtools.h : *87 INTF_AUD0 #define (1 hardware/intbits.h : *44 INTF_AUD1 #define (1 hardware/intbits.h : *43 INTF_AUD2 #define (1 hardware/intbits.h : *42 INTF_AUD3 #define (1 hardware/intbits.h : *41 INTF_BLIT #define (1 hardware/intbits.h : *45 INTF_COPER #define (1 hardware/intbits.h : *47 INTF_DSKBLK #define (1 hardware/intbits.h : *50 INTF_DSKSYNC #define (1 hardware/intbits.h : *39 INTF_EXTER #define (1 hardware/intbits.h : *38 INTF_INTEN #define (1 hardware/intbits.h : *37 INTF_NMI #define (1 exec/interrupts.h : *47 INTF_PORTS #define (1 hardware/intbits.h : *48 INTF_RBF #define (1 hardware/intbits.h : *40 INTF_SETCLR #define (1 hardware/intbits.h : *36 INTF_SOFTINT #define (1 hardware/intbits.h : *49 INTF_TBE #define (1 hardware/intbits.h : *51 INTF_VERTB #define (1 hardware/intbits.h : *46 INTUITICKS #define IDCMP_INTUITICKS = 0x00400000 intuition/iobsolete.h : *136 INTUITION_CGHOOKS_H #define 1 = 0x00000001 intuition/cghooks.h : *2 INTUITION_CLASSES_H #define 1 = 0x00000001 intuition/classes.h : *2 INTUITION_CLASSUSR_H #define 1 = 0x00000001 intuition/classusr.h : *2, 1 INTUITION_GADGETCLASS_H #define 1 = 0x00000001 intuition/gadgetclass.h : *2 INTUITION_ICCLASS_H #define intuition/icclass.h : *2 INTUITION_IMAGECLASS_H #define TRUE = 0x00000001 intuition/imageclass.h : *2 INTUITION_INTUITIONBASE_H #define 1 = 0x00000001 intuition/intuitionbase.h : *2 INTUITION_INTUITION_H #define TRUE = 0x00000001 intuition/intuition.h : *2, 1 intuition/iobsolete.h : 38 intuition/cghooks.h : 19 intuition/gadgetclass.h : 19 intuition/intuitionbase.h : 23 libraries/gadtools.h : 25 workbench/workbench.h : 31 INTUITION_IOBSOLETE_H #define intuition/iobsolete.h : *2, 1 intuition/intuition.h : 1357 intuition/gadgetclass.h : 244 intuition/imageclass.h : 203 INTUITION_PREFERENCES_H #define TRUE = 0x00000001 intuition/preferences.h : *2, 1 INTUITION_SCREENS_H #define TRUE = 0x00000001 intuition/screens.h : *2, 1 INTUITION_SGHOOKS_H #define TRUE = 0x00000001 intuition/sghooks.h : *2 INVALID_ID #define ~0 = 0xffffffff graphics/displayinfo.h : *141 INVERSVID #define 4 = 0x00000004 graphics/rastport.h : *97 IOAudio structure tag size 0x0044 devices/audio.h : *47 IOB_QUICK #define 0 = 0x00000000 exec/io.h : *47 IOClipReq structure tag size 0x0034 devices/clipboard.h : *43 libraries/iffparse.h : 117 IODRPReq structure tag size 0x003e devices/printer.h : *156 IOERR_ABORTED #define (-2) = 0xfffffffe exec/errors.h : *16 IOERR_BADADDRESS #define (-5) = 0xfffffffb exec/errors.h : *19 IOERR_BADLENGTH #define (-4) = 0xfffffffc exec/errors.h : *18 IOERR_NOCMD #define (-3) = 0xfffffffd exec/errors.h : *17 IOERR_OPENFAIL #define (-1) = 0xffffffff exec/errors.h : *15 IOERR_SELFTEST #define (-7) = 0xfffffff9 exec/errors.h : *21 IOERR_UNITBUSY #define (-6) = 0xfffffffa exec/errors.h : *20 IOExtPar structure tag size 0x003e devices/parallel.h : *29 devices/prtbase.h : 76, 84 IOExtSer structure tag size 0x0052 devices/serial.h : *38 devices/prtbase.h : 77, 85 IOExtTD structure tag size 0x0038 devices/trackdisk.h : *119 IOF_QUICK #define (1 exec/io.h : *48 IOPARB_ABORT #define 5 = 0x00000005 devices/parallel.h : *75 IOPARB_ACTIVE #define 4 = 0x00000004 devices/parallel.h : *77 IOPARB_QUEUED #define 6 = 0x00000006 devices/parallel.h : *73 IOPARF_ABORT #define (1 devices/parallel.h : *76 IOPARF_ACTIVE #define (1 devices/parallel.h : *78 IOPARF_QUEUED #define (1 devices/parallel.h : *74 IOPArray structure tag size 0x0008 devices/parallel.h : *19, 55 IOPTB_PAPEROUT #define 1 = 0x00000001 devices/parallel.h : *85 IOPTB_PARBUSY #define 0 = 0x00000000 devices/parallel.h : *87 IOPTB_PARSEL #define 2 = 0x00000002 devices/parallel.h : *81 IOPTB_RWDIR #define 3 = 0x00000003 devices/parallel.h : *79 IOPTF_PAPEROUT #define (1 devices/parallel.h : *86 IOPTF_PARBUSY #define (1 devices/parallel.h : *88 IOPTF_PARSEL #define (1 devices/parallel.h : *84 IOPTF_RWDIR #define (1 devices/parallel.h : *80 IOPar struct IOStdReq(size 0x0030 bytes) in struct IOExtPar +0x0000 devices/parallel.h : *30 IOPrtCmdReq structure tag size 0x0026 devices/printer.h : *142 IORequest structure tag size 0x0020 exec/io.h : *20 devices/audio.h : 48 devices/timer.h : 38 IOSer struct IOStdReq(size 0x0030 bytes) in struct IOExtSer +0x0000 devices/serial.h : *39 IOStdReq structure tag size 0x0030 exec/io.h : *29 devices/narrator.h : 94 devices/parallel.h : 30 devices/serial.h : 39 devices/trackdisk.h : 120 IOTArray structure tag size 0x0008 devices/serial.h : *22, 67 IOTDB_INDEXSYNC #define 4 = 0x00000004 devices/trackdisk.h : *173 IOTDB_WORDSYNC #define 5 = 0x00000005 devices/trackdisk.h : *179 IOTDF_INDEXSYNC #define (1 devices/trackdisk.h : *174 IOTDF_WORDSYNC #define (1 devices/trackdisk.h : *180 IO_STATB_OVERRUN #define 8 = 0x00000008 devices/serial.h : *126 IO_STATB_READBREAK #define 10 = 0x0000000a devices/serial.h : *122 IO_STATB_WROTEBREAK #define 9 = 0x00000009 devices/serial.h : *124 IO_STATB_XOFFREAD #define 12 = 0x0000000c devices/serial.h : *118 IO_STATB_XOFFWRITE #define 11 = 0x0000000b devices/serial.h : *120 IO_STATF_OVERRUN #define (1 devices/serial.h : *127 IO_STATF_READBREAK #define (1 devices/serial.h : *123 IO_STATF_WROTEBREAK #define (1 devices/serial.h : *125 IO_STATF_XOFFREAD #define (1 devices/serial.h : *119 IO_STATF_XOFFWRITE #define (1 devices/serial.h : *121 ISDRAWN #define 0x1000 = 0x00001000 intuition/intuition.h : *135 ISGRTRX #define 4 = 0x00000004 graphics/clip.h : *85 ISGRTRY #define 8 = 0x00000008 graphics/clip.h : *86 ISLESSX #define 1 = 0x00000001 graphics/clip.h : *83 ISLESSY #define 2 = 0x00000002 graphics/clip.h : *84 ITEMENABLED #define 0x0010 = 0x00000010 intuition/intuition.h : *122 ITEMNUM macro (1 argument) intuition/intuition.h : *1267 ITEMTEXT #define 0x0002 = 0x00000002 intuition/intuition.h : *119 ITEM_EQUAL #define -2 = 0xfffffffe dos/dos.h : *230 ITEM_ERROR #define -1 = 0xffffffff dos/dos.h : *231 ITEM_NOTHING #define 0 = 0x00000000 dos/dos.h : *232 ITEM_QUOTED #define 2 = 0x00000002 dos/dos.h : *234 ITEM_UNQUOTED #define 1 = 0x00000001 dos/dos.h : *233 IText pointer to unsigned char in struct IntuiText +0x000c intuition/intuition.h : *577 ITextFont pointer to struct TextAttr in struct IntuiText +0x0008 intuition/intuition.h : *576 IVALUE macro (1 argument) rexx/storage.h : *51 IX "LONG" libraries/commodities.h : *192 IXSYM_ALT #define 4 = 0x00000004 libraries/commodities.h : *197 IXSYM_ALTMASK #define (IEQUALIFIER_LALT | IEQUALIFIER_RALT) = 0x00000030 libraries/commodities.h : *202 IXSYM_CAPS #define 2 = 0x00000002 libraries/commodities.h : *196 IXSYM_CAPSMASK #define (IXSYM_SHIFTMASK | IEQUALIFIER_CAPSLOCK) = 0x00000007 libraries/commodities.h : *201 IXSYM_SHIFT #define 1 = 0x00000001 libraries/commodities.h : *195 IXSYM_SHIFTMASK #define (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT) = 0x00000003 libraries/commodities.h : *200 IX_NORMALQUALS #define 0x7FFF; libraries/commodities.h : *204 IX_VERSION #define 2 = 0x00000002 libraries/commodities.h : *171 IdleCount unsigned long int in struct ExecBase +0x0118 exec/execbase.h : *65 Image structure tag size 0x0014 intuition/intuition.h : *174, 619, 666, 865, 996, 1054 ImageBMap pointer to struct BitMap in struct Requester +0x0044 intuition/intuition.h : *171 ImageData pointer to unsigned short int in struct Image +0x000a intuition/intuition.h : *626 ImageData pointer to short int in struct VSprite +0x0024 graphics/gels.h : *105 ImageShadow pointer to short int in struct Bob +0x0006 graphics/gels.h : *148 InfoData structure tag size 0x0024 dos/dos.h : *119 InitAnimate macro (1 argument) graphics/gels.h : *246 InitialModes unsigned long int in struct StringExtend +0x0008 intuition/sghooks.h : *26 InputEvent structure tag size 0x0016 devices/inputevent.h : *199, 200 intuition/gadgetclass.h : 204 intuition/sghooks.h : 42 InputXpression structure tag size 0x000c libraries/commodities.h : *173, 192 IntVector structure tag size 0x000c exec/interrupts.h : *31 exec/execbase.h : 59 IntVects array [16] of struct IntVector(size 0x000c bytes) in struct ExecBase +0x0054 exec/execbase.h : *59 Interrupt structure tag size 0x0016 exec/interrupts.h : *24 graphics/gfxbase.h : 36 resources/disk.h : 45, 46, 47, 59, 60, 61 IntrList struct List(size 0x000e bytes) in struct ExecBase +0x016c exec/execbase.h : *89 IntuiMessage structure tag size 0x0034 intuition/intuition.h : *677, 716, 857 IntuiText structure tag size 0x0014 intuition/intuition.h : *155, 240, 570, 578 IntuitionBase structure tag size 0x0050 intuition/intuitionbase.h : *68 IoBuff structure tag size 0x0100 rexx/rexxio.h : *25 Iptr pointer to struct Isrvstr in struct Isrvstr +0x000e graphics/graphint.h : *23 IsListEmpty macro (1 argument) exec/lists.h : *53 IsMsgPortEmpty macro (1 argument) exec/lists.h : *56 Isrvstr structure tag size 0x001e graphics/graphint.h : *20, 23 ItemFill pointer to void in struct MenuItem +0x0012 intuition/intuition.h : *99 [Back to Amiga Developer Docs ]
AmigaMail_Vol2_guide/node0102.html.txt:1:VIII-17: Developing Network Applications for the Amiga ]" border=0> by Dale Larson When you run a wire between two or more computers, you have a network. Big Deal. When your applications use that wire however, you have a revolution. Although some of the following software is only internal or experimental, these are things I can do now with my Amiga, with software that I have now: * From my Amiga, I can transparently access filesystems on Suns, on the local Vax system (cbmvax), and on other Amigas. * Whenever I print, I send my files to a network printer. * I continuously receive mail on my Amiga--from as far as Seattle, Sydney and Denmark, and near as a desk next to mine. * Every night when I go home, my Amigas at work (and several others) are used to do distributed graphics rendering. The process is started over the network and all data is sent over the network. A picture that would have taken a week can be finished overnight. In the scheme of what is possible, this is only the tip of the iceberg. * In a high school environment, a network could allow students to interactively participate in computer simulations. It could allow them to collaborate electronically. It could allow teachers to electronically monitor and assist students. It could save schools money because peripherals such as printers, hard-drives and CD-ROMs could be easily shared. Even the computational power of one expensive machine could be shared by the students. * A small office can use a network for an email-like facility for phone messages and other notes. Another application might replace the intercom. Form letters can be kept in a central database accessed by a word processor. A distributed appointment calendar could allow a secretary to add a new appointment even as the boss is looking at what his afternoon schedule is. A distributed database application would allow access to such things as a central client database, outstanding orders and the present inventory. * Imagine multi-player games that use the computational power of each machine connected by a high speed Local Area Network (LAN). * In a software development environment, several programmers can work on the same project, updating the same sources. Debugging information could be sent over the network, or a debugger on one machine could control the programs on others (For example, there is a version of Wack that runs over a network). * Multimedia applications might do any number of exciting things with the network. A few of the applications which have been experimented with on other machines are: real-time audio and video conferencing, interactive demos for groups, and shared electronic blackboards. In much the same way as all applications are candidates for a GUI interface, all applications are candidates for becoming network applications. The GUI has only changed the ways in which people interact with their computers. Networks will change the ways in which people interact with each other. This article introduces some of the principles of writing network programs using the AS225's Berkeley Socket interface. Even more so than in most of software development, networking seems simple in theory, but, in reality, gets complicated in a hurry. To develop network software for AS225, you will need to obtain the Network Developer's kit from CATS. It has all the necessary include files and Autodocs to develop for the AS225's socket.library. Also, you should plan read at least some of the material in the "References" section of this article. Protocol Layers and the Berkeley Sockets Interface Network Applications Application Protocols Kinds of Servers Addresses Finding Servers Reserved Ports Skeleton for Applications Using TCP (connection-based) Skeleton for Applications Using UDP (connectionless) Which Protocol Is Right For My Application? The Shared Socket Library References [Back to Amiga Developer Docs ]
AmigaMail_Vol2_guide/node00DF.html.txt:1:VI-1: Creating Virtual Voices with Amiga Audio ]" border=0> Creating Virtual Voices with Amiga Audio by Dan Baker Every Amiga model comes standard with 4-channel, 8-bit stereo audio hardware. This hardware provides every application with the capability of producing 4-part, stereo sound. Some applications however may want to exceed the 4-channel limit. For games and other applications that use sound effects extensively, it may be desirable to trigger more than 4 sounds simultaneously. This article demonstrates two techniques you can use to implement virtual voices on the Amiga's audio hardware effectively doubling the number of voices available to 8. Audio Hardware Limits Using DMA, the audio hardware can fetch about 2 bytes per scan line for each channel without processor intervention. This means that each audio channel can play back sampled data at up to 28,867 bytes per second. It turns out that this 28,867 byte per second limit far exceeds the requirements of most audio sample files. The typical 8SVX file contains data sampled at a rate of about 10,000 bytes per second. In that case, the audio hardware only uses about 1/3 of the available audio bandwidth. The audio hardware is capable of fetching much more sound data without affecting system performance. The question then arises, can this extra horsepower be harnessed in some way? The answer is yes. Audio Interleaving An application can use any extra audio bandwidth to interleave the bytes from two separate sample files. This technique allows an application to play both samples simultaneously on a single audio channel. For instance, if you have two files sampled at 10,000 bytes per second, you could set the playback speed to 20,000 bytes per second and alternate playing bytes from each sample. The effective speed of each sample is preserved since each sample is output only half the time. Figure 1 - Interleaved audio data As shown in the diagram above, an application interleaves the data bytes from two sound files into a memory buffer. The application then plays the back the interleaved sample at twice the rate. Note that for this method to work, the speeds of the two samples should be the same, or at least a close match. Another restriction is that the sample speed must be no more than half the maximum speed available on the Amiga. Since the playback speed has to be doubled for interleaving to work and since the speed limit of the Amiga's built in audio hardware is 28,867 bytes per second, the speed limit of each interleaved sample is 14,433 bytes per second. The biggest advantage of audio interleaving is that it exploits unused audio bandwidth available on the Amiga hardware. Also, interleaving does not effect the values of the sampled sound data. The individual sound samples remain in their original, noninterleaved form. The disadvantage is interleaving certain wave forms can combine into an unexpected and undesirable wave form. Consider the following two wave forms: Figure 2 - Wave Forms When the Amiga interleaves these two wave forms, it has to alternate between wave form A and wave form B. Because the Amiga is constantly oscillating between two wave forms, it produces a completely different wave form: Figure 3 - Wave Form In practice, this usually isn't a problem if you are working with sampled sound. Typically, sampled sounds are not pure periodic wave forms (like the wave forms above). Audio Averaging It is not always possible to interleave two samples. For example, the frequency of a sample may be more than 14,433 bytes per second, so doubling it would exceed the 28,867 bytes per second limit. In that case, there is another trick you can do to the audio data to combine two samples on one channel. If the values from each sample file are added and the resulting value is divided by two, a new data stream can be created which contains the audio information from both files. Figure 4 - Averaged output data Note that in the example above, data values are represented as signed bytes in the range -128 to +127 using twos complement format. The resulting average values are correct as shown. Even though the ioa_Data field of the IOAudio structure used for all audio.device requests is shown as (UBYTE *) in the include file , do not be misled. The data values are signed bytes. Audio averaging introduces some noise into the resulting combined signal. Dividing the summed values by two effectively reduces the dynamic range of the component samples by one bit (from eight to seven bits). Also, when the values are divided by two, any fractional amount is truncated, hence, some information is lost. Despite these drawbacks, the results of audio averaging on the Amiga's eight bit audio hardware are comparable to the interleaving technique described above. In fact, the two techniques are virtually indistinguishable on the current generation of Amigas (although this may not always be true--see the ``Audio Experiments'' section later in this article). Virtual Voices When two samples are combined on a single channel using interleaving or averaging, both samples are clearly audible but, subjectively, it sounds as if one bit of volume control has been lost on each sample. Because of this, it is not wise to carry these virtual voice techniques to an extreme. Combining samples without limit will result in a badly degraded composite in which the component signals are no longer clearly audible. It is however quite feasible to double the number of available voices to 8 using interleaving or averaging techniques. The loss of fidelity with 8 virtual voices is quite tolerable. The code listed below shows how this can be implemented. Using the Interplay Program The program, named interplay.c , allows the playback of standard IFF 8SVX files in three different ways: 1. Normal playback of a single file on one channel 2. Interleaved playback of two files on one channel 3. Averaged playback of two files on one channel For normal playback of a single 8SVX file, enter the following command at the Shell prompt: 1>interplay sample.8svx This feature allows you to find out how a sample sounds alone as compared with its interleaved or averaged counterpart. For playback of two 8SVX files on a single channel using interleaving, enter the following command at the Shell prompt: 1>interplay voice.8svx music.8svx The program reads the two files, figures out which has the faster sampling rate, and sets the audio device to twice that value. If the calculated rate exceeds the maximum of 28,867 bytes per second, then interplay sets the speed to the maximum. The program then interleaves the data from the two files so that the bytes played by the audio channel alternate from one file to the other. If the data from one file runs out before the other, any remaining data bytes are interleaved with zero. For playback of two 8SVX files on a single channel using averaging, enter the following command at the Shell prompt: 1>interplay voice.8svx music.8svx SUM The ``SUM'' keyword enables averaging instead of interleaving. In this case, the speed is set to whichever file uses the faster playback rate. One byte is taken from each file, the two bytes are added and then divided by two. The resulting average value is played back. If the data from one file runs out before the other, any remaining data bytes are averaged with zero. Interplay can play samples of any size. If a sample is too long, you can terminate playback by pressing Ctrl-C. How Interplay Works Interplay uses a double-buffered approach for the playback of samples of arbitrary length. While one data buffer is playing, the other data buffer is being prepared using either the averaging or interleaving technique descried above. Most of the code in the main loop within main() is concerned with switching between one of the two playback buffers and their corresponding I/O request blocks and message ports. The averaging or interleaving of bytes actually takes place in the FillAudio() subroutine, not in main(). The reading and parsing of the 8SVX file are handled by the Parse8svx() subroutine which takes as a parameter an InterPlay structure. The InterPlay struture holds all the state information that the program needs to manage playback of the sampled data. Thus there will be one filled-in InterPlay structure for each file to be played back. If the user requests a combined playback, the two InterPlay structures are linked together via the InterPlay.next_iplay field. Otherwise this field is set to NULL. Housekeeping for the audio.device channels used is handled by the SiezeChannel() and ReleaseChannel() subroutines. Audio Experiments Using the interplay.c program listed below, we found that there was very little difference in the audio quality between the two methods of combining samples. We also found that for best results, the dynamic ranges within the samples themselves had to be closely matched or the result would be one sample drowning out the other. Of course, it also helps if the speeds are a close match. If they aren't then one or the other of the samples will be too slow or too fast. Although both of these methods work comparitively well on the Amiga's eight-bit audio hardware, doing the same tricks with 16-bit samples on 16-bit hardware would yield a different result. As mentioned earlier, the drawback of the averaging method is it loses a bit from the dynamic range of the sound samples. Compared to eight-bit sound, this loss is much less significant when working with 16-bit sound. As the dynamic range increases, the impact of losing a single bit from the dynamic range decreases. On the other hand, the drawback to the interleaving method is that it has to oscillate between two samples, which produces a waveform equal to the sample playback rate. The waveform is independent of the dynamic range, so it remains constant as the dynamic range increases. The result is the avaeraging method will produce superior results on systems with greater dynamic range. Perhaps the best thing about the audio techniques demonstrated by interplay.c is that they are not limited to the Amiga architecture. In fact, you can use interleaving and averaging with any system that supports the variable speed playback of digitally sampled audio. These methods will work not only in the current generation of Amigas but in any future system that support digital audio, although as the dynamic range increases, the additive method will provide superior sound quality. [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node04B4.html.txt:1:audio.device/CMD_STOP ]" border=0> NAME CMD_STOP -- stop device processing (like ^S) FUNCTION CMD_STOP is a standard command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct, CMD_STOP immediately stops any writes (CMD_WRITE) in progress; otherwise, CMD_STOP returns an error (ADIOERR_NOALLOCATION). CMD_WRITE queues up writes to a stopped channel until CMD_START starts the channel or CMD_RESET resets the channel. CMD_STOP is synchronous and only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. Do not use CMD_STOP in interrupt code at interrupt level 5 or higher. INPUTS mn_ReplyPort- pointer to message port that receives I/O request after if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to stop (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for CMD_STOP io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channels successfully stopped (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node04AF.html.txt:1:audio.device/CMD_CLEAR ]" border=0> NAME CMD_CLEAR -- throw away internal caches FUNCTION CMD_CLEAR is a standard command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct, CMD_CLEAR does nothing; otherwise, CMD_CLEAR returns an error (ADIOERR_NOALLOCATION). CMD_CLEAR is synchronous and only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. INPUTS mn_ReplyPort- pointer to message port that receives I/O request after if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to clear (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for CMD_CLEAR io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command OUTPUTS io_Unit - bit map of channels successfully cleared (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node04A6.html.txt:1:audio.device/ADCMD_ALLOCATE ]" border=0> ADCMD_ALLOCATE -- allocate a set of audio channels FUNCTION ADCMD_ALLOCATE is a command that allocates multiple audio channels. ADCMD_ALLOCATE takes an array of possible channel combinations (ioa_Data) and an allocation precedence (ln_Pri) and tries to allocate one of the combinations of channels. If the channel combination array is zero length (ioa_Length), the allocation succeeds; otherwise, ADCMD_ALLOCATE checks each combination, one at a time, in the specified order, to find one combination that does not require ADCMD_ALLOCATE to steal allocated channels. If it must steal allocated channels, it uses the channel combination that steals the lowest precedence channels. ADCMD_ALLOCATE cannot steal a channel of equal or greater precedence than the allocation precedence (ln_Pri). If it fails to allocate any channel combination and the no-wait flag (ADIOF_NOWAIT) is set ADCMD_ALLOCATE returns a zero in the unit field of the I/O request (io_Unit) and an error (IOERR_ALLOCFAILED). If the no-wait flag is clear, it places the I/O request in a list that tries to allocate again whenever ADCMD_FREE frees channels or ADCMD_SETPREC lowers the channels' precedences. If the allocation is successful, ADCMD_ALLOCATE checks if any channels are locked (ADCMD_LOCK) and if so, replies (ReplyMsg) the lock I/O request with an error (ADIOERR_CHANNELSTOLEN). Then it places the allocation I/O request in a list waiting for the locked channels to be freed. When all the allocated channels are un-locked, ADCMD_ALLOCATE: . resets (CMD_RESET) the allocated channels, . generates a new allocation key (ioa_AllocKey), if it is zero, . copies the allocation key into each of the allocated channels . copies the allocation precedence into each of the allocated channels, and . copies the channel bit map into the unit field of the I/O request. If channels are allocated with a non-zero allocation key, ADCMD_ALLOCATE allocates with that same key; otherwise, it generates a new and unique key. ADCMD_ALLOCATE is synchronous: . if the allocation succeeds and there are no locked channels to be stolen, or . if the allocation fails and the no-wait flag is set. In either case, ADCMD_ALLOCATE only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear; otherwise, the allocation is asynchronous, so it clears the quick flag and replies the I/O request after the allocation is finished. If channels are stolen, all audio device commands return an error (IOERR_NOALLOCATION) when the former user tries to use them again. Do not use ADCMD_ALLOCATE in interrupt code. If you decide to store directly to the audio hardware registers, you must either lock the channels you've allocated, or set the precedence to maximum (ADALLOC_MAXPREC) to prevent the channels from being stolen. Under all circumstances, unless channels are stolen, you must free (ADCMD_FREE) all allocated channels when you are finished using them. INPUTS ln_Pri - allocation precedence (-128 thru 127) mn_ReplyPort- pointer to message port that receives I/O request after the allocation completes is asynchronous or quick flag (ADIOF_QUICK) is set io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Command - command number for ADCMD_ALLOCATE io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request (SET) only reply I/O request only if asynchronous (see above text) ADIOF_NOWAIT- (CLEAR) if allocation fails, wait till is succeeds (SET) if allocation fails, return error (ADIOERR_ALLOCFAILED) ioa_AllocKey- allocation key, zero to generate new key; otherwise, it must be set by (or copied from I/O block set by) OpenDevice function or previous ADCMD_ALLOCATE command ioa_Data - pointer to channel combination options (byte array, bits 0 thru 3 correspond to channels 0 thru 3) ioa_Length - length of the channel combination option array (0 thru 16, 0 always succeeds) OUTPUTS io_Unit - bit map of successfully allocated channels (bits 0 thru 3 correspond to channels 0 thru 3) io_Flags - IOF_QUICK flag cleared if asynchronous (see above text) io_Error - error number: 0 - no error ADIOERR_ALLOCFAILED - allocation failed ioa_AllocKey- allocation key, set to a unique number if passed a zero and command succeeds [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node04A4.html.txt:1:audio.doc ]" border=0> AbortIO() ADCMD_PERVOL CMD_CLEAR CMD_STOP ADCMD_ALLOCATE ADCMD_SETPREC CMD_FLUSH CMD_UPDATE ADCMD_FINISH ADCMD_WAITCYCLE CMD_READ CMD_WRITE ADCMD_FREE BeginIO() CMD_RESET Expunge() ADCMD_LOCK CloseDevice() CMD_START OpenDevice() [Back to Amiga Developer Docs ]
AmigaMail_Vol2_guide/node013E.html.txt:1:Level 1 Minimum Requirements ]" border=0> 1. No program crashes. The application should not crash, guru or otherwise cease to be functional. Test, retest and test again till you are sure your application is robust. 2. No logic or flow errors. The application cannot take a path other than the one requested or expected by the user. For example, if the user asks for a map, but instead gets a picture of a tree, a logic or flow error has occurred. 3. All images presented should be free of error and look clean. For example, a title should not have a garbled picture or a video sequence that exhibits solarization, i.e., a color picture that looks like a negative. 4. No low quality images. All still images should be high quality, preferably digitized interlaced HAM images. Drawings or animations should be detailed and free of major color banding. All still images should be overscanned unless a conscious effort is made to provide a colored border. 5. User interface. The program should follow generally accepted CDTV interface rules including: A button for action, B button for backup, arrow keys move in direction of arrow. Single click to select an object. Use highlighted hitboxes rather than a pointer where possible. Highlighted hitboxes should be accessible by cursor keys in any direction. If a pointer is used for products with invisible hot boxes or for special purposes such as coloring, the pointer should change when it is over an invisible hot box and be in a form relevant to the application (paint brush, wand, etc.). Numbered items should allow use of the numeric keypad on the controller. Selectable items should stand out (e.g., 3D buttons) from non-selectable items, and they should give audio/visual feedback when selected. Selectable items should give appropriate, consistent, and predictable results. There should be no references to a computer keyboard (e.g., F1 key). 6. The application should look good on any television. This means you should buy a cheap television for testing. 7. There should be no signs of AmigaDOS. Examples include the AmigaDOS cursor, Workbench screen, system requesters, sleep icon, pull down menus, flashing title bar, front/back gadgets, or jargon (x memory free, loading next module, etc.). 8. Efforts must be made to reduce perceived boot-up time. The titlescreen should appear within five seconds of the appearance of the CDTV Interactive Multimedia logo. (See Discis' products) The program should show a title screen before doing anything else. It should not show CLI, Workbench, or any pointer. 9. It must have a screen blanker tied to preferences. We recommend the screen blanker supplied as part of the OS. 10. Applications must work under AmigaDOS 1.3 and 2.0 in both NTSC and PAL. Programs should be able to successfully pass enforcer and mungwall testing. 11. The program must be designed for use on a PAL or NTSC TV, which means care must be taken in regard to all graphic elements (fonts, symbols, pictures, animations, video) with respect to size, style, color combinations, and contrast. Test your applications on those two environments, not just with a monitor and one of the two standards. Specific suggestions include: Fonts should be simple with no thin lines, anti-aliased, easy to read on a television and at least 20 point size. Text should generally be highly contrasted to its background. Text should have borders or drop shadows to make it more readable. Don't use pure colors (R, G, B values should be less than or equal to 13 out of a range of 0--15) because they bleed on television sets. Be careful of the colors used as some colors show up very differently on NTSC versus PAL. For example, deep red in NTSC comes out pale pink in PAL. The only way to find this out is to test on both systems. Avoid stark contrasts when using thin horizontal lines since this will not look good in an interlaced medium (TV), and avoid single pixel horizontal lines entirely. Do not base instructions solely on color, i.e., don't state ``Pick the orange button'' since TV sets will be adjusted differently. This could also be a problem for colorblind users. There should be no more than nine selectable (by cursor or by pointer) items on a screen unless the individual items are recognizable because they are part of a set (i.e., alphabet, numbers, states). Nine items fit well with the font size required for television. 12. Products must not substitute repetitiveness for depth by reusing the same elements in different places. If a product is perceptually redundant, it is boring. For example, using a passage from Beethoven's Piano Concerto No. 5 as an example of his music, and as an example of how a piano sounds, and as an example of a piano concerto is a lack of depth. 13. Eliminate all spelling and grammatical errors; people will not want to use a product, especially an education product, if they cannot trust something elementary like its spelling. Run your text through a spell checker and a grammar checker. Some of these titles are available in UK English or American English only, and these are acceptable, at least for the initial shipment. 14. Programs should reboot when the disc is removed unless the program disc needs to be removed for the product to be usable (CD-Remix). The program should reboot when the eject button is pushed, and the reboot should occur even if the disk is being accessed or Amiga audio is playing. 15. Sound quality should match the application requirement. Use Amiga sounds for audio feedback; CD-DA for game background, dramatic intro music and other sections designed to evoke an emotional response. All sounds should be clear and free from hiss or other extraneous problems. Speech must be ungarbled and unclipped and digitized at a reasonable level or be CD-DA. 16. Volume levels of speech, music, and sound effects should be uniform throughout the product. All audio must come through both channels unless there is a compelling reason to do otherwise. Note that compelling does not mean being unwilling to take the time to code so that the sound comes through both channels nor does it mean that your authoring system only works with one channel. Compelling does mean trying to add depth to the sound by having one person come through the right channel and another through the left channel. 17. Interruptability. All titles need to be interruptable at any time, including title and credit screens, introduction, during accesses, or animations. 18. Products must use preferences for language selections. Unless the language chosen in preferences is unavailable, the user should not normally see language selection screens. 19. All programs that can save to a floppy must be able to format a disk. 20. All programs should test for joystick/mouse mode. If the controller is not in the proper mode, it should ask the user to change modes. 21. Programs should disable keys that are not functional in the product. Typically this means disabling the audio keys for CD control. 22. Controller responsiveness. The product should not queue up button presses, it should react and give feedback immediately, and any cursor or highlight should move quickly enough for that specific application. In many cases, if a pointer is used it should include an accelerator feature. If a user feels compelled to repeat an operation because there is no response, the application is at fault. 23. The products should not have any dead time, i.e., time when nothing is occurring. Accesses should first give audio and visual feedback that a selection has been made, then have a transition of some sort, then begin the load during the transition. The transition interlude can consist of music, color cycling, a voice over, a fade to a colored screen, or in some way distract the user. A sleep or load symbol is generally insufficient to improve the perception. 24. Test that your product works properly with a trackball and a mouse. 25. They should also not be adversely affected by the presence of video peripherals such as genlocks. [Back to Amiga Developer Docs ]
AmigaMail_Vol2_guide/node0141.html.txt:1:Level 2 Quality: The Next Standard ]" border=0> In addition to the requirements of the Level One, products need to be compelling enough to compete successfully in the marketplace. 32. All titles must have an important and distinguishing value over doing the product on magnetic media, or by book, or by cassette. Products should have greater detail, more choices, more ``sizzle'', be easier to use, or be faster to perform a function. Ports from another platform--including the Amiga--must be enhanced (music, speech, additional video, more choices, etc.). An example of an excellent port is SimCity which added digital audio and rewrote the user interface to take advantage of the numeric keypad on the IR controller. 33. Timely response is important. On a multitasking operating system, the time that elapses from when a selection is made till the activity begins should be no more than three seconds. This is part perception (i.e., start showing a graphic change while still loading), part disk organization (to speed access times), and part programming (sometimes things can be cached or optimized). (Asterix appears to have achieved this goal, so it is therefore possible.) To reiterate, first audio/visual feedback, then some type of transition interlude which lasts no longer than three seconds, then the desired result. For very long searches that cannot be done in a short period of time, inform the user of the progress of the search. Options include putting up a screen and start listing ``hits'' or showing a ``gas gauge'' depicting the progress of a search. 34. Multimedia elements should be comparable to video or cartoons viewed on TV. These elements (animations, speech, music, sounds, video) should be streamed from disk so that they can be more in-depth and longer in duration. The animations should normally be 3 dimensional and change focus (i.e., background, perspective), not limited to a static background screen. 35. Educational titles and adventure type recreational products need to have a depth of interactivity options. For instance, if a character is walking down a street, the user should be able to go down alleyways, into buildings, etc. Each screen or in each section should have more than one (and more than two!) things that can be done. These options should include non-linear choices, i.e., being able to jump around. Linear choices are really no choices at all because you must follow a prescribed path. 36. Educational titles should have some type of testing function to allow you to examine your progress in a section. The Bookmark feature should be used if appropriate (e.g., game scores, place in a book, tests, etc.). 37. Reference titles should allow numbers and spaces to be input for searches. All reference titles should support searches on keywords in body or title, and not be just an alphabetized index of options (similar to the index of a book). They should also have the Bookmark feature using Non-Volatile RAM (NVR) to save search criteria and possibly the resultant elements. 38. Recreational titles should use continuous streamed animations and CD audio for background. They should be able to save game states and high scores using NVR. 39. Possible suggestions: Online help Templates to fit on top of the IR controller to simplify the buttons for complex products (i.e., flight simulator). Optionally viewable demo commercials of other products. Hardware add-ons (a la Nintendo). Supply a formatted disk (or at least a disk label) if the product can use a floppy. [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node0556.html.txt:1:2.0 IncludeXREF: D ]" border=0> da_BootPoint unsigned short int in struct DiagArea +0x0006 libraries/configregs.h : *242 da_Config unsigned char in struct DiagArea +0x0000 libraries/configregs.h : *238 da_DiagPoint unsigned short int in struct DiagArea +0x0004 libraries/configregs.h : *241 da_Flags unsigned char in struct DiagArea +0x0001 libraries/configregs.h : *239 da_Name unsigned short int in struct DiagArea +0x0008 libraries/configregs.h : *243 da_Reserved01 unsigned short int in struct DiagArea +0x000a libraries/configregs.h : *247 da_Reserved02 unsigned short int in struct DiagArea +0x000c libraries/configregs.h : *248 da_Size unsigned short int in struct DiagArea +0x0002 libraries/configregs.h : *240 dat_Flags unsigned char in struct DateTime +0x000d dos/datetime.h : *30 dat_Format unsigned char in struct DateTime +0x000c dos/datetime.h : *29 dat_Stamp struct DateStamp(size 0x000c bytes) in struct DateTime +0x0000 dos/datetime.h : *28 dat_StrDate pointer to unsigned char in struct DateTime +0x0012 dos/datetime.h : *32 dat_StrDay pointer to unsigned char in struct DateTime +0x000e dos/datetime.h : *31 dat_StrTime pointer to unsigned char in struct DateTime +0x0016 dos/datetime.h : *33 dataa unsigned short int in struct SpriteDef +0x0004 hardware/custom.h : *119 datab unsigned short int in struct SpriteDef +0x0006 hardware/custom.h : *120 dbf function returning "LONG" libraries/mathffp.h : *78 dd_CmdBytes pointer to void in struct DeviceData +0x002e devices/prtbase.h : *56 dd_CmdVectors pointer to void in struct DeviceData +0x002a devices/prtbase.h : *55 dd_CurrentX long int in struct OldDrawerData +0x0030 workbench/workbench.h : *46 dd_CurrentX long int in struct DrawerData +0x0030 workbench/workbench.h : *54 dd_CurrentY long int in struct OldDrawerData +0x0034 workbench/workbench.h : *47 dd_CurrentY long int in struct DrawerData +0x0034 workbench/workbench.h : *55 dd_Device struct Library(size 0x0022 bytes) in struct DeviceData +0x0000 devices/prtbase.h : *52 dd_ExecBase pointer to void in struct DeviceData +0x0026 devices/prtbase.h : *54 dd_Flags unsigned long int in struct DrawerData +0x0038 workbench/workbench.h : *56 dd_Library struct Library(size 0x0022 bytes) in struct Device +0x0000 exec/devices.h : *27 dd_NewWindow struct NewWindow(size 0x0030 bytes) in struct OldDrawerData +0x0000 workbench/workbench.h : *45 dd_NewWindow struct NewWindow(size 0x0030 bytes) in struct DrawerData +0x0000 workbench/workbench.h : *53 dd_NumCommands unsigned short int in struct DeviceData +0x0032 devices/prtbase.h : *57 dd_Segment pointer to void in struct DeviceData +0x0022 devices/prtbase.h : *53 dd_ViewModes unsigned short int in struct DrawerData +0x003c workbench/workbench.h : *57 ddfstop unsigned short int in struct Custom +0x0094 hardware/custom.h : *91 ddfstrt unsigned short int in struct Custom +0x0092 hardware/custom.h : *90 de_Baud unsigned long int in struct DosEnvec +0x0044 dos/filehandler.h : *49 de_BlocksPerTrack unsigned long int in struct DosEnvec +0x0014 dos/filehandler.h : *35 de_BootBlocks unsigned long int in struct DosEnvec +0x004c dos/filehandler.h : *51 de_BootPri long int in struct DosEnvec +0x003c dos/filehandler.h : *45 de_BufMemType unsigned long int in struct DosEnvec +0x0030 dos/filehandler.h : *42 de_Control unsigned long int in struct DosEnvec +0x0048 dos/filehandler.h : *50 de_DosType unsigned long int in struct DosEnvec +0x0040 dos/filehandler.h : *46 de_HighCyl unsigned long int in struct DosEnvec +0x0028 dos/filehandler.h : *40 de_Interleave unsigned long int in struct DosEnvec +0x0020 dos/filehandler.h : *38 de_LowCyl unsigned long int in struct DosEnvec +0x0024 dos/filehandler.h : *39 de_Mask unsigned long int in struct DosEnvec +0x0038 dos/filehandler.h : *44 de_MaxTransfer unsigned long int in struct DosEnvec +0x0034 dos/filehandler.h : *43 de_NumBuffers unsigned long int in struct DosEnvec +0x002c dos/filehandler.h : *41 de_PreAlloc unsigned long int in struct DosEnvec +0x001c dos/filehandler.h : *37 de_Reserved unsigned long int in struct DosEnvec +0x0018 dos/filehandler.h : *36 de_SecOrg unsigned long int in struct DosEnvec +0x0008 dos/filehandler.h : *32 de_SectorPerBlock unsigned long int in struct DosEnvec +0x0010 dos/filehandler.h : *34 de_SizeBlock unsigned long int in struct DosEnvec +0x0004 dos/filehandler.h : *31 de_Surfaces unsigned long int in struct DosEnvec +0x000c dos/filehandler.h : *33 de_TableSize unsigned long int in struct DosEnvec +0x0000 dos/filehandler.h : *30 default_monitor pointer to struct MonitorSpec in struct GfxBase +0x018e graphics/gfxbase.h : *87 deniseid unsigned short int in struct Custom +0x007c hardware/custom.h : *81 detailPen #define DETAILPEN = 0x00000000 intuition/iobsolete.h : *261 dfh_DF struct Node(size 0x000e bytes) in struct DiskFontHeader +0x0000 libraries/diskfont.h : *72 dfh_FileID unsigned short int in struct DiskFontHeader +0x000e libraries/diskfont.h : *73 dfh_Name array [32] of char in struct DiskFontHeader +0x0016 libraries/diskfont.h : *76 dfh_Revision unsigned short int in struct DiskFontHeader +0x0010 libraries/diskfont.h : *74 dfh_Segment long int in struct DiskFontHeader +0x0012 libraries/diskfont.h : *75 dfh_TF struct TextFont(size 0x0034 bytes) in struct DiskFontHeader +0x0036 libraries/diskfont.h : *77 dfh_TagList #define dfh_Segment libraries/diskfont.h : *82 dg_BufMemType unsigned long int in struct DriveGeometry +0x0018 devices/trackdisk.h : *144 dg_CylSectors unsigned long int in struct DriveGeometry +0x000c devices/trackdisk.h : *141 dg_Cylinders unsigned long int in struct DriveGeometry +0x0008 devices/trackdisk.h : *140 dg_DeviceType unsigned char in struct DriveGeometry +0x001c devices/trackdisk.h : *146 dg_Flags unsigned char in struct DriveGeometry +0x001d devices/trackdisk.h : *147 dg_Heads unsigned long int in struct DriveGeometry +0x0010 devices/trackdisk.h : *142 dg_Reserved unsigned short int in struct DriveGeometry +0x001e devices/trackdisk.h : *148 dg_SectorSize unsigned long int in struct DriveGeometry +0x0000 devices/trackdisk.h : *138 dg_TotalSectors unsigned long int in struct DriveGeometry +0x0004 devices/trackdisk.h : *139 dg_TrackSectors unsigned long int in struct DriveGeometry +0x0014 devices/trackdisk.h : *143 di_DevInfo long int in struct DosInfo +0x0004 dos/dosextens.h : *277 di_DevLock struct SignalSemaphore(size 0x002e bytes) in struct DosInfo +0x0014 dos/dosextens.h : *281 di_Devices long int in struct DosInfo +0x0008 dos/dosextens.h : *278 di_EntryLock struct SignalSemaphore(size 0x002e bytes) in struct DosInfo +0x0042 dos/dosextens.h : *282 di_Handlers long int in struct DosInfo +0x000c dos/dosextens.h : *279 di_McName long int in struct DosInfo +0x0000 dos/dosextens.h : *275 di_NetHand pointer to void in struct DosInfo +0x0010 dos/dosextens.h : *280 di_ResList #define di_McName dos/dosextens.h : *276 diagstrt array [4] of unsigned short int in struct copinit +0x000c graphics/copper.h : *96 diwhigh unsigned short int in struct Custom +0x01e4 hardware/custom.h : *141 diwstart array [4] of unsigned short int in struct copinit +0x0004 graphics/copper.h : *95 diwstop unsigned short int in struct Custom +0x0090 hardware/custom.h : *89 diwstrt unsigned short int in struct Custom +0x008e hardware/custom.h : *88 dl_A2 long int in struct DosLibrary +0x002a dos/dosextens.h : *232 dl_A5 long int in struct DosLibrary +0x002e dos/dosextens.h : *233 dl_A6 long int in struct DosLibrary +0x0032 dos/dosextens.h : *234 dl_DiskType long int in struct DeviceList +0x0020 dos/dosextens.h : *338 dl_Errors pointer to struct ErrorString in struct DosLibrary +0x0036 dos/dosextens.h : *235 dl_GV pointer to void in struct DosLibrary +0x0026 dos/dosextens.h : *231 dl_Lock long int in struct DeviceList +0x000c dos/dosextens.h : *335 dl_LockList long int in struct DeviceList +0x001c dos/dosextens.h : *337 dl_Name long int in struct DeviceList +0x0028 dos/dosextens.h : *340 dl_Next long int in struct DeviceList +0x0000 dos/dosextens.h : *332 dl_Root pointer to struct RootNode in struct DosLibrary +0x0022 dos/dosextens.h : *230 dl_Task pointer to struct MsgPort in struct DeviceList +0x0008 dos/dosextens.h : *334 dl_TimeReq pointer to struct timerequest in struct DosLibrary +0x003a dos/dosextens.h : *236 dl_Type long int in struct DeviceList +0x0004 dos/dosextens.h : *333 dl_UtilityBase pointer to struct Library in struct DosLibrary +0x003e dos/dosextens.h : *237 dl_VolumeDate struct DateStamp(size 0x000c bytes) in struct DeviceList +0x0010 dos/dosextens.h : *336 dl_lib struct Library(size 0x0022 bytes) in struct DosLibrary +0x0000 dos/dosextens.h : *229 dl_unused long int in struct DeviceList +0x0024 dos/dosextens.h : *339 dmacon unsigned short int in struct Custom +0x0096 hardware/custom.h : *92 dmaconr unsigned short int in struct Custom +0x0002 hardware/custom.h : *29 dn_GlobalVec long int in struct DeviceNode +0x0024 dos/filehandler.h : *114 dn_Handler long int in struct DeviceNode +0x0010 dos/filehandler.h : *108 dn_Lock long int in struct DeviceNode +0x000c dos/filehandler.h : *107 dn_Name long int in struct DeviceNode +0x0028 dos/filehandler.h : *122 dn_Next long int in struct DeviceNode +0x0000 dos/filehandler.h : *102 dn_Priority long int in struct DeviceNode +0x0018 dos/filehandler.h : *110 dn_SegList long int in struct DeviceNode +0x0020 dos/filehandler.h : *112 dn_StackSize unsigned long int in struct DeviceNode +0x0014 dos/filehandler.h : *109 dn_Startup long int in struct DeviceNode +0x001c dos/filehandler.h : *111 dn_Task pointer to struct MsgPort in struct DeviceNode +0x0008 dos/filehandler.h : *104 dn_Type unsigned long int in struct DeviceNode +0x0004 dos/filehandler.h : *103 do_CurrentX long int in struct DiskObject +0x003a workbench/workbench.h : *69 do_CurrentY long int in struct DiskObject +0x003e workbench/workbench.h : *70 do_DefaultTool pointer to char in struct DiskObject +0x0032 workbench/workbench.h : *67 do_DrawerData pointer to struct DrawerData in struct DiskObject +0x0042 workbench/workbench.h : *71 do_Gadget struct Gadget(size 0x002c bytes) in struct DiskObject +0x0004 workbench/workbench.h : *65 do_Magic unsigned short int in struct DiskObject +0x0000 workbench/workbench.h : *63 do_StackSize long int in struct DiskObject +0x004a workbench/workbench.h : *73 do_ToolTypes pointer to pointer to char in struct DiskObject +0x0036 workbench/workbench.h : *68 do_ToolWindow pointer to char in struct DiskObject +0x0046 workbench/workbench.h : *72 do_Type unsigned char in struct DiskObject +0x0030 workbench/workbench.h : *66 do_Version unsigned short int in struct DiskObject +0x0002 workbench/workbench.h : *64 do_monitor pointer to function returning int in struct SpecialMonitor +0x001a graphics/monitor.h : *146 dol_AssignName pointer to unsigned char in struct (no tag) +0x0000 dos/dosextens.h : *385 dol_DiskType long int in struct (no tag) +0x0010 dos/dosextens.h : *381 dol_GlobVec long int in struct (no tag) +0x0014 dos/dosextens.h : *373 dol_Handler long int in struct (no tag) +0x0000 dos/dosextens.h : *368 dol_List pointer to struct AssignList in struct (no tag) +0x0004 dos/dosextens.h : *386 dol_Lock long int in struct DosList +0x000c dos/dosextens.h : *365 dol_LockList long int in struct (no tag) +0x000c dos/dosextens.h : *380 dol_Name long int in struct DosList +0x0028 dos/dosextens.h : *391 dol_Next long int in struct DosList +0x0000 dos/dosextens.h : *362 dol_Priority long int in struct (no tag) +0x0008 dos/dosextens.h : *370 dol_SegList long int in struct (no tag) +0x0010 dos/dosextens.h : *372 dol_StackSize long int in struct (no tag) +0x0004 dos/dosextens.h : *369 dol_Startup unsigned long int in struct (no tag) +0x000c dos/dosextens.h : *371 dol_Task pointer to struct MsgPort in struct DosList +0x0008 dos/dosextens.h : *364 dol_Type long int in struct DosList +0x0004 dos/dosextens.h : *363 dol_VolumeDate struct DateStamp(size 0x000c bytes) in struct (no tag) +0x0000 dos/dosextens.h : *379 dol_assign struct (no tag) (size 0x0008 bytes) in union (no tag) +0x0000 dos/dosextens.h : *387 dol_handler struct (no tag) (size 0x0018 bytes) in union (no tag) +0x0000 dos/dosextens.h : *376 dol_misc union (no tag) (size 0x0018 bytes) in struct DosList +0x0010 dos/dosextens.h : *389 dol_volume struct (no tag) (size 0x0014 bytes) in union (no tag) +0x0000 dos/dosextens.h : *382 dp_Action #define dp_Type dos/dosextens.h : *124 dp_Arg1 long int in struct DosPacket +0x0014 dos/dosextens.h : *128 dp_Arg2 long int in struct DosPacket +0x0018 dos/dosextens.h : *129 dp_Arg3 long int in struct DosPacket +0x001c dos/dosextens.h : *130 dp_Arg4 long int in struct DosPacket +0x0020 dos/dosextens.h : *131 dp_Arg5 long int in struct DosPacket +0x0024 dos/dosextens.h : *132 dp_Arg6 long int in struct DosPacket +0x0028 dos/dosextens.h : *133 dp_Arg7 long int in struct DosPacket +0x002c dos/dosextens.h : *134 dp_BufAddr #define dp_Arg1 dos/dosextens.h : *127 dp_Link pointer to struct Message in struct DosPacket +0x0000 dos/dosextens.h : *111 dp_Port pointer to struct MsgPort in struct DosPacket +0x0004 dos/dosextens.h : *112 dp_Res1 long int in struct DosPacket +0x000c dos/dosextens.h : *117 dp_Res2 long int in struct DosPacket +0x0010 dos/dosextens.h : *121 dp_Status #define dp_Res1 dos/dosextens.h : *125 dp_Status2 #define dp_Res2 dos/dosextens.h : *126 dp_Type long int in struct DosPacket +0x0008 dos/dosextens.h : *114 dr_CiaResource pointer to struct Library in struct DiscResource +0x002c resources/disk.h : *56 dr_CurrTask pointer to struct Task in struct DiscResource +0x0090 resources/disk.h : *62 dr_Current pointer to struct DiscResourceUnit in struct DiscResource +0x0022 resources/disk.h : *52 dr_DiscBlock struct Interrupt(size 0x0016 bytes) in struct DiscResource +0x004e resources/disk.h : *59 dr_DiscSync struct Interrupt(size 0x0016 bytes) in struct DiscResource +0x0064 resources/disk.h : *60 dr_Flags unsigned char in struct DiscResource +0x0026 resources/disk.h : *53 dr_Index struct Interrupt(size 0x0016 bytes) in struct DiscResource +0x007a resources/disk.h : *61 dr_Library struct Library(size 0x0022 bytes) in struct DiscResource +0x0000 resources/disk.h : *51 dr_SysLib pointer to struct Library in struct DiscResource +0x0028 resources/disk.h : *55 dr_UnitID array [4] of unsigned long int in struct DiscResource +0x0030 resources/disk.h : *57 dr_Waiting struct List(size 0x000e bytes) in struct DiscResource +0x0040 resources/disk.h : *58 dr_pad unsigned char in struct DiscResource +0x0027 resources/disk.h : *54 dri_Depth unsigned short int in struct DrawInfo +0x000c intuition/screens.h : *68 dri_Flags unsigned long int in struct DrawInfo +0x0012 intuition/screens.h : *75 dri_Font pointer to struct TextFont in struct DrawInfo +0x0008 intuition/screens.h : *67 dri_NumPens unsigned short int in struct DrawInfo +0x0002 intuition/screens.h : *64 dri_Pens pointer to unsigned short int in struct DrawInfo +0x0004 intuition/screens.h : *65 dri_Reserved array [7] of unsigned long int in struct DrawInfo +0x0016 intuition/screens.h : *76 dri_Resolution struct (no tag) (size 0x0004 bytes) in struct DrawInfo +0x000e intuition/screens.h : *73 dri_Version unsigned short int in struct DrawInfo +0x0000 intuition/screens.h : *63 dru_DiscBlock struct Interrupt(size 0x0016 bytes) in struct DiscResourceUnit +0x0014 resources/disk.h : *45 dru_DiscSync struct Interrupt(size 0x0016 bytes) in struct DiscResourceUnit +0x002a resources/disk.h : *46 dru_Index struct Interrupt(size 0x0016 bytes) in struct DiscResourceUnit +0x0040 resources/disk.h : *47 dru_Message struct Message(size 0x0014 bytes) in struct DiscResourceUnit +0x0000 resources/disk.h : *44 ds_Days long int in struct DateStamp +0x0000 dos/dos.h : *55 ds_Minute long int in struct DateStamp +0x0004 dos/dos.h : *56 ds_Tick long int in struct DateStamp +0x0008 dos/dos.h : *57 dskbytr unsigned short int in struct Custom +0x001a hardware/custom.h : *41 dskdat unsigned short int in struct Custom +0x0026 hardware/custom.h : *46 dskdatr unsigned short int in struct Custom +0x0008 hardware/custom.h : *32 dsklen unsigned short int in struct Custom +0x0024 hardware/custom.h : *45 dskpt pointer to void in struct Custom +0x0020 hardware/custom.h : *44 dsksync unsigned short int in struct Custom +0x007e hardware/custom.h : *82 dummy char in struct RastPort +0x001f graphics/rastport.h : *71 dvi_GlobVec long int in struct DevInfo +0x0024 dos/dosextens.h : *355 dvi_Handler long int in struct DevInfo +0x0010 dos/dosextens.h : *350 dvi_Lock long int in struct DevInfo +0x000c dos/dosextens.h : *349 dvi_Name long int in struct DevInfo +0x0028 dos/dosextens.h : *356 dvi_Next long int in struct DevInfo +0x0000 dos/dosextens.h : *346 dvi_Priority long int in struct DevInfo +0x0018 dos/dosextens.h : *352 dvi_SegList long int in struct DevInfo +0x0020 dos/dosextens.h : *354 dvi_StackSize long int in struct DevInfo +0x0014 dos/dosextens.h : *351 dvi_Startup long int in struct DevInfo +0x001c dos/dosextens.h : *353 dvi_Task pointer to void in struct DevInfo +0x0008 dos/dosextens.h : *348 dvi_Type long int in struct DevInfo +0x0004 dos/dosextens.h : *347 dvp_DevNode pointer to struct DosList in struct DevProc +0x000c dos/dosextens.h : *414 dvp_Flags unsigned long int in struct DevProc +0x0008 dos/dosextens.h : *413 dvp_Lock long int in struct DevProc +0x0004 dos/dosextens.h : *412 dvp_Port pointer to struct MsgPort in struct DevProc +0x0000 dos/dosextens.h : *411 DAC_BINDTIME #define 0x20 = 0x00000020 libraries/configregs.h : *264 DAC_BOOTTIME #define 0x30 = 0x00000030 libraries/configregs.h : *260 DAC_BUSWIDTH #define 0xC0 = 0x000000c0 libraries/configregs.h : *255 DAC_BYTEWIDE #define 0x40 = 0x00000040 libraries/configregs.h : *257 DAC_CONFIGTIME #define 0x10 = 0x00000010 libraries/configregs.h : *262 DAC_NEVER #define 0x00 = 0x00000000 libraries/configregs.h : *261 DAC_NIBBLEWIDE #define 0x00 = 0x00000000 libraries/configregs.h : *256 DAC_WORDWIDE #define 0x80 = 0x00000080 libraries/configregs.h : *258 DBLPF #define 0x400 = 0x00000400 graphics/display.h : *22 DBUFFER #define 0x04 = 0x00000004 graphics/rastport.h : *103 DBufPacket structure tag size 0x000c graphics/gels.h : *160, 230 DBuffer pointer to struct DBufPacket in struct Bob +0x001a graphics/gels.h : *160 DDB_AllBit #define 3 = 0x00000003 dos/dosasl.h : *113 DDB_Completed #define 2 = 0x00000002 dos/dosasl.h : *111 DDB_ExaminedBit #define 1 = 0x00000001 dos/dosasl.h : *109 DDB_PatternBit #define 0 = 0x00000000 dos/dosasl.h : *107 DDB_Single #define 4 = 0x00000004 dos/dosasl.h : *115 DDF_AllBit #define 8 = 0x00000008 dos/dosasl.h : *114 DDF_Completed #define 4 = 0x00000004 dos/dosasl.h : *112 DDF_ExaminedBit #define 2 = 0x00000002 dos/dosasl.h : *110 DDF_PatternBit #define 1 = 0x00000001 dos/dosasl.h : *108 DDF_Single #define 16 = 0x00000010 dos/dosasl.h : *116 DEADEND_ALERT #define 0x80000000 = 0x80000000 intuition/intuition.h : *1312 DEFARTIC #define 100 = 0x00000064 devices/narrator.h : *70 DEFAULTMOUSEQUEUE #define (5) = 0x00000005 intuition/intuition.h : *960 DEFAULT_MONITOR_ID #define 0x00000000 = 0x00000000 graphics/displayinfo.h : *147 DEFAULT_MONITOR_NAME #define "default.monitor" graphics/monitor.h : *65 DEFCENTRAL #define 0 = 0x00000000 devices/narrator.h : *71 DEFERREFRESH #define 0x8000 = 0x00008000 intuition/intuition.h : *206 DEFF0ENTHUS #define 32 = 0x00000020 devices/narrator.h : *73 DEFF0PERT #define 0 = 0x00000000 devices/narrator.h : *72 DEFFREQ #define 22200 = 0x000056b8 devices/narrator.h : *62 DEFMODE #define NATURALF0 = 0x00000000 devices/narrator.h : *69 DEFPITCH #define 110 = 0x0000006e devices/narrator.h : *59 DEFPRIORITY #define 100 = 0x00000064 devices/narrator.h : *74 DEFRATE #define 150 = 0x00000096 devices/narrator.h : *60 DEFSEX #define MALE = 0x00000000 devices/narrator.h : *68 DEFVOL #define 64 = 0x00000040 devices/narrator.h : *61 DELTAMOVE #define IDCMP_DELTAMOVE = 0x00100000 intuition/iobsolete.h : *134 DEPTHIMAGE #define (0x00L) = 0x00000000 intuition/imageclass.h : *101 DEST #define 0x100 = 0x00000100 hardware/blit.h : *58 DESTADDR #define u3.u4.u1.DestAddr graphics/copper.h : *50 DESTDATA #define u3.u4.u2.DestData graphics/copper.h : *52 DETAILPEN #define (0x0000) = 0x00000000 intuition/screens.h : *82 DEVICES_AUDIO_H #define devices/audio.h : *2 DEVICES_BOOTBLOCK_H #define devices/bootblock.h : *2 DEVICES_CIA_H #define 1 = 0x00000001 resources/cia.h : *2 DEVICES_CLIPBOARD_H #define devices/clipboard.h : *2 libraries/iffparse.h : 25 DEVICES_CONSOLE_H #define devices/console.h : *2 devices/conunit.h : 23 DEVICES_CONUNIT_H #define devices/conunit.h : *2 DEVICES_GAMEPORT_H #define devices/gameport.h : *2 DEVICES_HARDBLOCKS_H #define devices/hardblocks.h : *2 DEVICES_INPUTEVENT_H #define devices/inputevent.h : *2, 1 intuition/intuition.h : 47 DEVICES_INPUT_H #define devices/input.h : *2 DEVICES_KEYBOARD_H #define devices/keyboard.h : *2 DEVICES_KEYMAP_H #define devices/keymap.h : *2, 1 DEVICES_NARRATOR_H #define devices/narrator.h : *2 DEVICES_PARALLEL_H #define devices/parallel.h : *2 devices/prtbase.h : 34 DEVICES_PRINTER_H #define devices/printer.h : *2 DEVICES_PRTBASE_H #define devices/prtbase.h : *2 DEVICES_PRTGFX_H #define devices/prtgfx.h : *2 DEVICES_SCSIDISK_H #define devices/scsidisk.h : *2 DEVICES_SERIAL_H #define devices/serial.h : *2, 1 DEVICES_TIMER_H #define 1 = 0x00000001 devices/timer.h : *2, 1 devices/prtbase.h : 40 dos/dosextens.h : 27 intuition/preferences.h : 19 DEVICES_TRACKDISK_H #define devices/trackdisk.h : *2 DEV_ABORTIO #define (-36) = 0xffffffdc exec/io.h : *44 DEV_BEGINIO #define (-30) = 0xffffffe2 exec/io.h : *43 DE_BAUD #define 17 = 0x00000011 dos/filehandler.h : *78 DE_BLKSPERTRACK #define 5 = 0x00000005 dos/filehandler.h : *62 DE_BOOTBLOCKS #define 19 = 0x00000013 dos/filehandler.h : *80 DE_BOOTPRI #define 15 = 0x0000000f dos/filehandler.h : *74 DE_BUFMEMTYPE #define 12 = 0x0000000c dos/filehandler.h : *71 DE_CONTROL #define 18 = 0x00000012 dos/filehandler.h : *79 DE_DOSTYPE #define 16 = 0x00000010 dos/filehandler.h : *77 DE_INTERLEAVE #define 8 = 0x00000008 dos/filehandler.h : *65 DE_LOWCYL #define 9 = 0x00000009 dos/filehandler.h : *66 DE_MASK #define 14 = 0x0000000e dos/filehandler.h : *73 DE_MAXTRANSFER #define 13 = 0x0000000d dos/filehandler.h : *72 DE_MEMBUFTYPE #define 12 = 0x0000000c dos/filehandler.h : *69 DE_NUMBUFFERS #define 11 = 0x0000000b dos/filehandler.h : *68 DE_NUMHEADS #define 3 = 0x00000003 dos/filehandler.h : *60 DE_PREFAC #define 7 = 0x00000007 dos/filehandler.h : *64 DE_RESERVEDBLKS #define 6 = 0x00000006 dos/filehandler.h : *63 DE_SECORG #define 2 = 0x00000002 dos/filehandler.h : *59 DE_SECSPERBLK #define 4 = 0x00000004 dos/filehandler.h : *61 DE_SIZEBLOCK #define 1 = 0x00000001 dos/filehandler.h : *58 DE_TABLESIZE #define 0 = 0x00000000 dos/filehandler.h : *57 DE_UPPERCYL #define 10 = 0x0000000a dos/filehandler.h : *67 DFH_ID #define 0x0f80 = 0x00000f80 libraries/diskfont.h : *61 DFTCH_MASK #define 0xFF = 0x000000ff graphics/display.h : *37 DGB_REMOVABLE #define 0 = 0x00000000 devices/trackdisk.h : *165 DGF_REMOVABLE #define 1 = 0x00000001 devices/trackdisk.h : *166 DG_CDROM #define 5 = 0x00000005 devices/trackdisk.h : *157 DG_COMMUNICATION #define 9 = 0x00000009 devices/trackdisk.h : *161 DG_DIRECT_ACCESS #define 0 = 0x00000000 devices/trackdisk.h : *152 DG_MEDIUM_CHANGER #define 8 = 0x00000008 devices/trackdisk.h : *160 DG_OPTICAL_DISK #define 7 = 0x00000007 devices/trackdisk.h : *159 DG_PRINTER #define 2 = 0x00000002 devices/trackdisk.h : *154 DG_PROCESSOR #define 3 = 0x00000003 devices/trackdisk.h : *155 DG_SCANNER #define 6 = 0x00000006 devices/trackdisk.h : *158 DG_SEQUENTIAL_ACCESS #define 1 = 0x00000001 devices/trackdisk.h : *153 DG_UNKNOWN #define 31 = 0x0000001f devices/trackdisk.h : *162 DG_WORM #define 4 = 0x00000004 devices/trackdisk.h : *156 DHeight short int in struct ViewPort +0x001a graphics/view.h : *50 DIAB_630 #define 0x04 = 0x00000004 intuition/preferences.h : *196 DIAB_ADV_D25 #define 0x05 = 0x00000005 intuition/preferences.h : *197 DIAB_C_150 #define 0x06 = 0x00000006 intuition/preferences.h : *198 DIMENSIONS_MASK #define (BOUNDED_DIMENSIONS|ABSOLUTE_DIMENSIONS| PIXEL_DIMENSIONS|MULTIPLY_DIMENSIONS) = 0x000000f0 intuition/preferences.h : *265 DIPF_IS_BEAMSYNC #define 0x00000800 = 0x00000800 graphics/displayinfo.h : *88 DIPF_IS_DRAGGABLE #define 0x00000200 = 0x00000200 graphics/displayinfo.h : *86 DIPF_IS_DUALPF #define 0x00000002 = 0x00000002 graphics/displayinfo.h : *73 DIPF_IS_ECS #define 0x00000010 = 0x00000010 graphics/displayinfo.h : *80 DIPF_IS_EXTRAHALFBRITE #define 0x00001000 = 0x00001000 graphics/displayinfo.h : *90 DIPF_IS_GENLOCK #define 0x00000080 = 0x00000080 graphics/displayinfo.h : *83 DIPF_IS_HAM #define 0x00000008 = 0x00000008 graphics/displayinfo.h : *75 DIPF_IS_LACE #define 0x00000001 = 0x00000001 graphics/displayinfo.h : *72 DIPF_IS_PAL #define 0x00000020 = 0x00000020 graphics/displayinfo.h : *81 DIPF_IS_PANELLED #define 0x00000400 = 0x00000400 graphics/displayinfo.h : *87 DIPF_IS_PF2PRI #define 0x00000004 = 0x00000004 graphics/displayinfo.h : *74 DIPF_IS_SPRITES #define 0x00000040 = 0x00000040 graphics/displayinfo.h : *82 DIPF_IS_WB #define 0x00000100 = 0x00000100 graphics/displayinfo.h : *85 DISKINSERTED #define IDCMP_DISKINSERTED = 0x00008000 intuition/iobsolete.h : *129 DISKNAME #define "disk.resource" resources/disk.h : *102 DISKREMOVED #define IDCMP_DISKREMOVED = 0x00010000 intuition/iobsolete.h : *130 DISPLAYDUAL #define 0x0040 = 0x00000040 hardware/custom.h : *153 DISPLAYNAMELEN #define 32 = 0x00000020 graphics/displayinfo.h : *130, 135 DISPLAYPAL #define 0x0020 = 0x00000020 hardware/custom.h : *154 DITHERING_MASK #define (HALFTONE_DITHERING|FLOYD_DITHERING) = 0x00000600 intuition/preferences.h : *266 DIW_HORIZ_POS #define 0x7F = 0x0000007f graphics/display.h : *32 DIW_VRTCL_POS #define 0x1FF = 0x000001ff graphics/display.h : *33 DIW_VRTCL_POS_SHIFT #define 7 = 0x00000007 graphics/display.h : *34 DI_AVAIL_NOCHIPS #define 0x0001 = 0x00000001 graphics/displayinfo.h : *66 DI_AVAIL_NOMONITOR #define 0x0002 = 0x00000002 graphics/displayinfo.h : *67 DI_AVAIL_NOTWITHGENLOCK #define 0x0004 = 0x00000004 graphics/displayinfo.h : *68 DLT_DEVICE #define 0 = 0x00000000 dos/dosextens.h : *402 DLT_DIRECTORY #define 1 = 0x00000001 dos/dosextens.h : *403 DLT_LATE #define 3 = 0x00000003 dos/dosextens.h : *405 DLT_NONBINDING #define 4 = 0x00000004 dos/dosextens.h : *406 DLT_PRIVATE #define -1 = 0xffffffff dos/dosextens.h : *407 DLT_VOLUME #define 2 = 0x00000002 dos/dosextens.h : *404 DMAB_AUD0 #define 0 = 0x00000000 hardware/dmabits.h : *37 DMAB_AUD1 #define 1 = 0x00000001 hardware/dmabits.h : *38 DMAB_AUD2 #define 2 = 0x00000002 hardware/dmabits.h : *39 DMAB_AUD3 #define 3 = 0x00000003 hardware/dmabits.h : *40 DMAB_BLITHOG #define 10 = 0x0000000a hardware/dmabits.h : *47 DMAB_BLITTER #define 6 = 0x00000006 hardware/dmabits.h : *43 DMAB_BLTDONE #define 14 = 0x0000000e hardware/dmabits.h : *48 DMAB_BLTNZERO #define 13 = 0x0000000d hardware/dmabits.h : *49 DMAB_COPPER #define 7 = 0x00000007 hardware/dmabits.h : *44 DMAB_DISK #define 4 = 0x00000004 hardware/dmabits.h : *41 DMAB_MASTER #define 9 = 0x00000009 hardware/dmabits.h : *46 DMAB_RASTER #define 8 = 0x00000008 hardware/dmabits.h : *45 DMAB_SETCLR #define 15 = 0x0000000f hardware/dmabits.h : *36 DMAB_SPRITE #define 5 = 0x00000005 hardware/dmabits.h : *42 DMAF_ALL #define 0x01FF = 0x000001ff hardware/dmabits.h : *29 DMAF_AUD0 #define 0x0001 = 0x00000001 hardware/dmabits.h : *18 DMAF_AUD1 #define 0x0002 = 0x00000002 hardware/dmabits.h : *19 DMAF_AUD2 #define 0x0004 = 0x00000004 hardware/dmabits.h : *20 DMAF_AUD3 #define 0x0008 = 0x00000008 hardware/dmabits.h : *21 DMAF_AUDIO #define 0x000F = 0x0000000f hardware/dmabits.h : *17 DMAF_BLITHOG #define 0x0400 = 0x00000400 hardware/dmabits.h : *28 DMAF_BLITTER #define 0x0040 = 0x00000040 hardware/dmabits.h : *24 DMAF_BLTDONE #define 0x4000 = 0x00004000 hardware/dmabits.h : *33 DMAF_BLTNZERO #define 0x2000 = 0x00002000 hardware/dmabits.h : *34 DMAF_COPPER #define 0x0080 = 0x00000080 hardware/dmabits.h : *25 DMAF_DISK #define 0x0010 = 0x00000010 hardware/dmabits.h : *22 DMAF_MASTER #define 0x0200 = 0x00000200 hardware/dmabits.h : *27 DMAF_RASTER #define 0x0100 = 0x00000100 hardware/dmabits.h : *26 DMAF_SETCLR #define 0x8000 = 0x00008000 hardware/dmabits.h : *16 DMAF_SPRITE #define 0x0020 = 0x00000020 hardware/dmabits.h : *23 DMODECOUNT #define 0x0002 = 0x00000002 intuition/intuitionbase.h : *35 DMRequest pointer to struct Requester in struct Window +0x0028 intuition/intuition.h : *815 DOSFALSE #define (0L) = 0x00000000 dos/dos.h : *25 DOSNAME #define "dos.library" dos/dos.h : *20 DOSTRUE #define (-1L) = 0xffffffff dos/dos.h : *24 DOS_CLI #define 4 = 0x00000004 dos/dos.h : *241 DOS_DATETIME_H #define dos/datetime.h : *2 DOS_DOSASL_H #define dos/dosasl.h : *2 DOS_DOSEXTENS_H #define dos/dosextens.h : *2, 1 DOS_DOSHUNKS_H #define dos/doshunks.h : *2 DOS_DOSTAGS_H #define dos/dostags.h : *2 DOS_DOS_H #define dos/dos.h : *2, 1 dos/filehandler.h : 19 dos/record.h : 17 dos/datetime.h : 17 dos/dosasl.h : 25 libraries/dos.h : 15 resources/filesysres.h : 21 DOS_EXALLCONTROL #define 1 = 0x00000001 dos/dos.h : *238 DOS_EXALL_H #define dos/exall.h : *2 DOS_FIB #define 2 = 0x00000002 dos/dos.h : *239 DOS_FILEHANDLE #define 0 = 0x00000000 dos/dos.h : *237 DOS_FILEHANDLER_H #define dos/filehandler.h : *2 libraries/filehandler.h : 15 DOS_NOTIFY_H #define dos/notify.h : *2 DOS_RDARGS #define 5 = 0x00000005 dos/dos.h : *242 DOS_RDARGS_H #define dos/rdargs.h : *2 DOS_RECORD_H #define dos/record.h : *2 DOS_STDIO_H #define dos/stdio.h : *2 DOS_STDPKT #define 3 = 0x00000003 dos/dos.h : *240 DOS_VAR_H #define dos/var.h : *2 DOUBLE typedef double exec/types.h : *65 DOWNBACKGADGET #define 1 = 0x00000001 intuition/intuitionbase.h : *48 DOWNIMAGE #define (0x0DL) = 0x0000000d intuition/imageclass.h : *109 DPB_DEAD #define 3 = 0x00000003 devices/keymap.h : *70 DPB_MOD #define 0 = 0x00000000 devices/keymap.h : *68 DPF_DEAD #define 0x08 = 0x00000008 devices/keymap.h : *71 DPF_MOD #define 0x01 = 0x00000001 devices/keymap.h : *69 DP_2DFACSHIFT #define 4 = 0x00000004 devices/keymap.h : *74 DP_2DINDEXMASK #define 0x0f = 0x0000000f devices/keymap.h : *73 DRAFT #define 0x000 = 0x00000000 intuition/preferences.h : *164 DRAGGADGET #define 4 = 0x00000004 intuition/intuitionbase.h : *51 DRAWERDATAFILESIZE #define (sizeof(struct DrawerData)) = 0x0000003e workbench/workbench.h : *60 DRB_ACTIVE #define 7 = 0x00000007 resources/disk.h : *70 DRB_ALLOC0 #define 0 = 0x00000000 resources/disk.h : *66 DRB_ALLOC1 #define 1 = 0x00000001 resources/disk.h : *67 DRB_ALLOC2 #define 2 = 0x00000002 resources/disk.h : *68 DRB_ALLOC3 #define 3 = 0x00000003 resources/disk.h : *69 DRF_ACTIVE #define (1 resources/disk.h : *76 DRF_ALLOC0 #define (1 resources/disk.h : *72 DRF_ALLOC1 #define (1 resources/disk.h : *73 DRF_ALLOC2 #define (1 resources/disk.h : *74 DRF_ALLOC3 #define (1 resources/disk.h : *75 DRIF_NEWLOOK #define 0x00000001 = 0x00000001 intuition/screens.h : *79 DRIVE3_5 #define 1 = 0x00000001 devices/trackdisk.h : *203 DRIVE3_5_150RPM #define 3 = 0x00000003 devices/trackdisk.h : *205 DRIVE5_25 #define 2 = 0x00000002 devices/trackdisk.h : *204 DRI_VERSION #define (1) = 0x00000001 intuition/screens.h : *59 DRT_150RPM #define (0xAAAAAAAA) = 0xaaaaaaaa resources/disk.h : *123 DRT_37422D2S #define (0x55555555) = 0x55555555 resources/disk.h : *121 DRT_AMIGA #define (0x00000000) = 0x00000000 resources/disk.h : *120 DRT_EMPTY #define (0xFFFFFFFF) = 0xffffffff resources/disk.h : *122 DR_ALLOCUNIT #define (LIB_BASE - 0*LIB_VECTSIZE) = 0xfffffffa resources/disk.h : *105 DR_FREEUNIT #define (LIB_BASE - 1*LIB_VECTSIZE) = 0xfffffff4 resources/disk.h : *106 DR_GETUNIT #define (LIB_BASE - 2*LIB_VECTSIZE) = 0xffffffee resources/disk.h : *107 DR_GETUNITID #define (LIB_BASE - 4*LIB_VECTSIZE) = 0xffffffe2 resources/disk.h : *109 DR_GIVEUNIT #define (LIB_BASE - 3*LIB_VECTSIZE) = 0xffffffe8 resources/disk.h : *108 DR_LASTCOMM #define (DR_READUNITID) = 0xffffffdc resources/disk.h : *112 DR_READUNITID #define (LIB_BASE - 5*LIB_VECTSIZE) = 0xffffffdc resources/disk.h : *110 DSKDMAOFF #define 0x4000 = 0x00004000 resources/disk.h : *87 DSR_CPR #define 6 = 0x00000006 devices/console.h : *86 DTAG_DIMS #define 0x80001000 = 0x80001000 graphics/displayinfo.h : *38 DTAG_DISP #define 0x80000000 = 0x80000000 graphics/displayinfo.h : *37 DTAG_MNTR #define 0x80002000 = 0x80002000 graphics/displayinfo.h : *39 DTAG_NAME #define 0x80003000 = 0x80003000 graphics/displayinfo.h : *40 DTB_FUTURE #define 1 = 0x00000001 dos/datetime.h : *43 DTB_SUBST #define 0 = 0x00000000 dos/datetime.h : *41 DTF_FUTURE #define 2 = 0x00000002 dos/datetime.h : *44 DTF_SUBST #define 1 = 0x00000001 dos/datetime.h : *42 DT_DEV #define 0L = 0x00000000 rexx/rexxio.h : *73 DT_DIR #define 1L = 0x00000001 rexx/rexxio.h : *74 DT_VOL #define 2L = 0x00000002 rexx/rexxio.h : *75 DUALPF #define 0x0400 = 0x00000400 graphics/view.h : *96 DVPB_ASSIGN #define 1 = 0x00000001 dos/dosextens.h : *420 DVPB_UNLOCK #define 0 = 0x00000000 dos/dosextens.h : *418 DVPF_ASSIGN #define (1L dos/dosextens.h : *421 DVPF_UNLOCK #define (1L dos/dosextens.h : *419 DWidth short int in struct ViewPort +0x0018 graphics/view.h : *50 DamageList pointer to struct Region in struct Layer +0x009c graphics/clip.h : *60 DateStamp structure tag size 0x000c dos/dos.h : *54, 72 dos/dosextens.h : 247, 336, 379 dos/datetime.h : 28 DateTime structure tag size 0x001a dos/datetime.h : *27 Debug char in struct GfxBase +0x00a1 graphics/gfxbase.h : *41 DebugData pointer to void in struct ExecBase +0x0046 exec/execbase.h : *51 DebugEntry pointer to void in struct ExecBase +0x0042 exec/execbase.h : *50 DefaultFont pointer to struct TextFont in struct GfxBase +0x009a graphics/gfxbase.h : *38 DefaultTitle pointer to unsigned char in struct Screen +0x001a intuition/screens.h : *111 DefaultTitle pointer to unsigned char in struct NewScreen +0x0014 intuition/screens.h : *322 DefaultTitle pointer to unsigned char in struct ExtNewScreen +0x0014 intuition/screens.h : *353 DeniseMaxDisplayColumn unsigned short int in struct MonitorSpec +0x0026 graphics/monitor.h : *35 DeniseMinDisplayColumn unsigned short int in struct MonitorSpec +0x0052 graphics/monitor.h : *48 Depth unsigned char in struct BitMap +0x0005 graphics/gfx.h : *53 Depth short int in struct Image +0x0008 intuition/intuition.h : *625 Depth short int in struct NewScreen +0x0008 intuition/screens.h : *312 Depth short int in struct ExtNewScreen +0x0008 intuition/screens.h : *348 Depth short int in struct VSprite +0x001e graphics/gels.h : *100 Descendant pointer to struct Window in struct Window +0x0046 intuition/intuition.h : *844 DestAddr short int in union (no tag) +0x0000 graphics/copper.h : *37 DestData short int in union (no tag) +0x0000 graphics/copper.h : *42 DetailPen unsigned char in struct Window +0x0062 intuition/intuition.h : *859 DetailPen unsigned char in struct NewWindow +0x0008 intuition/intuition.h : *979 DetailPen unsigned char in struct ExtNewWindow +0x0008 intuition/intuition.h : *1049 DetailPen unsigned char in struct Screen +0x014a intuition/screens.h : *137 DetailPen unsigned char in struct NewScreen +0x000a intuition/screens.h : *314 DetailPen unsigned char in struct ExtNewScreen +0x000a intuition/screens.h : *349 DetailPen unsigned char in struct (no tag) +0x0000 intuition/cghooks.h : *53 DevInfo structure tag size 0x002c dos/dosextens.h : *345 DevProc structure tag size 0x0010 dos/dosextens.h : *410 Device structure tag size 0x0022 exec/devices.h : *26 exec/io.h : 22, 31 devices/clipboard.h : 45 devices/printer.h : 144, 158 DeviceData structure tag size 0x0034 devices/prtbase.h : *51, 66 DeviceList struct List(size 0x000e bytes) in struct ExecBase +0x015e exec/execbase.h : *88 DeviceList structure tag size 0x002c dos/dosextens.h : *331 DeviceNode structure tag size 0x002c dos/filehandler.h : *101 DiagArea structure tag size 0x000e libraries/configregs.h : *237 DimensionInfo structure tag size 0x0058 graphics/displayinfo.h : *92 DiscResource structure tag size 0x0094 resources/disk.h : *50 DiscResourceUnit structure tag size 0x0056 resources/disk.h : *43, 52 DiskFontHeader structure tag size 0x006a libraries/diskfont.h : *64 DiskObject structure tag size 0x004e workbench/workbench.h : *62 DispCount unsigned long int in struct ExecBase +0x011c exec/execbase.h : *66 DispCount short int in struct StringInfo +0x0012 intuition/intuition.h : *536 DispPos short int in struct StringInfo +0x000c intuition/intuition.h : *531 DisplayClip struct Rectangle(size 0x0008 bytes) in struct ViewPortExtra +0x001c graphics/view.h : *83 DisplayCompatible unsigned long int in struct MonitorSpec +0x0054 graphics/monitor.h : *49 DisplayFlags unsigned short int in struct GfxBase +0x00ce graphics/gfxbase.h : *53 DisplayID unsigned long int in struct QueryHeader +0x0004 graphics/displayinfo.h : *45 DisplayInfo structure tag size 0x0030 graphics/displayinfo.h : *50 DisplayInfoDataBase struct List(size 0x000e bytes) in struct MonitorSpec +0x0058 graphics/monitor.h : *50 DisplayInfoDataBase pointer to void in struct GfxBase +0x0196 graphics/gfxbase.h : *89 DisplayInfoDataBaseSemaphore struct SignalSemaphore(size 0x002e bytes) in struct MonitorSpec +0x0066 graphics/monitor.h : *51 DisplayInfoHandle "APTR" graphics/displayinfo.h : *33 DosEnvec structure tag size 0x0050 dos/filehandler.h : *29 DosInfo structure tag size 0x0070 dos/dosextens.h : *274 DosLibrary structure tag size 0x0042 dos/dosextens.h : *228 DosList structure tag size 0x002c dos/dosextens.h : *361, 414 DosPacket structure tag size 0x0030 dos/dosextens.h : *110, 143 DoubleClick struct timeval(size 0x0008 bytes) in struct Preferences +0x0014 intuition/preferences.h : *58 DrawCircle macro (4 arguments) graphics/gfxmacros.h : *43 DrawInfo structure tag (size 0x0032 bytes)in struct impDraw intuition/screens.h : *61 intuition/cghooks.h : 61 intuition/imageclass.h : 143, 161 DrawMode char in struct RastPort +0x001c graphics/rastport.h : *68 DrawMode unsigned char in struct IntuiText +0x0002 intuition/intuition.h : *573 DrawMode unsigned char in struct Border +0x0006 intuition/intuition.h : *602 DrawPath pointer to struct VSprite in struct VSprite +0x0008 graphics/gels.h : *81 DrawerData structure tag size 0x003e workbench/workbench.h : *52, 71 DriveGeometry structure tag size 0x0020 devices/trackdisk.h : *137 DspIns pointer to struct CopList in struct ViewPort +0x0008 graphics/view.h : *46 DxOffset short int in struct ViewPort +0x001c graphics/view.h : *51 DxOffset short int in struct View +0x000e graphics/view.h : *63 DyOffset short int in struct CopList +0x0020 graphics/copper.h : *74 DyOffset short int in struct ViewPort +0x001e graphics/view.h : *51 DyOffset short int in struct View +0x000c graphics/view.h : *63 [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node0326.html.txt:1:exec.library/AddIntServer ]" border=0> NAME AddIntServer -- add an interrupt server to a system server chain SYNOPSIS AddIntServer(intNum, interrupt) D0-0:4 A1 void AddIntServer(ULONG, struct Interrupt *); FUNCTION This function adds a new interrupt server to a given server chain. The node is located on the chain in a priority dependent position. If this is the first server on a particular chain, interrupts will be enabled for that chain. Each link in the chain will be called in priority order until the chain ends or one of the servers returns with the 68000's Z condition code clear (indicating non-zero). Servers on the chain should return with the Z flag clear if the interrupt was specifically for that server, and no one else. VERTB servers should always return Z set. (Take care with High Level Language servers, the language may not have a mechanism for reliably setting the Z flag on exit). Servers are called with the following register conventions: D0 - scratch D1 - scratch A0 - scratch A1 - server is_Data pointer (scratch) A5 - jump vector register (scratch) A6 - scratch all other registers must be preserved INPUTS intNum - the Paula interrupt bit number (0 through 14). Processor level seven interrupts (NMI) are encoded as intNum 15. The PORTS, COPER, VERTB, EXTER and NMI interrupts are set up as server chains. interrupt - pointer to an Interrupt structure. By convention, the LN_NAME of the interrupt structure must point a descriptive string so that other users may identify who currently has control of the interrupt. WARNING Some compilers or assemblers may optimize code in unexpected ways, affecting the conditions codes returned from the function. Watch out for a "MOVEM" instruction (which does not affect the condition codes) turning into "MOVE" (which does). BUGS The graphics library's VBLANK server, and some user code, currently assume that address register A0 will contain a pointer to the custom chips. If you add a server at a priority of 10 or greater, you must compensate for this by providing the expected value ($DFF000). SEE ALSO RemIntServer , SetIntVector , hardware/intbits.i,exec/interrupts.i [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node0553.html.txt:1:2.0 IncludeXREF: A ]" border=0> a2024_sync_raster pointer to long int in struct GfxBase +0x0174 graphics/gfxbase.h : *82 aBMS #define 63 = 0x0000003f devices/printer.h : *125 aCAM #define 66 = 0x00000042 devices/printer.h : *128 aDEN1 #define 26 = 0x0000001a devices/printer.h : *67 aDEN2 #define 25 = 0x00000019 devices/printer.h : *66 aDEN3 #define 24 = 0x00000018 devices/printer.h : *65 aDEN4 #define 23 = 0x00000017 devices/printer.h : *64 aDEN5 #define 22 = 0x00000016 devices/printer.h : *63 aDEN6 #define 21 = 0x00000015 devices/printer.h : *62 aEXTEND #define 75 = 0x0000004b devices/printer.h : *138 aFNT0 #define 34 = 0x00000022 devices/printer.h : *77 aFNT1 #define 35 = 0x00000023 devices/printer.h : *78 aFNT10 #define 44 = 0x0000002c devices/printer.h : *87 aFNT2 #define 36 = 0x00000024 devices/printer.h : *79 aFNT3 #define 37 = 0x00000025 devices/printer.h : *80 aFNT4 #define 38 = 0x00000026 devices/printer.h : *81 aFNT5 #define 39 = 0x00000027 devices/printer.h : *82 aFNT6 #define 40 = 0x00000028 devices/printer.h : *83 aFNT7 #define 41 = 0x00000029 devices/printer.h : *84 aFNT8 #define 42 = 0x0000002a devices/printer.h : *85 aFNT9 #define 43 = 0x0000002b devices/printer.h : *86 aHTS #define 67 = 0x00000043 devices/printer.h : *130 aIND #define 2 = 0x00000002 devices/printer.h : *40 aJFY0 #define 52 = 0x00000034 devices/printer.h : *112 aJFY1 #define 54 = 0x00000036 devices/printer.h : *114 aJFY3 #define 53 = 0x00000035 devices/printer.h : *113 aJFY5 #define 49 = 0x00000031 devices/printer.h : *109 aJFY6 #define 51 = 0x00000033 devices/printer.h : *111 aJFY7 #define 50 = 0x00000032 devices/printer.h : *110 aLMS #define 60 = 0x0000003c devices/printer.h : *122 aNEL #define 3 = 0x00000003 devices/printer.h : *41 aPERF #define 58 = 0x0000003a devices/printer.h : *119 aPERF0 #define 59 = 0x0000003b devices/printer.h : *120 aPLD #define 33 = 0x00000021 devices/printer.h : *75 aPLU #define 32 = 0x00000020 devices/printer.h : *74 aPROP0 #define 47 = 0x0000002f devices/printer.h : *107 aPROP1 #define 46 = 0x0000002e devices/printer.h : *106 aPROP2 #define 45 = 0x0000002d devices/printer.h : *105 aRAW #define 76 = 0x0000004c devices/printer.h : *140 aRI #define 4 = 0x00000004 devices/printer.h : *42 aRIN #define 1 = 0x00000001 devices/printer.h : *39 aRIS #define 0 = 0x00000000 devices/printer.h : *38 aRMS #define 61 = 0x0000003d devices/printer.h : *123 aSBC #define 13 = 0x0000000d devices/printer.h : *52 aSFC #define 12 = 0x0000000c devices/printer.h : *51 aSGR0 #define 5 = 0x00000005 devices/printer.h : *44 aSGR1 #define 10 = 0x0000000a devices/printer.h : *49 aSGR22 #define 11 = 0x0000000b devices/printer.h : *50 aSGR23 #define 7 = 0x00000007 devices/printer.h : *46 aSGR24 #define 9 = 0x00000009 devices/printer.h : *48 aSGR3 #define 6 = 0x00000006 devices/printer.h : *45 aSGR4 #define 8 = 0x00000008 devices/printer.h : *47 aSHORP0 #define 14 = 0x0000000e devices/printer.h : *54 aSHORP1 #define 16 = 0x00000010 devices/printer.h : *56 aSHORP2 #define 15 = 0x0000000f devices/printer.h : *55 aSHORP3 #define 18 = 0x00000012 devices/printer.h : *58 aSHORP4 #define 17 = 0x00000011 devices/printer.h : *57 aSHORP5 #define 20 = 0x00000014 devices/printer.h : *60 aSHORP6 #define 19 = 0x00000013 devices/printer.h : *59 aSLPP #define 57 = 0x00000039 devices/printer.h : *118 aSLRM #define 65 = 0x00000041 devices/printer.h : *127 aSTBM #define 64 = 0x00000040 devices/printer.h : *126 aSUS0 #define 31 = 0x0000001f devices/printer.h : *73 aSUS1 #define 28 = 0x0000001c devices/printer.h : *70 aSUS2 #define 27 = 0x0000001b devices/printer.h : *69 aSUS3 #define 30 = 0x0000001e devices/printer.h : *72 aSUS4 #define 29 = 0x0000001d devices/printer.h : *71 aTBC0 #define 69 = 0x00000045 devices/printer.h : *132 aTBC1 #define 71 = 0x00000047 devices/printer.h : *134 aTBC3 #define 70 = 0x00000046 devices/printer.h : *133 aTBC4 #define 72 = 0x00000048 devices/printer.h : *135 aTBCALL #define 73 = 0x00000049 devices/printer.h : *136 aTBSALL #define 74 = 0x0000004a devices/printer.h : *137 aTMS #define 62 = 0x0000003e devices/printer.h : *124 aTSS #define 48 = 0x00000030 devices/printer.h : *108 aVERP0 #define 55 = 0x00000037 devices/printer.h : *116 aVERP1 #define 56 = 0x00000038 devices/printer.h : *117 aVTS #define 68 = 0x00000044 devices/printer.h : *131 abs function returning "LONG" libraries/mathffp.h : *64 ac_dat unsigned short int in struct AudChannel +0x000a hardware/custom.h : *102 ac_len unsigned short int in struct AudChannel +0x0004 hardware/custom.h : *99 ac_pad array [2] of unsigned short int in struct AudChannel +0x000c hardware/custom.h : *103 ac_per unsigned short int in struct AudChannel +0x0006 hardware/custom.h : *100 ac_ptr pointer to unsigned short int in struct AudChannel +0x0000 hardware/custom.h : *98 ac_vol unsigned short int in struct AudChannel +0x0008 hardware/custom.h : *101 acos #define IEEEDPAcos libraries/mathffp.h : *42 libraries/mathieeedp.h : *42 adkcon unsigned short int in struct Custom +0x009e hardware/custom.h : *96 adkconr unsigned short int in struct Custom +0x0010 hardware/custom.h : *36 af_Attr struct TextAttr(size 0x0008 bytes) in struct AvailFonts +0x0002 libraries/diskfont.h : *97 af_Type unsigned short int in struct AvailFonts +0x0000 libraries/diskfont.h : *96 afh_NumEntries unsigned short int in struct AvailFontsHeader +0x0000 libraries/diskfont.h : *106 afp function returning "LONG" libraries/mathffp.h : *78 ai_PRIVATE pointer to void in struct AppIcon +0x0000 workbench/workbench.h : *147 al_Lock long int in struct AssignList +0x0004 dos/dosextens.h : *398 al_Next pointer to struct AssignList in struct AssignList +0x0000 dos/dosextens.h : *397 am_ArgList pointer to struct WBArg in struct AppMessage +0x0022 workbench/workbench.h : *132 am_Class unsigned short int in struct AppMessage +0x0028 workbench/workbench.h : *134 am_ID unsigned long int in struct AppMessage +0x001a workbench/workbench.h : *130 am_Message struct Message(size 0x0014 bytes) in struct AppMessage +0x0000 workbench/workbench.h : *127 am_Micros unsigned long int in struct AppMessage +0x0032 workbench/workbench.h : *138 am_MouseX short int in struct AppMessage +0x002a workbench/workbench.h : *135 am_MouseY short int in struct AppMessage +0x002c workbench/workbench.h : *136 am_NumArgs long int in struct AppMessage +0x001e workbench/workbench.h : *131 am_Reserved array [8] of unsigned long int in struct AppMessage +0x0036 workbench/workbench.h : *139 am_Seconds unsigned long int in struct AppMessage +0x002e workbench/workbench.h : *137 am_Type unsigned short int in struct AppMessage +0x0014 workbench/workbench.h : *128 am_UserData unsigned long int in struct AppMessage +0x0016 workbench/workbench.h : *129 am_Version unsigned short int in struct AppMessage +0x0026 workbench/workbench.h : *133 ami_PRIVATE pointer to void in struct AppMenuItem +0x0000 workbench/workbench.h : *148 an_Child pointer to struct AChain in struct AChain +0x0000 dos/dosasl.h : *99 an_Flags char in struct AChain +0x0110 dos/dosasl.h : *103 an_Info struct FileInfoBlock(size 0x0104 bytes) in struct AChain +0x000c dos/dosasl.h : *102 an_Lock long int in struct AChain +0x0008 dos/dosasl.h : *101 an_Parent pointer to struct AChain in struct AChain +0x0004 dos/dosasl.h : *100 an_String array [1] of unsigned char in struct AChain +0x0111 dos/dosasl.h : *104 ap_Base pointer to struct AChain in struct AnchorPath +0x0000 dos/dosasl.h : *55 ap_BreakBits long int in struct AnchorPath +0x0008 dos/dosasl.h : *59 ap_Buf array [1] of unsigned char in struct AnchorPath +0x0118 dos/dosasl.h : *66 ap_Current #define ap_Last dos/dosasl.h : *58 ap_First #define ap_Base dos/dosasl.h : *56 ap_Flags char in struct AnchorPath +0x0010 dos/dosasl.h : *61 ap_FoundBreak long int in struct AnchorPath +0x000c dos/dosasl.h : *60 ap_Info struct FileInfoBlock(size 0x0104 bytes) in struct AnchorPath +0x0014 dos/dosasl.h : *65 ap_Last pointer to struct AChain in struct AnchorPath +0x0004 dos/dosasl.h : *57 ap_Length #define ap_Flags dos/dosasl.h : *64 ap_Reserved char in struct AnchorPath +0x0011 dos/dosasl.h : *62 ap_Strlen short int in struct AnchorPath +0x0012 dos/dosasl.h : *63 articulate unsigned char in struct narrator_rb +0x004e devices/narrator.h : *115 asi_Start unsigned short int in struct AnalogSignalInterval +0x0000 graphics/monitor.h : *138 asi_Stop unsigned short int in struct AnalogSignalInterval +0x0002 graphics/monitor.h : *139 asin #define IEEEDPAsin libraries/mathffp.h : *44 libraries/mathieeedp.h : *44 atan #define IEEEDPAtan libraries/mathffp.h : *40 libraries/mathieeedp.h : *40 aud array [4] of struct AudChannel(size 0x0010 bytes) in struct Custom +0x00a0 hardware/custom.h : *104 aw_PRIVATE pointer to void in struct AppWindow +0x0000 workbench/workbench.h : *146 A1adj char in struct narrator_rb +0x004b devices/narrator.h : *112 A2024FIFTEENHERTZ_KEY #define 0x00049000 = 0x00049000 graphics/displayinfo.h : *210 A2024TENHERTZ_KEY #define 0x00041000 = 0x00041000 graphics/displayinfo.h : *209 A2024_MONITOR_ID #define 0x00041000 = 0x00041000 graphics/displayinfo.h : *207 A2adj char in struct narrator_rb +0x004c devices/narrator.h : *113 A3adj char in struct narrator_rb +0x004d devices/narrator.h : *114 ABC #define 0x80 = 0x00000080 hardware/blit.h : *32 ABNC #define 0x40 = 0x00000040 hardware/blit.h : *33 ABORT_BUSY #define 288 = 0x00000120 dos/dosextens.h : *460 ABORT_DISK_ERROR #define 296 = 0x00000128 dos/dosextens.h : *459 ABS macro (1 argument) clib/macros.h : *17 ABSOLUTE_DIMENSIONS #define 0x0020 = 0x00000020 intuition/preferences.h : *249 ACCESS_READ #define -2 = 0xfffffffe dos/dos.h : *50 ACCESS_WRITE #define -1 = 0xffffffff dos/dos.h : *52 ACTION_ADD_NOTIFY #define 4097 = 0x00001001 dos/dosextens.h : *211 ACTION_CHANGE_MODE #define 1028 = 0x00000404 dos/dosextens.h : *201 ACTION_CHANGE_SIGNAL #define 995 = 0x000003e3 dos/dosextens.h : *193 ACTION_COPY_DIR #define 19 = 0x00000013 dos/dosextens.h : *162 ACTION_COPY_DIR_FH #define 1030 = 0x00000406 dos/dosextens.h : *203 ACTION_CREATE_DIR #define 22 = 0x00000016 dos/dosextens.h : *165 ACTION_CURRENT_VOLUME #define 7 = 0x00000007 dos/dosextens.h : *153 ACTION_DELETE_OBJECT #define 16 = 0x00000010 dos/dosextens.h : *159 ACTION_DIE #define 5 = 0x00000005 dos/dosextens.h : *151 ACTION_DISK_CHANGE #define 33 = 0x00000021 dos/dosextens.h : *176 ACTION_DISK_INFO #define 25 = 0x00000019 dos/dosextens.h : *168 ACTION_DISK_TYPE #define 32 = 0x00000020 dos/dosextens.h : *175 ACTION_END #define 1007 = 0x000003ef dos/dosextens.h : *187 ACTION_EVENT #define 6 = 0x00000006 dos/dosextens.h : *152 ACTION_EXAMINE_ALL #define 1033 = 0x00000409 dos/dosextens.h : *205 ACTION_EXAMINE_FH #define 1034 = 0x0000040a dos/dosextens.h : *206 ACTION_EXAMINE_NEXT #define 24 = 0x00000018 dos/dosextens.h : *167 ACTION_EXAMINE_OBJECT #define 23 = 0x00000017 dos/dosextens.h : *166 ACTION_FH_FROM_LOCK #define 1026 = 0x00000402 dos/dosextens.h : *199 ACTION_FINDINPUT #define 1005 = 0x000003ed dos/dosextens.h : *185 ACTION_FINDOUTPUT #define 1006 = 0x000003ee dos/dosextens.h : *186 ACTION_FINDUPDATE #define 1004 = 0x000003ec dos/dosextens.h : *184 ACTION_FLUSH #define 27 = 0x0000001b dos/dosextens.h : *170 ACTION_FORMAT #define 1020 = 0x000003fc dos/dosextens.h : *194 ACTION_FREE_LOCK #define 15 = 0x0000000f dos/dosextens.h : *158 ACTION_FREE_RECORD #define 2009 = 0x000007d9 dos/dosextens.h : *209 ACTION_GET_BLOCK #define 2 = 0x00000002 dos/dosextens.h : *149 ACTION_INFO #define 26 = 0x0000001a dos/dosextens.h : *169 ACTION_INHIBIT #define 31 = 0x0000001f dos/dosextens.h : *174 ACTION_IS_FILESYSTEM #define 1027 = 0x00000403 dos/dosextens.h : *200 ACTION_LOCATE_OBJECT #define 8 = 0x00000008 dos/dosextens.h : *154 ACTION_LOCK_RECORD #define 2008 = 0x000007d8 dos/dosextens.h : *208 ACTION_MAKE_LINK #define 1021 = 0x000003fd dos/dosextens.h : *195 ACTION_MORE_CACHE #define 18 = 0x00000012 dos/dosextens.h : *161 ACTION_NIL #define 0 = 0x00000000 dos/dosextens.h : *147 ACTION_PARENT #define 29 = 0x0000001d dos/dosextens.h : *172 ACTION_PARENT_FH #define 1031 = 0x00000407 dos/dosextens.h : *204 ACTION_QUEUE #define 2003L = 0x000007d3 rexx/rexxio.h : *81 ACTION_READ #define 'R' = 0x00000052 dos/dosextens.h : *157 ACTION_READ_LINK #define 1024 = 0x00000400 dos/dosextens.h : *198 ACTION_READ_RETURN #define 1001 = 0x000003e9 dos/dosextens.h : *181 ACTION_REMOVE_NOTIFY #define 4098 = 0x00001002 dos/dosextens.h : *212 ACTION_RENAME_DISK #define 9 = 0x00000009 dos/dosextens.h : *155 ACTION_RENAME_OBJECT #define 17 = 0x00000011 dos/dosextens.h : *160 ACTION_SAME_LOCK #define 40 = 0x00000028 dos/dosextens.h : *192 ACTION_SCREEN_MODE #define 994 = 0x000003e2 dos/dosextens.h : *179 ACTION_SEEK #define 1008 = 0x000003f0 dos/dosextens.h : *183 ACTION_SET_COMMENT #define 28 = 0x0000001c dos/dosextens.h : *171 ACTION_SET_DATE #define 34 = 0x00000022 dos/dosextens.h : *177 ACTION_SET_FILE_SIZE #define 1022 = 0x000003fe dos/dosextens.h : *188 ACTION_SET_MAP #define 4 = 0x00000004 dos/dosextens.h : *150 ACTION_SET_PROTECT #define 21 = 0x00000015 dos/dosextens.h : *164 ACTION_STACK #define 2002L = 0x000007d2 rexx/rexxio.h : *80 ACTION_STARTUP #define 0 = 0x00000000 dos/dosextens.h : *148 ACTION_TIMER #define 30 = 0x0000001e dos/dosextens.h : *173 ACTION_WAIT_CHAR #define 20 = 0x00000014 dos/dosextens.h : *163 ACTION_WRITE #define 'W' = 0x00000057 dos/dosextens.h : *156 ACTION_WRITE_PROTECT #define 1023 = 0x000003ff dos/dosextens.h : *189 ACTION_WRITE_RETURN #define 1002 = 0x000003ea dos/dosextens.h : *182 ACTIVATE #define WFLG_ACTIVATE = 0x00001000 intuition/iobsolete.h : *160 ACTIVEGADGET #define GACT_ACTIVEGADGET = 0x00004000 intuition/iobsolete.h : *86 ACTIVEWINDOW #define IDCMP_ACTIVEWINDOW = 0x00040000 intuition/iobsolete.h : *132 AChain structure tag size 0x0112 dos/dosasl.h : *55, 57, 98, 99, 100 ADALLOC_MAXPREC #define 127 = 0x0000007f devices/audio.h : *24 ADALLOC_MINPREC #define -128 = 0xffffff80 devices/audio.h : *23 ADCMD_ALLOCATE #define 32 = 0x00000020 devices/audio.h : *32 ADCMD_FINISH #define (CMD_NONSTD+2) = 0x0000000b devices/audio.h : *28 ADCMD_FREE #define (CMD_NONSTD+0) = 0x00000009 devices/audio.h : *26 ADCMD_LOCK #define (CMD_NONSTD+4) = 0x0000000d devices/audio.h : *30 ADCMD_PERVOL #define (CMD_NONSTD+3) = 0x0000000c devices/audio.h : *29 ADCMD_SETPREC #define (CMD_NONSTD+1) = 0x0000000a devices/audio.h : *27 ADCMD_WAITCYCLE #define (CMD_NONSTD+5) = 0x0000000e devices/audio.h : *31 ADHARD_CHANNELS #define 4 = 0x00000004 devices/audio.h : *21 ADIOB_NOWAIT #define 6 = 0x00000006 devices/audio.h : *38 ADIOB_PERVOL #define 4 = 0x00000004 devices/audio.h : *34 ADIOB_SYNCCYCLE #define 5 = 0x00000005 devices/audio.h : *36 ADIOB_WRITEMESSAGE #define 7 = 0x00000007 devices/audio.h : *40 ADIOERR_ALLOCFAILED #define -11 = 0xfffffff5 devices/audio.h : *44 ADIOERR_CHANNELSTOLEN #define -12 = 0xfffffff4 devices/audio.h : *45 ADIOERR_NOALLOCATION #define -10 = 0xfffffff6 devices/audio.h : *43 ADIOF_NOWAIT #define (1 devices/audio.h : *39 ADIOF_PERVOL #define (1 devices/audio.h : *35 ADIOF_SYNCCYCLE #define (1 devices/audio.h : *37 ADIOF_WRITEMESSAGE #define (1 devices/audio.h : *41 ADKB_FAST #define 8 = 0x00000008 hardware/adkbits.h : *22 ADKB_MFMPREC #define 12 = 0x0000000c hardware/adkbits.h : *18 ADKB_MSBSYNC #define 9 = 0x00000009 hardware/adkbits.h : *21 ADKB_PRECOMP0 #define 13 = 0x0000000d hardware/adkbits.h : *17 ADKB_PRECOMP1 #define 14 = 0x0000000e hardware/adkbits.h : *16 ADKB_SETCLR #define 15 = 0x0000000f hardware/adkbits.h : *15 ADKB_UARTBRK #define 11 = 0x0000000b hardware/adkbits.h : *19 ADKB_USE0P1 #define 4 = 0x00000004 hardware/adkbits.h : *26 ADKB_USE0V1 #define 0 = 0x00000000 hardware/adkbits.h : *30 ADKB_USE1P2 #define 5 = 0x00000005 hardware/adkbits.h : *25 ADKB_USE1V2 #define 1 = 0x00000001 hardware/adkbits.h : *29 ADKB_USE2P3 #define 6 = 0x00000006 hardware/adkbits.h : *24 ADKB_USE2V3 #define 2 = 0x00000002 hardware/adkbits.h : *28 ADKB_USE3PN #define 7 = 0x00000007 hardware/adkbits.h : *23 ADKB_USE3VN #define 3 = 0x00000003 hardware/adkbits.h : *27 ADKB_WORDSYNC #define 10 = 0x0000000a hardware/adkbits.h : *20 ADKF_FAST #define (1 hardware/adkbits.h : *39 ADKF_MFMPREC #define (1 hardware/adkbits.h : *35 ADKF_MSBSYNC #define (1 hardware/adkbits.h : *38 ADKF_PRE000NS #define 0 = 0x00000000 hardware/adkbits.h : *49 ADKF_PRE140NS #define (ADKF_PRECOMP0) = 0x00002000 hardware/adkbits.h : *50 ADKF_PRE280NS #define (ADKF_PRECOMP1) = 0x00004000 hardware/adkbits.h : *51 ADKF_PRE560NS #define (ADKF_PRECOMP0|ADKF_PRECOMP1) = 0x00006000 hardware/adkbits.h : *52 ADKF_PRECOMP0 #define (1 hardware/adkbits.h : *34 ADKF_PRECOMP1 #define (1 hardware/adkbits.h : *33 ADKF_SETCLR #define (1 hardware/adkbits.h : *32 ADKF_UARTBRK #define (1 hardware/adkbits.h : *36 ADKF_USE0P1 #define (1 hardware/adkbits.h : *43 ADKF_USE0V1 #define (1 hardware/adkbits.h : *47 ADKF_USE1P2 #define (1 hardware/adkbits.h : *42 ADKF_USE1V2 #define (1 hardware/adkbits.h : *46 ADKF_USE2P3 #define (1 hardware/adkbits.h : *41 ADKF_USE2V3 #define (1 hardware/adkbits.h : *45 ADKF_USE3PN #define (1 hardware/adkbits.h : *40 ADKF_USE3VN #define (1 hardware/adkbits.h : *44 ADKF_WORDSYNC #define (1 hardware/adkbits.h : *37 ADNB_STARTPROC #define 0 = 0x00000000 libraries/expansion.h : *18 ADNF_STARTPROC #define (1L libraries/expansion.h : *19 ADO_CommFileLen #define (ADO_Dummy + 4) = 0x800007d4 dos/dostags.h : *132 ADO_CommNameLen #define (ADO_Dummy + 3) = 0x800007d3 dos/dostags.h : *130 ADO_DirLen #define (ADO_Dummy + 2) = 0x800007d2 dos/dostags.h : *128 ADO_Dummy #define (TAG_USER + 2000) = 0x800007d0 dos/dostags.h : *115 ADO_FH_Mode #define (ADO_Dummy + 1) = 0x800007d1 dos/dostags.h : *116 ADO_PromptLen #define (ADO_Dummy + 5) = 0x800007d5 dos/dostags.h : *134 AFB_68010 #define 0 = 0x00000000 exec/execbase.h : *153 AFB_68020 #define 1 = 0x00000001 exec/execbase.h : *154 AFB_68030 #define 2 = 0x00000002 exec/execbase.h : *155 AFB_68040 #define 3 = 0x00000003 exec/execbase.h : *156 AFB_68881 #define 4 = 0x00000004 exec/execbase.h : *157 AFB_68882 #define 5 = 0x00000005 exec/execbase.h : *158 AFB_DISK #define 1 = 0x00000001 libraries/diskfont.h : *87 AFB_MEMORY #define 0 = 0x00000000 libraries/diskfont.h : *85 AFB_SCALED #define 2 = 0x00000002 libraries/diskfont.h : *89 AFB_TAGGED #define 16 = 0x00000010 libraries/diskfont.h : *92 AFF_68010 #define (1L exec/execbase.h : *160 AFF_68020 #define (1L exec/execbase.h : *161 AFF_68030 #define (1L exec/execbase.h : *162 AFF_68040 #define (1L exec/execbase.h : *163 AFF_68881 #define (1L exec/execbase.h : *164 AFF_68882 #define (1L exec/execbase.h : *165 AFF_DISK #define 0x0002 = 0x00000002 libraries/diskfont.h : *88 AFF_MEMORY #define 0x0001 = 0x00000001 libraries/diskfont.h : *86 AFF_SCALED #define 0x0004 = 0x00000004 libraries/diskfont.h : *90 AFF_TAGGED #define 0x10000L = 0x00010000 libraries/diskfont.h : *93 AFbias char in struct narrator_rb +0x0055 devices/narrator.h : *119 AGNUS #define graphics/gfx.h : *22, 23 AG_BadParm #define 0x00080000 = 0x00080000 exec/alerts.h : *53 AG_CloseDev #define 0x000A0000 = 0x000a0000 exec/alerts.h : *55 AG_CloseLib #define 0x00090000 = 0x00090000 exec/alerts.h : *54 AG_IOError #define 0x00060000 = 0x00060000 exec/alerts.h : *51 AG_MakeLib #define 0x00020000 = 0x00020000 exec/alerts.h : *47 AG_NoMemory #define 0x00010000 = 0x00010000 exec/alerts.h : *46 AG_NoSignal #define 0x00070000 = 0x00070000 exec/alerts.h : *52 AG_OpenDev #define 0x00040000 = 0x00040000 exec/alerts.h : *49 AG_OpenLib #define 0x00030000 = 0x00030000 exec/alerts.h : *48 AG_OpenRes #define 0x00050000 = 0x00050000 exec/alerts.h : *50 AG_ProcCreate #define 0x000B0000 = 0x000b0000 exec/alerts.h : *56 ALERTLAYERSNOMEM #define 0x83010000 = 0x83010000 graphics/layers.h : *52 ALERT_TYPE #define 0x80000000 = 0x80000000 intuition/intuition.h : *1310 ALPHA_P_101 #define 0x01 = 0x00000001 intuition/preferences.h : *193 ALTKEYMAP #define GACT_ALTKEYMAP = 0x00001000 intuition/iobsolete.h : *84 ALTLEFT #define (IEQUALIFIER_LALT) = 0x00000010 intuition/intuition.h : *1336 ALTRIGHT #define (IEQUALIFIER_RALT) = 0x00000020 intuition/intuition.h : *1337 AMIGAKEYS #define (AMIGALEFT | AMIGARIGHT) = 0x000000c0 intuition/intuition.h : *1340 AMIGALEFT #define (IEQUALIFIER_LCOMMAND) = 0x00000040 intuition/intuition.h : *1338 AMIGARIGHT #define (IEQUALIFIER_RCOMMAND) = 0x00000080 intuition/intuition.h : *1339 AM_VERSION #define 1 = 0x00000001 workbench/workbench.h : *124 ANBC #define 0x20 = 0x00000020 hardware/blit.h : *34 ANBNC #define 0x10 = 0x00000010 hardware/blit.h : *35 ANFRACSIZE #define 6 = 0x00000006 graphics/gels.h : *46 ANIMHALF #define 0x0020 = 0x00000020 graphics/gels.h : *47 ANTI_ALIAS #define 0x0800 = 0x00000800 intuition/preferences.h : *259 AN_AddSWGadget #define 0x8401000A = 0x8401000a exec/alerts.h : *151 AN_AsyncPkt #define 0x07000004 = 0x07000004 exec/alerts.h : *166 AN_AudioDev #define 0x10000000 = 0x10000000 exec/alerts.h : *193 AN_BadChkSum #define 0x07000009 = 0x07000009 exec/alerts.h : *171 AN_BadExpansionFree #define 0x0A000001 = 0x0a000001 exec/alerts.h : *187 AN_BadFreeAddr #define 0x0100000F = 0x0100000f exec/alerts.h : *116 AN_BadGadget #define 0x04000001 = 0x04000001 exec/alerts.h : *142 AN_BadInitFunc #define 0x0700000D = 0x0700000d exec/alerts.h : *175 AN_BadMessage #define 0x8400000D = 0x8400000d exec/alerts.h : *154 AN_BadOverlay #define 0x0700000C = 0x0700000c exec/alerts.h : *174 AN_BadSegList #define 0x08000001 = 0x08000001 exec/alerts.h : *180 AN_BadState #define 0x8400000C = 0x8400000c exec/alerts.h : *153 AN_BaseChkSum #define 0x01000002 = 0x01000002 exec/alerts.h : *100 AN_BitMap #define 0x07000007 = 0x07000007 exec/alerts.h : *169 AN_BltBitMap #define 0x8201000A = 0x8201000a exec/alerts.h : *125 AN_BogusExcpt #define 0x8100000A = 0x8100000a exec/alerts.h : *109 AN_BootError #define 0x30000001 = 0x30000001 exec/alerts.h : *228 AN_BootStrap #define 0x30000000 = 0x30000000 exec/alerts.h : *227 AN_CIARsrc #define 0x20000000 = 0x20000000 exec/alerts.h : *216 AN_ConsoleDev #define 0x11000000 = 0x11000000 exec/alerts.h : *196 AN_CreatePort #define 0x84010002 = 0x84010002 exec/alerts.h : *143 AN_DOSLib #define 0x07000000 = 0x07000000 exec/alerts.h : *162 AN_DRHasDisk #define 0x21000001 = 0x21000001 exec/alerts.h : *220 AN_DRIntNoAct #define 0x21000002 = 0x21000002 exec/alerts.h : *221 AN_DiskBlkSeq #define 0x07000006 = 0x07000006 exec/alerts.h : *168 AN_DiskCopy #define 0x32000000 = 0x32000000 exec/alerts.h : *252 AN_DiskError #define 0x0700000A = 0x0700000a exec/alerts.h : *172 AN_DiskRsrc #define 0x21000000 = 0x21000000 exec/alerts.h : *219 AN_DiskfontLib #define 0x0B000000 = 0x0b000000 exec/alerts.h : *190 AN_EndTask #define 0x07000002 = 0x07000002 exec/alerts.h : *164 AN_ExcptVect #define 0x01000001 = 0x01000001 exec/alerts.h : *99 AN_ExecLib #define 0x01000000 = 0x01000000 exec/alerts.h : *98 AN_ExpansionLib #define 0x0A000000 = 0x0a000000 exec/alerts.h : *186 AN_FileReclosed #define 0x0700000E = 0x0700000e exec/alerts.h : *176 AN_FreeTwice #define 0x01000009 = 0x01000009 exec/alerts.h : *108 AN_FreeVec #define 0x07000005 = 0x07000005 exec/alerts.h : *167 AN_GadTools #define 0x33000000 = 0x33000000 exec/alerts.h : *255 AN_GadgetType #define 0x84000001 = 0x84000001 exec/alerts.h : *141 AN_GamePortDev #define 0x12000000 = 0x12000000 exec/alerts.h : *200 AN_GfxFreeError #define 0x0200000D = 0x0200000d exec/alerts.h : *129 AN_GfxNewError #define 0x0200000C = 0x0200000c exec/alerts.h : *128 AN_GfxNoLCM #define 0x82011234 = 0x82011234 exec/alerts.h : *131 AN_GfxNoMem #define 0x82010000 = 0x82010000 exec/alerts.h : *120 AN_GfxNoMemMspc #define 0x82010001 = 0x82010001 exec/alerts.h : *121 AN_GraphicsLib #define 0x02000000 = 0x02000000 exec/alerts.h : *119 AN_IOAfterClose #define 0x0100000D = 0x0100000d exec/alerts.h : *113 AN_IOUsedTwice #define 0x0100000B = 0x0100000b exec/alerts.h : *110 AN_IconLib #define 0x09000000 = 0x09000000 exec/alerts.h : *183 AN_InitAPtr #define 0x01000007 = 0x01000007 exec/alerts.h : *105 AN_IntrMem #define 0x81000006 = 0x81000006 exec/alerts.h : *104 AN_Intuition #define 0x04000000 = 0x04000000 exec/alerts.h : *140 AN_ItemAlloc #define 0x04010003 = 0x04010003 exec/alerts.h : *144 AN_ItemBoxTop #define 0x84000006 = 0x84000006 exec/alerts.h : *147 AN_KeyFree #define 0x07000008 = 0x07000008 exec/alerts.h : *170 AN_KeyRange #define 0x0700000B = 0x0700000b exec/alerts.h : *173 AN_KeyboardDev #define 0x13000000 = 0x13000000 exec/alerts.h : *203 AN_LayersLib #define 0x03000000 = 0x03000000 exec/alerts.h : *136 AN_LayersNoMem #define 0x83010000 = 0x83010000 exec/alerts.h : *137 AN_LibChkSum #define 0x01000003 = 0x01000003 exec/alerts.h : *101 AN_LongFrame #define 0x82010006 = 0x82010006 exec/alerts.h : *122 AN_MakeVPort #define 0x82010030 = 0x82010030 exec/alerts.h : *127 AN_MathLib #define 0x05000000 = 0x05000000 exec/alerts.h : *159 AN_MemCorrupt #define 0x81000005 = 0x81000005 exec/alerts.h : *103 AN_MemoryInsane #define 0x0100000C = 0x0100000c exec/alerts.h : *112 AN_MiscRsrc #define 0x22000000 = 0x22000000 exec/alerts.h : *224 AN_NoConsole #define 0x8400000F = 0x8400000f exec/alerts.h : *156 AN_NoFonts #define 0xB1000001 = 0xb1000001 exec/alerts.h : *232 AN_NoWindow #define 0x11000001 = 0x11000001 exec/alerts.h : *197 AN_ObsoleteFont #define 0x02000401 = 0x02000401 exec/alerts.h : *133 AN_OpenScreen #define 0x84010007 = 0x84010007 exec/alerts.h : *148 AN_OpenScrnRast #define 0x84010008 = 0x84010008 exec/alerts.h : *149 AN_OpenWindow #define 0x8401000B = 0x8401000b exec/alerts.h : *152 AN_PlaneAlloc #define 0x84010005 = 0x84010005 exec/alerts.h : *146 AN_QPktFail #define 0x07000003 = 0x07000003 exec/alerts.h : *165 AN_RAMLib #define 0x08000000 = 0x08000000 exec/alerts.h : *179 AN_RegionMemory #define 0x8201000B = 0x8201000b exec/alerts.h : *126 AN_SemCorrupt #define 0x01000008 = 0x01000008 exec/alerts.h : *107 AN_ShortFrame #define 0x82010007 = 0x82010007 exec/alerts.h : *123 AN_StackProbe #define 0x0100000E = 0x0100000e exec/alerts.h : *114 AN_StartMem #define 0x07010001 = 0x07010001 exec/alerts.h : *163 AN_SubAlloc #define 0x04010004 = 0x04010004 exec/alerts.h : *145 AN_SysScrnType #define 0x84000009 = 0x84000009 exec/alerts.h : *150 AN_TDCalibSeek #define 0x14000001 = 0x14000001 exec/alerts.h : *207 AN_TDDelay #define 0x14000002 = 0x14000002 exec/alerts.h : *208 AN_TMBadReq #define 0x15000001 = 0x15000001 exec/alerts.h : *212 AN_TMBadSupply #define 0x15000002 = 0x15000002 exec/alerts.h : *213 AN_TextTmpRas #define 0x02010009 = 0x02010009 exec/alerts.h : *124 AN_TimerDev #define 0x15000000 = 0x15000000 exec/alerts.h : *211 AN_TrackDiskDev #define 0x14000000 = 0x14000000 exec/alerts.h : *206 AN_Unknown #define 0x35000000 = 0x35000000 exec/alerts.h : *261 AN_UtilityLib #define 0x34000000 = 0x34000000 exec/alerts.h : *258 AN_WBAddToolMenuItem #define 0xB1010008 = 0xb1010008 exec/alerts.h : *241 AN_WBBadIOMsg #define 0x31000003 = 0x31000003 exec/alerts.h : *235 AN_WBBadStartupMsg1 #define 0x31000001 = 0x31000001 exec/alerts.h : *233 AN_WBBadStartupMsg2 #define 0x31000002 = 0x31000002 exec/alerts.h : *234 AN_WBCreateWBMenusCreateMenus1 #define 0xB1010005 = 0xb1010005 exec/alerts.h : *238 AN_WBCreateWBMenusCreateMenus2 #define 0xB1010006 = 0xb1010006 exec/alerts.h : *239 AN_WBInitLayerDemon #define 0xB101000B = 0xb101000b exec/alerts.h : *244 AN_WBInitPotionAllocDrawer #define 0xB1010004 = 0xb1010004 exec/alerts.h : *237 AN_WBInitScreenAndWindows1 #define 0xB101000D = 0xb101000d exec/alerts.h : *246 AN_WBInitScreenAndWindows2 #define 0xB101000E = 0xb101000e exec/alerts.h : *247 AN_WBInitScreenAndWindows3 #define 0xB101000F = 0xb101000f exec/alerts.h : *248 AN_WBLayoutWBMenusLayoutMenus #define 0xB1010007 = 0xb1010007 exec/alerts.h : *240 AN_WBMAlloc #define 0xB1010010 = 0xb1010010 exec/alerts.h : *249 AN_WBReLayoutToolMenu #define 0xB1010009 = 0xb1010009 exec/alerts.h : *242 AN_WBinitTimer #define 0xB101000A = 0xb101000a exec/alerts.h : *243 AN_WBinitWbGels #define 0xB101000C = 0xb101000c exec/alerts.h : *245 AN_WeirdEcho #define 0x8400000E = 0x8400000e exec/alerts.h : *155 AN_Workbench #define 0x31000000 = 0x31000000 exec/alerts.h : *231 AO_AudioDev #define 0x00008010 = 0x00008010 exec/alerts.h : *72 AO_BootStrap #define 0x00008030 = 0x00008030 exec/alerts.h : *83 AO_CIARsrc #define 0x00008020 = 0x00008020 exec/alerts.h : *79 AO_ConsoleDev #define 0x00008011 = 0x00008011 exec/alerts.h : *73 AO_DOSLib #define 0x00008007 = 0x00008007 exec/alerts.h : *65 AO_DiskCopy #define 0x00008032 = 0x00008032 exec/alerts.h : *85 AO_DiskRsrc #define 0x00008021 = 0x00008021 exec/alerts.h : *80 AO_DiskfontLib #define 0x0000800B = 0x0000800b exec/alerts.h : *69 AO_ExecLib #define 0x00008001 = 0x00008001 exec/alerts.h : *60 AO_ExpansionLib #define 0x0000800A = 0x0000800a exec/alerts.h : *68 AO_GadTools #define 0x00008033 = 0x00008033 exec/alerts.h : *86 AO_GamePortDev #define 0x00008012 = 0x00008012 exec/alerts.h : *74 AO_GraphicsLib #define 0x00008002 = 0x00008002 exec/alerts.h : *61 AO_IconLib #define 0x00008009 = 0x00008009 exec/alerts.h : *67 AO_Intuition #define 0x00008004 = 0x00008004 exec/alerts.h : *63 AO_KeyboardDev #define 0x00008013 = 0x00008013 exec/alerts.h : *75 AO_LayersLib #define 0x00008003 = 0x00008003 exec/alerts.h : *62 AO_MathLib #define 0x00008005 = 0x00008005 exec/alerts.h : *64 AO_MiscRsrc #define 0x00008022 = 0x00008022 exec/alerts.h : *81 AO_RAMLib #define 0x00008008 = 0x00008008 exec/alerts.h : *66 AO_TimerDev #define 0x00008015 = 0x00008015 exec/alerts.h : *77 AO_TrackDiskDev #define 0x00008014 = 0x00008014 exec/alerts.h : *76 AO_Unknown #define 0x00008035 = 0x00008035 exec/alerts.h : *87 AO_UtilityLib #define 0x0000800C = 0x0000800c exec/alerts.h : *70 AO_Workbench #define 0x00008031 = 0x00008031 exec/alerts.h : *84 AOlPen char in struct RastPort +0x001b graphics/rastport.h : *67 APB_DIDDIR #define 3 = 0x00000003 dos/dosasl.h : *85 APB_DODIR #define 2 = 0x00000002 dos/dosasl.h : *80 APB_DODOT #define 5 = 0x00000005 dos/dosasl.h : *91 APB_DOWILD #define 0 = 0x00000000 dos/dosasl.h : *71 APB_DirChanged #define 6 = 0x00000006 dos/dosasl.h : *94 APB_ITSWILD #define 1 = 0x00000001 dos/dosasl.h : *74 APB_NOMEMERR #define 4 = 0x00000004 dos/dosasl.h : *88 APF_DIDDIR #define 8 = 0x00000008 dos/dosasl.h : *86 APF_DODIR #define 4 = 0x00000004 dos/dosasl.h : *81 APF_DODOT #define 32 = 0x00000020 dos/dosasl.h : *92 APF_DOWILD #define 1 = 0x00000001 dos/dosasl.h : *72 APF_DirChanged #define 64 = 0x00000040 dos/dosasl.h : *95 APF_ITSWILD #define 2 = 0x00000002 dos/dosasl.h : *75 APF_NOMEMERR #define 16 = 0x00000010 dos/dosasl.h : *89 APTR typedef pointer to void exec/types.h : *36 APTR_TYPEDEF #define exec/types.h : *35 AREAOUTLINE #define 0x08 = 0x00000008 graphics/rastport.h : *107 ARG0 macro (1 argument) rexx/storage.h : *117 ARG1 macro (1 argument) rexx/storage.h : *118 ARG2 macro (1 argument) rexx/storage.h : *119 ARROWIDCMP #define (IDCMP_GADGETUP | IDCMP_GADGETDOWN | IDCMP_INTUITICKS | IDCMP_MOUSEBUTTONS) = 0x00400068 libraries/gadtools.h : *64 ASHIFTSHIFT #define 12 = 0x0000000c hardware/blit.h : *63 ASL_BackPen #define ASL_Dummy+15 = 0x8008000f libraries/asl.h : *210 ASL_CancelText #define ASL_Dummy+19 = 0x80080013 libraries/asl.h : *215 ASL_Dir #define ASL_Dummy+9 = 0x80080009 libraries/asl.h : *202 ASL_Dummy #define (TAG_USER + 0x80000) = 0x80080000 libraries/asl.h : *190 ASL_ExtFlags1 #define ASL_Dummy+22 = 0x80080016 libraries/asl.h : *219 ASL_File #define ASL_Dummy+8 = 0x80080008 libraries/asl.h : *201 ASL_FileRequest #define 0 = 0x00000000 libraries/asl.h : *183 ASL_FontFlags #define ASL_Dummy+13 = 0x8008000d libraries/asl.h : *208 ASL_FontHeight #define ASL_Dummy+11 = 0x8008000b libraries/asl.h : *206 ASL_FontName #define ASL_Dummy+10 = 0x8008000a libraries/asl.h : *205 ASL_FontRequest #define 1 = 0x00000001 libraries/asl.h : *184 ASL_FontStyles #define ASL_Dummy+12 = 0x8008000c libraries/asl.h : *207 ASL_FrontPen #define ASL_Dummy+14 = 0x8008000e libraries/asl.h : *209 ASL_FuncFlags #define ASL_Dummy+20 = 0x80080014 libraries/asl.h : *216 ASL_Hail #define ASL_Dummy+1 = 0x80080001 libraries/asl.h : *192 ASL_Height #define ASL_Dummy+6 = 0x80080006 libraries/asl.h : *197 ASL_HookFunc #define ASL_Dummy+7 = 0x80080007 libraries/asl.h : *198 ASL_LeftEdge #define ASL_Dummy+3 = 0x80080003 libraries/asl.h : *194 ASL_MaxHeight #define ASL_Dummy+17 = 0x80080011 libraries/asl.h : *212 ASL_MinHeight #define ASL_Dummy+16 = 0x80080010 libraries/asl.h : *211 ASL_ModeList #define ASL_Dummy+21 = 0x80080015 libraries/asl.h : *218 ASL_OKText #define ASL_Dummy+18 = 0x80080012 libraries/asl.h : *214 ASL_Pattern #define ASL_FontName = 0x8008000a libraries/asl.h : *221 ASL_TopEdge #define ASL_Dummy+4 = 0x80080004 libraries/asl.h : *195 ASL_Width #define ASL_Dummy+5 = 0x80080005 libraries/asl.h : *196 ASL_Window #define ASL_Dummy+2 = 0x80080002 libraries/asl.h : *193 ASPECT_HORIZ #define 0x00 = 0x00000000 intuition/preferences.h : *176 ASPECT_VERT #define 0x01 = 0x00000001 intuition/preferences.h : *177 AT_DeadEnd #define 0x80000000 = 0x80000000 exec/alerts.h : *41 AT_Recovery #define 0x00000000 = 0x00000000 exec/alerts.h : *42 AUDIONAME #define "audio.device" devices/audio.h : *19 AUL #define 0x4 = 0x00000004 hardware/blit.h : *78 AUTOBACKPEN #define 1 = 0x00000001 intuition/intuition.h : *1321 AUTODRAWMODE #define JAM2 = 0x00000001 intuition/intuition.h : *1322 AUTOFRONTPEN #define 0 = 0x00000000 intuition/intuition.h : *1320 AUTOITEXTFONT #define NULL = 0x00000000 intuition/intuition.h : *1325 AUTOKNOB #define 0x0001 = 0x00000001 intuition/intuition.h : *497 AUTOLEFTEDGE #define 6 = 0x00000006 intuition/intuition.h : *1323 AUTONEXTTEXT #define NULL = 0x00000000 intuition/intuition.h : *1326 AUTOSCROLL #define 0x4000 = 0x00004000 intuition/screens.h : *182 AUTOTOPEDGE #define 3 = 0x00000003 intuition/intuition.h : *1324 AUserExt short int in struct AnimOb +0x0028 graphics/gels.h : *225 AUserStuff #define WORD graphics/gels.h : *64, 224 AVbias char in struct narrator_rb +0x0054 devices/narrator.h : *118 A_OR_B #define ABC|ANBC|NABC | ABNC|ANBNC|NABNC = 0x000000fc hardware/blit.h : *42 A_OR_C #define ABC|NABC|ABNC | ANBC|NANBC|ANBNC = 0x000000fa hardware/blit.h : *43 A_TO_D #define ABC|ANBC|ABNC|ANBNC = 0x000000f0 hardware/blit.h : *45 A_XOR_C #define NABC|ABNC | NANBC|ANBNC = 0x0000005a hardware/blit.h : *44 ActiView pointer to struct View in struct GfxBase +0x0022 graphics/gfxbase.h : *28 ActiViewCprSemaphore pointer to struct SignalSemaphore in struct GfxBase +0x019a graphics/gfxbase.h : *90 Actions unsigned long int in struct SGWork +0x001e intuition/sghooks.h : *46 Activation unsigned short int in struct Gadget +0x000e intuition/intuition.h : *225 ActivePens array [2] of unsigned char in struct StringExtend +0x0006 intuition/sghooks.h : *23 ActiveScreen pointer to struct Screen in struct IntuitionBase +0x0038 intuition/intuitionbase.h : *75 ActiveWindow pointer to struct Window in struct IntuitionBase +0x0034 intuition/intuitionbase.h : *74 After pointer to struct Bob in struct Bob +0x000e graphics/gels.h : *154 AlertData pointer to void in struct ExecBase +0x004a exec/execbase.h : *52 AlgoStyle unsigned char in struct RastPort +0x0038 graphics/rastport.h : *79 AltKeyMap pointer to struct KeyMap in struct StringInfo +0x0020 intuition/intuition.h : *560 AnOldX short int in struct AnimOb +0x000e graphics/gels.h : *208 AnOldY short int in struct AnimOb +0x000c graphics/gels.h : *208 AnX short int in struct AnimOb +0x0012 graphics/gels.h : *211 AnY short int in struct AnimOb +0x0010 graphics/gels.h : *211 AnalogSignalInterval structure tag size 0x0004 graphics/monitor.h : *136, 150, 151, 152, 153 AnchorPath structure tag size 0x0119 dos/dosasl.h : *54 AnimBob pointer to struct Bob in struct AnimComp +0x0022 graphics/gels.h : *197 AnimCRoutine pointer to function returning short int in struct AnimComp +0x0016 graphics/gels.h : *190 AnimComp structure tag size 0x0026 graphics/gels.h : *158, 165, 183, 184, 187, 188, 222 AnimORoutine pointer to function returning short int in struct AnimOb +0x0020 graphics/gels.h : *219 AnimOb structure tag size 0x002a graphics/gels.h : *195, 200, 203 AppIcon structure tag size 0x0004 workbench/workbench.h : *147 AppMenuItem structure tag size 0x0004 workbench/workbench.h : *148 AppMessage structure tag size 0x0056 workbench/workbench.h : *126 AppWindow structure tag size 0x0004 workbench/workbench.h : *146 AreaCircle macro (4 arguments) graphics/gfxmacros.h : *44 AreaInfo structure tag size 0x0018 graphics/rastport.h : *23, 62 AreaInfo pointer to struct AreaInfo in struct RastPort +0x0010 graphics/rastport.h : *62 AreaPtSz char in struct RastPort +0x001d graphics/rastport.h : *69 AreaPtrn pointer to unsigned short int in struct RastPort +0x0008 graphics/rastport.h : *60 AslName #define "asl.library" libraries/asl.h : *50 AssignList structure tag size 0x0008 dos/dosextens.h : *386, 396, 397 AttnFlags unsigned short int in struct ExecBase +0x0128 exec/execbase.h : *73 AttnResched unsigned short int in struct ExecBase +0x012a exec/execbase.h : *75 AudChannel structure tag (size 0x0010 bytes)in struct Custom hardware/custom.h : *97 AvailFonts structure tag size 0x000a libraries/diskfont.h : *95 AvailFontsHeader structure tag size 0x0002 libraries/diskfont.h : *105 [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node04AA.html.txt:1:audio.device/ADCMD_PERVOL ]" border=0> NAME ADCMD_PERVOL -- change the period and volume for writes in progress to audio channels FUNCTION ADCMD_PERVOL is a command for multiple audio channels. For each selected channel (io_Unit), if the allocation key (ioa_AllocKey) is correct and there is a write (CMD_WRITE) in progress, ADCMD_PERVOL loads a new volume and period immediately or at the end of the current cycle depending on the sync flag (ADIOF_SYNCCYCLE). If the allocation key in incorrect, ADCMD_PERVOL returns an error (ADIOERR_NOALLOCATION). ADCMD_PERVOL is synchronous and only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. Do not use ADCMD_PERVOL in interrupt code at interrupt level 5 or higher. INPUTS mn_ReplyPort- pointer to message port that receives I/O request if the quick flag (IOF_QUICK) is clear io_Device - pointer to device node, must be set by (or copied from I/O block set by) OpenDevice function io_Unit - bit map of channels to load period and volume (bits 0 thru 3 correspond to channels 0 thru 3) io_Command - command number for ADCMD_PERVOL io_Flags - flags, must be cleared if not used: IOF_QUICK - (CLEAR) reply I/O request ADIOF_SYNCCYCLE- (CLEAR) load period and volume immediately (SET) load period and volume at the end of the current cycle ioa_AllocKey- allocation key, must be set by (or copied from I/O block set by) OpenDevice function or ADCMD_ALLOCATE command ioa_Period - new sample period in 279.365 ns increments (124 thru 65536, anti-aliasing filter works below 300 to 500 depending on waveform) ioa_Volume - new volume (0 thru 64, linear) OUTPUTS io_Unit - bit map of channels that successfully loaded period and volume (bits 0 thru 3 correspond to channels 0 thru 3) io_Error - error number: 0 - no error ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) does not match key for channel [Back to Amiga Developer Docs ]
Includes_and_Autodocs_2._guide/node00C8.html.txt:1:Includes/hardware/dmabits.h ]" border=0> #ifndef HARDWARE_DMABITS_H #define HARDWARE_DMABITS_H /* ** $Filename: hardware/dmabits.h $ ** $Release: 2.04 Includes, V37.4 $ ** $Revision: 36.2 $ ** $Date: 90/07/10 $ ** ** include file for defining dma control stuff ** ** (C) Copyright 1985-1999 Amiga, Inc. ** All Rights Reserved */ /* write definitions for dmaconw */ #define DMAF_SETCLR 0x8000 #define DMAF_AUDIO 0x000F /* 4 bit mask */ #define DMAF_AUD0 0x0001 #define DMAF_AUD1 0x0002 #define DMAF_AUD2 0x0004 #define DMAF_AUD3 0x0008 #define DMAF_DISK 0x0010 #define DMAF_SPRITE 0x0020 #define DMAF_BLITTER 0x0040 #define DMAF_COPPER 0x0080 #define DMAF_RASTER 0x0100 #define DMAF_MASTER 0x0200 #define DMAF_BLITHOG 0x0400 #define DMAF_ALL 0x01FF /* all dma channels */ /* read definitions for dmaconr */ /* bits 0-8 correspnd to dmaconw definitions */ #define DMAF_BLTDONE 0x4000 #define DMAF_BLTNZERO 0x2000 #define DMAB_SETCLR 15 #define DMAB_AUD0 0 #define DMAB_AUD1 1 #define DMAB_AUD2 2 #define DMAB_AUD3 3 #define DMAB_DISK 4 #define DMAB_SPRITE 5 #define DMAB_BLITTER 6 #define DMAB_COPPER 7 #define DMAB_RASTER 8 #define DMAB_MASTER 9 #define DMAB_BLITHOG 10 #define DMAB_BLTDONE 14 #define DMAB_BLTNZERO 13 #endif /* HARDWARE_DMABITS_H */ [Back to Amiga Developer Docs ]
AmigaMail_Vol2_guide/node013D.html.txt:1:XII-1: CDTV Application Guidelines ]" border=0> Staff A CDTV application is not simply an Amiga application running in a different box. The CDTV player imposes certain restrictions on an application--no menus and large icons, for example, and provides certain benefits--large storage capacity and digital audio. The wise CDTV developer respects the former and takes advantage of the latter. The list below gives you, the developer, a quick reference to the do's and don'ts of CDTV applications. It contains rules and common sense advice. They are broken into two groups, minimum requirements and quality standards. Minimum Requirements - The minimum necessary to be an acceptable CDTV application. Quality Standards - To get into people's homes, you need to do more than the minimum. These will help you make the trip. Level 1 Minimum Requirements Reference Titles Recreation Titles Level 2 Quality: The Next Standard [Back to Amiga Developer Docs ]
Devices_Manual_guide/node02EE.html.txt:1:Devices/iffp/8svx.h ]" border=0> /*-----------------------------------------------------------------------* * 8SVX.H Definitions for 8-bit sampled voice (VOX). 2/10/86 * * By Jerry Morrison and Steve Hayes, Electronic Arts. * This software is in the public domain. * * Modified for use with iffparse.library 05/91 - CAS_CBM * * This version for the Amiga computer. *----------------------------------------------------------------------*/ #ifndef EIGHTSVX_H #define EIGHTSVX_H #ifndef COMPILER_H #include "iffp/compiler.h" #endif #include "iffp/iff.h" #define ID_8SVX MAKE_ID('8', 'S', 'V', 'X') #define ID_VHDR MAKE_ID('V', 'H', 'D', 'R') #define ID_ATAK MAKE_ID('A', 'T', 'A', 'K') #define ID_RLSE MAKE_ID('R', 'L', 'S', 'E') /* defined in iffp/iff.h #define ID_NAME MAKE_ID('N', 'A', 'M', 'E') #define ID_Copyright MAKE_ID('(', 'c', ')', ' ') #define ID_AUTH MAKE_ID('A', 'U', 'T', 'H') #define ID_ANNO MAKE_ID('A', 'N', 'N', 'O') #define ID_BODY MAKE_ID('B', 'O', 'D', 'Y') */ /* ---------- Voice8Header ---------------------------------------------*/ typedef LONG Fixed; /* A fixed-point value, 16 bits to the left of * the point and 16 to the right. A Fixed is a * number of 2**16ths, i.e. 65536ths. */ #define Unity 0x10000L /* Unity = Fixed 1.0 = maximum volume */ /* sCompression: Choice of compression algorithm applied to the samples. */ #define sCmpNone 0 /* not compressed */ #define sCmpFibDelta 1 /* Fibonacci-delta encoding (Appendix C) */ /* Could be more kinds in the future. */ typedef struct { ULONG oneShotHiSamples, /* # samples in the high octave 1-shot part */ repeatHiSamples, /* # samples in the high octave repeat part */ samplesPerHiCycle; /* # samples/cycle in high octave, else 0 */ UWORD samplesPerSec; /* data sampling rate */ UBYTE ctOctave, /* # of octaves of waveforms */ sCompression; /* data compression technique used */ Fixed volume; /* playback nominal volume from 0 to Unity * (full volume). Map this value into * the output hardware's dynamic range. */ } Voice8Header; /* ---------- NAME -----------------------------------------------------*/ /* NAME chunk contains a CHAR[], the voice's name. */ /* ---------- Copyright ------------------------------------------------*/ /* "(c) " chunk contains a CHAR[], the FORM's copyright notice. */ /* ---------- AUTH -----------------------------------------------------*/ /* AUTH chunk contains a CHAR[], the author's name. */ /* ---------- ANNO -----------------------------------------------------*/ /* ANNO chunk contains a CHAR[], the author's text annotations. */ /* ---------- Envelope ATAK & RLSE -------------------------------------*/ typedef struct { UWORD duration; /* segment duration in milliseconds, > 0 */ Fixed dest; /* destination volume factor */ } EGPoint; /* ATAK and RLSE chunks contain an EGPoint[], piecewise-linear envelope. */ /* The envelope defines a function of time returning Fixed values. * It's used to scale the nominal volume specified in the Voice8Header. */ /* ---------- BODY -----------------------------------------------------*/ /* BODY chunk contains a BYTE[], array of audio data samples. */ /* (8-bit signed numbers, -128 through 127.) */ /* ---------- 8SVX Writer Support Routines -----------------------------*/ /* Just call this macro to write a VHDR chunk. */ #define PutVHDR(iff, vHdr) \ PutCk(iff, ID_VHDR, sizeof(Voice8Header), (BYTE *)vHdr) #endif [Back to Amiga Developer Docs ]
AmigaMail_Vol2_guide/node0022.html.txt:1:Audio.device ]" border=0> * Now not initialized until used. This means low memory open failure is possible. Check your return values from OpenDevice(). This also means audio.device cannot be opened during 2.0 Strap unless InitResident()ed first. If OpenDevice() of audio.device fails during strap, you must FindResident()/InitResident() audio.device, and then try OpenDevice() again. There will be a small memory loss (until reboot) generated by the first opener of audio.device or narrator.device (memory used in building of audio.device's base). [Back to Amiga Developer Docs ]
AmigaMail_Vol2_guide/node0000.html.txt:1:Contents of Amiga Mail articles - as of May/June 1993 ]" border=0> Amiga Mail Volume II is a bi-monthly technical publication that contains additional information and examples on the correct usage of the techniques and operating system functions. I Programming Practices and Standards - general purpose programming II AmigaDOS - dos.library III Exec - the multitasking executive, exec.library IV Intuition and Workbench - the Amiga user interface V Graphics - animation, text, the Blitter, layers.library VI Sound and Music - audio, speech, MIDI VII IFF - iffparse.library and other IFF topics VIII Unix and Networking - Unix SVR4, NFS, TCP/IP, Ethernet IX Timer, Serial, and Parallel - timer.device, serial & parallel port X Output - printers, printing, Postscript XI Input - user input, Commodities Exchange XII CDTV - Commodore Dynamic Total Vision XIII Hardware - Cards, chips, connectors © Copyright 1996-1999 Amiga, Inc. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node0161.html.txt:1:Devices/Dev_examples/Audio.c ]" border=0> /* * Audio.c * * Audio example * * Compile with SAS C 5.10 lc -b1 -cfistq -v -y -L * * Run from CLI only */ #include #include #include #include #include #include #include #include #include #include #include #include #ifdef LATTICE int CXBRK(void) { return(0); } /* Disable SAS CTRL/C handling */ int chkabort(void) { return(0); } /* really */ #endif struct GfxBase *GfxBase; /*-----------------------------------------------------------*/ /* The whichannel array is used when we allocate a channel. */ /* It tells the audio device which channel we want. The code */ /* is 1 =channel0, 2 =channel1, 4 =channel2, 8 =channel3. */ /* If you want more than one channel, add the codes up. */ /* This array says "Give me channel 0. If it's not available */ /* then try channel 1; then try channel 2 and then channel 3 */ /*-----------------------------------------------------------*/ UBYTE whichannel[] = { 1,2,4,8 }; void main(int argc, char **argv) { struct IOAudio *AudioIO; /* Pointer to the I/O block for I/O commands */ struct MsgPort *AudioMP; /* Pointer to a port so the device can reply */ struct Message *AudioMSG; /* Pointer for the reply message */ ULONG device; BYTE *waveptr; /* Pointer to the sample bytes */ LONG frequency = 440; /* Frequency of the tone desired */ LONG duration = 3; /* Duration in seconds */ LONG clock = 3579545; /* Clock constant, 3546895 for PAL */ LONG samples = 2; /* Number of sample bytes */ LONG samcyc = 1; /* Number of cycles in the sample */ /*-----------------------------------------------------------------------*/ /* Ask the system if it is PAL or NTSC and set clock constant accordingly*/ /*-----------------------------------------------------------------------*/ GfxBase = (struct GfxBase *)OpenLibrary("graphics.library",0L); if (GfxBase == 0L) goto killaudio; if (GfxBase->DisplayFlags & PAL) clock = 3546895; /* PAL clock */ else clock = 3579545; /* NTSC clock */ if (GfxBase) CloseLibrary((struct Library *) GfxBase); /*-----------------------------------------------------------------------*/ /* Create an audio I/O block so we can send commands to the audio device*/ /*-----------------------------------------------------------------------*/ AudioIO = (struct IOAudio *) AllocMem( sizeof(struct IOAudio),MEMF_PUBLIC | MEMF_CLEAR); if (AudioIO == 0) goto killaudio; printf("IO block created...\n"); /*-------------------------------------------------------------------*/ /* Create a reply port so the audio device can reply to our commands */ /*-------------------------------------------------------------------*/ AudioMP = CreatePort(0,0); if (AudioMP == 0) goto killaudio; printf("Port created...\n"); /*----------------------------------------------------------------------*/ /* Set up the audio I/O block for channel allocation: */ /* ioa_Request.io_Message.mn_ReplyPort is the address of a reply port. */ /* ioa_Request.io_Message.mn_Node.ln_Pri sets the precedence (priority) */ /* of our use of the audio device. Any tasks asking to use the audio */ /* device that have a higher precedence will steal the channel from us.*/ /* ioa_Request.io_Command is the command field for I/O. */ /* ioa_Request.io_Flags is used for the I/O flags. */ /* ioa_AllocKey will be filled in by the audio device if the allocation */ /* succeeds. We must use the key it gives for all other commands sent.*/ /* ioa_Data is a pointer to the array listing the channels we want. */ /* ioa_Length tells how long our list of channels is. */ /*----------------------------------------------------------------------*/ AudioIO->ioa_Request.io_Message.mn_ReplyPort = AudioMP; AudioIO->ioa_Request.io_Message.mn_Node.ln_Pri = 0; AudioIO->ioa_Request.io_Command = ADCMD_ALLOCATE; AudioIO->ioa_Request.io_Flags = ADIOF_NOWAIT; AudioIO->ioa_AllocKey = 0; AudioIO->ioa_Data = whichannel; AudioIO->ioa_Length = sizeof(whichannel); printf("I/O block initialized for channel allocation...\n"); /*-----------------------------------------------*/ /* Open the audio device and allocate a channel */ /*-----------------------------------------------*/ device = OpenDevice(AUDIONAME,0L, (struct IORequest *) AudioIO ,0L); if (device != 0) goto killaudio; printf("%s opened, channel allocated...\n",AUDIONAME); /*----------------------------------------------*/ /* Create a very simple audio sample in memory. */ /* The sample must be CHIP RAM */ /*----------------------------------------------*/ waveptr = (BYTE *)AllocMem( samples , MEMF_CHIP|MEMF_PUBLIC); if (waveptr == 0) goto killaudio; waveptr[0] = 127; waveptr[1] = -127; printf("Wave data ready...\n"); /*------------------------------------------------------------*/ /* Set up audio I/O block to play a sample using CMD_WRITE. */ /* The io_Flags are set to ADIOF_PERVOL so we can set the */ /* period (speed) and volume with the our sample; */ /* ioa_Data points to the sample; ioa_Length gives the length */ /* ioa_Cycles tells how many times to repeat the sample */ /* If you want to play the sample at a given sampling rate, */ /* set ioa_Period = clock/(given sampling rate) */ /*------------------------------------------------------------*/ AudioIO->ioa_Request.io_Message.mn_ReplyPort =AudioMP; AudioIO->ioa_Request.io_Command =CMD_WRITE; AudioIO->ioa_Request.io_Flags =ADIOF_PERVOL; AudioIO->ioa_Data =(BYTE *)waveptr; AudioIO->ioa_Length =samples; AudioIO->ioa_Period =clock*samcyc/(samples*frequency); AudioIO->ioa_Volume =64; AudioIO->ioa_Cycles =frequency*duration/samcyc; printf("I/O block initialized to play tone...\n"); /*-------------------------------------------------------*/ /* Send the command to start a sound using BeginIO() */ /* Go to sleep and wait for the sound to finish with */ /* WaitPort(). When we wake-up we have to get the reply */ /*-------------------------------------------------------*/ printf("Starting tone now...\n"); BeginIO((struct IORequest *) AudioIO ); WaitPort(AudioMP); AudioMSG = GetMsg(AudioMP); printf("Sound finished...\n"); killaudio: printf("Killing audio device...\n"); if (waveptr != 0) FreeMem(waveptr, 2); if (device == 0) CloseDevice( (struct IORequest *) AudioIO ); if (AudioMP != 0) DeletePort(AudioMP); if (AudioIO != 0) FreeMem( AudioIO,sizeof(struct IOAudio) ); } [Back to Amiga Developer Docs ]
AmigaMail_Vol2_guide/node00C6.html.txt:1:IV-101: Introduction to the Datatypes Library ]" border=0> Introduction to the Datatypes Library by Dan Baker The latest version of the Amiga operating system, Release 3.0, includes the new datatypes library. The purpose of the datatypes library is to provide software tools for handling data in an object-oriented way. The object-oriented approach means that your application can work with numerous data file standards without having to worry about the complex details of each one. Instead you need only understand the simple conventions of the datatypes library. The datatypes library is built on Intuition's boopsi facility (boopsi is an acronym for Basic Object-Oriented Programming System for Intuition). Although not required, it is very helpful to know a little about how boopsi works before trying to use the datatypes library. For information on boopsi, refer to chapter 12 and appendix B of the Amiga ROM Kernel Reference Manual: Libraries (ISBN 0-201-56774-1). Some familiarity with object-oriented theory and practice is also helpful, though not required. Since the datatypes library uses the TagItem structure for passing parameters to functions, you will have to understand how TagItems work before you can call the functions in the datatypes library. For more information on TagItems refer to chapter 37 of the Libraries manual. Why Use the Datatypes Library? One practical benefit of the datatypes library is that it allows you to quickly add support for IFF data files (this article will show you how). However, the goals of the datatypes library are much more ambitious than that. Here's a summary: Consistent, simple handling of multiple data standards - Most of the details of dealing with the various data standards are hidden. Once you have learned how to handle one type of data with the datatypes library, you will find that the other types are handled in much the same way. Extensible - You can add your own types of data objects to those already supported by the datatypes library. Datatypes has functions that allow other applications to find out about and work with your data object, without having to understand the internal details of the data. Automatic support of IFF and clipboard - The initial version of the datatypes library (V39) provides support for 8SVX sound data and ILBM graphic data. These are the two most widely used data file standards on the Amiga. Developers who want to support these IFF standards no longer have to become IFF experts. Similarly, the datatypes library provides a consistent and easy-to-use interface to the Amiga's clipboard device to encourage data sharing between applications. Intuition gadget support - Because the datatypes library is implemented with boopsi, the data objects it handles can also be treated as gadgets. Gadget operations can be performed on data objects within Intuition's task context, the same as other boopsi gadgets. Automatic conversion from one format to another - Future versions of the datatypes library will support other types of data objects. Conversion from one format to another will be automatically handled by the library. Validation - Datatypes lets you easily check if a given file is a valid instance of one of the data objects it supports. For example, you can check to see if a file is a valid ILBM or not. Classes, Objects and Methods The jargon used to describe the datatypes library may be a little confusing if you have never worked with object-oriented systems before. For instance, the kinds of data supported by the library are divided into ``classes'' and ``sub-classes''. The term ``class'' is used here in a familiar way; the members of a class simply have a common set of properties. The members of a sub-class have all the properties of the parent class and additional properties specific to the sub-class. (Each sub-class could be further broken down into sub-sub-classes and so on.) Class: Ungulate Has hooves, can run. Sub-class: Cow Has udder, can be milked (also has hooves and can run). Object: Daisy An instance of class Cow; can run and can be milked. An actual instance of a class or sub-class is referred to as an ``object''. The term ``object'' is appropriate because in general we want to ignore the details of each individual case and concentrate instead on what we can do with an object based on its class. In the example above the Daisy object can run and can be milked. The operations that can be performed with an object are referred to as ``methods'' and the object is said to ``inherit'' the methods and other attributes of its parent class (which in turn inherits the methods and attributes of its parent class, if it has one). Currently, there are only four object classes (see Table 1) in the datatypes library. More will be implemented in future versions of the Amiga OS. Table 1: Datatypes Library Object Classes in Release 3.0 (V39) Object Classes Autodoc File Showing the and Sub-classes Methods Supported Type of Data Object ----------------- -------------------------- --------------------- Picture class ILBM sub-class IFF graphic image file Sound class 8SVX sub-class IFF audio sample file Text class ASCII sub-class ASCII characters AmigaGuide class Hypertext databases The examples programs listed below demonstrate how to perform some basic ``methods'' on ILBM and 8SVX class objects. Datatypes Class Attributes Datatype library classes have other attributes in addition to the methods (operations) that they support. For each attribute, there is a corresponding TagItem defined in the datatypes library that you can use to examine or set that attribute in a particular object For example, picture objects have a display mode attribute. The tag that controls this attribute is named PDTA_ModeID and is described in the Autodoc file picture_dtc.doc. See the Autodoc files for each class (as shown in Table 1) for a complete list of all class attributes. The class attribute descriptions in the include files also have a set of codes that indicate the ``applicability'' of the attribute. The codes are as follows: I - Initialize. You can initialize the attribute when the object is created. S - Set. You can set the attribute to a new value after the object is created. G - Get. You can get the value of the attribute after the object is created. N - Notify. Changing the attribute triggers the object to send notification. U - Update. Attribute can be set using the object's OM_UPDATE method. These codes may seem a little mysterious until you have actually tried using the datatypes library. The N and U codes in particular are for special applications that want to implement their own object classes, an advanced topic beyond the scope of this article. Basic Functions of the Datatypes Library If all these new concepts seem a little daunting, rest assured; the datatypes library uses conventional C language function calls to get the job done. The calls you will be using most often are listed below. Notice that for each of these basic functions of the V39 datatypes library there is an equivalent boopsi call in the V37 Intuition library. Function Name Library Purpose ----------------- ----------------- ------------------------------------ NewDTObject() datatypes.library Create a datatype object in NewObject() intuition.library memory from a file or clip. DisposeDTObject() datatypes.library Free an object created earlier with DisposeObject() intuition.library NewDTObject() (or NewObject() ). GetDTAttrs() datatypes.library Get attributes of a datatype object. GetAttr() intuition.library SetDTAttrs() datatypes.library Set attributes for a datatype object. SetAttrs() intuition.library DoDTMethod() datatypes.library Perform the given method (operation) DoMethod() amiga.lib with a datatype object. In a typical application the sequence of calls might be performed like this: 1. Use NewDTObject() to create an object in memory from given data. 2. Get (or perhaps set) attributes of the object using GetDTAttr() (or SetDTAttrs() ). 3. Perform ``methods'' (operations) with the object using DoDTMethod(). 4. Free the object and any memory or other resources it was using with the DisposeDTObject() call. Basic Structures of the Datatypes Library There are a lot of structures used with datatypes library function calls; too many to summarize in this article. However, here's a listing of the relevant include files that contain the structure definitions of interest to class users. Group IDs, error numbers plus library overhead Defines datatype methods and associated structures Structures specific to the picture class Structures specific to the sound class Structures specific to the text class Structures and methods for AmigaGuide databases Defines general boopsi object methods Defines gadget methods and associated structures The two most important definitions in these include files appear in . The objects used with datatypes library functions (and the boopsi functions in Intuition) are defined as follows: typedef ULONG Object; /* abstract handle */ Since we want to treat objects as black boxes and don't really care how they are implemented, this definition is very appropriate. When a method is performed with an object, the parameter used to identify the method is a Msg structure defined as follows: typedef struct { ULONG MethodID; /* method-specific data goes here */ } *Msg; Some methods require more information than just the method identifier. Such methods have a custom structure defined in the include files. All method structures, however, begin with a field that contains the method ID. A Simple Datatypes Example The example program listed here should clarify some of the concepts discussed so far. Suppose you have a communications program and want to add the capability of playing back a user-specified 8SVX sample file for the bell sound (Ctrl-G). The program below shows how to play a sound with the datatypes library. In this program, objects are of class 8SVX (a sub-class of the sound datatype). The method performed with the object is named DTM_TRIGGER (described in the Autodoc file sound_dtc.doc). The DTM_TRIGGER method (with type set to STM_PLAY) causes a sampled sound to be played on the Amiga's audio hardware. Since the DTM_TRIGGER method requires other information in addition to the method ID, a dtTrigger structure is used. This structure is defined in . Note that if the sound datatype is enhanced to support other types of sound files in a future version of the Amiga OS, the code given here will automatically support the new type. This example expects the file name and path to a sound file. dt.c In addition to playing back a sampled sound, the datatypes library allows sound objects to become gadgets (the library includes default imagery for a sound gadget). Since all datatypes object classes are implemented as a sub-class of the boopsi ``gadget'' class, they all support the methods of gadget objects as described in the boopsi chapter of the Libraries manual. A Picture Class Example Here is a second, more complex example showing how to use all the datatypes library functions described so far. In this example, the objects used are of class ILBM, a sub-class of picture. Two methods will be performed with the object, DTM_PROCLAYOUT and DTM_FRAMEBOX. Both these methods have associated structures (gpLayout and dtFrameBox respectively). DTM_PROCLAYOUT makes the object available within the context of your application task (as opposed to Intuition's). DTM_FRAMEBOX queries the display environment required by the picture. Other attributes of the picture are obtained with a call to GetDTAttrs() and then a matching Intuition screen is created and the ILBM object is displayed. This example expects the file and path name of a picture file. dtpic.c As with 8SVX objects, the datatypes library allows ILBM objects to be treated as gadgets. Remember that all datatypes object classes a sub-class of the boopsi ``gadget'' class and therefore support the gadget methods described in the boopsi chapter of the Amiga ROM Kernel Reference Manual: Libraries. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node001F.html.txt:1:2 / Device Interface / Opening The Audio Device ]" border=0> Before you can use the audio device, you must first open it with a call to OpenDevice() . Four primary steps are required to open the audio device: * Create a message port using CreatePort Reply messages from the device must be directed to a message port. * Allocate memory for an extended I/O request structure of type IOAudio using AllocMem() . * Fill in io_Message.mn_ReplyPort with the message port created by CreatePort. * Open the audio device. Call OpenDevice(), passing IOAudio. struct MsgPort *AudioMP; /* Define storage for port pointer */ struct IOAudio *AudioIO; /* Define storage for IORequest pointer */ if (AudioMP = CreatePort(0,0) ) { AudioIO = (struct IOAudio *) AllocMem(sizeof(struct IOAudio), MEMF_PUBLIC | MEMF_CLEAR); if (AudioIO) { AudioIO->ioa_Request.io_Message.mn_ReplyPort = AudioMP; AudioIO->ioa_AllocKey = 0; } if (OpenDevice(AUDIONAME,0L,(struct IORequest *)AudioIO,0L) ) printf("%s did not open\n",AUDIONAME); A special feature of the OpenDevice() function with the audio device allows you to automatically allocate channels for your program to use when the device is opened. This is convenient since you must allocate one or more channels before you can produce sound. This is done by setting ioa_AllocKey to zero, setting ioa_Request.io_Message.mn_Node.ln_Pri to the appropriate precedence, setting io_Data to the address of a channel combination array, and setting ioa_Request.ioa_Length to a non-zero value (the length of the channel combination array). The audio device will attempt to allocate channels just as if you had sent the ADCMD_ALLOCATE command (see below). If the allocation fails, the OpenDevice() call will return immediately. If you want to allocate channels at some later time, set the ioa_Request.ioa_Length field of the IOAudio block to zero when you call OpenDevice(). For more on channel allocation and the ADCMD_ALLOCATE command, see the section on Allocation and Arbitration below. UBYTE chans[] = {1,2,4,8}; /* get any of the four channels */ if (AudioIO) { AudioIO->ioa_Request.io_Message.mn_ReplyPort = AudioMP; AudioIO->ioa_AllocKey = 0; AudioIO->ioa_Request.io_Message.mn_Node.ln_Pri= 120; AudioIO->ioa_Data = chans; AudioIO->ioa_Length = sizeof(chans); } if (OpenDevice(AUDIONAME,0L,(struct IORequest *)AudioIO,0L) ) printf("%s did not open\n",AUDIONAME); [Back to Amiga Developer Docs ]
AmigaMail_Vol2_guide/node0020.html.txt:1:Strap ]" border=0> * romboot.library is gone. * audio.device cannot be OpenDevice()ed by a boot block program because it is not yet InitResident()ed. If OpenDevice() of audio.device fails during strap, you must FindResident()/InitResident() audio.device, and then try OpenDevice() again. * Boot from other floppies (+5,-10,-20,-30) is possible. * Undocumented system stack and register usage at Diag and Boot time have changed. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node001B.html.txt:1:2 Audio Device / About Amiga Audio ]" border=0> Most personal computers that produce sound have hardware designed for one specific synthesis technique. The Amiga computer uses a very general method of digital sound synthesis that is quite similar to the method used in digital hi-fi components and state-of-the-art keyboard and drum synthesizers. For programs that can afford the memory, playing sampled sounds gives you a simple and very CPU-efficient method of sound synthesis. A sampled sound is a table of numbers which represents a sound digitally. When the sound is played back by the Amiga, the table is fed by a DMA channel into one of the four digital-to-analog converters in the custom chips. The digital-to-analog converter converts the samples into voltages that can be played through amplifiers and loudspeakers, reproducing the sound. On the Amiga you can create sound data in many other ways. For instance, you can use trigonometric functions in your programs to create the more traditional sounds - sine waves, square waves, or triangle waves - by using tables that describe their shapes. Then you can combine these waves for richer sound effects by adding the tables together. Once the data are entered, you can modify them with techniques described below. For information about the limitations of the audio hardware and suggestions for improving system efficiency and sound quality, refer to the Amiga Hardware Reference Manual . Some commands enable your program to co-reside with other programs using the audio device at the same time. Programs can co-reside because the audio device handles allocation of audio channels and arbitrates among programs competing for the same resources. When properly used, this allows many programs to use the audio device simultaneously. The audio device commands help isolate the programmer from the idiosyncrasies of the custom chip hardware and make it easier to use. But you can also produce sound on the Amiga by directly accessing the hardware registers if you temporarily lock out other users first. For certain types of sound synthesis, this is more CPU-efficient. Definitions [Back to Amiga Developer Docs ]
Devices_Manual_guide/node003F.html.txt:1:10 Printer Device / Printer Device Commands and Functions ]" border=0> Command Operation ------- ---------- CMD_FLUSH Remove all queued requests for the printer device. Does not affect active requests. CMD_RESET Reset the printer device to its initialized state. All active and queued I/O requests will be aborted. CMD_START Restart all paused I/O requests CMD_STOP Pause all active and queued I/O requests. CMD_WRITE Write out a stream of characters to the printer device. The number of characters can be specified or a NULL-terminated string can be sent. PRD_DUMPRPORT Dump the specified RastPort to a graphics printer. PRD_PRTCOMMAND Send a command to the printer. PRD_QUERY Return the status of the printer port's lines and registers. PRD_RAWWRITE Send unprocessed output to the the printer. Exec Functions as Used in This Chapter -------------------------------------- AbortIO() Abort a command to the printer device. CloseDevice() Relinquish use of the printer device. All requests must be complete before closing. DoIO() Start a command and wait for completion (synchronous request). OpenDevice() Obtain use of the printer device. SendIO() Start a command and return immediately (asynchronous request). WaitIO() Wait for the completion of an asynchronous request. When the request is complete, the message will be removed from the printer message port. Exec Support Functions as Used in This Chapter ---------------------------------------------- CreatePort() Create a signal message port for reply messages from the audio device. Exec will signal a task when a message arrives at the reply port. CreateExtIO() Create an I/O request structure of type printerIO. This structure will be used to send commands to the printer device. DeletePort() Delete the message port created by CreatePort() . DeleteExtIO() Delete an I/O request structure created by CreateExtIO() . [Back to Amiga Developer Docs ]
Devices_Manual_guide/node0115.html.txt:1:8 Narrator Device / Device Interface ]" border=0> The narrator device operates like all other Amiga devices. To use the narrator device, you must first open it. This initializes certain global areas, opens the audio device, allocates audio channels, and performs other housekeeping functions. Once open, the device is ready to receive I/O commands (most typically CMD_WRITE and CMD_READ ). Finally, when finished, the user should close the device. This will free some buffers and allow the entire device to be expunged should the system require memory. See the Introduction to Amiga System Devices chapter for general information on device usage. The narrator device uses two extended I/O request structures: narrator_rb for write commands (to produce speech output) and mouth_rb for read commands (to receive mouth shape changes and word/syllable synchronization events). Both I/O request structures have been expanded (in a backwards compatible fashion) for the V37 narrator device with several new fields defined. struct narrator_rb { struct IOStdReq message; /* Standard IORequest Block */ UWORD rate; /* Speaking rate (words/minute) */ UWORD pitch; /* Baseline pitch in Hertz */ UWORD mode; /* Pitch mode */ UWORD sex; /* Sex of voice */ UBYTE *ch_masks; /* Pointer to audio allocation maps */ UWORD nm_masks; /* Number of audio allocation maps */ UWORD volume; /* Volume. 0 (off) thru 64 */ UWORD sampfreq; /* Audio sampling frequency */ UBYTE mouths; /* If non-zero, generate mouths */ UBYTE chanmask; /* Which ch mask used (internal - do not modify)*/ UBYTE numchan; /* Num ch masks used (internal- do not modify) */ UBYTE flags; /* New feature flags */ UBYTE F0enthusiasm; /* F0 excursion factor */ UBYTE F0perturb; /* Amount of F0 perturbation */ BYTE F1adj; /* F1 adjustment in +- 5% steps */ BYTE F2adj; /* F2 adjustment in +- 5% steps */ BYTE F3adj; /* F3 adjustment in +- 5% steps */ BYTE A1adj; /* A1 adjustment in decibels */ BYTE A2adj; /* A2 adjustment in decibels */ BYTE A3adj; /* A3 adjustment in decibels */ UBYTE articulate; /* Transition time multiplier */ UBYTE centralize; /* Degree of vowel centralization */ char *centphon; /* Pointer to central ASCII phon */ BYTE AVbias; /* Amplitude of voicing bias */ BYTE AFbias; /* Amplitude of frication bias */ BYTE priority; /* Priority while speaking */ BYTE pad1; /* For alignment */ }; struct mouth_rb { struct narrator_rb voice;/* Speech IORequest Block */ UBYTE width; /* Mouth width (returned value) */ UBYTE height; /* Mouth height (returned value) */ UBYTE shape; /* Internal use, do not modify */ UBYTE sync; /* Returned sync events */ }; Details on the meaning of the various fields of the two I/O request blocks can be found in the Writing to the Narrator Device and Reading from the Narrator Device sections later in this chapter. See the include file devices/ narrator.h for the complete structure definitions. The Amiga Speech System Opening The Narrator Device Closing The Narrator Device [Back to Amiga Developer Docs ]
Devices_Manual_guide/node012F.html.txt:1:Audio Device Index ]" border=0> Audio Device, 13 AbortIO(), 18 additional information, 34 BeginIO(), 18 changing the volume, 26 channel, 14 CloseDevice(), 18 closing, 18 CMD_FLUSH, 27 CMD_READ, 27 CMD_RESET, 27 CMD_START, 27 CMD_STOP, 27 CMD_WRITE, 25 commands and functions, 15 definitions, 14 device interface, 16 double-buffering, 26 free, 17 hardware control commands, 25 IORequest block, 16 IORequest structures, 16 lock, 17 opening, 16 playing a sound, 25 precedence of users, 22 precedence, 17 reserve, 17 sample, 14 scope of commands, 17 simple audio example, 18 starting a sound, 27 steal channel, 22 stopping a sound, 26 , 27 Wait(), 18 WaitPort(), 18 [Back to Amiga Developer Docs ]
Devices_Manual_guide/node0119.html.txt:1:8 Narrator Device / Writing to the Narrator Device ]" border=0> You write to the narrator device by passing a narrator_rb I/O request to the device with CMD_WRITE set in io_Command, the number of bytes to be written set in io_Length and the address of the write buffer set in io_Data. VoiceIO->message.io_Command = CMD_WRITE; VoiceIO->message.io_Offset = 0; VoiceIO->message.io_Data = PhonBuffer; VoiceIO->message.io_Length = strlen(PhonBuffer); DoIO((struct IORequest *)VoiceIO); You can control several characteristics of the speech, as indicated in the narrator_rb struct shown in the Device Interface section. Generally, the narrator device attempts to speak in a non-regional dialect of American English. With pre-V37 versions of the device, the user could change only a few of the more basic aspects of the speaking voice such as pitch, male/female, speaking rate, etc. With the V37 and later versions of the narrator device, the user can now change many more aspects of the speaking voice. In addition, in the pre-V37 device, only mouth shape changes could be queried by the user. With the V37 device, the user can also receive start of word and start of syllable synchronization events. These events can be generated independently, giving the user much greater flexibility in synchronizing voice to animation or other effects. The following describes the fields of the narrator_rb structure: message.io_Data Points to a NULL-terminated ASCII phonetic input string. For backwards compatibility issues, the string may also be terminated with a "#" symbol. See the How to Write Phonetically for Narrator section of this chapter for details. message.io_Length Length of the input string. The narrator device will parse the input string until either a NULL or a "#" is encountered, or until io_Length characters have been processed. rate The speaking rate in words/minute. Range is from 40 to 400 wpm. pitch The baseline pitch of the speaking voice. Range is 65 to 320 Hertz. mode The F0 (pitch) mode. ROBOTICF0 produces a monotone pitch, NATURALF0 produces a normal pitch contour, and MANUALF0 (new for V37 and later) gives the user more explicit control over the pitch contour by creative use of accent numbers. In MANUALF0 mode, a given accent number will have the same effect on the pitch regardless of its position in the sentence and its relation to other accented syllables. In NATURALF0 mode, accent numbers have a reduced effect towards the end of sentences (especially long ones). In addition, the proximity of other accented syllables, the number of syllables in the word, and the number of phrases and words in the sentence all affect the pitch contour. In MANUALF0 mode these things are ignored and it's up to the user to do the controlling. This has the advantage of being able to have the pitch be more expressive. The F0enthusiasm field will scale the effect. sex Controls the sex of the speaking voice (MALE or FEMALE). In actuality, only the formant targets are changed. The user must still change the pitch and speaking rate of the voice to get the correct sounding sex. See the include files for default pitch and rate settings. ch_masks Pointer to a set of audio allocation maps. See the " Audio Device " chapter for details. nm_masks Number of audio allocation maps. See the " Audio Device " chapter for details. volume Sets the volume of the speaking voice. Range 0 - 64. sampfreq The synthesizer is ``tuned" to a sampling frequency of 22,200 Hz. Changing sampfreq affects pitch and formant tunings and can be used to create unusual vocal effects. For V37 and later, it is recommended that F1, F2, and F3adj be used instead to achieve this effect. mouths If set to a non-zero value will direct the narrator device to generate mouth shape changes and send this data to the user in response to read requests. See the Reading from the Narrator Device section for more details. chanmask Used internally by the narrator device. The user should not modify this field. numchan Used internally by the narrator device. The user should not modify this field. flags (V37) Used to specify V37 features of the device. Possible bit settings are: NDB_NEWIORB - I/O request block uses V37 features. NDB_WORDSYNC - Device should generate start of word sync events. NDB_SYLSYNC - Device should generate start of syllable sync events. These bit definitions and their corresponding field definitions (NDF_NEWIORB, NDF_WORDSYNC, and NDF_SYLSYNC) can be found in the include files. F0enthusiasm (V37) The value of this field controls the scaling of pitch (F0) excursions used on accented syllables and has the effect of making the narrator device sound more or less "enthusiastic" about what it is saying. It is calibrated in 1/32s with unity (32) being the default value. Higher values cause more F0 variation, lesser values cause less. This feature is most useful in manual F0 mode. F0perturb (V37) Non-zero values in this field cause varying amounts of random low-frequency modulation of the pitch (F0). In other words, the pitch shakes in much the same way as an elderly person's voice does. Range is 0 to 255. F1adj, F2adj, F3adj (V37) Changes the tuning of the formant frequencies. A formant is a major vocal tract resonance, and the frequencies of these formants move continuously as we speak. Traditionally, they have been given the abbreviations of F1, F2, F3... with F1 being the one lowest in frequency. Moving these formants away from their normal positions causes drastic changes in the sound of the voice and is a very powerful tool in the creation of character voices. This adjustment is in ±5% steps. Positive values raise the formant frequencies and vice versa. The default is zero. Use these adjustments instead of changing sampfreq. A1adj, A2adj, A3adj (V37) In a parallel formant synthesizer, the amplitudes of the formants need to be specified along with their frequencies. These fields bias the amplitudes computed by the narrator device. This is useful for creating different tonal balances (bass or treble), and listening to formants in isolation for educational purposes. The adjustments are calibrated directly in ±1db (decibel) steps. Using negative values will cause no problems; use of positive numbers can cause clipping. If you want to raise an amplitude, try cutting the others the same relative amount, then bring them all up equally until clipping is heard, then back them off. This should produce an optimum setting. This field has a +31 to -32 db range and the value -32db is equivalent to -infinity, shutting that formant off completely. articulate (V37) According to the popular theories of speech production, we move our articulators (jaw, tongue, lips, etc.) smoothly from one "target" position to the next. These articulatory targets correspond to acoustic targets specified by the narrator device for each phoneme. The device calculates the time it should take to get from one target to the next and this field allows you to intervene in that process. Values larger than the default will cause the transitions to be proportionately longer and vice versa. This field is calibrated in percent with 100 being the default. For example, a value of 50 will cause the transitions to take half the normal time, with the result being "sharper", more deliberate sounding speech (not necessarily more natural). A value of 200 will cause the transitions to be twice as long, slurring the speech. Zero is a special value in the narrator device will take special measures to create no transitions at all and each phoneme will simply be abutted to the next. centralize (V37) This field together with centphon can be used to create regional accent effects by modifying vowel sounds. centralize specifies the degree (in percent) to which vowel targets are "pulled" towards the targets of the vowel specified by centphon. The default value of 0% indicates that each vowel in the utterance retains its own target values. The maximum value of 100% indicates that each vowel's targets are replaced by the targets of the specified vowel. Intermediate values control the degree of interpolation between the utterance vowel's targets and the targets of the vowel specified by centphon. centphon (V37) Pointer to an ASCII string specifying the vowel whose targets are used in the interpolation specified by centralize. The vowels which can be specified are: IY, IH, EH, AE, AA, AH, AO, OW, UH, ER, UW. Specifying other than these will result in an error code being returned. AVbias, AFbias (V37) Controls the relative amplitudes of the voiced and unvoiced speech sounds. Voiced sounds are those made with the vocal cords vibrating, such as vowels and some consonants like y, r, w, and m. Unvoiced sounds are made without the vocal cords vibrating and use the sound of turbulent air, such as s, t, sh, and f. Some sounds are combinations of both such as z and v. AVbias and AFbias change the default amplitude of the voiced and unvoiced components of the sounds respectively. (AV stands for Amplitude of Voicing and AF stands for Amplitude of Frication). These fields are calibrated in ±1db steps and have the same range as the other amplitude biases, namely +31 to -32 db. Again, positive values may cause clipping. Negative values are the most useful. priority (V37) Task priority while speaking. When the narrator device begins to synthesize a sentence, the task priority remains unchanged while it is calculating acoustic parameters. However, when speech begins at the end of this process, the priority is bumped to 100 (the default value). If you wish, you may change this to anything you want. Higher values will tend to lock out most anything while speech is going on, and lower values may cause audible breaks in the speech output. The following example shows how to issue a write request to the narrator device. The first write is done with the default parameter settings. The second write is done after modifying the first and third formant loudness and using the centralization feature. The following example shows how to issue a write request to the narrator device. The first write is done with the default parameter settings. The second write is done after modifying the first and third formant loudness and using the centralization feature. Speak_Narrator.c [Back to Amiga Developer Docs ]
Devices_Manual_guide/node02C9.html.txt:1:8SVX IFF 8-Bit Sampled Voice / Introduction ]" border=0> This is the IFF supplement for FORM "8SVX". An 8SVX is an IFF "data section" or " FORM " (which can be an IFF file or a part of one) containing a digitally sampled audio voice consisting of 8-bit samples. A voice can be a one-shot sound or - with repetition and pitch scaling - a musical instrument. " EA IFF 85 " is Electronic Arts' standard interchange file format. [See EA IFF 85 Standard for Interchange Format Files.] The 8SVX format is designed for playback hardware that uses 8-bit samples attenuated by a volume control for good overall signal-to-noise ratio. So a FORM 8SVX stores 8-bit samples and a volume level. A similar data format (or two) will be needed for higher resolution samples (typically 12 or 16 bits). Properly converting a high resolution sample down to 8 bits requires one pass over the data to find the minimum and maximum values and a second pass to scale each sample into the range -128 through 127. So it's reasonable to store higher resolution data in a different FORM type and convert between them. For instruments, FORM 8SVX can record a repeating waveform optionally preceded by a startup transient waveform. These two recorded signals can be pre-synthesized or sampled from an acoustic instrument. For many instruments, this representation is compact. FORM 8SVX is less practical for an instrument whose waveform changes from cycle to cycle like a plucked string, where a long sample is needed for accurate results. FORM 8SVX can store an "envelope" or "amplitude contour" to enrich musical notes. A future voice FORM could also store amplitude, frequency, and filter modulations. FORM 8SVX is geared for relatively simple musical voices, where one waveform per octave is sufficient, the waveforms for the different octaves follow a factor-of-two size rule, and one envelope is adequate for all octaves. You could store a more general voice as a LIST containing one or more FORM s 8SVX per octave. A future voice FORM could go beyond one "one-shot" waveform and one "repeat" waveform per octave. Section 2 defines the required property sound header " VHDR ", optional properties name " NAME ", copyright " (c) ", and author " AUTH ", the optional annotation data chunk " ANNO ", the required data chunk " BODY ", and optional envelope chunks " ATAK " and " RLSE ". These are the "standard" chunks. Specialized chunks for private or future needs can be added later, e.g., to hold a frequency contour or Fourier series coefficients. The 8SVX syntax is summarized in Appendix A as a regular expression and in Appendix B as an example box diagram. Appendix C explains the optional Fibonacci-delta compression algorithm. Reference [Back to Amiga Developer Docs ]
Devices_Manual_guide/node003C.html.txt:1:2 Audio Device / Double Buffered Sound Example ]" border=0> The program listed below demonstrates double buffering with the audio device. Run the program from the CLI. It takes one parameter - the name of an IFF 8SVX sample file to play on the Amiga's audio device. The maximum size for a sample on the Amiga is 128K. However, by using double-buffering and queueing up requests to the audio device, you can play longer samples smoothly and without breaks. Audio_8SVX.c [Back to Amiga Developer Docs ]
Devices_Manual_guide/node0002.html.txt:1:Amiga® RKM Devices: Preface ]" border=0> The Amiga® Technical Reference Series is the official guide to programming Amiga computers. This revised edition of the Amiga ROM Kernel Reference Manual: Devices provides detailed information about the Amiga's I/O subsystems. It has been updated for Release 2 (Kickstart V36 and up) of the Amiga operating system, however, most of the material and example programs are also compatible with version 1.3. This book is intended for the following audiences: * Novice Amiga programmers who want to try out features of the Amiga devices without writing full-blown applications. * Experienced programmers new to the Amiga. * Amiga programmers and developers who want to use the devices in an application. It is assumed that the reader can program in C or at least understand it. Here is a brief overview of the contents: Chapter 1, Introduction to Amiga System Devices An introduction to the concept of an Amiga system device, the device interface, and how to perform I/O using the devices. Chapter 2, Audio Device The Amiga audio device allows you to play music and make sounds. Two example programs are included. Chapter 3, Clipboard Device The clipboard device is a central facility for sharing information between applications. The chapter covers the types of clipboard data and the proper ways to use the clipboard. Two example programs are included plus an extensively commented module of support functions for the programs. Chapter 4, Console Device The console device is the text-oriented interface for Amiga windows. The chapter lists the escape sequences used for console windows and the types of console windows. An example program is included. Chapter 5, Gameport Device The gameport device manages the various pointing devices you plug into the mouse/joystick connectors. The chapter discusses the types of pointing devices, the protocol for using the device and includes an example program. Chapter 6, Input Device The input device collects input event information and passes this on to the operating system. The chapter covers this interaction between the various input sources of the system, tells how to create your own input events and includes two example programs. Chapter 7, Keyboard Device The keyboard device is the Amiga keyboard manager. The chapter covers how to read the keyboard at a low level and also how to program system reset (Ctrl-Amiga-Amiga) handlers. Three example programs are included. Chapter 8, Narrator Device The narrator device is the voice of the Amiga. This chapter explains how to use the narrator device and the translator library, how to write phonetic strings for the device, and discusses the technical aspects of computer generated speech in thorough, but understandable terms. Two example programs are included. Chapter 9, Parallel Device The parallel device manages the Amiga parallel port. Two example programs are included. Chapter 10, Printer Device The printer device translates character streams into printer specific sequences. The chapter covers how to use the printer device and how to write your own printer driver. It contains two example programs and two complete printer drivers. Chapter 11, SCSI Device The SCSI device provides the Small Computer System Interface for the Amiga. The chapter covers how to send Amiga specific and SCSI specific commands to SCSI devices. An example program is included. Chapter 12, Serial Device The serial device manages the Amiga serial port. Three example programs are included. Chapter 13, Timer Device The timer device an interface to the Amiga's internal clocks. The chapter explains the types of clocks and clock units. Four example programs are included. Chapter 14, Trackdisk Device The trackdisk device controls the Amiga disk drives. The chapter covers how to use the drives at a high-level (formatted reads and writes) and low-level (raw reads and writes). An example program is included. Chapter 15, Resources The Amiga resources are a collection of low-level interfaces to special Amiga hardware. The chapter covers the general resource interface and how to use all seven resources. Example code is included for all but one of the resources. Appendix A, IFF, Interchange File Format IFF is the standardized file format of the Amiga. This appendix introduces IFF, covers five of the IFF types, lists the official FORM and Chunk names that are reserved and in use and how to register new ones. IFF include files, link modules, example programs and utilities are included. Appendix B, Example Device This appendix contains the assembly code for an Amiga device for all those who want to create their own custom software I/O device. Appendix C, Amiga Floppy Boot Process and Physical Layout This appendix lists the method used to read the boot block of a floppy and how the data is arranged in the boot block. The other manuals in this series are the Amiga User Interface Style Guide, an application design specification and reference work for Amiga programmers, the Amiga ROM Kernel Reference Manual: Includes and Autodocs , an alphabetically organized reference of ROM function summaries and Amiga system include files, the Amiga ROM Kernel Reference Manual: Libraries , a work consisting of tutorial-style chapters on the use of each Amiga system library, and the Amiga Hardware Reference Manual , a detailed description of the Amiga's hardware components. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node002C.html.txt:1:2 / ADCMD_ALLOCATE / The ADIOF_NOWAIT Flag ]" border=0> If you need to produce a sound right now and otherwise don't want to allocate, set the ADIOF_NOWAIT flag to 1. This will cause the command to return an IOERR_ALLOCFAILED error if it cannot allocate any of the channels. If you are producing a non-urgent sound and you can wait, set the ADIOF_NOWAIT flag to 0. Then, the IOAudio block returns only when you get the allocation. If ADIOF_NOWAIT is set to 0, the audio device will continue to retry the allocation request whenever channels are freed until it is successful. If the program decides to cancel the request, AbortIO() can be used. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node0291.html.txt:1:SAMP.doc / The MHDR Chunk ]" border=0> The required "MHDR" chunk immediately follows the "SAMP" header and consists of the following components: #define ID_MHDR MakeID('M','H','D','R') /* MHDR size is dependant on the size of the imbedded PlayMap. */ typedef struct{ UBYTE NumOfWaves, /* The number of waves in this file */ Format, /* # of ORIGINAL significant bits from 8-28 */ Flags, /* Various bits indicate various functions */ PlayMode, /* determines play MODE of the PlayMap */ NumOfChans, Pad, PlayMap[128*4], /* a map of which wave numbers to use for each of 128 possible Midi Notes. Default to 4 */ } MHDRChunk; The PlayMap is an array of bytes representing wave numbers. There can be a total of 255 waves in a "SAMP" file. They are numbered from 1 to 255. A wave number of 0 is reserved to indicate "NO WAVE". The Midi Spec 1.0 designates that there are 128 possible note numbers (pitches), 0 to 127. The size of an MHDR's PlayMap is determined by (NumOfChans * 128). For example, if NumOfChans = 4, then an MHDR's PlayMap is 512 bytes. There are 4 bytes in the PlayMap for EACH of the 128 Midi Note numbers. For example, the first 4 bytes in PlayMap pertain to Midi Note #0. Of those 4 bytes, the first byte is the wave number to play back on Amiga audio channel 0. The second byte is the wave number to play back on Amiga audio channel 1, etc. In this way, a single Midi Note Number could simultaneously trigger a sound event on each of the 4 Amiga audio channels. If NumOfChans is 1, then the PlayMap is 128 bytes and each midi note has only 1 byte in the PlayMap. The first byte pertains to midi note #0, the second pertains to midi note #1, etc. In this case, a player program might elect to simply play back the PlayMap wave number on any available amiga audio channel. If NumOfChans = 0, then there is no imbedded PlayMap in the MHDR, no midi note assignments for the waves, and an application should play back waves on any channel at their default sampleRates. In effect, the purpose of the PlayMap array is to determine which (if any) waves are to be played back for each of the 128 possible Midi Note Numbers. Usually, the MHDR's NumOfChans will be set to 4 since the Amiga has 4 audio channels. For the rest of this document, the NumOfChans is assumed to be 4. As mentioned, there can be a total of 255 waves in a "SAMP" file, numbered from 1 to 255. A PlayMap wave number of 0 is reserved to indicate that NO WAVE number should be played back. Consider the following example: The first 4 bytes of PlayMap are 1,3,0,200. If a sample playing program receives (from the serial port or another task perhaps) Midi Note Number 0, the following should occur: 1) The sampler plays back wave 1 on Amiga audio channel number 0 (because the first PlayMap byte is 1). 2) The sampler plays back wave 3 on Amiga audio channel number 1 (because the second PlayMap byte is 3). 3) The sampler does not effect Amiga audio channel 2 in any way (because the third PlayMap byte is a 0). 4) The sampler plays back wave 200 on Amiga audio channel number 4 (because the fourth PlayMap byte is 200). (This assumes INDEPENDANT CHANNEL play MODE to be discussed later in this document.) All four of the PlayMap bytes could even be the same wave number. This would cause that wave to be output of all 4 Amiga channels simultaneously. NumOfWaves is simply the number of waves in the sound file. Format is the number of significant bits in every sample of a wave. For example, if Format = 8, then this means that the sample data is an 8 bit format, and that every sample of the wave can be expressed by a single BYTE. (A 16 bit sample would need a WORD for every sample point). Each bit of the Flags byte, when set, means the following: Bit #0 - File continued on another disc. This might occur if the SAMP file was too large to fit on 1 floppy. The accepted practice (as incor- porated by Yamaha's TX sampler and Casio's FZ-1 for example) is to dump as much as possible onto one disc and set a flag to indicate that more is on another disc's file. The name of the files must be the related. The continuation file should have its own SAMP header MHDR, and BODY chunks. This file could even have its continuation bit set, etc. Never chop a sample wave in half. Always close the file on 1 disc after the last wave which can be completely saved. Resume with the next wave within the BODY of the continuation file. Also, the NumOfWaves in each file's BODY should be the number saved on that disc (not the total number in all combined disk files). See the end of this document for filename conventions. In C, here is how the PlayMap is used when receiving a midi note-on event: MapOffset = (UBYTE) MidiNoteNumber * numOfChans; /* MidiNoteNumber is the received note number (i.e. the second byte of a midi note-on event. numOfChans is from the SAMP MHDR. */ chan0waveNum = (UBYTE) playMap[MapOffset]; chan1waveNum = (UBYTE) playMap[MapOffset+1]; chan2waveNum = (UBYTE) playMap[MapOffset+2]; chan3waveNum = (UBYTE) playMap[MapOffset+3]; if (chan0waveNum != 0) { /* get the pointer to wave #1's data, determine the values that need to be passed to the audio device, and play this wave on Amiga audio channel #0 (if INDEPENDANT PlayMode) */ } /* do the same with the other 3 channel's wave numbers */ In assembly, the "MHDR" structure looks like this: CNOP 0,2 MHDR dc.b 'MHDR' sizeOfMHDR dc.l [this is 6 + (NumOfChans * 128) ] NumOfWaves dc.b [a byte count of # of waves in the file] Format dc.b [a byte count of # of significant bits in a sample point] Flags dc.b [bit mask] PlayMode dc.b [play MODE discussed later] NumOfChans dc.b [# of bytes per midi note for PlayMap] PlayMap ds.b [128 x NumOfChans bytes of initialized values] and a received MidiNoteNumber is interpreted as follows: moveq #0,d0 move.b MidiNoteNumber,d0 ;this is the received midi note # bmi.s Illegal_Number ;exit, as this is an illegal midi note # moveq #0,d1 move.b NumOfChans,d1 mulu.w d1,d0 ;MidiNoteNumber x NumOfChans lea PlayMap,a0 adda.l d0,a0 move.b (a0)+,chan0waveNum move.b (a0)+,chan1waveNum move.b (a0)+,chan2waveNum move.b (a0),chan3waveNum tst.b chan0waveNum beq.s Chan1 ;Now get the address of this wave number's sample data, determine the ;values that need to be passed to the audio device, and output the wave's ;data on Amiga chan 0 (assuming INDEPENDANT PlayMode). Chan1 tst.b chan1waveNum beq.s Chan2 ;do the same for the other wave numbers, etc. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node02D3.html.txt:1:Appendix A. Quick Reference / Type Definitions ]" border=0> #define ID_8SVX MakeID('8', 'S', 'V', 'X') #define ID_VHDR MakeID('V', 'H', 'D', 'R') typedef LONG Fixed; /* A fixed-point value, 16 bits to the left of * the point and 16 to the right. A Fixed is a * number of 2^16ths, i.e., 65536ths. */ #define Unity 0x10000L /* Unity = Fixed 1.0 = maximum volume */ /* sCompression: Choice of compression algorithm. */ #define sCmpNone 0 /* not compressed */ #define sCmpFibDelta 1 /* Fibonacci-delta encoding (Appendix C) */ /* Can be more kinds in the future. */ typedef struct { ULONG oneShotHiSamples, /* # samples in the high octave 1-shot part */ repeatHiSamples, /* # samples in the high octave repeat part */ samplesPerHiCycle;/* # samples/cycle in high octave, else 0 */ UWORD samplesPerSec; /* data sampling rate */ UBYTE ctOctave, /* # octaves of waveforms */ sCompression; /* data compression technique used */ Fixed volume; /* playback volume from 0 to Unity (full * * volume). Map this value into the output * * hardware's dynamic range. */ } Voice8Header; #define ID_NAME MakeID('N', 'A', 'M', 'E') /* NAME chunk contains a CHAR[], the voice's name. */ #define ID_Copyright MakeID('(', 'c', ')', ' ') /* "(c) " chunk contains a CHAR[], the FORM's copyright notice. */ #define ID_AUTH MakeID('A', 'U', 'T', 'H') /* AUTH chunk contains a CHAR[], the author's name. */ #define ID_ANNO MakeID('A', 'N', 'N', 'O') /* ANNO chunk contains a CHAR[], author's text annotations. */ #define ID_ATAK MakeID('A', 'T', 'A', 'K') #define ID_RLSE MakeID('R', 'L', 'S', 'E') typedef struct { UWORD duration; /* segment duration in milliseconds, > 0 */ Fixed dest; /* destination volume factor */ } EGPoint; /* ATAK and RLSE chunks contain an EGPoint[],piecewise-linear envelope. */ /* The envelope defines a function of time returning Fixed values. It's * * used to scale the nominal volume specified in the Voice8Header. */ #define ID_BODY MakeID('B', 'O', 'D', 'Y') typedef character BYTE; /* 8 bit signed number, -128 through 127. */ /* BODY chunk contains a BYTE[], array of audio data samples. */ [Back to Amiga Developer Docs ]
Devices_Manual_guide/node01AA.html.txt:1:Devices/Dev_examples/Speak_Narrator.c ]" border=0> /* * Speak_Narrator.c * * This example program sends a string of phonetic text to the narrator * device twice, changing some of the characteristics the second time. * * Compile with SAS C 5.10 lc -b1 -cfistq -v -y -L * * Requires Kickstart V37 or greater. */ #include #include #include #include #include #include #include #include #include #ifdef LATTICE int CXBRK(void) { return(0); } /* Disable SAS CTRL/C handling */ int chkabort(void) { return(0); } /* really */ #endif void main(void) { struct MsgPort *VoiceMP; struct narrator_rb *VoiceIO; UBYTE *PhoneticText = "DHIHS IHZ AHMIY5GAH SPIY5KIHNX."; BYTE audio_chan[4] = {3, 5, 10, 12}; if (VoiceMP=CreateMsgPort()) /* Create the message port */ { /* Create the I/O request */ if (VoiceIO = CreateIORequest(VoiceMP,sizeof(struct narrator_rb))) { /*Set the NEWIORB bit in the flags field to use the new fields*/ VoiceIO->flags = NDF_NEWIORB; /* Open the narrator device */ if (OpenDevice("narrator.device",0,(struct IORequest *)VoiceIO,0L)) /* Inform user that it could not be opened */ printf("Error: narrator.device did not open\n"); else { /* Speak the string using the default parameters */ VoiceIO->ch_masks = &audio_chan[0]; VoiceIO->nm_masks = sizeof(audio_chan); VoiceIO->message.io_Command = CMD_WRITE; VoiceIO->message.io_Data = PhoneticText; VoiceIO->message.io_Length = strlen(PhoneticText); DoIO(VoiceIO); /* Now change some of the characteristics: * Raise the first formant, lower the third formant, * and move 50% of the way towards AO. * and speak it again. */ VoiceIO->A1adj = -32; /* Shut off first formant */ VoiceIO->A3adj = 11; /* Raise the third formant */ VoiceIO->centralize = 50; /* Move 50% of the way */ VoiceIO->centphon = "AO"; /* towards AO */ DoIO(VoiceIO); /* Close the narrator device */ CloseDevice((struct IORequest *)VoiceIO); } /* Delete the IORequest */ DeleteIORequest(VoiceIO); } else /* Inform user that the I/O request could be created */ printf("Error: Could not create I/O request\n"); /* Delete the message port */ DeleteMsgPort(VoiceMP); } else /* Inform user that the message port could not be created */ printf("Error: Could not create message port\n"); } [Back to Amiga Developer Docs ]
Devices_Manual_guide/node0226.html.txt:1:AIFF.doc / AIFF / The Audio Recording Chunk ]" border=0> The Audio Recording Chunk contains information pertinent to audio recording devices. #define AudioRecordingID 'AESD' /* ckID for Audio Recording */ /* Chunk. */ typedef struct { ID ckID long ckSize; unsigned char AESChannelStatusData[24]; } AudioRecordingChunk; The ckID is always 'AESD'. The ckSize is the size of the data portion of the chunk, in bytes For the Audio Recording Chunk, ckSize is always 24. The 24 bytes of AESCChannelStatusData are specified in the "AES Recommended Practice for Digital Audio Engineering - Serial Transmission Format for Linearly Represented Digital Audio Data", transmission of digital audio between audio devices. This information is duplicated in the Audio Recording Chunk for convenience. Of general interest would be bits 2, 3, and 4 of byte 0, which describe recording emphasis. The Audio Recording Chunk is optional. No more than one Audio Recording Chunk may appear in a FORM AIFF. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node02CD.html.txt:1:Standard Data and Property Chunks / Required Property VHDR ]" border=0> The required property "VHDR" holds a Voice8Header structure as defined in these C declarations and following documentation. This structure holds the playback parameters for the sampled waveforms in the BODY chunk. (See "Data Chunk BODY", below, for the storage layout of these waveforms.) #define ID_8SVX MakeID('8', 'S', 'V', 'X') #define ID_VHDR MakeID('V', 'H', 'D', 'R') typedef LONG Fixed; /* A fixed-point value, 16 bits to the left of the point and 16 to the right. A Fixed is a number of 2^16ths, i.e., 65536ths. */ #define Unity 0x10000L /* Unity = Fixed 1.0 = maximum volume */ /* sCompression: Choice of compression algorithm applied to the samples. */ #define sCmpNone 0 /* not compressed */ #define sCmpFibDelta 1 /* Fibonacci-delta encoding (Appendix C) */ /* Can be more kinds in the future. */ typedef struct { ULONG oneShotHiSamples, /* # samples in the high octave 1-shot part */ repeatHiSamples, /* # samples in the high octave repeat part */ samplesPerHiCycle;/* # samples/cycle in high octave, else 0 */ UWORD samplesPerSec; /* data sampling rate */ UBYTE ctOctave, /* # octaves of waveforms */ sCompression; /* data compression technique used */ Fixed volume; /* playback volume from 0 to Unity (full * volume). Map this value into the output * hardware's dynamic range. */ } Voice8Header; [Implementation details. Fields are filed in the order shown. The UBYTE fields are byte-packed (2 per 16-bit word). MakeID is a C macro defined in the main IFF document and in the source file IFF.h.] A FORM 8SVX holds waveform data for one or more octaves, each containing a one-shot part and a repeat part. The fields oneShotHiSamples and repeatHiSamples tell the number of audio samples in the two parts of the highest frequency octave. Each successive (lower frequency) octave contains twice as many data samples in both its one-shot and repeat parts. One of these two parts can be empty across all octaves. Note: Most audio output hardware and software has limitations. For example the Amiga computer has sound hardware that requires that all one-shot and repeat parts have even numbers of samples. Amiga sound driver software should adjust an odd-sized waveform, ignore an odd-sized lowest octave, or ignore odd 8SVX FORMs altogether. Some other output devices require all sample sizes to be powers of two. The field samplesPerHiCycle tells the number of samples/cycle in the highest frequency octave of data, or else 0 for "unknown". Each successive (lower frequency) octave contains twice as many samples/cycle. The samplesPerHiCycle value is needed to compute the data rate for a desired playback pitch. Actually, samplesPerHiCycle is an average number of samples/cycle. If the one-shot part contains pitch bends, store the samples/cycle of the repeat part in samplesPerHiCycle. The division repeatHiSamples/samplesPerHiCycle should yield an integer number of cycles. (When the repeat waveform is repeated, a partial cycle would come out as a higher-frequency cycle with a "click".) More limitations: some Amiga music drivers require samplesPerHiCycle to be a power of two in order to play the FORM 8SVX as a musical instrument in tune. They may even assume samplesPerHiCycle is a particular power of two without checking. (If samplesPerHiCycle is different by a factor of two, the instrument will just be played an octave too low or high.) The field samplesPerSec gives the sound sampling rate. A program may adjust this to achieve frequency shifts or vary it dynamically to achieve pitch bends and vibrato. A program that plays a FORM 8SVX as a musical instrument would ignore samplesPerSec and select a playback rate for each musical pitch. The field ctOctave tells how many octaves of data are stored in the BODY chunk. See "Data Chunk BODY ", below, for the layout of the octaves. The field sCompression indicates the compression scheme, if any, that was applied to the entire set of data samples stored in the BODY chunk. This field should contain one of the values defined above. Of course, the matching decompression algorithm must be applied to the BODY data before the sound can be played. (The Fibonacci-delta encoding scheme sCmpFibDelta is described in Appendix C .) Note that the whole series of data samples is compressed as a unit. The field volume gives an overall playback volume for the waveforms (all octaves). It lets the 8-bit data samples use the full range -128 through 127 for good signal-to-noise ratio. The playback program should multiply this value by a "volume control" and perhaps by a playback envelope (see ATAK and RLSE , below). Recording a one-shot sound. To store a one-shot sound in a FORM 8SVX , set oneShotHiSamples = number of samples, repeatHiSamples = 0 , samplesPerHiCycle = 0, samplesPerSec = sampling rate, and ctOctave = 1. Scale the signal amplitude to the full sampling range -128 through 127. Set volume so the sound will playback at the desired volume level. If you set the samplesPerHiCycle field properly, the data can also be used as a musical instrument. Experiment with data compression. If the decompressed signal sounds OK, store the compressed data in the BODY chunk and set sCompression to the compression code number. Recording a musical instrument. To store a musical instrument in a FORM 8SVX, first record or synthesize as many octaves of data as you want to make available for playback. Set ctOctave to the count of octaves. From the recorded data, excerpt an integral number of steady state cycles for the repeat part and set repeatHiSamples and samplesPerHiCycle. Either excerpt a startup transient waveform and set oneShotHiSamples, or else set oneShotHiSamples to 0. Remember, the one-shot and repeat parts of each octave must be twice as long as those of the next higher octave. Scale the signal amplitude to the full sampling range and set volume to adjust the instrument playback volume. If you set the samplesPerSec field properly, the data can also be used as a one-shot sound. A distortion-introducing compressor like sCmpFibDelta is not recommended for musical instruments, but you might try it anyway. Typically, creators of FORM 8SVX record an acoustic instrument at just one frequency. Decimate (down-sample with filtering) to compute higher octaves. Interpolate to compute lower octaves. If you sample an acoustic instrument at different octaves, you may find it hard to make the one-shot and repeat waveforms follow the factor-of-two rule for octaves. To compensate, lengthen an octave's one-shot part by appending replications of the repeating cycle or prepending zeros. (This will have minimal impact on the sound's start time.) You may be able to equalize the ratio of one-shot-samples to repeat-samples across all octaves. Note that a "one-shot sound" may be played as a "musical instrument" and vice-versa. However, an instrument player depends on samplesPerHiCycle, and a one-shot player depends on samplesPerSec. Playing a one-shot sound. To play any FORM 8SVX data as a one-shot sound, first select an octave if ctOctave > 1. (The lowest-frequency octave has the greatest resolution.) Play the one-shot samples then the repeat samples, scaled by volume, at a data rate of samplesPerSec. Of course, you may adjust the playback rate and volume. You can play out an envelope, too. (See ATAK and RLSE , below.) Playing a musical note. To play a musical note using any FORM 8SVX , first select the nearest octave of data from those available. Play the one-shot waveform then cycle on the repeat waveform as long as needed to sustain the note. Scale the signal by volume, perhaps also by an envelope, and by a desired note volume. Select a playback data rate s samples/second to achieve the desired frequency (in Hz): frequency = s / samplesPerHiCycle for the highest frequency octave. The idea is to select an octave and one of 12 sampling rates (assuming a 12-tone scale). If the FORM 8SVX doesn't have the right octave, you can decimate or interpolate from the available data. When it comes to musical instruments, FORM 8SVX is geared for a simple sound driver. Such a driver uses a single table of 12 data rates to reach all notes in all octaves. That's why 8SVX requires each octave of data to have twice as many samples as the next higher octave. If you restrict samplesPerHiCycle to a power of two, you can use a predetermined table of data rates. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node002A.html.txt:1:2 / Allocation and Arbitration Commands / ADCMD_ALLOCATE ]" border=0> This command gives your program a channel to use and should be the first command you send to the audio device. You specify the channels you want by setting a pointer to an array in the ioa_Data field of the IOAudio structure. This array uses a value of 1 to allocate channel 0, 2 for channel 1, 4 for channel 2, and 8 for channel 3. For multiple channels, add the values together. For example, if you want to allocate all channels, use a value of 15. If you want a pair of stereo channels and you have no preference about which of the left and right channels the system will choose for the allocation, you can pass a pointer to an array containing 3, 5, 10, and 12. Channels 1 and 2 produce sound on the left side and channels 0 and 3 on the right side. The table below shows how this array corresponds to all the possible combinations of a right and a left channel. POSSIBLE CHANNEL COMBINATIONS Decimal Channel 3 Channel 2 Channel 1 Channel 0 Value of (right) (left) (left) (right) Allocation Mask --------- --------- --------- --------- --------------- 0 0 1 1 3 0 1 0 1 5 1 0 1 0 10 1 1 0 0 12 How ADCMD_ALLOCATE Operates ADCMD_ALLOCATE Examples The ADIOF_NOWAIT Flag The Allocation Key [Back to Amiga Developer Docs ]
Devices_Manual_guide/node02CC.html.txt:1:Standard Data and Property Chunks / Background ]" border=0> There are two ways to use FORM 8SVX : as a one-shot sampled sound or as a sampled musical instrument that plays "notes". Storing both kinds of sounds in the same kind of FORM makes it easy to play a one-shot sound as an instrument or an instrument as a one-note sound. A one-shot sound is a series of audio data samples with a nominal playback rate and amplitude. The recipient program can optionally adjust or modulate the amplitude and playback data rate. For musical instruments, the idea is to store a sampled (or pre-synthesized) waveform that will be parameterized by pitch, duration, and amplitude to play each "note". The creator of the FORM 8SVX can supply a waveform per octave over a range of octaves for this purpose. The intent is to perform a pitch by selecting the closest octave's waveform and scaling the playback data rate. An optional "one-shot" waveform supplies an arbitrary startup transient, then a "repeat" waveform is iterated as long as necessary to sustain the note. A FORM 8SVX can also store an envelope to modulate the waveform. Envelopes are mostly useful for variable-duration notes but could be used for one-shot sounds, too. The FORM 8SVX standard has some restrictions. For example, each octave of data must be twice as long as the next higher octave. Most sound driver software and hardware imposes additional restrictions. E.g., the Amiga sound hardware requires an even number of samples in each one-shot and repeat waveform. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node02D0.html.txt:1:Standard Data and Property Chunks / Data Chunk BODY ]" border=0> The BODY chunk contains the audio data samples. #define ID_BODY MakeID('B', 'O', 'D', 'Y') typedef character BYTE; /* 8 bit signed number, -128 through 127. */ /* BODY chunk contains a BYTE[], array of audio data samples. */ The BODY contains data samples grouped by octave. Within each octave are one-shot and repeat portions. Figure 2 depicts this arrangement of samples for an 8SVX where oneShotHiSamples = 24, repeatHiSamples = 16, samplesPerHiCycle = 8, and ctOctave = 3. The major divisions are octaves, the intermediate divisions separate the one-shot and repeat portions, and the minor divisions are cycles. +-+-+-+-+-+---+---+---+---+---+------+------+------+------+------+ | | | | | | | | | | | | | | | | | | | | | | | | O | R | One-shot | Repeat| One-shot | Repeat | | | | | | | | | |hi octave| middle octave | low octave | +---------+-------------------+----------------------------------+ Figure 2. BODY subdivisions. In general, the BODY has ctOctave octaves of data. The highest frequency octave comes first, comprising the fewest samples: oneShotHiSamples + repeatHiSamples. Each successive octave contains twice as many samples as the next higher octave but the same number of cycles. The lowest frequency octave comes last with the most samples: 2^(ctOctave-1) * (oneShotHiSamples + repeatHiSamples). The number of samples in the BODY chunk is ( 2^0 + ... + 2^(ctOctave-1) ) * (oneShotHiSamples + repeatHiSamples) Figure 3, below, looks closer at an example waveform within one octave of a different BODY chunk. In this example, oneShotHiSamples / samplesPerHiCycle = 2 cycles and repeatHiSamples / samplesPerHiCycle = 1 cycle. ^ (volume)| | /\ | /\ | | | | \ | | \ | | /\ | | \ | | \ | | / \ /\| / \| / \| +---/----\--/--+------/------+------/------+ |\ / \/ |\ | |\ | | | V | \ | | \ | | | | \ / | \ / | | | V | V | +--------------+-------------+-------------+----> (time) one-shot repeat repeat Figure 3. Example waveform. To avoid playback "clicks" the one-shot part should begin with a small sample value, and flow smoothly into the repeat part. The end of the repeat part should flow smoothly into the beginning of the next repeat part. If the VHDR field sCompression != sCmpNone, the BODY chunk is just an array of data bytes to feed through the specified decompresser function. All this stuff about sample sizes, octaves, and repeat parts applies to the decompressed data. Be sure to follow an odd-length BODY chunk with a 0 pad byte. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node01C4.html.txt:1:A Quick Introduction to IFF / Why IFF? ]" border=0> Did you ever have this happen to your picture file? You can't load it into another paint program. You need a converter to adopt to "ZooPaint" release 2.0 or a new hardware feature. You must "export" and "import" to use it in a page layout program. You can't move it to another brand of computer. What about interchanging musical scores, digitized audio, and other data? It seems the only thing that does interchange well is plain ASCII text files. It's inexcusable. And yet this is "normal" in MS-DOS. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node0024.html.txt:1:2 / Audio And System I/O Functions / Wait() and WaitPort() ]" border=0> These functions can be used to put your task to sleep while a sound plays. Wait() takes a wake-up mask as its argument. The wake-up mask is usually the mp_SigBit of a MsgPort that you have set up to get replies back from the audio device. WaitPort() will put your task to sleep while a sound plays. The argument to WaitPort() is a pointer to a MsgPort that you have set up to get replies back from the audio device. Wait() and WaitPort() will not remove the message from the reply port. You must use GetMsg() to remove it. You must always use Wait() or WaitPort() to wait for I/O to finish with the audio device. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node0294.html.txt:1:SAMP.doc / Structure of an Individual Sample Point ]" border=0> Even though the next generation of computers will probably have 16 bit audio, and 8 bit sampling will quickly disappear, this spec has sizes expressed in BYTES. (ie LoopStart, WaveSize, etc.) This is because each successive address in RAM is a byte to the 68000, and so calculating address offsets will be much easier with all sizes in BYTES. The Midi sample dump, on the other hand, has sizes expressed in WORDS. What this means is that if you have a 16 bit wave, for example, the WaveSize is the total number of BYTES, not WORDS, in the wave. Also, there is no facility for storing a compression type. This is because sample data should be stored in linear format (as per the MIDI spec). Currently, all music samplers, regardless of their internal method of playing sample data must transmit and expect to receive sample dumps in a linear format. It is up to each device to translate the linear format into its own compression scheme. For example, if you are using an 8 bit compression scheme that yields a 14 bit linear range, you should convert each sample data BYTE to a decom- pressed linear WORD when you save a sound file. Set the MHDR's Format to 14. It is up to the application to do its own compression upon loading a file. The midi spec was set up this way because musical samplers need to pass sample data between each other, and computers (via a midi interface). Since there are almost as many data compression schemes on the market as there are musical products, it was decided that all samplers should expect data received over midi to be in LINEAR format. It seems logical to store it this way on disc as well. Therefore, any software program "need not know" how to decompress another software program's SAMP file. When 16 bit sampling is eventually implemented there won't be much need for compression on playback anyway. The continuation Flag solves the problem of disc storage as well. Since the 68000 can only perform math on BYTES, WORDS, or LONGS, it has been decided that a sample point should be converted to one of these sizes when saved in SAMP as follows: ORIGINAL significant bits SAMP sample point size ­­­­­­­­­­­­­­­­­­­­­­­­­ ­­­­­­­­­­­­­­­­­­­­­­ 8 BYTE 9 to 16 WORD 17 to 28 LONG Furthermore, the significant bits should be left-justified since it is easier to perform math on the samples. So, for example, an 8 bit sample point (like 8SVX) would be saved as a BYTE with all 8 bits being significant. The MHDR's Format = 8. No conversion is necessary. A 12 bit sample point should be stored as a WORD with the significant bits being numbers 4 to 15. (i.e shift the 12-bit WORD 4 places to the left). Bits 0, 1, 2 and 3 may be zero (unless some 16-bit math was performed and you wish to save these results). The MHDR's Format = 12. In this way, the sample may be loaded and manipulated as a 16-bit wave, but when transmitted via midi, it can be converted back to 12 bits (rounded and shifted right by 4). A 16 bit sample point would be saved as a WORD with all 16 bits being significant. The MHDR's Format = 16. No conversion is necessary. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node0005.html.txt:1:1 Introduction to Amiga System Devices / Accessing a Device ]" border=0> Accessing a device requires obtaining a message port, allocating memory for a specialized message packet called an I/O request, setting a pointer to the message port in the I/O request, and finally, establishing the link to the device itself by opening it. An example of how to do this will be provided later in this chapter. The message port is used by the device to return messages to you. A message port is obtained by calling the CreateMsgPort() or CreatePort() function. You must delete the message port when you are finished by calling the DeleteMsgPort() or DeletePort() function. For pre-V36 versions of the operating system (before Release 2.0), use the amiga.lib functions CreatePort() and DeletePort() ; for V36 and higher, use the Exec functions CreateMsgPort() and DeleteMsgPort() . CreatePort() and DeletePort() are upward compatible, you can use them with V36/V37; CreateMsgPort() and DeleteMsgPort() are not backward compatible, however. The I/O request is used to send commands and data from your application to the device. The I/O request consists of fields used to hold the command you wish to execute and any parameters it requires. You set up the fields with the appropriate information and send it to the device by using Exec I/O functions. At least four methods exist for creating an I/O request: * Declaring it as a structure. The memory required will be allocated at compile time. * Declaring it as a pointer and calling the AllocMem() function. You will have to call the FreeMem() function to release the memory when you are done. * Declaring it as a pointer and calling the CreateExtIO() function. This function not only allocates the memory for the request, it also puts the message port in the I/O request. You will have to call the DeleteExtIO() function to delete the I/O request when you are done. This is the pre-V36 method (used in 1.3 and earlier versions of the operating system), but is upward compatible. * Declaring it as a pointer and calling the CreateIORequest() function. This function not only allocates the memory for the request, it also puts the message port in the I/O request. You will have to call the DeleteIORequest() function to delete the I/O request when you are done. This is the V36/V37 method; it is not backwards compatible. The message port pointer in the I/O request tells the device where to respond with messages for your application. You must set a pointer to the message port in the I/O request if you declare it as a structure or allocate memory for it using AllocMem() . The device is opened by calling the OpenDevice() function. In addition to establishing the link to the device, OpenDevice() also initializes fields in the I/O request. OpenDevice() has this format: return = OpenDevice(device_name,unit_number, (struct IORequest *)IORequest,flags) where: * device_name is one of the following NULL-terminated strings for system devices: audio.device keyboard.device serial.device clipboard.device narrator.device timer.device console.device parallel.device trackdisk.device gameport.device printer.device input.device scsi.device * unit_number refers to one of the logical units of the device. Devices with one unit always use unit 0. Multiple unit devices like the trackdisk device and the timer device use the different units for specific purposes. The device chapters discuss the units in detail. * IORequest is the structure discussed above. Some of the devices have their own I/O requests defined in their include files and others use standard I/O requests, ( IOStdReq ). The device chapters list the I/O request that each device requires. * flags are bits set to indicate options for some of the devices. This field is set to zero for devices which don't accept options when they are opened. The device chapters and autodocs list the flags values and uses. * return is an indication of whether the OpenDevice() was successful with zero indicating success. Never assume that a device will successfully open. Check the return value and act accordingly. Zero Equals Success for OpenDevice(). ------------------------------------- Unlike most Amiga system functions, OpenDevice() returns zero for success and a device-specific error value for failure. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node001E.html.txt:1:2 Audio Device / Device Interface ]" border=0> The audio device operates like the other Amiga I/O devices. To make sound, you first open the audio device, then send I/O requests to it, and then close it when finished. See " Introduction to Amiga System Devices " chapter for general information on device usage. Audio device commands use an extended I/O request block named IOAudio to send commands to the audio device. This is the standard IORequest block with some extra fields added at the end. struct IOAudio { struct IORequest ioa_Request;/* I/O request block. See exec/io.h. */ WORD ioa_AllocKey; /* Alloc. key filled in by audio device */ UBYTE *ioa_Data; /* Pointer to a sample or allocation mask */ ULONG ioa_Length; /* Length of sample or allocation mask. */ UWORD ioa_Period; /* Sample playback speed */ UWORD ioa_Volume; /* Volume of sound */ UWORD ioa_Cycles; /* # of times to play sample. 0=forever. */ struct Message ioa_WriteMsg;/* Filled in by device- usually not used */ }; See the include file devices/ audio.h for the complete structure definition. Opening The Audio Device Audio And System I/O Functions Audio Device Command Types Closing The Audio Device Scope Of Audio Commands [Back to Amiga Developer Docs ]
Devices_Manual_guide/node0027.html.txt:1:2 Audio Device / A Simple Audio Example ]" border=0> The Amiga's audio software has a complex allocation and arbitration system which is described in detail in the sections below. At this point, though, it may be helpful to look at a simple audio example: Audio.c [Back to Amiga Developer Docs ]
Devices_Manual_guide/node0020.html.txt:1:2 / Device Interface / Audio Device Command Types ]" border=0> Commands for audio use can be divided into two categories: allocation/arbitration commands and hardware control commands. There are four allocation/arbitration commands. These do not actually produce any sound. Instead they manage and arbitrate the audio resources for the many tasks that may be using audio in the Amiga's multitasking environment. ADCMD_ALLOCATE - Reserves an audio channel for your program to use. ADCMD_FREE - Frees an audio channel. ADCMD_SETPREC - Changes the precedence of a sound in progress. ADCMD_LOCK - Tells if a channel has been stolen from you. The hardware control commands are used to set up, start, and stop sounds on the audio device: CMD_WRITE - The main command. Starts a sound playing. ADCMD_FINISH - Aborts a sound in progress. ADCMD_PERVOL - Changes the period (speed) and volume of a sound in progress. CMD_FLUSH - Clears the audio channels. CMD_RESET - Resets and initializes the audio device. ADCMD_WAITCYCLE - Signals you when a cycle finishes. CMD_STOP - Temporarily stops a channel from playing. CMD_START - Restarts an audio channel that was stopped. CMD_READ - Returns a pointer to the current IOAudio request. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node0034.html.txt:1:2 / Hardware Control Commands / ADCMD_FINISH ]" border=0> The ADCMD_FINISH command aborts (calls AbortIO() ) the current write request on a channel or channels. This is useful if you have something playing, such as a long buffer or some repetitions of a buffer, and you want to stop it. ADCMD_FINISH has a flag you can set (ADIOF_SYNCCYCLE) that allows the waveform to finish the current cycle before aborting it. This is useful for splicing together sounds at zero crossings or some other place in the waveform where the amplitude at the end of one waveform matches the amplitude at the beginning of the next. Zero crossings are positions within the waveform at which the amplitude is zero. Splicing at zero crossings gives you fewer clicks and pops when the audio channel is turned off or the volume is changed. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node001A.html.txt:1:Amiga® RKM Devices: 2 Audio Device ]" border=0> The Amiga has four hardware audio channels - two of the channels produce audio output from the left audio connector, and two from the right. These channels can be used in many ways. You can combine a right and a left channel for stereo sound, use a single channel, or play a different sound through each of the channels to create four-part harmony. About Amiga Audio Audio Device Commands and Functions Device Interface A Simple Audio Example Audio Allocation and Arbitration Allocation and Arbitration Commands Hardware Control Commands Double Buffered Sound Example Additional Information on the Audio Device [Back to Amiga Developer Docs ]
Devices_Manual_guide/node029C.html.txt:1:SAMP.doc / Making the Velocity Table ]" border=0> The 16 entries in the velocity table should be within the oneShot portion of the sample (ie not in the looping portion). THe first offset, VelTable[0] should be set to zero (in order to play back from the beginning of the data). The subsequent values should be increasing numbers. If you are using a graphic editor, try choosing offsets that will keep you within the initial attack portion of the wave. In practice, these values will be relatively close together within the wave. Always set the offsets so that when they are added to the sample start point, the resulting address points to a sample value of zero (a zero crossing point). This will eliminate pops and clicks at the beginning of the playback. In addition, the start of the wave should be on a sample with a value of zero. The last sample of the oneShot portion and the first sample of the looping portion should be approximately equal, (or zero points). The same is true of the first and last samples of the looping portion. Finally, try to keep the slopes of the end of the oneShot, the beginning of the looping, and the end of the looping section, approximately equal. All this will eliminate noise on the audio output and provide "seamless" looping. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node0004.html.txt:1:1 Introduction to Amiga System Devices / What is a Device? ]" border=0> An Amiga device is a software module that accepts commands and data and performs I/O operations based on the commands it receives. In most cases, a device interacts with either internal or external hardware. Generally, an Amiga device runs as a separate task which is capable of processing your commands while your application attends to other things. Device I/O is based on the Exec messaging system. The philosophy behind the devices is that I/O operations should be consistent and uniform. You print a file in the same manner as you play an audio sample, i.e., you send the device in question a WRITE command and the address of the buffer holding the data you wish to write. The result is that the interface presented to the programmer is essentially device independent and accessible from any computer language. This greatly expands the power the Amiga computer brings to the programmer and, ultimately, to the user. Devices support two types of commands: Exec standard commands like READ and WRITE, and device specific commands like the trackdisk device MOTOR command which controls the floppy drive motor. The Exec standard commands are supported by most Amiga devices. You should keep in mind, however, that supporting standard commands does not mean that all devices execute them in exactly the same manner. This manual contains a chapter about each of the Amiga devices. The chapters cover how you use a device and the commands it supports. In addition, the Amiga ROM Kernel Reference Manual: Includes and Autodocs contains expanded explanations of the commands and the include files for each device, and the Amiga ROM Kernel Reference Manual: Libraries contains chapters on Exec . The command explanations list the data, flags, and other information required by a device to execute a command. The Exec chapters provide detailed discussions of its operation. Both are very useful manuals to have on your desk when you are programming the devices. [Back to Amiga Developer Docs ]
index.html.txt:1:Amiga Developer Docs: ADCD 2.1 File List ADCD 2.1 File List File Title AmigaMail_Vol2_guide/node0000.html Contents of Amiga Mail articles - as of May/June 1993 AmigaMail_Vol2_guide/node0001.html I: Programming Practices and Standards AmigaMail_Vol2_guide/node0002.html II: AmigaDOS AmigaMail_Vol2_guide/node0003.html III: Exec AmigaMail_Vol2_guide/node0004.html IV: Intuition and Workbench AmigaMail_Vol2_guide/node0005.html V: Graphics AmigaMail_Vol2_guide/node0006.html VI: Sound and Music AmigaMail_Vol2_guide/node0007.html VII: IFF AmigaMail_Vol2_guide/node0008.html VIII: Unix and Networking AmigaMail_Vol2_guide/node0009.html IX: Timer, Serial, and Parallel AmigaMail_Vol2_guide/node000A.html X: Output AmigaMail_Vol2_guide/node000B.html XI: Input AmigaMail_Vol2_guide/node000C.html XII: CDTV AmigaMail_Vol2_guide/node000D.html XIII: Hardware AmigaMail_Vol2_guide/node000E.html Copyright notice AmigaMail_Vol2_guide/node000F.html I-1: TagItems and Tag Lists AmigaMail_Vol2_guide/node0010.html I-3: 2.0 Version Strings AmigaMail_Vol2_guide/node0011.html Hand-Coded Version Strings AmigaMail_Vol2_guide/node0012.html Automating Version Numbering with Bumprev AmigaMail_Vol2_guide/node0013.html I-7: The ASL Library AmigaMail_Vol2_guide/node0014.html Opening a Simple File Requester AmigaMail_Vol2_guide/node0015.html File Pattern Matching and Multiple Selects AmigaMail_Vol2_guide/node0016.html The ASL_Window Tag AmigaMail_Vol2_guide/node0017.html The Save Requester AmigaMail_Vol2_guide/node0018.html A Directory Requester AmigaMail_Vol2_guide/node0019.html The Font Requester AmigaMail_Vol2_guide/node001A.html The ASL_HookFunc Tag AmigaMail_Vol2_guide/node001B.html I-19: 2.0 Compatibility Problem Areas AmigaMail_Vol2_guide/node001C.html General Compatibility Problem Areas AmigaMail_Vol2_guide/node001D.html 2.0 Changes That Can Affect Compatibility AmigaMail_Vol2_guide/node001E.html Exec AmigaMail_Vol2_guide/node001F.html Expansion AmigaMail_Vol2_guide/node0020.html Strap AmigaMail_Vol2_guide/node0021.html DOS AmigaMail_Vol2_guide/node0022.html Audio.device AmigaMail_Vol2_guide/node0023.html Gameport.device AmigaMail_Vol2_guide/node0024.html Serial.device AmigaMail_Vol2_guide/node0025.html Timer.device AmigaMail_Vol2_guide/node0026.html Trackdisk AmigaMail_Vol2_guide/node0027.html CIA Timers AmigaMail_Vol2_guide/node0028.html Other Hardware Issues AmigaMail_Vol2_guide/node0029.html Intuition AmigaMail_Vol2_guide/node002A.html Preferences AmigaMail_Vol2_guide/node002B.html Workbench AmigaMail_Vol2_guide/node002C.html Layers AmigaMail_Vol2_guide/node002D.html Graphics AmigaMail_Vol2_guide/node002E.html Fonts AmigaMail_Vol2_guide/node002F.html CLI / Shell AmigaMail_Vol2_guide/node0030.html Console AmigaMail_Vol2_guide/node0031.html Additional Information AmigaMail_Vol2_guide/node0032.html Task Switching AmigaMail_Vol2_guide/node0033.html Intuition Gadgets and Window Borders AmigaMail_Vol2_guide/node0034.html Intuition Fonts AmigaMail_Vol2_guide/node0035.html I-35: Release 2.0 Specific Functions and Commands AmigaMail_Vol2_guide/node0036.html asl.library (basename: _AslBase) V36 AmigaMail_Vol2_guide/node0037.html battclock.resource (basename: _BattClockBase) AmigaMail_Vol2_guide/node0038.html battmem.resource (basename: _BattMemBase) AmigaMail_Vol2_guide/node0039.html clipboard.device (device commands) AmigaMail_Vol2_guide/node003A.html commodities.library (basename: _CxBase) V36 AmigaMail_Vol2_guide/node003B.html disk.resource (basename: _DiskBase) AmigaMail_Vol2_guide/node003C.html diskfont.library (basename: _DiskfontBase) AmigaMail_Vol2_guide/node003D.html dos.library (basename: _DOSBase) AmigaMail_Vol2_guide/node003E.html exec.library (basename: _SysBase) AmigaMail_Vol2_guide/node003F.html expansion.library (basename: _ExpansionBase) AmigaMail_Vol2_guide/node0040.html gadtools.library (basename: _GadToolsBase) V36 AmigaMail_Vol2_guide/node0041.html graphics.library (basename: _GfxBase) AmigaMail_Vol2_guide/node0042.html icon.library (basename: _IconBase) AmigaMail_Vol2_guide/node0043.html iffparse.library (basename: _IFFParseBase) V36 AmigaMail_Vol2_guide/node0044.html input.device (basename: _InputBase) AmigaMail_Vol2_guide/node0045.html intuition.library (basename: _IntuitionBase) AmigaMail_Vol2_guide/node0046.html keymap.library (basename: _KeymapBase) AmigaMail_Vol2_guide/node0047.html layers.library (basename: _LayersBase) AmigaMail_Vol2_guide/node0048.html mathieeesingbas.library (basename: _MathIeeeSingBasBase) V36 AmigaMail_Vol2_guide/node0049.html mathieeesingtrans.library (basename: _MathIeeeSingTransBase) V36 AmigaMail_Vol2_guide/node004A.html ramdrive.device (basename: _RamdriveDevice) AmigaMail_Vol2_guide/node004B.html rexxsyslib.library (basename: _RexxSysBase) V36 AmigaMail_Vol2_guide/node004C.html Timer.Device (basename: _TimerBase) AmigaMail_Vol2_guide/node004D.html trackdisk.device (device commands) AmigaMail_Vol2_guide/node004E.html utility.library (basename: _UtilityBase) V36 AmigaMail_Vol2_guide/node004F.html workbench.library (basename: _WorkbenchBase) AmigaMail_Vol2_guide/node0050.html I-43: Callback Hooks AmigaMail_Vol2_guide/node0051.html Callback Hook Functions and Structures AmigaMail_Vol2_guide/node0052.html Simple Callback Hook Usage AmigaMail_Vol2_guide/node0053.html I-47: Debugging with Enforcer and Mungwall AmigaMail_Vol2_guide/node0054.html The Debugging Setup AmigaMail_Vol2_guide/node0055.html Sample Enforcer Output AmigaMail_Vol2_guide/node0056.html Sample Mungwall Output AmigaMail_Vol2_guide/node0057.html Using Enforcer and Mungwall Together AmigaMail_Vol2_guide/node0058.html A Sample Debugging Session AmigaMail_Vol2_guide/node0059.html More Remote Debugging Tips AmigaMail_Vol2_guide/node005A.html Who Should Use Enforcer and Mungwall AmigaMail_Vol2_guide/node005B.html II-1: Executing External Programs with Release 2.0 AmigaMail_Vol2_guide/node005C.html The System() Function AmigaMail_Vol2_guide/node005D.html The 2.0 Con-handler AmigaMail_Vol2_guide/node005E.html II-5: AmigaDOS Packet Interface Specification AmigaMail_Vol2_guide/node005F.html Basic Input/Output AmigaMail_Vol2_guide/node0060.html Directory/File Manipulation/Information AmigaMail_Vol2_guide/node0061.html Volume Manipulation/Information AmigaMail_Vol2_guide/node0062.html Handler Maintenance and Control AmigaMail_Vol2_guide/node0063.html Handler Internal AmigaMail_Vol2_guide/node0064.html Obsolete Packets AmigaMail_Vol2_guide/node0065.html Console Only Packets AmigaMail_Vol2_guide/node0066.html II-27: Standard Command Line Parsing AmigaMail_Vol2_guide/node0067.html II-31: Notification AmigaMail_Vol2_guide/node0068.html II-37: Using the AmigaDOS Pattern Matching Functions AmigaMail_Vol2_guide/node0069.html Patterns AmigaMail_Vol2_guide/node006A.html Parsing AmigaMail_Vol2_guide/node006B.html Matching AmigaMail_Vol2_guide/node006C.html II-43: The 2.0 Dos.library Path Name Handling Functions AmigaMail_Vol2_guide/node006D.html II-49: Directory Scanning AmigaMail_Vol2_guide/node006E.html Atomic Directory Scanning AmigaMail_Vol2_guide/node006F.html MultiDirectory Assigns AmigaMail_Vol2_guide/node0070.html Filename Matching AmigaMail_Vol2_guide/node0071.html II-65: Writing a UserShell AmigaMail_Vol2_guide/node0072.html Initialization AmigaMail_Vol2_guide/node0073.html A Word About the Shell's I/O Handles AmigaMail_Vol2_guide/node0074.html The Main Shell Loop AmigaMail_Vol2_guide/node0075.html Finding a Program AmigaMail_Vol2_guide/node0076.html Running a Program AmigaMail_Vol2_guide/node0077.html Cleanup AmigaMail_Vol2_guide/node0078.html Installing the New User Shell AmigaMail_Vol2_guide/node0079.html Credits AmigaMail_Vol2_guide/node007A.html II-77: Fast AmigaDOS I/O AmigaMail_Vol2_guide/node007B.html II-87: Cooperative Record Locking with AmigaDOS AmigaMail_Vol2_guide/node007C.html II-95: Packet Level I/O under Release 2 AmigaMail_Vol2_guide/node007D.html II-107: Even Faster AmigaDOS I/O AmigaMail_Vol2_guide/node007E.html II-113: Handling Multiple Assigns with Conventional Directories AmigaMail_Vol2_guide/node007F.html III-1: Using SetFunction() in a Debugger AmigaMail_Vol2_guide/node0080.html Exec Library Structure AmigaMail_Vol2_guide/node0081.html Caveats AmigaMail_Vol2_guide/node0082.html An Example Debugger AmigaMail_Vol2_guide/node0083.html III-11: 68040 Compatibility Warning AmigaMail_Vol2_guide/node0084.html CacheControl AmigaMail_Vol2_guide/node0085.html CacheClearE AmigaMail_Vol2_guide/node0086.html CacheClearU AmigaMail_Vol2_guide/node0087.html CachePostDMA AmigaMail_Vol2_guide/node0088.html CachePreDMA AmigaMail_Vol2_guide/node0089.html III-17: Signalling with SIGF_SINGLE AmigaMail_Vol2_guide/node008A.html III-19: Memory Pools AmigaMail_Vol2_guide/node008B.html III-25: Quick Interrupts AmigaMail_Vol2_guide/node008C.html III-29: Writing Runtime Libraries with SAS/C 6.x AmigaMail_Vol2_guide/node008D.html IV-1: Obtaining an Icon Image AmigaMail_Vol2_guide/node008E.html IV-3: An Introduction to V36 Screens and Windows AmigaMail_Vol2_guide/node008F.html The Display Database AmigaMail_Vol2_guide/node0090.html Opening Screens and Windows AmigaMail_Vol2_guide/node0091.html Public Screens AmigaMail_Vol2_guide/node0092.html Visitor Windows AmigaMail_Vol2_guide/node0093.html Overscan AmigaMail_Vol2_guide/node0094.html DisplayClip AmigaMail_Vol2_guide/node0095.html IV-17: Opening Screens and Windows on Any Amiga AmigaMail_Vol2_guide/node0096.html Opening Full Size Screens AmigaMail_Vol2_guide/node0097.html PAL or NTSC? AmigaMail_Vol2_guide/node0098.html Opening Full Sized Windows AmigaMail_Vol2_guide/node0099.html IV-23: Introduction to Boopsi AmigaMail_Vol2_guide/node009A.html Attributes AmigaMail_Vol2_guide/node009B.html Imageclass Subclasses AmigaMail_Vol2_guide/node009C.html Gadgetclass Subclasses AmigaMail_Vol2_guide/node009D.html Interconnection AmigaMail_Vol2_guide/node009E.html IV-41: Writing a Boopsi Image Class AmigaMail_Vol2_guide/node009F.html Callback Hooks AmigaMail_Vol2_guide/node00A0.html Initializing a Boopsi Class AmigaMail_Vol2_guide/node00A1.html Boopsi Dispatcher AmigaMail_Vol2_guide/node00A2.html Boopsi Rootclass Methods AmigaMail_Vol2_guide/node00A3.html OM_NEW AmigaMail_Vol2_guide/node00A4.html OM_DISPOSE AmigaMail_Vol2_guide/node00A5.html OM_SET AmigaMail_Vol2_guide/node00A6.html OM_GET AmigaMail_Vol2_guide/node00A7.html Imageclass Methods AmigaMail_Vol2_guide/node00A8.html IM_DRAW AmigaMail_Vol2_guide/node00A9.html IM_ERASE AmigaMail_Vol2_guide/node00AA.html IM_HITTEST AmigaMail_Vol2_guide/node00AB.html IM_DRAWFRAME AmigaMail_Vol2_guide/node00AC.html IM_ERASEFRAME AmigaMail_Vol2_guide/node00AD.html IM_HITFRAME AmigaMail_Vol2_guide/node00AE.html IM_MOVE AmigaMail_Vol2_guide/node00AF.html IM_FRAMEBOX AmigaMail_Vol2_guide/node00B0.html Image Class Example AmigaMail_Vol2_guide/node00B1.html IV-57: Boopsi's Transparent Base Classes AmigaMail_Vol2_guide/node00B2.html IV-59: AppWindows, AppIcons, and AppMenuItems AmigaMail_Vol2_guide/node00B3.html The AppMessage Structure AmigaMail_Vol2_guide/node00B4.html Adding AppObjects AmigaMail_Vol2_guide/node00B5.html AppWindows AmigaMail_Vol2_guide/node00B6.html AppIcons AmigaMail_Vol2_guide/node00B7.html AppMenuItems AmigaMail_Vol2_guide/node00B8.html IV-69: Making Your Windows More Shiny and Manageable AmigaMail_Vol2_guide/node00B9.html Public Screens AmigaMail_Vol2_guide/node00BA.html Zooming AmigaMail_Vol2_guide/node00BB.html Iconifying AmigaMail_Vol2_guide/node00BC.html IV-77: Optimized Window Refreshing AmigaMail_Vol2_guide/node00BD.html Damaging Information AmigaMail_Vol2_guide/node00BE.html When To Refresh AmigaMail_Vol2_guide/node00BF.html Scrolling Your Life Away AmigaMail_Vol2_guide/node00C0.html Faster Rendering AmigaMail_Vol2_guide/node00C1.html Using Multiple RastPorts AmigaMail_Vol2_guide/node00C2.html Refreshing a Sizable Window AmigaMail_Vol2_guide/node00C3.html BeginRefresh() and EndRefresh() AmigaMail_Vol2_guide/node00C4.html Backfill Hook AmigaMail_Vol2_guide/node00C5.html IV-91: Color Wheel and Gradient Slider Boopsi Classes AmigaMail_Vol2_guide/node00C6.html IV-101: Introduction to the Datatypes Library AmigaMail_Vol2_guide/node00C7.html IV-111: Boopsi in Release 3 AmigaMail_Vol2_guide/node00C8.html IV-125: Features of V39 GadTools AmigaMail_Vol2_guide/node00C9.html IV-137: Menu Verify Handling AmigaMail_Vol2_guide/node00CA.html V-1: Using the ECS Genlocking Features AmigaMail_Vol2_guide/node00CB.html V-11: Finding the Aspect Ratio AmigaMail_Vol2_guide/node00CC.html V-15: Amiga Font Scaling and Aspect Ratio AmigaMail_Vol2_guide/node00CD.html Where Do the X and Y DPI values Come From? AmigaMail_Vol2_guide/node00CE.html Some Things to Look Out For AmigaMail_Vol2_guide/node00CF.html V-23: Using Compugraphic Typefaces with Bullet AmigaMail_Vol2_guide/node00D0.html Starting the Engine AmigaMail_Vol2_guide/node00D1.html Step 1 AmigaMail_Vol2_guide/node00D2.html Step 2 AmigaMail_Vol2_guide/node00D3.html Step 3 AmigaMail_Vol2_guide/node00D4.html Step 4 AmigaMail_Vol2_guide/node00D5.html Step 5 AmigaMail_Vol2_guide/node00D6.html Rasterizing a Glyph AmigaMail_Vol2_guide/node00D7.html Kerning AmigaMail_Vol2_guide/node00D8.html Width Lists AmigaMail_Vol2_guide/node00D9.html Rotating AmigaMail_Vol2_guide/node00DA.html Shearing AmigaMail_Vol2_guide/node00DB.html Other Level 0 Tags AmigaMail_Vol2_guide/node00DC.html The Otag File Tags AmigaMail_Vol2_guide/node00DD.html About the Examples AmigaMail_Vol2_guide/node00DE.html V-39: Naming Graphics Display Modes AmigaMail_Vol2_guide/node00DF.html VI-1: Creating Virtual Voices with Amiga Audio AmigaMail_Vol2_guide/node00E0.html VII-1: The DR2D FORM AmigaMail_Vol2_guide/node00E1.html The DR2D Chunks AmigaMail_Vol2_guide/node00E2.html FORM (0x464F524D) / All drawings are a FORM / AmigaMail_Vol2_guide/node00E3.html DR2D (0x44523244) / ID of 2D drawing / AmigaMail_Vol2_guide/node00E4.html The Global Drawing Attribute Chunks AmigaMail_Vol2_guide/node00E5.html DRHD (0x44524844) / Drawing header / AmigaMail_Vol2_guide/node00E6.html PPRF (0x50505249) / Page preferences / AmigaMail_Vol2_guide/node00E7.html CMAP (0x434D4150) / Color map (Same as ILBM CMAP) / AmigaMail_Vol2_guide/node00E8.html FONS (0x464F4E53) / Font chunk (Same as FTXT FONS chunk) / AmigaMail_Vol2_guide/node00E9.html DASH (0x44415348) / Line dash pattern for edges / AmigaMail_Vol2_guide/node00EA.html AROW (0x41524F57) / An arrow-head pattern / AmigaMail_Vol2_guide/node00EB.html FILL (0x46494C4C) / Object-oriented fill pattern / AmigaMail_Vol2_guide/node00EC.html LAYR (0x4C415952) / Define a layer / AmigaMail_Vol2_guide/node00ED.html The Object Attribute Chunks AmigaMail_Vol2_guide/node00EE.html ATTR (0x41545452) / Object attributes / AmigaMail_Vol2_guide/node00EF.html BBOX (0x42424F48) / Bounding box of next object in FORM / AmigaMail_Vol2_guide/node00F0.html XTRN (0x5854524E) / Externally controlled object / AmigaMail_Vol2_guide/node00F1.html The Object Chunks AmigaMail_Vol2_guide/node00F2.html VBM (0x56424D20) / Virtual BitMap / AmigaMail_Vol2_guide/node00F3.html CPLY (0x43504C59) and OPLY (0x4F504C59) AmigaMail_Vol2_guide/node00F4.html GRUP (0x47525550) / Group / AmigaMail_Vol2_guide/node00F5.html STXT (0x53545854) / Simple text / AmigaMail_Vol2_guide/node00F6.html TPTH (0x54505448) / A text string along a path / AmigaMail_Vol2_guide/node00F7.html A Simple DR2D Example AmigaMail_Vol2_guide/node00F8.html The OFNT FORM AmigaMail_Vol2_guide/node00F9.html OFNT (0x4F464E54) / ID of outline font file / AmigaMail_Vol2_guide/node00FA.html OFHD (0x4F464844) / ID of OutlineFontHeaDer / AmigaMail_Vol2_guide/node00FB.html KERN (0x4B45524C) / Kerning pair / AmigaMail_Vol2_guide/node00FC.html CHDF (0x43484446) / Character definition / AmigaMail_Vol2_guide/node00FD.html VII-17: ECS Display Modes and ILBM CAMG AmigaMail_Vol2_guide/node00FE.html VII-21: Developing New IFF FORMs and Chunks AmigaMail_Vol2_guide/node00FF.html VII-25: AmigaGuide(TM) 101 AmigaMail_Vol2_guide/node0100.html VIII-1: Using the Amiga A3000UX as a NFS File Server AmigaMail_Vol2_guide/node0101.html VIII-9: Keeping Time--Interval Timers in Amiga UNIX AmigaMail_Vol2_guide/node0102.html VIII-17: Developing Network Applications for the Amiga AmigaMail_Vol2_guide/node0103.html Protocol Layers and the Berkeley Sockets Interface AmigaMail_Vol2_guide/node0104.html Network Applications AmigaMail_Vol2_guide/node0105.html Application Protocols AmigaMail_Vol2_guide/node0106.html Kinds of Servers AmigaMail_Vol2_guide/node0107.html Addresses AmigaMail_Vol2_guide/node0108.html Finding Servers AmigaMail_Vol2_guide/node0109.html Reserved Ports AmigaMail_Vol2_guide/node010A.html Skeleton for Applications Using TCP (connection-based) AmigaMail_Vol2_guide/node010B.html Skeleton for Applications Using UDP (connectionless) AmigaMail_Vol2_guide/node010C.html Which Protocol Is Right For My Application? AmigaMail_Vol2_guide/node010D.html The Shared Socket Library AmigaMail_Vol2_guide/node010E.html References AmigaMail_Vol2_guide/node010F.html VIII-31: A Shared Socket Library Server and Client AmigaMail_Vol2_guide/node0110.html The Application Protocol AmigaMail_Vol2_guide/node0111.html The ShowNote Server Application AmigaMail_Vol2_guide/node0112.html Listening for Network and Amiga Events AmigaMail_Vol2_guide/node0113.html Identifying Network Events and Talking to the Client AmigaMail_Vol2_guide/node0114.html Starting the ShowNote Server AmigaMail_Vol2_guide/node0115.html The SendNote Client Application AmigaMail_Vol2_guide/node0116.html Resolving the Target (Host) Address AmigaMail_Vol2_guide/node0117.html Locating the Server Port and Connecting to It AmigaMail_Vol2_guide/node0118.html Starting the SendNote Client AmigaMail_Vol2_guide/node0119.html VIII-51: SANA-II Network Device Driver Specification AmigaMail_Vol2_guide/node011A.html Driver Form AmigaMail_Vol2_guide/node011B.html Opening a SANA-II Device AmigaMail_Vol2_guide/node011C.html Buffer Management AmigaMail_Vol2_guide/node011D.html Packet Type AmigaMail_Vol2_guide/node011E.html Ethernet Packet Types AmigaMail_Vol2_guide/node011F.html ARCNET Frames AmigaMail_Vol2_guide/node0120.html Addressing AmigaMail_Vol2_guide/node0121.html Hardware Type AmigaMail_Vol2_guide/node0122.html Errors AmigaMail_Vol2_guide/node0123.html Standard Commands AmigaMail_Vol2_guide/node0124.html Broadcast and Multicast AmigaMail_Vol2_guide/node0125.html Stats AmigaMail_Vol2_guide/node0126.html Configuration AmigaMail_Vol2_guide/node0127.html On-line AmigaMail_Vol2_guide/node0128.html Acknowledgments AmigaMail_Vol2_guide/node0129.html Unresolved Issues AmigaMail_Vol2_guide/node012A.html IX-1: Four Can Play-Supporting Parallel Port Joysticks AmigaMail_Vol2_guide/node012B.html Building the +2 Interface AmigaMail_Vol2_guide/node012C.html Housing the Interface AmigaMail_Vol2_guide/node012D.html Supporting the Interface in Software AmigaMail_Vol2_guide/node012E.html XI-1: Introduction to Commodities Exchange AmigaMail_Vol2_guide/node012F.html CxObjects AmigaMail_Vol2_guide/node0130.html Installing a Broker AmigaMail_Vol2_guide/node0131.html CxMessages AmigaMail_Vol2_guide/node0132.html Tool Types AmigaMail_Vol2_guide/node0133.html Filter CxObjects AmigaMail_Vol2_guide/node0134.html Senders CxObjects AmigaMail_Vol2_guide/node0135.html Translate CxObjects AmigaMail_Vol2_guide/node0136.html CxObject Errors AmigaMail_Vol2_guide/node0137.html Uniqueness AmigaMail_Vol2_guide/node0138.html DeleteCxObjAll() AmigaMail_Vol2_guide/node0139.html Other CxObjects AmigaMail_Vol2_guide/node013A.html IX AmigaMail_Vol2_guide/node013B.html XI-21/Loading Keymaps AmigaMail_Vol2_guide/node013C.html XI-25: Customizing the Keypad Keymap AmigaMail_Vol2_guide/node013D.html XII-1: CDTV Application Guidelines AmigaMail_Vol2_guide/node013E.html Level 1 Minimum Requirements AmigaMail_Vol2_guide/node013F.html Reference Titles AmigaMail_Vol2_guide/node0140.html Recreation Titles AmigaMail_Vol2_guide/node0141.html Level 2 Quality: The Next Standard AmigaMail_Vol2_guide/node0142.html XII-9: Making CDTV Titles That Work on Amigas AmigaMail_Vol2_guide/node0143.html Physical Differences AmigaMail_Vol2_guide/node0144.html Operating System Issues AmigaMail_Vol2_guide/node0145.html Kickstart 1.3 vs. 2.04 AmigaMail_Vol2_guide/node0146.html What Am I Running On? AmigaMail_Vol2_guide/node0147.html Memory AmigaMail_Vol2_guide/node0148.html Emulating the Remote Controller AmigaMail_Vol2_guide/node0149.html Cursor Buttons AmigaMail_Vol2_guide/node014A.html The 'A' and 'B' Buttons AmigaMail_Vol2_guide/node014B.html 0-9 Buttons AmigaMail_Vol2_guide/node014C.html Escape Key AmigaMail_Vol2_guide/node014D.html Help Key AmigaMail_Vol2_guide/node014E.html REW, PLAY, PAUSE, FF, STOP AmigaMail_Vol2_guide/node014F.html Genlock AmigaMail_Vol2_guide/node0150.html CD/TV AmigaMail_Vol2_guide/node0151.html JOY/MOUSE AmigaMail_Vol2_guide/node0152.html Screen Design Issues AmigaMail_Vol2_guide/node0153.html Fonts AmigaMail_Vol2_guide/node0154.html Three Levels of Support for the A570 AmigaMail_Vol2_guide/node0155.html Level One-Minimal Support AmigaMail_Vol2_guide/node0156.html Level Two-Support For Workbench Startup and Exit AmigaMail_Vol2_guide/node0157.html Level Three-Full Multitasking Support AmigaMail_Vol2_guide/node0158.html Conclusion AmigaMail_Vol2_guide/node0159.html XII-17: Memory Limits for Various CDTV Configurations AmigaMail_Vol2_guide/node015A.html XIII-1: Video Adapter Diagrams AmigaMail_Vol2_guide/node015B.html Warning AmigaMail_Vol2_guide/node015C.html Construction Tips AmigaMail_Vol2_guide/node015D.html 15-Pin Male D-Sub to 9 Pin Female D-Sub Analog Adapter AmigaMail_Vol2_guide/node015E.html 23-Pin Female D-Sub to 15 Pin Female D-Sub Analog Adapter AmigaMail_Vol2_guide/node015F.html 23-Pin Female D-Sub to 9 Pin Female D-Sub Analog Adapter AmigaMail_Vol2_guide/node0160.html 23-Pin Female D-Sub to 9 Pin Female D-Sub Digital Adapter AmigaMail_Vol2_guide/node0161.html XIII-5: The 68030 and 68040 on the Zorro III Bus AmigaMail_Vol2_guide/node0162.html XIII-11: Expanding RAM on the Amiga 4000 AmigaMail_Vol2_guide/node0163.html XIII-15: A1200 CPU Card Expansion RAM AmigaMail_Vol2_guide/node0164.html XIII-17: Game Port Form Factor AmigaMail_Vol2_guide/node0165.html I-7/SimpleFR.c AmigaMail_Vol2_guide/node0166.html I-7/simpleFR.ilbm AmigaMail_Vol2_guide/node0167.html I-7/FilePat.c AmigaMail_Vol2_guide/node0168.html I-7/fontreq.ilbm AmigaMail_Vol2_guide/node0169.html I-7/FontReq.c AmigaMail_Vol2_guide/node016A.html I-7/FileHook.c AmigaMail_Vol2_guide/node016B.html I-43/Hooks1.c AmigaMail_Vol2_guide/node016C.html II-1/SystemTest.c AmigaMail_Vol2_guide/node016D.html II-27/ReadArgs.c AmigaMail_Vol2_guide/node016E.html II-31/SignalNotification.c AmigaMail_Vol2_guide/node016F.html II-31/MessageNotification.c AmigaMail_Vol2_guide/node0170.html II-37/SetStar.c AmigaMail_Vol2_guide/node0171.html II-37/Pattern.c AmigaMail_Vol2_guide/node0172.html II-43/Part.c AmigaMail_Vol2_guide/node0173.html II-43/Split.c AmigaMail_Vol2_guide/node0174.html II-49/ListDir.c AmigaMail_Vol2_guide/node0175.html II-49/ListDir2.c AmigaMail_Vol2_guide/node0176.html II-49/Find.c AmigaMail_Vol2_guide/node0177.html II-49/ListPattern.c AmigaMail_Vol2_guide/node0178.html II-49/DirComp.c AmigaMail_Vol2_guide/node0179.html II-65/myshell.c AmigaMail_Vol2_guide/node017A.html II-65/RestoreShell.c AmigaMail_Vol2_guide/node017B.html II-77/Async.doc AmigaMail_Vol2_guide/node017C.html II-77/ASyncExample.c AmigaMail_Vol2_guide/node017D.html II-77/ASyncIO.c AmigaMail_Vol2_guide/node017E.html II-77/ASyncIO.h AmigaMail_Vol2_guide/node017F.html II-87/LockRecord.c AmigaMail_Vol2_guide/node0180.html II-87/ExRecLock1.c AmigaMail_Vol2_guide/node0181.html II-87/ExRecLock2.c AmigaMail_Vol2_guide/node0182.html II-95/CompareIO.c AmigaMail_Vol2_guide/node0183.html II-95/InOutCTRL-C.c AmigaMail_Vol2_guide/node0184.html II-107/ASync.doc AmigaMail_Vol2_guide/node0185.html II-107/ASyncExample.c AmigaMail_Vol2_guide/node0186.html II-107/ASyncIO.c AmigaMail_Vol2_guide/node0187.html II-107/ASyncIO.h AmigaMail_Vol2_guide/node0188.html II-113/multilist.c AmigaMail_Vol2_guide/node0189.html III-1/Diagram1.ilbm AmigaMail_Vol2_guide/node018A.html III-1/Diagram2.ilbm AmigaMail_Vol2_guide/node018B.html III-1/Diagram3.ilbm AmigaMail_Vol2_guide/node018C.html III-1/Diagram4.ilbm AmigaMail_Vol2_guide/node018D.html III-1/Diagram5.ilbm AmigaMail_Vol2_guide/node018E.html III-1/ISpy.c AmigaMail_Vol2_guide/node018F.html III-1/Ispy_stubs.asm AmigaMail_Vol2_guide/node0190.html III-17/SIGF_Single.c AmigaMail_Vol2_guide/node0191.html III-19/PoolTime.c AmigaMail_Vol2_guide/node0192.html III-29/Armadillo_lib.fd AmigaMail_Vol2_guide/node0193.html III-29/dillo.c AmigaMail_Vol2_guide/node0194.html III-29/dillo.h AmigaMail_Vol2_guide/node0195.html III-29/dillo_lib.c AmigaMail_Vol2_guide/node0196.html III-29/dillo_protos.h AmigaMail_Vol2_guide/node0197.html III-29/dillo_test.c AmigaMail_Vol2_guide/node0198.html III-29/Makefile AmigaMail_Vol2_guide/node0199.html IV-1/wbarg.c AmigaMail_Vol2_guide/node019A.html IV-3/CloneWB.c AmigaMail_Vol2_guide/node019B.html IV-3/Pub.c AmigaMail_Vol2_guide/node019C.html IV-3/Lockpub.c AmigaMail_Vol2_guide/node019D.html IV-3/ScreenDisplayModes.c AmigaMail_Vol2_guide/node019E.html IV-17/extscreen.c AmigaMail_Vol2_guide/node019F.html IV-23: Appendix: Boopsi Class Reference AmigaMail_Vol2_guide/node01A0.html rootclass AmigaMail_Vol2_guide/node01A1.html imageclass AmigaMail_Vol2_guide/node01A2.html frameiclass AmigaMail_Vol2_guide/node01A3.html sysiclass AmigaMail_Vol2_guide/node01A4.html fillrectclass AmigaMail_Vol2_guide/node01A5.html itexticlass AmigaMail_Vol2_guide/node01A6.html icclass AmigaMail_Vol2_guide/node01A7.html modelclass AmigaMail_Vol2_guide/node01A8.html gadgetclass AmigaMail_Vol2_guide/node01A9.html propgclass AmigaMail_Vol2_guide/node01AA.html strgclass AmigaMail_Vol2_guide/node01AB.html groupgclass AmigaMail_Vol2_guide/node01AC.html buttongclass AmigaMail_Vol2_guide/node01AD.html frbuttonclass AmigaMail_Vol2_guide/node01AE.html IV-23/boopsi1.c AmigaMail_Vol2_guide/node01AF.html IV-41/mytextlabelclass.c AmigaMail_Vol2_guide/node01B0.html IV-41/usemyIC.c AmigaMail_Vol2_guide/node01B1.html IV-59/adc.c AmigaMail_Vol2_guide/node01B2.html IV-59/AppWindow.c AmigaMail_Vol2_guide/node01B3.html IV-59/AppIcon.c AmigaMail_Vol2_guide/node01B4.html IV-59/AppIcon.h AmigaMail_Vol2_guide/node01B5.html IV-59/AppMenu.c AmigaMail_Vol2_guide/node01B6.html IV-69/jumpy.c AmigaMail_Vol2_guide/node01B7.html IV-69/zoom.c AmigaMail_Vol2_guide/node01B8.html IV-69/hide.c AmigaMail_Vol2_guide/node01B9.html IV-69/hide.h AmigaMail_Vol2_guide/node01BA.html IV-77/Optimrefresh.c AmigaMail_Vol2_guide/node01BB.html IV-91/WheelGrad.c AmigaMail_Vol2_guide/node01BC.html IV-101/dt.c AmigaMail_Vol2_guide/node01BD.html IV-101/dtpic.c AmigaMail_Vol2_guide/node01BE.html IV-111/fig1.ilbm AmigaMail_Vol2_guide/node01BF.html IV-111/fig2.ilbm AmigaMail_Vol2_guide/node01C0.html IV-111/fig3.ilbm AmigaMail_Vol2_guide/node01C1.html IV-111/fig4.ilbm AmigaMail_Vol2_guide/node01C2.html IV-111/relative.c AmigaMail_Vol2_guide/node01C3.html IV-125/NewGadgets.c AmigaMail_Vol2_guide/node01C4.html IV-125/Figure1.ilbm AmigaMail_Vol2_guide/node01C5.html V-1/genlockdemo.c AmigaMail_Vol2_guide/node01C6.html V-11/getaspect.c AmigaMail_Vol2_guide/node01C7.html V-15/FTA.c AmigaMail_Vol2_guide/node01C8.html V-15/cliptext.c AmigaMail_Vol2_guide/node01C9.html V-23/Engine.c AmigaMail_Vol2_guide/node01CA.html V-23/Rotate.c AmigaMail_Vol2_guide/node01CB.html V-23/View.c AmigaMail_Vol2_guide/node01CC.html V-23/BulletMain.c AmigaMail_Vol2_guide/node01CD.html V-23/BulletMainFile.c AmigaMail_Vol2_guide/node01CE.html V-39/NameMode.c AmigaMail_Vol2_guide/node01CF.html VI-1/fig1.ilbm AmigaMail_Vol2_guide/node01D0.html VI-1/fig2.ilbm AmigaMail_Vol2_guide/node01D1.html VI-1/fig3.ilbm AmigaMail_Vol2_guide/node01D2.html VI-1/fig4.ilbm AmigaMail_Vol2_guide/node01D3.html VI-1/interplay.c AmigaMail_Vol2_guide/node01D4.html VII-1/DR2D-1.pic AmigaMail_Vol2_guide/node01D5.html VII-1/DR2D-2.pic AmigaMail_Vol2_guide/node01D6.html VII-1/DR2D-3.pic AmigaMail_Vol2_guide/node01D7.html VII-1/DR2D-4.pic AmigaMail_Vol2_guide/node01D8.html VII-17/camg.c AmigaMail_Vol2_guide/node01D9.html VII-21/Form.txt AmigaMail_Vol2_guide/node01DA.html VII-25/AmigaGuide.ilbm AmigaMail_Vol2_guide/node01DB.html VIII-31/Note.h AmigaMail_Vol2_guide/node01DC.html VIII-31/SendNote.c AmigaMail_Vol2_guide/node01DD.html VIII-31/ShowNote.c AmigaMail_Vol2_guide/node01DE.html VIII-51: SANA-II Network Device Driver Specification AmigaMail_Vol2_guide/node01DF.html VIII-51/include/devices/sana2.h AmigaMail_Vol2_guide/node01E0.html Developer Support Package / sana2device.doc AmigaMail_Vol2_guide/node01E1.html sana2.device/AbortIO AmigaMail_Vol2_guide/node01E2.html sana2.device/CloseDevice AmigaMail_Vol2_guide/node01E3.html sana2.device/CMD_CLEAR AmigaMail_Vol2_guide/node01E4.html sana2.device/CMD_FLUSH AmigaMail_Vol2_guide/node01E5.html sana2.device/CMD_INVALID AmigaMail_Vol2_guide/node01E6.html sana2.device/CMD_READ AmigaMail_Vol2_guide/node01E7.html sana2.device/CMD_RESET AmigaMail_Vol2_guide/node01E8.html sana2.device/CMD_START AmigaMail_Vol2_guide/node01E9.html sana2.device/CMD_STOP AmigaMail_Vol2_guide/node01EA.html sana2.device/CMD_UPDATE AmigaMail_Vol2_guide/node01EB.html sana2.device/CMD_WRITE AmigaMail_Vol2_guide/node01EC.html sana2.device/OpenDevice AmigaMail_Vol2_guide/node01ED.html sana2.device/S2_ADDMULTICASTADDRESS AmigaMail_Vol2_guide/node01EE.html sana2.device/S2_BROADCAST AmigaMail_Vol2_guide/node01EF.html sana2.device/S2_CONFIGINTERFACE AmigaMail_Vol2_guide/node01F0.html sana2.device/S2_DELMULTICASTADDRESS AmigaMail_Vol2_guide/node01F1.html sana2.device/S2_DEVICEQUERY AmigaMail_Vol2_guide/node01F2.html sana2.device/S2_GETGLOBALSTATS AmigaMail_Vol2_guide/node01F3.html sana2.device/S2_GETSPECIALSTATS AmigaMail_Vol2_guide/node01F4.html sana2.device/S2_GETSTATIONADDRESS AmigaMail_Vol2_guide/node01F5.html sana2.device/S2_GETTYPESTATS AmigaMail_Vol2_guide/node01F6.html sana2.device/S2_MULTICAST AmigaMail_Vol2_guide/node01F7.html sana2.device/S2_OFFLINE AmigaMail_Vol2_guide/node01F8.html sana2.device/S2_ONEVENT AmigaMail_Vol2_guide/node01F9.html sana2.device/S2_ONLINE AmigaMail_Vol2_guide/node01FA.html sana2.device/S2_READORPHAN AmigaMail_Vol2_guide/node01FB.html sana2.device/S2_TRACKTYPE AmigaMail_Vol2_guide/node01FC.html sana2.device/S2_UNTRACKTYPE AmigaMail_Vol2_guide/node01FD.html VIII-51/include/devices/sana2specialstats.h AmigaMail_Vol2_guide/node01FE.html IX-1/4play.c AmigaMail_Vol2_guide/node01FF.html IX-1/read34.asm AmigaMail_Vol2_guide/node0200.html IX-1/lmkfile AmigaMail_Vol2_guide/node0201.html XI-1/cx.ilbm AmigaMail_Vol2_guide/node0202.html XI-1/Broker.c AmigaMail_Vol2_guide/node0203.html XI-1/HotKey.c AmigaMail_Vol2_guide/node0204.html XI-21/LoadKeyMap.c AmigaMail_Vol2_guide/node0205.html XI-21/LoadKeyMap.h AmigaMail_Vol2_guide/node0206.html XI-25/AppKeyMap.doc AmigaMail_Vol2_guide/node0207.html XI-25/AppKeyMap.c AmigaMail_Vol2_guide/node0208.html XI-25/AppKeyMap.h AmigaMail_Vol2_guide/node0209.html XI-25/AppMap_demo.c AmigaMail_Vol2_guide/node020A.html XIII-1/15PM29PFAnalog.ilbm AmigaMail_Vol2_guide/node020B.html XIII-1/23PF15PFAnalog.ilbm AmigaMail_Vol2_guide/node020C.html XIII-1/23PF29PFAnalog.ilbm AmigaMail_Vol2_guide/node020D.html XIII-1/23PF29PFDigital.ilbm AmigaMail_Vol2_guide/node020E.html XIII-17/1200_port.ilbm AmigaMail_Vol2_guide/node020F.html XIII-17/4000_port.ilbm AmigaMail_Vol2_guide/node0210.html XIII-17/600_port.ilbm AmigaMail_Vol2_guide/node0211.html XIII-17/PageXIII017.ilbm AmigaMail_Vol2_guide/node0212.html SANA-II Developer Support Package / Changes AmigaMail_Vol2_guide/node0213.html SANA-II Developer Support Package / ethernet.txt AmigaMail_Vol2_guide/node0214.html VIII-51: SANA-II Network Device Driver Specification AmigaMail_Vol2_guide/node0215.html Developer Support Package / copybuff.doc AmigaMail_Vol2_guide/node0216.html any_sana2_protocol/CopyFromBuff AmigaMail_Vol2_guide/node0217.html any_sana2_protocol/CopyToBuff AmigaMail_Vol2_guide/node0218.html VIII-51/include/devices/sana2specialstats.i AmigaMail_Vol2_guide/node0219.html VIII-51/include/devices/sana2.i Devices_Manual_guide/node0000.html Amiga® RKM Devices: Contents Devices_Manual_guide/node0001.html Please note... Devices_Manual_guide/node0002.html Amiga® RKM Devices: Preface Devices_Manual_guide/node0003.html Amiga® RKM Devices: 1 Introduction to Amiga System Devices Devices_Manual_guide/node0004.html 1 Introduction to Amiga System Devices / What is a Device? Devices_Manual_guide/node0005.html 1 Introduction to Amiga System Devices / Accessing a Device Devices_Manual_guide/node0006.html 1 Introduction to Amiga System Devices / Using a Device Devices_Manual_guide/node0007.html 1 / Using a Device /Amiga Exec Commands Devices_Manual_guide/node0008.html 1 / Using a Device / Amiga System Device Command Prefixes and Examples Devices_Manual_guide/node0009.html 1 Introduction Amiga System Devices / Synchronous vs. Asynchronous Requests Devices_Manual_guide/node000A.html 1 Introduction to Amiga System Devices / I/O Request Completion Devices_Manual_guide/node000B.html 1 Introduction to Amiga System Devices / Ending Device Access Devices_Manual_guide/node000C.html 1 Introduction to Amiga System Devices / Devices With Functions Devices_Manual_guide/node000D.html 1 Introduction to Amiga System Devices / Example Device Programs Devices_Manual_guide/node000E.html Amiga® RKM Devices: 9 / Parallel Device Devices_Manual_guide/node000F.html 9 Parallel Device / Parallel Device Commands and Functions Devices_Manual_guide/node0010.html 9 Parallel Device / Device Interface Devices_Manual_guide/node0011.html 9 Device Interface / Opening The Parallel Device Devices_Manual_guide/node0012.html 9 / Device Interface / Reading From The Parallel Device Devices_Manual_guide/node0013.html 9 / Device Interface / Writing To The Parallel Device Devices_Manual_guide/node0014.html 9 / Device Interface / Closing The Parallel Device Devices_Manual_guide/node0015.html 9 Parallel Device / Ending A Read or Write with Termination Characters Devices_Manual_guide/node0016.html 9 Parallel Device / Setting Parallel Parameters Devices_Manual_guide/node0017.html 9 / Setting Parallel Parameters / Parallel Flags (Bits for io_ParFlags) Devices_Manual_guide/node0018.html 9 Parallel Device / Querying the Parallel Device Devices_Manual_guide/node0019.html 9 Parallel Device / Additional Information on the Parallel Device Devices_Manual_guide/node001A.html Amiga® RKM Devices: 2 Audio Device Devices_Manual_guide/node001B.html 2 Audio Device / About Amiga Audio Devices_Manual_guide/node001C.html 2 / About Amiga Audio / Definitions Devices_Manual_guide/node001D.html 2 Audio Device / Audio Device Commands and Functions Devices_Manual_guide/node001E.html 2 Audio Device / Device Interface Devices_Manual_guide/node001F.html 2 / Device Interface / Opening The Audio Device Devices_Manual_guide/node0020.html 2 / Device Interface / Audio Device Command Types Devices_Manual_guide/node0021.html 2 / Device Interface / Scope Of Audio Commands Devices_Manual_guide/node0022.html 2 / Device Interface / Audio And System I/O Functions Devices_Manual_guide/node0023.html 2 / Audio And System I/O Functions / BeginIO() Devices_Manual_guide/node0024.html 2 / Audio And System I/O Functions / Wait() and WaitPort() Devices_Manual_guide/node0025.html 2 / Audio And System I/O Functions / AbortIO() Devices_Manual_guide/node0026.html 2 / Device Interface / Closing The Audio Device Devices_Manual_guide/node0027.html 2 Audio Device / A Simple Audio Example Devices_Manual_guide/node0028.html 2 Audio Device / Audio Allocation and Arbitration Devices_Manual_guide/node0029.html 2 Audio Device / Allocation and Arbitration Commands Devices_Manual_guide/node002A.html 2 / Allocation and Arbitration Commands / ADCMD_ALLOCATE Devices_Manual_guide/node002B.html 2 / ADCMD_ALLOCATE / How ADCMD_ALLOCATE Operates Devices_Manual_guide/node002C.html 2 / ADCMD_ALLOCATE / The ADIOF_NOWAIT Flag Devices_Manual_guide/node002D.html 2 / ADCMD_ALLOCATE / ADCMD_ALLOCATE Examples Devices_Manual_guide/node002E.html 2 / ADCMD_ALLOCATE / The Allocation Key Devices_Manual_guide/node002F.html 2 / Allocation and Arbitration Commands / ADCMD_FREE Devices_Manual_guide/node0030.html 2 / Allocation and Arbitration Commands / ADCMD_SETPREC Devices_Manual_guide/node0031.html 2 / Allocation and Arbitration Commands / ADCMD_LOCK Devices_Manual_guide/node0032.html 2 Audio Device / Hardware Control Commands Devices_Manual_guide/node0033.html 2 / Hardware Control Commands / CMD_WRITE Devices_Manual_guide/node0034.html 2 / Hardware Control Commands / ADCMD_FINISH Devices_Manual_guide/node0035.html 2 / Hardware Control Commands / ADCMD_PERVOL Devices_Manual_guide/node0036.html 2 / Hardware Control Commands / CMD_FLUSH Devices_Manual_guide/node0037.html 2 / Hardware Control Commands / CMD_RESET Devices_Manual_guide/node0038.html 2 / Hardware Control Commands / ADCMD_WAITCYCLE Devices_Manual_guide/node0039.html 2 / Hardware Control Commands / CMD_STOP Devices_Manual_guide/node003A.html 2 / Hardware Control Commands / CMD_START Devices_Manual_guide/node003B.html 2 / Hardware Control Commands / CMD_READ Devices_Manual_guide/node003C.html 2 Audio Device / Double Buffered Sound Example Devices_Manual_guide/node003D.html 2 Audio Device / Additional Information on the Audio Device Devices_Manual_guide/node003E.html Amiga® RKM Devices: 10 Printer Device Devices_Manual_guide/node003F.html 10 Printer Device / Printer Device Commands and Functions Devices_Manual_guide/node0040.html 10 Printer Device / Printer Device Access Devices_Manual_guide/node0041.html 10 / Printer Device Access / Opening Prt: Devices_Manual_guide/node0042.html 10 / Printer Device Access / Writing To Prt: Devices_Manual_guide/node0043.html 10 / Printer Device Access / Closing Prt: Devices_Manual_guide/node0044.html 10 Printer Device / Device Interface Devices_Manual_guide/node0045.html 10 / Device Interface / Opening The Printer Device Devices_Manual_guide/node0046.html 10 / Device Interface / Writing Text To The Printer Device Devices_Manual_guide/node0047.html 10 / Device Interface / Important Points About Print Requests Devices_Manual_guide/node0048.html 10 / Device Interface / Closing The Printer Device Devices_Manual_guide/node0049.html 10 Printer Device / Sending Printer Commands to a Printer Devices_Manual_guide/node004A.html 10 / Sending Printer Commands to a Printer / Command Definitions Devices_Manual_guide/node004B.html 10 Printer Device / Obtaining Printer Specific Data Devices_Manual_guide/node004C.html 10 Printer Device / Reading and Changing Printer Preferences Settings Devices_Manual_guide/node004D.html 10 Printer Device / Querying the Printer Device Devices_Manual_guide/node004E.html 10 Printer Device / Error Codes from the Printer Device Devices_Manual_guide/node004F.html 10 Printer Device / Dumping a Rastport to a Printer Devices_Manual_guide/node0050.html 10 / Dumping a Rastport to a Printer / Printer Special Flags Devices_Manual_guide/node0051.html 10 / Dumping Rastport to a Printer / Printing Corrected Aspect Ratio Devices_Manual_guide/node0052.html 10 / Dumping a Rastport to a Printer / Strip Printing Devices_Manual_guide/node0053.html 10 / Dumping Rastport to a Printer / Additional Notes on Graphic Dumps Devices_Manual_guide/node0054.html 10 Printer Device / Creating a Printer Driver Devices_Manual_guide/node0055.html 10 / Creating a Printer Driver / Writing Alphanumeric Printer Drivers Devices_Manual_guide/node0056.html 10 / / Writing An Alphanumeric Printer Driver / Command Table Devices_Manual_guide/node0057.html 10 / / Writing An Alphanumeric Printer Driver / DoSpecial() Devices_Manual_guide/node0058.html 10 / / Writing An Alphanumeric Printer Driver / Printertag.asm Devices_Manual_guide/node0059.html 10 / / Writing An Alphanumeric Printer Driver / Extended Character Table Devices_Manual_guide/node005A.html 10 / / Writing An Alphanumeric Printer Driver / Character Conversion Devices_Manual_guide/node005B.html 10 / Creating a Printer Driver / Writing A Graphics Printer Driver Devices_Manual_guide/node005C.html 10 / Writing A Graphics Printer Driver / Render() Devices_Manual_guide/node005D.html 10 / Writing A Graphics Printer Driver / Transfer() Devices_Manual_guide/node005E.html 10 / Writing A Graphics Printer Driver / SetDensity() Devices_Manual_guide/node005F.html 10 / Writing A Graphics Printer Driver / Printertag.asm Devices_Manual_guide/node0060.html 10 / Creating a Printer Driver / Testing The Printer Driver Devices_Manual_guide/node0061.html 10 Printer Device / Example Printer Driver Source Code Devices_Manual_guide/node0062.html 10 / Example Printer Driver Source Code / EpsonX Devices_Manual_guide/node0063.html 10 / Example Printer Driver Source Code / HP_Laserjet Devices_Manual_guide/node0064.html 10 Printer Device / Additional Information on the Printer Device Devices_Manual_guide/node0065.html Amiga® RKM Devices: 3 Clipboard Device Devices_Manual_guide/node0066.html 3 Clipboard Device / Clipboard Device Commands and Functions Devices_Manual_guide/node0067.html 3 Clipboard Device / Device Interface Devices_Manual_guide/node0068.html 3 / Device Interface / Opening The Clipboard Device Devices_Manual_guide/node0069.html 3 / Device Interface / Clipboard Data Devices_Manual_guide/node006A.html 3 / Device Interface / Multiple Clips Devices_Manual_guide/node006B.html 3 / Device Interface / Writing To The Clipboard Device Devices_Manual_guide/node006C.html 3 / Device Interface / Updating The Clipboard Device Devices_Manual_guide/node006D.html 3 / Device Interface / Clipboard Messages Devices_Manual_guide/node006E.html 3 / Device Interface / Reading From The Clipboard Device Devices_Manual_guide/node006F.html 3 / Device Interface / Closing The Clipboard Device Devices_Manual_guide/node0070.html 3 Clipboard Device / Monitoring Clipboard Changes Devices_Manual_guide/node0071.html 3 / Monitoring Clipboard Changes / Caveats For CBD_CHANGEHOOK Devices_Manual_guide/node0072.html 3 Clipboard Device / Additional Information on the Clipboard Device Devices_Manual_guide/node0073.html Amiga® RKM Devices: 11 SCSI Device Devices_Manual_guide/node0074.html 11 SCSI Device / SCSI Device Commands and Functions Devices_Manual_guide/node0075.html 11 SCSI Device / Device Interface Devices_Manual_guide/node0076.html 11 / Device Interface / Opening The SCSI Device Devices_Manual_guide/node0077.html 11 / Device Interface / Closing The SCSI Device Devices_Manual_guide/node0078.html 11 SCSI Device / SCSI-Direct Devices_Manual_guide/node0079.html 11 SCSI Device / RigidDiskBlock - Fields and Implementation Devices_Manual_guide/node007A.html 11 / RigidDiskBlock-Fields and Implementation / How A Driver Uses RDB Devices_Manual_guide/node007B.html 11 / RigidDiskBlock - Fields and Implementation / Alien Filing Systems Devices_Manual_guide/node007C.html 11 SCSI Device / Amiga BootStrap Devices_Manual_guide/node007D.html 11 / Amiga BootStrap / Bootblock Booting Devices_Manual_guide/node007E.html 11 / Amiga BootStrap / Bootpoint Booting Devices_Manual_guide/node007F.html 11 SCSI Device / Additional Information on the SCSI Device Devices_Manual_guide/node0080.html Amiga® RKM Devices: 4 Console Device Devices_Manual_guide/node0081.html 4 Console Device / Console Device Commands and Functions Devices_Manual_guide/node0082.html 4 Console Device / Device Interface Devices_Manual_guide/node0083.html 4 / Device Interface / Console Device Units Devices_Manual_guide/node0084.html 4 / Device Interface / Opening The Console Device Devices_Manual_guide/node0085.html 4 / Device Interface / Closing The Console Device Devices_Manual_guide/node0086.html 4 Console Device / About Console I/O Devices_Manual_guide/node0087.html 4 / About Console I/O / Exec Functions And The Console Device Devices_Manual_guide/node0088.html 4 / About Console I/O / General Console Screen Output Devices_Manual_guide/node0089.html 4 / About Console I/O / Console Keyboard Input Devices_Manual_guide/node008A.html 4 Console Device / Writing to the Console Device Devices_Manual_guide/node008B.html 4 / Writing to the Console Device / Hints For Writing Text Devices_Manual_guide/node008C.html 4 / Writing to the Console Device / Control Sequences For Window Output Devices_Manual_guide/node008D.html 4 / / Set Graphic Rendition Implementation Notes Devices_Manual_guide/node008E.html 4 / Writing to the Console Device / Example Console Control Sequences Devices_Manual_guide/node008F.html 4 Console Device / Reading from the Console Device Devices_Manual_guide/node0090.html 4 / Reading from the Console Device / Information About The Input Stream Devices_Manual_guide/node0091.html 4 / Reading from the Console Device / Cursor Position Report Devices_Manual_guide/node0092.html 4 / Reading from the Console Device / Window Bounds Report Devices_Manual_guide/node0093.html 4 Console Device / Copy and Paste Support Devices_Manual_guide/node0094.html 4 Console Device / Selecting Raw Input Events Devices_Manual_guide/node0095.html 4 Console Device / Input Event Reports Devices_Manual_guide/node0096.html 4 Console Device / Using the Console Device Without a Window Devices_Manual_guide/node0097.html 4 Console Device / Where Is All the Keymap Information? Devices_Manual_guide/node0098.html 4 Console Device / Console Device Caveats Devices_Manual_guide/node0099.html 4 Console Device / Additional Information on the Console Device Devices_Manual_guide/node009A.html Amiga® RKM Devices: 12 Serial Device Devices_Manual_guide/node009B.html 12 Serial Device / Serial Device Commands and Functions Devices_Manual_guide/node009C.html 12 Serial Device / Device Interface Devices_Manual_guide/node009D.html 12 / Device Interface / Opening The Serial Device Devices_Manual_guide/node009E.html 12 / Device Interface / Reading From The Serial Device Devices_Manual_guide/node009F.html 12 / Device Interface / Writing To The Serial Device Devices_Manual_guide/node00A0.html 12 / Device Interface / Closing The Serial Device Devices_Manual_guide/node00A1.html 12 Serial Device / Alternative Modes for Serial Input or Output Devices_Manual_guide/node00A2.html 12 / Alternative Modes for Serial Input or Output / High Speed Operation Devices_Manual_guide/node00A3.html 12 / / Use Of BeginIO() With The Serial Device Devices_Manual_guide/node00A4.html 12 / / Ending A Read Or Write Using Termination Characters Devices_Manual_guide/node00A5.html 12 / / Using Separate Read And Write Tasks Devices_Manual_guide/node00A6.html 12 Serial Device / Setting Serial Parameters (SDCMD_SETPARAMS) Devices_Manual_guide/node00A7.html 12 / Setting Serial Parameters / Serial Flags (Bits For io_SerFlags) Devices_Manual_guide/node00A8.html 12 Serial Device / Querying the Serial Device Devices_Manual_guide/node00A9.html 12 Serial Device / Sending the Break Command Devices_Manual_guide/node00AA.html 12 Serial Device / Error Codes from the Serial Device Devices_Manual_guide/node00AB.html 12 Serial Device / Multiple Serial Port Support Devices_Manual_guide/node00AC.html 12 Serial Device / Taking Over the Hardware Devices_Manual_guide/node00AD.html 12 Serial Device / Additional Information on the Serial Device Devices_Manual_guide/node00AE.html Amiga® RKM Devices: 5 Gameport Device Devices_Manual_guide/node00AF.html 5 Gameport Device / Gameport Device Commands and Functions Devices_Manual_guide/node00B0.html 5 Gameport Device / Device Interface Devices_Manual_guide/node00B1.html 5 / Device Interface / Opening The Gameport Device Devices_Manual_guide/node00B2.html 5 / Device Interface / Gameport Device Controllers Devices_Manual_guide/node00B3.html 5 / Device Interface / Closing The Gameport Device Devices_Manual_guide/node00B4.html 5 Gameport Device / Gameport Events Devices_Manual_guide/node00B5.html 5 / Gameport Events / Reading Gameport Events Devices_Manual_guide/node00B6.html 5 / Gameport Events / Setting Gameport Event Trigger Conditions Devices_Manual_guide/node00B7.html 5 / Gameport Events / Determining The Trigger Conditions Devices_Manual_guide/node00B8.html 5 Gameport Device / Setting and Reading the Controller Type Devices_Manual_guide/node00B9.html 5 / Setting and Reading Controller Type / Determining The Controller Type Devices_Manual_guide/node00BA.html 5 / Setting and Reading the Controller Type / Setting The Controller Type Devices_Manual_guide/node00BB.html 5 / Setting Controller Type /Three Step Protocol for Using Gameport Device Devices_Manual_guide/node00BC.html 5 Gameport Device / Additional Information on the Gameport Device Devices_Manual_guide/node00BD.html Amiga® RKM Devices: 13 Timer Device Devices_Manual_guide/node00BE.html 13 Timer Device / Timer Device Commands and Functions Devices_Manual_guide/node00BF.html 13 Timer Device / Device Interface Devices_Manual_guide/node00C0.html 13 / Device Interface / Timer Device Units Devices_Manual_guide/node00C1.html 13 / Device Interface / Opening The Timer Device Devices_Manual_guide/node00C2.html 13 / Device Interface / Closing The Timer Device Devices_Manual_guide/node00C3.html 13 Timer Device / System Time Devices_Manual_guide/node00C4.html 13 Timer Device / Adding a Time Request Devices_Manual_guide/node00C5.html 13 / Adding a Time Request / Multiple Timer Requests Devices_Manual_guide/node00C6.html 13 Timer Device / Using the Time Arithmetic Functions Devices_Manual_guide/node00C7.html 13 / Using the Time Arithmetic Functions / Why Use Time Arithmetic? Devices_Manual_guide/node00C8.html 13 Timer Device / E-Clock Time and Its Relationship to Actual Time Devices_Manual_guide/node00C9.html 13 Timer Device / Additional Information on the Timer Device Devices_Manual_guide/node00CA.html Amiga® RKM Devices: 6 Input Device Devices_Manual_guide/node00CB.html 6 Input Device / Input Device Commands and Functions Devices_Manual_guide/node00CC.html 6 Input Device / Device Interface Devices_Manual_guide/node00CD.html 6 / Device Interface / Opening The Input Device Devices_Manual_guide/node00CE.html 6 / Device Interface / Input Device Event Types Devices_Manual_guide/node00CF.html 6 / Device Interface / Closing The Input Device Devices_Manual_guide/node00D0.html 6 Input Device / Using the Mouse Port With the Input Device Devices_Manual_guide/node00D1.html 6 / Setting The Conditions For A Mouse Port Report Devices_Manual_guide/node00D2.html 6 Input Device / Adding an Input Handler Devices_Manual_guide/node00D3.html 6 / Adding an Input Handler / Rules For Input Device Handlers Devices_Manual_guide/node00D4.html 6 / Adding an Input Handler / Removing An Input Handler Devices_Manual_guide/node00D5.html 6 Input Device / Writing Events to the Input Device Stream Devices_Manual_guide/node00D6.html 6 / Writing Events to Input Device Stream / Setting Position Of Mouse Devices_Manual_guide/node00D7.html 6 Input Device / Setting the Key Repeat Threshold Devices_Manual_guide/node00D8.html 6 Input Device / Setting the Key Repeat Interval Devices_Manual_guide/node00D9.html 6 Input Device / Determining the Current Qualifiers Devices_Manual_guide/node00DA.html 6 Input Device / Input Device and Intuition Devices_Manual_guide/node00DB.html 6 Input Device / Additional Information on the Input Device Devices_Manual_guide/node00DC.html Amiga® RKM Devices: 14 Trackdisk Device Devices_Manual_guide/node00DD.html 14 Trackdisk Device / Trackdisk Device Commands and Functions Devices_Manual_guide/node00DE.html 14 Trackdisk Device / Device Interface Devices_Manual_guide/node00DF.html 14 / Device Interface / About Amiga Floppy Disks Devices_Manual_guide/node00E0.html 14 / Device Interface / Opening The Trackdisk Device Devices_Manual_guide/node00E1.html 14 / Device Interface / Reading From The Trackdisk Device Devices_Manual_guide/node00E2.html 14 / Device Interface / Writing To The Trackdisk Device Devices_Manual_guide/node00E3.html 14 / Device Interface / Closing The Trackdisk Device Devices_Manual_guide/node00E4.html 14 Trackdisk Device / Advanced Commands Devices_Manual_guide/node00E5.html 14 / Advanced Commands / Determining The Drive Geometry Table Devices_Manual_guide/node00E6.html 14 / Advanced Commands / Clearing The Track Buffer Devices_Manual_guide/node00E7.html 14 / Advanced Commands / Controlling The Drive Motor Devices_Manual_guide/node00E8.html 14 / Advanced Commands / Updating A Track Sector Devices_Manual_guide/node00E9.html 14 / Advanced Commands / Formatting A Track Devices_Manual_guide/node00EA.html 14 / Advanced Commands / Ejecting A Disk Devices_Manual_guide/node00EB.html 14 Trackdisk Device / Disk Status Commands Devices_Manual_guide/node00EC.html 14 / Disk Status Commands / Determining The Presence Of A Disk Devices_Manual_guide/node00ED.html 14 / Disk Status Commands / Determining The Write-Protect Status Of A Disk Devices_Manual_guide/node00EE.html 14 / Disk Status Commands / Determining The Drive Type Devices_Manual_guide/node00EF.html 14 / Disk Status Commands / Determining The Number Of Tracks Of A Drive Devices_Manual_guide/node00F0.html 14 / Disk Status Commands / Determining The Current Diskchange Number Devices_Manual_guide/node00F1.html 14 Trackdisk Device / Commands for Diagnostics and Repair Devices_Manual_guide/node00F2.html 14 / Diagnostics and Repair / Moving The Drive Head To A Specific Track Devices_Manual_guide/node00F3.html 14 Trackdisk Device / Notification of Disk Changes Devices_Manual_guide/node00F4.html 14 / / Adding A Diskchange Software Interrupt Handler Devices_Manual_guide/node00F5.html 14 / / Removing A Diskchange Software Interrupt Handler Devices_Manual_guide/node00F6.html 14 Trackdisk Device / Commands for Low-Level Access Devices_Manual_guide/node00F7.html 14 / Commands for Low-Level Access / Reading Raw Data From A Disk Devices_Manual_guide/node00F8.html 14 / Commands for Low-Level Access / Writing Raw Data To A Disk Devices_Manual_guide/node00F9.html 14 / Low-Level Access Commands / Limitations For Synced Reads And Writes Devices_Manual_guide/node00FA.html 14 Trackdisk Device / Trackdisk Device Errors Devices_Manual_guide/node00FB.html 14 Trackdisk Device / Additional Information on the Trackdisk Device Devices_Manual_guide/node00FC.html Amiga® RKM Devices: 7 Keyboard Device Devices_Manual_guide/node00FD.html 7 Keyboard Device / Keyboard Device Commands and Functions Devices_Manual_guide/node00FE.html 7 Keyboard Device / Device Interface Devices_Manual_guide/node00FF.html 7 / Device Interface / Opening The Keyboard Device Devices_Manual_guide/node0100.html 7 / Device Interface / Closing The Keyboard Device Devices_Manual_guide/node0101.html 7 Keyboard Device / Reading the Keyboard Matrix Devices_Manual_guide/node0102.html 7 Keyboard Device / Amiga Reset Handling Devices_Manual_guide/node0103.html 7 / Amiga Reset Handling / Adding A Reset Handler (KBD_ADDRESETHANDLER) Devices_Manual_guide/node0104.html 7 / Amiga Reset Handling / Removing A Reset Handler (KBD_REMRESETHANDLER) Devices_Manual_guide/node0105.html 7 / Amiga Reset Handling / Ending A Reset Task (KBD_RESETHANDLERDONE) Devices_Manual_guide/node0106.html 7 Keyboard Device / Reading Keyboard Events Devices_Manual_guide/node0107.html 7 Keyboard Device / Additional Information on the Keyboard Device Devices_Manual_guide/node0108.html Amiga® RKM Devices: 15 Resources Devices_Manual_guide/node0109.html 15 Resources / The Amiga Resources Devices_Manual_guide/node010A.html 15 Resources / Resource Interface Devices_Manual_guide/node010B.html 15 Resources / BattClock Resource Devices_Manual_guide/node010C.html 15 Resources / BattMem Resource Devices_Manual_guide/node010D.html 15 Resources / CIA Resource Devices_Manual_guide/node010E.html 15 Resources / Disk Resource Devices_Manual_guide/node010F.html 15 Resources / FileSystem Resource Devices_Manual_guide/node0110.html 15 Resources / Misc Resource Devices_Manual_guide/node0111.html 15 / Misc Resource / C Example Of Allocating Misc Resources Devices_Manual_guide/node0112.html 15 Resources / Potgo Resource Devices_Manual_guide/node0113.html Amiga® RKM Devices: 8 Narrator Device Devices_Manual_guide/node0114.html 8 Narrator Device / Narrator Device Commands and Functions Devices_Manual_guide/node0115.html 8 Narrator Device / Device Interface Devices_Manual_guide/node0116.html 8 / Device Interface / The Amiga Speech System Devices_Manual_guide/node0117.html 8 / Device Interface / Opening The Narrator Device Devices_Manual_guide/node0118.html 8 / Device Interface / Closing The Narrator Device Devices_Manual_guide/node0119.html 8 Narrator Device / Writing to the Narrator Device Devices_Manual_guide/node011A.html 8 Narrator Device / Reading from the Narrator Device Devices_Manual_guide/node011B.html 8 Narrator Device / How to Write Phonetically for Narrator Devices_Manual_guide/node011C.html 8 / How to Write Phonetically for Narrator / Phonetic Spelling Devices_Manual_guide/node011D.html 8 / Phonetic Spelling / Choosing the Right Vowel Devices_Manual_guide/node011E.html 8 / Phonetic Spelling / Choosing the Right Consonant Devices_Manual_guide/node011F.html 8 / Phonetic Spelling / Contractions and Special Symbols Devices_Manual_guide/node0120.html 8 / How to Write Phonetically for Narrator / Stress And Intonation Devices_Manual_guide/node0121.html 8 / / Stress And Intonation / How and Where to Put the Stress Marks Devices_Manual_guide/node0122.html 8 / / Stress And Intonation / Which Stress Value Do I Use? Devices_Manual_guide/node0123.html 8 / How to Write Phonetically for Narrator / Punctuation Devices_Manual_guide/node0124.html 8 / How to Write Phonetically / Hints For Intelligibility Devices_Manual_guide/node0125.html 8 / Writing Phonetically / English And Phonetic Text Example Devices_Manual_guide/node0126.html 8 / How to Write Phonetically for Narrator / Concluding Remarks Devices_Manual_guide/node0127.html 8 Narrator Device / A More Technical Explanation Devices_Manual_guide/node0128.html 8 Narrator Device / Additional Information on the Narrator Device Devices_Manual_guide/node0129.html Amiga® RKM Devices: Appendix A - IFF: Interchange File Format Devices_Manual_guide/node012A.html Amiga® RKM Devices: Index Devices_Manual_guide/node012B.html A Index Devices_Manual_guide/node012C.html Amiga BootStrap Index Devices_Manual_guide/node012D.html Amiga System Devices Index Devices_Manual_guide/node012E.html Audio Channels Index Devices_Manual_guide/node012F.html Audio Device Index Devices_Manual_guide/node0130.html B,C Index Devices_Manual_guide/node0131.html CIA Resource Index Devices_Manual_guide/node0132.html Clipboard Device Index Devices_Manual_guide/node0133.html Console Device Index Devices_Manual_guide/node0134.html D,E Index Devices_Manual_guide/node0135.html EpsonX Driver Index Devices_Manual_guide/node0136.html F,G,H Index Devices_Manual_guide/node0137.html Floppy Disk Index Devices_Manual_guide/node0138.html Gameport Device Index Devices_Manual_guide/node0139.html Graphic Dumps Index Devices_Manual_guide/node013A.html HP_LaserJet Driver Index Devices_Manual_guide/node013B.html I Index Devices_Manual_guide/node013C.html IFF Index Devices_Manual_guide/node013D.html Input Device Index Devices_Manual_guide/node013E.html J,K,L Index Devices_Manual_guide/node013F.html Keyboard Device Index Devices_Manual_guide/node0140.html M,N,O Index Devices_Manual_guide/node0141.html Misc Resource Index Devices_Manual_guide/node0142.html mouth_rb Index Devices_Manual_guide/node0143.html Narrator Device Index Devices_Manual_guide/node0144.html narrator_rb Index Devices_Manual_guide/node0145.html P Index Devices_Manual_guide/node0146.html Parallel Device Index Devices_Manual_guide/node0147.html Phonemes Index Devices_Manual_guide/node0148.html Printer Device Index Devices_Manual_guide/node0149.html Printer Driver Index Devices_Manual_guide/node014A.html Q,R Index Devices_Manual_guide/node014B.html RastPort Index Devices_Manual_guide/node014C.html Render() Index Devices_Manual_guide/node014D.html Resources Index Devices_Manual_guide/node014E.html RigidDiskBlock Index Devices_Manual_guide/node014F.html S Index Devices_Manual_guide/node0150.html SCSI Device Index Devices_Manual_guide/node0151.html Serial Device Index Devices_Manual_guide/node0152.html Setting The Mouse Position Index Devices_Manual_guide/node0153.html Strip Printing Index Devices_Manual_guide/node0154.html Structures Index Devices_Manual_guide/node0155.html T Index Devices_Manual_guide/node0156.html Timer Device Index Devices_Manual_guide/node0157.html Trackdisk Device Index Devices_Manual_guide/node0158.html U,V,W Index Devices_Manual_guide/node0159.html Amiga® RKM Devices: Appendix B Example Device Devices_Manual_guide/node015A.html Amiga® RKM Devices: Appendix C : Floppy Boot Process and Physical Layout Devices_Manual_guide/node015B.html Appendix C / Commodore-Amiga Disk Format Devices_Manual_guide/node015C.html Appendix C / MFM Track Encoding Devices_Manual_guide/node015D.html Devices/Dev_examples/Pre_V36_Device_Use.c Devices_Manual_guide/node015E.html Devices/Dev_examples/V36_Device_Use.c Devices_Manual_guide/node015F.html Devices/Dev_examples/Terminate_Parallel.c Devices_Manual_guide/node0160.html Devices/Dev_examples/Parallel.c Devices_Manual_guide/node0161.html Devices/Dev_examples/Audio.c Devices_Manual_guide/node0162.html Devices/Dev_examples/Audio_8SVX.c Devices_Manual_guide/node0163.html Devices/Dev_examples/Printer_Data.c Devices_Manual_guide/node0164.html Devices/Dev_examples/Set_Prefs.c Devices_Manual_guide/node0165.html Devices/Dev_examples/Demo_Dump.c Devices_Manual_guide/node0166.html Devices/Dev_examples/printertag.asm Devices_Manual_guide/node0167.html FORM Specs from the Original EA Document / FTXT IFF Formatted Text Devices_Manual_guide/node0168.html FTXT IFF Formatted Text / Introduction Devices_Manual_guide/node0169.html FTXT IFF Formatted Text / Reference Devices_Manual_guide/node016A.html FTXT IFF Formatted / Standard Data and Property Chunks Devices_Manual_guide/node016B.html Standard Data and Property Chunks / Character Set Devices_Manual_guide/node016C.html Standard Data and Property Chunks / Control Sequences Devices_Manual_guide/node016D.html Standard Data and Property Chunks / Data Chunk CHRS Devices_Manual_guide/node016E.html Standard Data and Property Chunks / Property Chunk FONS Devices_Manual_guide/node016F.html Standard Data and Property Chunks / Future Properties Devices_Manual_guide/node0170.html Standard Data and Property Chunks / Positioning Units Devices_Manual_guide/node0171.html FTXT IFF Formatted / FTXT Stripper Devices_Manual_guide/node0172.html FTXT IFF Formatted / Appendix A: Character Code Table Devices_Manual_guide/node0173.html FTXT IFF Formatted / Appendix B. FTXT Example Devices_Manual_guide/node0174.html FTXT IFF Formatted / Appendix C. ISO/ANSI Control Sequences Devices_Manual_guide/node0175.html Devices/Dev_examples/Epsonx_transfer.c Devices_Manual_guide/node0176.html Devices/Dev_examples/macros.i Devices_Manual_guide/node0177.html Devices/Dev_examples/Epsonx_Makefile Devices_Manual_guide/node0178.html Devices/Dev_examples/Epsonx_init.asm Devices_Manual_guide/node0179.html Devices/Dev_examples/Epsonx_transfer.asm Devices_Manual_guide/node017A.html Devices/Dev_examples/Epsonx_macros.i Devices_Manual_guide/node017B.html Devices/Dev_examples/Epsonx_data.c Devices_Manual_guide/node017C.html Devices/Dev_examples/Epsonx_printertag.asm Devices_Manual_guide/node017D.html Devices/Dev_examples/Epsonx_dospecial.c Devices_Manual_guide/node017E.html Devices/Dev_examples/Epsonx_density.c Devices_Manual_guide/node017F.html Devices/Dev_examples/Epsonx_rev.i Devices_Manual_guide/node0180.html Devices/Dev_examples/Epsonx_render.c Devices_Manual_guide/node0181.html Devices/Dev_examples/HP_Laserjet_Makefile Devices_Manual_guide/node0182.html Devices/Dev_examples/HP_Laserjet_init.asm Devices_Manual_guide/node0183.html Devices/Dev_examples/HP_Laserjet_transfer.asm Devices_Manual_guide/node0184.html Devices/Dev_examples/HP_Laserjet_macros.i Devices_Manual_guide/node0185.html Devices/Dev_examples/HP_Laserjet_data.c Devices_Manual_guide/node0186.html Devices/Dev_examples/HP_Laserjet_transfer.c Devices_Manual_guide/node0187.html Devices/Dev_examples/HP_Laserjet_printertag.asm Devices_Manual_guide/node0188.html Devices/Dev_examples/HP_Laserjet_dospecial.c Devices_Manual_guide/node0189.html Devices/Dev_examples/HP_Laserjet_density.c Devices_Manual_guide/node018A.html Devices/Dev_examples/HP_Laserjet_rev.i Devices_Manual_guide/node018B.html Devices/Dev_examples/HP_Laserjet_render.c Devices_Manual_guide/node018C.html Devices/Dev_examples/Clipdemo.c Devices_Manual_guide/node018D.html Devices/Dev_examples/Cbio.c Devices_Manual_guide/node018E.html Devices/Dev_examples/cb.h Devices_Manual_guide/node018F.html Devices/Dev_examples/SCSI_Direct.c Devices_Manual_guide/node0190.html Devices/Dev_examples/Console.c Devices_Manual_guide/node0191.html Lib_examples/rawkey.c Devices_Manual_guide/node0192.html Devices/Dev_examples/Simple_Serial.c Devices_Manual_guide/node0193.html Devices/Dev_examples/Complex_Serial.c Devices_Manual_guide/node0194.html Devices/Dev_examples/Terminate_Serial.c Devices_Manual_guide/node0195.html Devices/Dev_examples/Absolute_joystick.c Devices_Manual_guide/node0196.html Devices/Dev_examples/Simple_Timer.c Devices_Manual_guide/node0197.html Devices/Dev_examples/Get_Systime.c Devices_Manual_guide/node0198.html Devices/Dev_examples/Multiple_Timers.c Devices_Manual_guide/node0199.html Devices/Dev_examples/Timer_Arithmetic.c Devices_Manual_guide/node019A.html Devices/Dev_examples/Swap_Buttons.c Devices_Manual_guide/node019B.html Devices/Dev_examples/Set_Mouse.c Devices_Manual_guide/node019C.html Devices/Dev_examples/Track_Copy.c Devices_Manual_guide/node019D.html hard_pics/8-11.pic Devices_Manual_guide/node019E.html Devices/Dev_examples/Read_Keyboard_Matrix.c Devices_Manual_guide/node019F.html Devices/Dev_examples/Key_Reset.c Devices_Manual_guide/node01A0.html Devices/Dev_examples/Keyboard_Events.c Devices_Manual_guide/node01A1.html Devices/Dev_examples/Read_BattClock.c Devices_Manual_guide/node01A2.html Devices/Dev_examples/Cia_Interval.c Devices_Manual_guide/node01A3.html Devices/Dev_examples/Get_Disk_Unit_ID.c Devices_Manual_guide/node01A4.html Devices/Dev_examples/Get_Filesys.c Devices_Manual_guide/node01A5.html Devices/Dev_examples/Alloc_Misc.a Devices_Manual_guide/node01A6.html Devices/Dev_examples/Allocate_Misc.c Devices_Manual_guide/node01A7.html Devices/Dev_examples/Query_Serial.c Devices_Manual_guide/node01A8.html Devices/Dev_examples/Read_Potinp.c Devices_Manual_guide/node01A9.html Devices/Dev_examples/Full_Narrator.c Devices_Manual_guide/node01AA.html Devices/Dev_examples/Speak_Narrator.c Devices_Manual_guide/node01AB.html A / FORM Specs from Original EA Doc / ILBM IFF Interleaved Bitmap Devices_Manual_guide/node01AC.html ILBM IFF Interleaved Bitmap / Introduction Devices_Manual_guide/node01AD.html ILBM IFF Interleaved Bitmap / Reference Devices_Manual_guide/node01AE.html ILBM IFF Interleaved Bitmap / Standard Properties Devices_Manual_guide/node01AF.html Standard Properties / BMHD Devices_Manual_guide/node01B0.html Standard Properties / CMAP Devices_Manual_guide/node01B1.html Standard Properties / GRAB Devices_Manual_guide/node01B2.html Standard Properties / DEST Devices_Manual_guide/node01B3.html Standard Properties / SPRT Devices_Manual_guide/node01B4.html Standard Properties / CAMG Devices_Manual_guide/node01B5.html ILBM IFF Interleaved Bitmap / Standard BODY Data Chunk Devices_Manual_guide/node01B6.html Standard BODY Data Chunk / Raster Layout Devices_Manual_guide/node01B7.html Standard BODY Data Chunk / BODY Devices_Manual_guide/node01B8.html ILBM IFF Interleaved Bitmap / Nonstandard Data Chunks Devices_Manual_guide/node01B9.html Nonstandard Data Chunks / CRNG Devices_Manual_guide/node01BA.html Nonstandard Data Chunks / CCRT Devices_Manual_guide/node01BB.html ILBM IFF Interleaved Bitmap / Appendix A. ILBM Regular Expression Devices_Manual_guide/node01BC.html ILBM IFF Interleaved Bitmap / Appendix B. ILBM Box Diagram Devices_Manual_guide/node01BD.html ILBM IFF Interleaved Bitmap / Appendix C. IFF Hints Devices_Manual_guide/node01BE.html Appendix C. IFF Hints / CGA and EGA subtleties Devices_Manual_guide/node01BF.html ILBM IFF Interleaved Bitmap / 24-bit ILBMs Devices_Manual_guide/node01C0.html ILBM IFF Interleaved Bitmap / Appendix D. ByteRun1 Run Encoding Devices_Manual_guide/node01C1.html ILBM IFF Interleaved Bitmap / Appendix E. Standards Committee Devices_Manual_guide/node01C2.html Appendix A / EA IFF 85 - General IFF Format Specifications Devices_Manual_guide/node01C3.html General IFF Format Specifications / A Quick Introduction to IFF Devices_Manual_guide/node01C4.html A Quick Introduction to IFF / Why IFF? Devices_Manual_guide/node01C5.html A Quick Introduction to IFF / What is IFF? Devices_Manual_guide/node01C6.html A Quick Introduction to IFF / What is the trick? Devices_Manual_guide/node01C7.html A Quick Introduction to IFF / What does an IFF file look like? Devices_Manual_guide/node01C8.html A Quick Introduction to IFF / How to read an IFF file? Devices_Manual_guide/node01C9.html A Quick Introduction to IFF / File extensibility Devices_Manual_guide/node01CA.html A Quick Introduction to IFF/ Advanced Topics Devices_Manual_guide/node01CB.html Appendix A / EA IFF 85: Standard for Interchange Format Files Devices_Manual_guide/node01CC.html EA IFF 85: Standard for Interchange Format Files / Introduction Devices_Manual_guide/node01CD.html A / Introduction / Standards are Good for Software Developers Devices_Manual_guide/node01CE.html A / Introduction / Standards are Good for Software Users Devices_Manual_guide/node01CF.html A / Introduction / Here is EA IFF 1985 Devices_Manual_guide/node01D0.html A / Introduction / References Devices_Manual_guide/node01D1.html A / EA IFF 85:Standard for Interchange Format Files / Design Background Devices_Manual_guide/node01D2.html Background for Designers / What Do We Need? Devices_Manual_guide/node01D3.html Background for Designers / Think Ahead Devices_Manual_guide/node01D4.html Background for Designers / Scope Devices_Manual_guide/node01D5.html Background for Designers / Data Abstraction Devices_Manual_guide/node01D6.html Background for Designers / Previous Work Devices_Manual_guide/node01D7.html App.A EA IFF/ Primitive Data Types Devices_Manual_guide/node01D8.html Primitive Data Types / Alignment Devices_Manual_guide/node01D9.html Primitive Data Types / Numbers Devices_Manual_guide/node01DA.html Primitive Data Types / Characters Devices_Manual_guide/node01DB.html Primitive Data Types / Dates Devices_Manual_guide/node01DC.html Primitive Data Types / Type IDs Devices_Manual_guide/node01DD.html Primitive Data Types / Chunks Devices_Manual_guide/node01DE.html Primitive Data Types / Strings, String Chunks, and String Properties Devices_Manual_guide/node01DF.html Primitive Data Types / Data Properties (advanced topic) Devices_Manual_guide/node01E0.html Primitive Data Types / Links Devices_Manual_guide/node01E1.html Primitive Data Types / File References Devices_Manual_guide/node01E2.html Appendix A / EA IFF/ Data Sections Devices_Manual_guide/node01E3.html Data Sections / Group FORM Devices_Manual_guide/node01E4.html Data Sections / Composite FORMs Devices_Manual_guide/node01E5.html Composite FORMs / FTXT Devices_Manual_guide/node01E6.html Composite FORMs / ILBM Devices_Manual_guide/node01E7.html Composite FORMs / PICS Devices_Manual_guide/node01E8.html Composite FORMs / Other Macintosh Resource Types Devices_Manual_guide/node01E9.html Data Sections / Designing New Data Sections Devices_Manual_guide/node01EA.html App.A EA IFF/ LISTs, CATs, and Shared Properties (Advanced topics) Devices_Manual_guide/node01EB.html LISTs, CATs, and Shared Properties (Advanced topics) / Group CAT Devices_Manual_guide/node01EC.html LISTs, CATs, and Shared Properties (Advanced topics) / Group LIST Devices_Manual_guide/node01ED.html LISTs, CATs, and Shared Properties (Advanced topics) / Group PROP Devices_Manual_guide/node01EE.html LISTs, CATs and Shared Properties (Advanced topics) / Properties for LIST Devices_Manual_guide/node01EF.html App.A EA IFF/ Standard File Structure Devices_Manual_guide/node01F0.html Standard File Structure / File Structure Overview Devices_Manual_guide/node01F1.html Standard File Structure / Single Purpose Files Devices_Manual_guide/node01F2.html Standard File Structure / Scrap Files (not currently used) Devices_Manual_guide/node01F3.html Standard File Structure / Rules for Reader Programs Devices_Manual_guide/node01F4.html Standard File Structure / Rules for Writer Programs Devices_Manual_guide/node01F5.html App.A EA IFF/ Standards Committee Devices_Manual_guide/node01F6.html App.A EA IFF/ Appendix A. Reference Devices_Manual_guide/node01F7.html Appendix A. Reference / Type Definitions Devices_Manual_guide/node01F8.html Appendix A. Reference / Syntax Definitions Devices_Manual_guide/node01F9.html Appendix A. Reference / Example Diagrams Devices_Manual_guide/node01FA.html Amiga® RKM Devices: Appendix A - IFF: Interchange File Format Devices_Manual_guide/node01FB.html A / IFF: Interchange File Format / Third Party FORM and Chunk Specs. Devices_Manual_guide/node01FC.html Appendix A - IFF: Interchange File Format / IFF Source Code Devices_Manual_guide/node01FD.html A / IFF Form and Chunk Registry Devices_Manual_guide/node01FE.html Devices/ramdev-mountlist Devices_Manual_guide/node01FF.html Devices/ramdev.i Devices_Manual_guide/node0200.html Devices/asmsupp.i Devices_Manual_guide/node0201.html Devices/ramdev.device.asm Devices_Manual_guide/node0202.html Devices/modules/saveilbm.c Devices_Manual_guide/node0203.html Devices/modules/ilbmr.c Devices_Manual_guide/node0204.html A / Third Party Public FORM and Chunk Specifications Devices_Manual_guide/node0205.html A / IFF Third Party Public Form and Chunk Specification / 0000.CSET.doc Devices_Manual_guide/node0206.html A / IFF Third Party Public Form and Chunk Specification / 0000.FVER.doc Devices_Manual_guide/node0207.html A / IFF Third Party Public Form and Chunk Specification / 8SVX.CHAN.PAN.doc Devices_Manual_guide/node0208.html 8SVX.CHAN.PAN.doc / Optional Data Chunk CHAN Devices_Manual_guide/node0209.html 8SVX.CHAN.PAN.doc / Optional Data Chunk PAN Devices_Manual_guide/node020A.html A / IFF Third Party Public Form & Chunk Specification / 8SVXSEQN.FADE.doc Devices_Manual_guide/node020B.html 8SVXSEQN.FADE.doc / EXAMPLE Devices_Manual_guide/node020C.html 8SVXSEQN.FADE.doc / Chunk Definitions Devices_Manual_guide/node020D.html 8SVXSEQN.FADE.doc / Optional Data Chunk SEQN Devices_Manual_guide/node020E.html 8SVXSEQN.FADE.doc / Optional Data Chunk FADE Devices_Manual_guide/node020F.html A / IFF Third Party Public Form and Chunk Specification / ACBM.doc Devices_Manual_guide/node0210.html ACBM.doc / FORM Devices_Manual_guide/node0211.html ACBM.doc / Chunk Devices_Manual_guide/node0212.html ACBM.doc / Supporting Software Devices_Manual_guide/node0213.html A / IFF Third Party Public Form and Chunk Specification / AIFF.doc Devices_Manual_guide/node0214.html AIFF.doc / AIFF / Data Types Devices_Manual_guide/node0215.html AIFF.doc / AIFF / Constants Devices_Manual_guide/node0216.html AIFF.doc / AIFF / Data Organization Devices_Manual_guide/node0217.html AIFF.doc / AIFF / Referring to Audio IFF Devices_Manual_guide/node0218.html AIFF.doc / AIFF / File Structure Devices_Manual_guide/node0219.html AIFF.doc / AIFF / Storage of AIFF on Apple and Other Platforms Devices_Manual_guide/node021A.html AIFF.doc / AIFF / Local Chunk Types Devices_Manual_guide/node021B.html AIFF / Local Chunk Types / The Common Chunk Devices_Manual_guide/node021C.html AIFF / Local Chunk Types / Sound Data Chunk Devices_Manual_guide/node021D.html AIFF.doc / AIFF / Sample Points and Sample Frames Devices_Manual_guide/node021E.html AIFF.doc / AIFF / Block-Aligning Sound Data Devices_Manual_guide/node021F.html AIFF.doc / AIFF / The Marker Chunk Devices_Manual_guide/node0220.html AIFF / The Marker Chunk / Markers Devices_Manual_guide/node0221.html AIFF / The Marker Chunk / Marker Chunk Format Devices_Manual_guide/node0222.html AIFF.doc / AIFF / The Instrument Chunk Devices_Manual_guide/node0223.html AIFF / The Instrument Chunk / Looping Devices_Manual_guide/node0224.html AIFF / The Instrument Chunk / The Instrument Chunk Format Devices_Manual_guide/node0225.html AIFF.doc / AIFF / The MIDI Data Chunk Devices_Manual_guide/node0226.html AIFF.doc / AIFF / The Audio Recording Chunk Devices_Manual_guide/node0227.html AIFF.doc / AIFF / The Application Specific Chunk Devices_Manual_guide/node0228.html AIFF.doc / AIFF / The Comments Chunk Devices_Manual_guide/node0229.html AIFF / The Comments Chunk / Comment Devices_Manual_guide/node022A.html AIFF / The Comments Chunk / Comments Chunk Format Devices_Manual_guide/node022B.html AIFF.doc / AIFF / The Text Chunks, Name, Author, Copyright, Annotation Devices_Manual_guide/node022C.html AIFF / The Text Chunks / Name Chunk Devices_Manual_guide/node022D.html AIFF / The Text Chunks / Author Chunk Devices_Manual_guide/node022E.html AIFF / The Text Chunks / Copyright Chunk Devices_Manual_guide/node022F.html AIFF / The Text Chunks / Annotation Chunk Devices_Manual_guide/node0230.html AIFF.doc / AIFF / Chunk Precedence Devices_Manual_guide/node0231.html AIFF.doc / AIFF / Further Reference Devices_Manual_guide/node0232.html A / IFF Third Party Public Form and Chunk Specification / ANBM.doc Devices_Manual_guide/node0233.html ANBM.doc / ANBM Devices_Manual_guide/node0234.html ANBM.doc / FSQN Devices_Manual_guide/node0235.html ANBM.doc / Supporting Software Devices_Manual_guide/node0236.html A / IFF Third Party Public Form and Chunk Specification / ANIM.brush.doc Devices_Manual_guide/node0237.html ANIM.brush.doc / DPAN chunk Format Devices_Manual_guide/node0238.html ANIM.brush.doc / ANHD chunk format Devices_Manual_guide/node0239.html ANIM.brush.doc / RIFF Devices_Manual_guide/node023A.html A / IFF Third Party Public Form and Chunk Specification / ANIM.doc Devices_Manual_guide/node023B.html ANIM.doc / Introduction Devices_Manual_guide/node023C.html Introduction / ANIM Format Overview Devices_Manual_guide/node023D.html Introduction / Recording ANIMs Devices_Manual_guide/node023E.html Introduction Recording ANIMs / XOR mode Devices_Manual_guide/node023F.html Introduction / Recording ANIMs / Long Delta mode Devices_Manual_guide/node0240.html Introduction / Recording ANIMs / Short Delta mode Devices_Manual_guide/node0241.html Introduction / Recording ANIMs / General Delta mode Devices_Manual_guide/node0242.html Introduction / Recording ANIMs / Byte Vertical Compression Devices_Manual_guide/node0243.html Introduction / Playing ANIMs Devices_Manual_guide/node0244.html ANIM.doc / Chunk Formats Devices_Manual_guide/node0245.html Chunk Formats / ANHD Chunk Devices_Manual_guide/node0246.html Chunk Formats / DLTA Chunk Devices_Manual_guide/node0247.html Chunk Formats / DLTA Chunk / Format for methods 2 & 3 Devices_Manual_guide/node0248.html Chunk Formats / DLTA Chunk / Format for method 4 Devices_Manual_guide/node0249.html Chunk Formats / DLTA Chunk / Format for method 5 Devices_Manual_guide/node024A.html A / IFF Third Party Public Form and Chunk Specification / DR2D.doc Devices_Manual_guide/node024B.html DR2D.doc / The DR2D Chunks Devices_Manual_guide/node024C.html The DR2D Chunks / The Global Drawing Attribute Chunks Devices_Manual_guide/node024D.html The Global Drawing Attribute Chunks / DRHD Devices_Manual_guide/node024E.html The Global Drawing Attribute Chunks / PPRF Devices_Manual_guide/node024F.html The Global Drawing Attribute Chunks / CMAP Devices_Manual_guide/node0250.html The Global Drawing Attribute Chunks / FONS Devices_Manual_guide/node0251.html The Global Drawing Attribute Chunks / DASH Devices_Manual_guide/node0252.html The Global Drawing Attribute Chunks / AROW Devices_Manual_guide/node0253.html The Global Drawing Attribute Chunks / FILL Devices_Manual_guide/node0254.html The Global Drawing Attribute Chunks / LAYR Devices_Manual_guide/node0255.html The DR2D Chunks / The Object Attribute Chunks Devices_Manual_guide/node0256.html The Object Attribute Chunks / ATTR Devices_Manual_guide/node0257.html The Object Attribute Chunks / BBOX Devices_Manual_guide/node0258.html The Object Attribute Chunks / XTRN Devices_Manual_guide/node0259.html The DR2D Chunks / The Object Chunks Devices_Manual_guide/node025A.html The Object Chunks / VBM Devices_Manual_guide/node025B.html The Object Chunks / CPLY, OPLY Devices_Manual_guide/node025C.html The Object Chunks / GRUP Devices_Manual_guide/node025D.html The Object Chunks / STXT Devices_Manual_guide/node025E.html The Object Chunks / TPTH Devices_Manual_guide/node025F.html DR2D.doc / A Simple DR2D Example Devices_Manual_guide/node0260.html DR2D.doc / The OFNT FORM Devices_Manual_guide/node0261.html DR2D.doc / OFNT Devices_Manual_guide/node0262.html DR2D.doc / OFHD Devices_Manual_guide/node0263.html DR2D.doc / KERN Devices_Manual_guide/node0264.html DR2D.doc / CHDF Devices_Manual_guide/node0265.html A / IFF Third Party Public Form and Chunk Specification / FANT.doc Devices_Manual_guide/node0266.html FANT.doc / Misc Fantavision Structures Devices_Manual_guide/node0267.html FANT.doc / Frame opcodes Devices_Manual_guide/node0268.html FANT.doc / Frame modes Devices_Manual_guide/node0269.html FANT.doc / Fantavision FORM defines Devices_Manual_guide/node026A.html FANT.doc / Polygon modes Devices_Manual_guide/node026B.html FANT.doc / Polygon types Devices_Manual_guide/node026C.html FANT.doc / Fantavision movie header Devices_Manual_guide/node026D.html FANT.doc / Fantavision frame info Devices_Manual_guide/node026E.html FANT.doc / Fantavision polygon info Devices_Manual_guide/node026F.html FANT.doc / Fantavision high-level IFF format Devices_Manual_guide/node0270.html FANT.doc / Notes Devices_Manual_guide/node0271.html A / IFF Third Party Public Form and Chunk Specification / HEAD.doc Devices_Manual_guide/node0272.html HEAD.doc / FORM Devices_Manual_guide/node0273.html HEAD.doc / CHUNKS Devices_Manual_guide/node0274.html A / IFF Third Party Public Form and Chunk Specification / ILBM.CLUT.doc Devices_Manual_guide/node0275.html ILBM.CLUT.doc / Introduction Devices_Manual_guide/node0276.html ILBM.CLUT.doc / Purpose Devices_Manual_guide/node0277.html ILBM.CLUT.DOC / Specifications Devices_Manual_guide/node0278.html ILBM.CLUT.doc / CLUT Example Devices_Manual_guide/node0279.html ILBM.CLUT.doc / Design Notes Devices_Manual_guide/node027A.html A / IFF Third Party Public Form & Chunk Specification / ILBM.CTBL.DYCP.doc Devices_Manual_guide/node027B.html A / IFF Third Party Public Form and Chunk Specification / ILBM.DPI.doc Devices_Manual_guide/node027C.html A / IFF Third Party Public Form and Chunk Specification / ILBM.DPPV.doc Devices_Manual_guide/node027D.html ILBM.DPPV.doc / Chunk Description Devices_Manual_guide/node027E.html ILBM.DPPV.doc / Chunk Specification Devices_Manual_guide/node027F.html Supporting Software Devices_Manual_guide/node0280.html A / IFF Third Party Public Form and Chunk Specification / ILBM.DRNG.doc Devices_Manual_guide/node0281.html ILBM.DRNG.doc / Enhanced Color Cycling Capabilities Devices_Manual_guide/node0282.html ILBM.DRNG.doc / DPaintIV DRNG chunk Devices_Manual_guide/node0283.html A / IFF Third Party Public Form and Chunk Specification / ILBM.EPSF.doc Devices_Manual_guide/node0284.html A / IFF Third Party Public Form and Chunk Specification / MTRX.doc Devices_Manual_guide/node0285.html MTRX.doc / Introduction Devices_Manual_guide/node0286.html MTRX.doc / Chunks Devices_Manual_guide/node0287.html A / IFF Third Party Public Form and Chunk Specification / PGTB.doc Devices_Manual_guide/node0288.html PGTB.doc / Format Devices_Manual_guide/node0289.html A / IFF Third Party Public Form and Chunk Specification / PRSP.doc Devices_Manual_guide/node028A.html A / IFF Third Party Public Form and Chunk Specification / RGBN-RGB8.doc Devices_Manual_guide/node028B.html RGBN-RGB8.doc / RGBN BODY Chunk Devices_Manual_guide/node028C.html RGBN-RGB8.doc / RGB8 Body Chunk Devices_Manual_guide/node028D.html RGBN-RGB8.doc / Sample BODY Code Devices_Manual_guide/node028E.html A / IFF Third Party Public Form and Chunk Specification / SAMP.doc Devices_Manual_guide/node028F.html SAMP.doc / Similarities and Differences from the 8SVX Form Devices_Manual_guide/node0290.html SAMP.doc / The SAMP Header Devices_Manual_guide/node0291.html SAMP.doc / The MHDR Chunk Devices_Manual_guide/node0292.html SAMP.doc / The NAME Chunk Devices_Manual_guide/node0293.html SAMP.doc / The BODY Chunk Devices_Manual_guide/node0294.html SAMP.doc / Structure of an Individual Sample Point Devices_Manual_guide/node0295.html SAMP.doc / The Waveheader Explained Devices_Manual_guide/node0296.html SAMP.doc / MIDI Velocity vs. Amiga Channel Volume Devices_Manual_guide/node0297.html SAMP.doc / An EGpoint (Envelope Generator) Devices_Manual_guide/node0298.html SAMP.doc / Additional User Data Section Devices_Manual_guide/node0299.html SAMP.doc / Converting Midi Sample Dump to SAMP Devices_Manual_guide/node029A.html SAMP.doc / Interpreting the Playmode Devices_Manual_guide/node029B.html SAMP.doc / Making A Transpose Table Devices_Manual_guide/node029C.html SAMP.doc / Making the Velocity Table Devices_Manual_guide/node029D.html SAMP.doc / The Instrument Type Devices_Manual_guide/node029E.html SAMP.doc / The Order of the Chunks Devices_Manual_guide/node029F.html SAMP.doc / Filename Conventions Devices_Manual_guide/node02A0.html SAMP.doc / Why Does Anyone Need Such a Complicated File? Devices_Manual_guide/node02A1.html A / IFF Third Party Public Form and Chunk Specification / TDDD.doc Devices_Manual_guide/node02A2.html TDDD.doc / Now, on with the details Devices_Manual_guide/node02A3.html Details / DESC sub-sub-chunks Devices_Manual_guide/node02A4.html Details / DESC notes Devices_Manual_guide/node02A5.html Details / INFO sub-chunks Devices_Manual_guide/node02A6.html Details / EXTR sub-sub-chunks Devices_Manual_guide/node02A7.html A / IFF Third Party Public Form and Chunk Specification / WORD.doc Devices_Manual_guide/node02A8.html WORD.doc / FORM Devices_Manual_guide/node02A9.html WORD.doc / Chunks Devices_Manual_guide/node02AA.html FORM Specs from the Original EA Document / SMUS IFF Simple Musical Score Devices_Manual_guide/node02AB.html SMUS IFF Simple Musical Score / Introduction Devices_Manual_guide/node02AC.html SMUS IFF Simple Musical Score / Introduction / References Devices_Manual_guide/node02AD.html SMUS IFF Simple Musical Score / Background Devices_Manual_guide/node02AE.html Background / Classical Event Durations Devices_Manual_guide/node02AF.html Background / Tracks Devices_Manual_guide/node02B0.html Background / Instrument Registers Devices_Manual_guide/node02B1.html Background / MIDI Instruments Devices_Manual_guide/node02B2.html SMUS IFF Simple Musical Score / Standard Data and Property Chunks Devices_Manual_guide/node02B3.html Standard Data and Property Chunks / Required Property SHDR Devices_Manual_guide/node02B4.html Standard Data and Property Chunks / Optional Text Chunks Devices_Manual_guide/node02B5.html Standard Data and Property Chunks / Optional Property INS1 Devices_Manual_guide/node02B6.html Standard Data and Property Chunks / Obsolete Property INST Devices_Manual_guide/node02B7.html Standard Data and Property Chunks / Data Chunk TRAK Devices_Manual_guide/node02B8.html Standard Data and Property Chunks / Note and Rest SEvents Devices_Manual_guide/node02B9.html Standard Data and Property Chunks / Set Instrument SEvent Devices_Manual_guide/node02BA.html Standard Data and Property Chunks / Set Time Signature SEvent Devices_Manual_guide/node02BB.html Standard Data and Property Chunks / Key Signature SEvent Devices_Manual_guide/node02BC.html Standard Data and Property Chunks / Dynamic Mark SEvent Devices_Manual_guide/node02BD.html Standard Data and Property Chunks / Set MIDI Channel SEvent Devices_Manual_guide/node02BE.html Standard Data and Property Chunks / Set MIDI Preset SEvent Devices_Manual_guide/node02BF.html Standard Data and Property Chunks / Instant Music Private SEvents Devices_Manual_guide/node02C0.html Standard Data and Property Chunks / End-Mark SEvent Devices_Manual_guide/node02C1.html Standard Data and Property Chunks / More SEvents To Be Defined Devices_Manual_guide/node02C2.html SMUS IFF Simple Musical Score / Private Chunks Devices_Manual_guide/node02C3.html SMUS IFF Simple Musical Score / Appendix A. Quick Reference Devices_Manual_guide/node02C4.html Appendix A. Quick Reference / Type Definitions Devices_Manual_guide/node02C5.html Appendix A. Quick Reference / SMUS Regular Expression Devices_Manual_guide/node02C6.html SMUS IFF Simple Musical Score / Appendix B. SMUS Example Devices_Manual_guide/node02C7.html SMUS IFF Simple Musical Score / Appendix C. Standards Committee Devices_Manual_guide/node02C8.html FORM Specifications from the Original EA Document / 8SVX IFF 8-Bit Sampled Voice Devices_Manual_guide/node02C9.html 8SVX IFF 8-Bit Sampled Voice / Introduction Devices_Manual_guide/node02CA.html 8SVX IFF 8-Bit Sampled Voice / Introduction / Reference Devices_Manual_guide/node02CB.html 8SVX IFF 8-Bit Sampled Voice / Standard Data and Property Chunks Devices_Manual_guide/node02CC.html Standard Data and Property Chunks / Background Devices_Manual_guide/node02CD.html Standard Data and Property Chunks / Required Property VHDR Devices_Manual_guide/node02CE.html Standard Data and Property Chunks / Optional Text Chunks Devices_Manual_guide/node02CF.html Standard Data and Property Chunks / Optional Data Chunks ATAK and RLSE Devices_Manual_guide/node02D0.html Standard Data and Property Chunks / Data Chunk BODY Devices_Manual_guide/node02D1.html Standard Data and Property Chunks / Other Chunks Devices_Manual_guide/node02D2.html 8SVX IFF 8-Bit Sampled Voice / Appendix A. Quick Reference Devices_Manual_guide/node02D3.html Appendix A. Quick Reference / Type Definitions Devices_Manual_guide/node02D4.html Appendix A. Quick Reference / 8SVX Regular Expression Devices_Manual_guide/node02D5.html 8SVX IFF 8-Bit Sampled Voice / Appendix B. 8SVX Example Devices_Manual_guide/node02D6.html 8SVX IFF 8-Bit Sampled Voice / Appendix C. Fibonacci Delta Compression Devices_Manual_guide/node02D7.html A / Additional Documents Devices_Manual_guide/node02D8.html Additional Info / Sample hex dump of beginning of an ILBM Devices_Manual_guide/node02D9.html Additional Info / Interpreting ILBMs Devices_Manual_guide/node02DA.html Additional Info / Body Compression Devices_Manual_guide/node02DB.html Additional Info / Interpreting the Scan Line Data Devices_Manual_guide/node02DC.html Additional Info / How Amiga HAM mode works Devices_Manual_guide/node02DD.html Additional Info / How Amiga HALFBRITE mode works Devices_Manual_guide/node02DE.html Additional Info / Other Notes Devices_Manual_guide/node02DF.html A / IFF Source Code / IFF Include Files Devices_Manual_guide/node02E0.html A / IFF Source Code / Source listings of examples Devices_Manual_guide/node02E1.html dev_pics/dr2d-1.pic Devices_Manual_guide/node02E2.html dev_pics/dr2d-2.pic Devices_Manual_guide/node02E3.html dev_pics/dr2d-3.pic Devices_Manual_guide/node02E4.html dev_pics/dr2d-4.pic Devices_Manual_guide/node02E5.html Devices/iffp/iff.h Devices_Manual_guide/node02E6.html Devices/IFFP_Modules.README Devices_Manual_guide/node02E7.html Devices/Makefile.SAS Devices_Manual_guide/node02E8.html Devices/iffp/8svxapp.h Devices_Manual_guide/node02E9.html Devices/iffp/debug.h Devices_Manual_guide/node02EA.html Devices/iffp/ilbmapp.h Devices_Manual_guide/node02EB.html Devices/Makefile.Manx Devices_Manual_guide/node02EC.html Devices/iffp/amiga.h Devices_Manual_guide/node02ED.html Devices/iffp/packer.h Devices_Manual_guide/node02EE.html Devices/iffp/8svx.h Devices_Manual_guide/node02EF.html Devices/iffp/compiler.h Devices_Manual_guide/node02F0.html Devices/iffp/ilbm.h Devices_Manual_guide/node02F1.html Devices/iffp/smus.h Devices_Manual_guide/node02F2.html Devices/apps/24bitDemo/24bitDemo.c Devices_Manual_guide/node02F3.html Devices/apps/Play8SVX/Play8SVX.c Devices_Manual_guide/node02F4.html Devices/modules/getbitmap.c Devices_Manual_guide/node02F5.html Devices/modules/packer.c Devices_Manual_guide/node02F6.html Devices/modules/unpacker.c Devices_Manual_guide/node02F7.html Devices/apps/ILBMDemo/ILBMDemo.c Devices_Manual_guide/node02F8.html Devices/apps/RawtoILBM/RawtoILBM.c Devices_Manual_guide/node02F9.html Devices/modules/getdisplay.c Devices_Manual_guide/node02FA.html Devices/modules/parse.c Devices_Manual_guide/node02FB.html Devices/other/clipftxt.c Devices_Manual_guide/node02FC.html Devices/apps/ILBMLoad/ILBMLoad.c Devices_Manual_guide/node02FD.html Devices/apps/ScreenSave/ScreenSave.c Devices_Manual_guide/node02FE.html Devices/other/cycvb.c Devices_Manual_guide/node02FF.html Devices/apps/ILBMtoC/ILBMtoC.c Devices_Manual_guide/node0300.html Devices/modules/bmprintc.c Devices_Manual_guide/node0301.html Devices/modules/ilbmw.c Devices_Manual_guide/node0302.html Devices/other/ilbmscan.c Devices_Manual_guide/node0303.html Devices/apps/ILBMtoRaw/ILBMtoRaw.c Devices_Manual_guide/node0304.html Devices/modules/copychunks.c Devices_Manual_guide/node0305.html Devices/modules/loadilbm.c Devices_Manual_guide/node0306.html Devices/modules/screendump.c Devices_Manual_guide/node0307.html Devices/other/sift.c Hardware_Manual_guide/node0000.html Amiga® Hardware Reference Manual: Contents Hardware_Manual_guide/node0001.html Amiga® Hardware Reference Manual: Preface Hardware_Manual_guide/node0002.html Amiga® Hardware Reference Manual: 1 Introduction Hardware_Manual_guide/node0003.html 1 Introduction / Components of the Amiga Hardware_Manual_guide/node0004.html 1 / Components of the Amiga / The MC68000 and the Amiga Custom Chips Hardware_Manual_guide/node0005.html 1 / Components of the Amiga / Amiga Memory System Hardware_Manual_guide/node0006.html 1 / Components of the Amiga / Peripherals Hardware_Manual_guide/node0007.html 1 / Components of the Amiga / System Expandability and Adaptability Hardware_Manual_guide/node0008.html 1 / Components of the Amiga / VCR and Direct Camera Interface Hardware_Manual_guide/node0009.html 1 / Components of the Amiga / Amiga System Block Diagram Hardware_Manual_guide/node000A.html 1 Introduction / About the Examples Hardware_Manual_guide/node000B.html 1 Introduction / General Development Guidelines Hardware_Manual_guide/node000C.html 1 / General Development Guidelines / 68010/020/030/040 Compatibility Hardware_Manual_guide/node000D.html 1 / General Development Guidelines / Hardware Programming Guidelines Hardware_Manual_guide/node000E.html 1 / General Development Guidelines / Additional Assembler Guidelines Hardware_Manual_guide/node000F.html 1 Introduction / Applications & Technical Support (CATS) Hardware_Manual_guide/node0010.html 1 Introduction / Error Reports Hardware_Manual_guide/node0011.html Amiga® Hardware Reference Manual:A Register Summary Alphabetical Order Hardware_Manual_guide/node0012.html A Register Summary / ADKCON, ADKCONR Hardware_Manual_guide/node0013.html A Register Summary / AUDxDAT Hardware_Manual_guide/node0014.html A Register Summary / AUDxLCH, AUDxLCL Hardware_Manual_guide/node0015.html A Register Summary / AUDxLEN Hardware_Manual_guide/node0016.html A Register Summary / AUDxPER Hardware_Manual_guide/node0017.html A Register Summary / AUDxVOL Hardware_Manual_guide/node0018.html A Register Summary / BEAMCON0 Hardware_Manual_guide/node0019.html A Register Summary / BLTAFWM, BLTALWM Hardware_Manual_guide/node001A.html A Register Summary / BLTCON0, BLTCON1 Hardware_Manual_guide/node001B.html A Register Summary / BLTCON0L Hardware_Manual_guide/node001C.html A Register Summary / BLTDDAT Hardware_Manual_guide/node001D.html A Register Summary / BLTSIZE, BLTSIZV, BLTSIZH Hardware_Manual_guide/node001E.html A Register Summary / BLTxDAT Hardware_Manual_guide/node001F.html A Register Summary / BLTxMOD Hardware_Manual_guide/node0020.html A Register Summary / BLTxPTH, BLTxPTL Hardware_Manual_guide/node0021.html A Register Summary / BPL1MOD, BPL2MOD Hardware_Manual_guide/node0022.html A Register Summary / BPLCON0, BPLCON1, BPLCON2, BPLCON3 Hardware_Manual_guide/node0023.html A Register Summary / BPLxDAT Hardware_Manual_guide/node0024.html A Register Summary / BPLxPTH, BPLxPTL Hardware_Manual_guide/node0025.html A Register Summary / CLXCON Hardware_Manual_guide/node0026.html A Register Summary / CLXDAT Hardware_Manual_guide/node0027.html A Register Summary / COLORxx Hardware_Manual_guide/node0028.html A Register Summary / COP1LCH, COP1LCL, COP2LCH, COP2LCL Hardware_Manual_guide/node0029.html A Register Summary / COPCON Hardware_Manual_guide/node002A.html A Register Summary / COPINS Hardware_Manual_guide/node002B.html A Register Summary / COPJMP1, COPJMP2 Hardware_Manual_guide/node002C.html A Register Summary / DDFSTOP, DDFSTRT Hardware_Manual_guide/node002D.html A Register Summary / DENISEID Hardware_Manual_guide/node002E.html A Register Summary / DIWHIGH, DIWSTOP, DIWSTRT Hardware_Manual_guide/node002F.html A Register Summary / DMACON, DMACONR Hardware_Manual_guide/node0030.html A Register Summary / DSKBYTR Hardware_Manual_guide/node0031.html A Register Summary / DSKDAT, DSKDATR Hardware_Manual_guide/node0032.html A Register Summary / DSKLEN Hardware_Manual_guide/node0033.html A Register Summary / DSKPTH, DSKPTL Hardware_Manual_guide/node0034.html A Register Summary / DSKSYNC Hardware_Manual_guide/node0035.html A Register Summary / HBSTOP, HBSTRT, HCENTER, HSSTOP, HSSTRT, HTOTAL Hardware_Manual_guide/node0036.html A Register Summary / INTENA, INTENAR Hardware_Manual_guide/node0037.html A Register Summary / INTREQ, INTREQR Hardware_Manual_guide/node0038.html A Register Summary / JOY0DAT, JOY1DAT Hardware_Manual_guide/node0039.html A Register Summary / JOYTEST Hardware_Manual_guide/node003A.html A Register Summary / POT0DAT, POT1DAT Hardware_Manual_guide/node003B.html A Register Summary / POTGO, POTGOR Hardware_Manual_guide/node003C.html A Register Summary / REFPTR Hardware_Manual_guide/node003D.html A Register Summary / SERDAT, SERDATR Hardware_Manual_guide/node003E.html A Register Summary / SERPER Hardware_Manual_guide/node003F.html A Register Summary / SPRxCTL, SPRxPOS Hardware_Manual_guide/node0040.html A Register Summary / SPRxDATA, SPRxDATB Hardware_Manual_guide/node0041.html A Register Summary / SPRxPTH, SPRxPTL Hardware_Manual_guide/node0042.html A Register Summary / STREQU, STRHOR, STRLONG, STRVBL Hardware_Manual_guide/node0043.html A Register Summary / VBSTOP, VBSTRT Hardware_Manual_guide/node0044.html A Register Summary / VHPOSR, VHPOSW Hardware_Manual_guide/node0045.html A Register Summary / VPOSR, VPOSW Hardware_Manual_guide/node0046.html A Register Summary / VSSTOP, VSSTRT, VTOTAL Hardware_Manual_guide/node0047.html Amiga® Hardware Reference Manual: 2 Coprocessor Hardware Hardware_Manual_guide/node0048.html 2 Coprocessor Hardware / About the Copper Hardware_Manual_guide/node0049.html 2 Coprocessor Hardware / What is a Copper Instruction? Hardware_Manual_guide/node004A.html 2 Coprocessor Hardware / The MOVE Instruction Hardware_Manual_guide/node004B.html 2 Coprocessor Hardware / The WAIT Instruction Hardware_Manual_guide/node004C.html 2 / The WAIT Instruction / Horizontal Beam Position Hardware_Manual_guide/node004D.html 2 / The WAIT Instruction / Vertical Beam Position Hardware_Manual_guide/node004E.html 2 / The WAIT Instruction / The Comparison Enable Bits Hardware_Manual_guide/node004F.html 2 Coprocessor Hardware / Using the Copper Registers Hardware_Manual_guide/node0050.html 2 / Using the Copper Registers / Location Registers Hardware_Manual_guide/node0051.html 2 / Using the Copper Registers / Jump Strobe Address Hardware_Manual_guide/node0052.html 2 / Using the Copper Registers / Control Register Hardware_Manual_guide/node0053.html 2 Coprocessor Hardware / Putting Together a Copper Instruction List Hardware_Manual_guide/node0054.html 2 / Putting Together a Copper List / Complete Sample Copper List Hardware_Manual_guide/node0055.html 2 Coprocessor Hardware / Starting and Stopping the Copper Hardware_Manual_guide/node0056.html 2 / Starting and Stopping the Copper / Starting the Copper After Reset Hardware_Manual_guide/node0057.html 2 / Starting and Stopping the Copper / Stopping the Copper Hardware_Manual_guide/node0058.html 2 Coprocessor Hardware / Advanced Topics Hardware_Manual_guide/node0059.html 2 / Advanced Topics / The SKIP Instruction Hardware_Manual_guide/node005A.html 2 / Advanced Topics / Copper Loops and Branches and Comparison Enable Hardware_Manual_guide/node005B.html 2 / Advanced Topics / A Copper Loop Example Hardware_Manual_guide/node005C.html 2 / Advanced Topics / Using the Copper In Interlaced Mode Hardware_Manual_guide/node005D.html 2 / Advanced Topics / Using the Copper with the Blitter Hardware_Manual_guide/node005E.html 2 / Advanced Topics / The Copper and the 680x0 Hardware_Manual_guide/node005F.html 2 Coprocessor Hardware / Summary of Copper Instructions Hardware_Manual_guide/node0060.html Amiga® Hardware Reference Manual: B Register Summary Address Order Hardware_Manual_guide/node0061.html Amiga® Hardware Reference Manual: 3 Playfield Hardware Hardware_Manual_guide/node0062.html 3 Playfield Hardware / About Amiga Playfields Hardware_Manual_guide/node0063.html 3 / About Amiga Playfields / How Amiga's Video Display is Produced Hardware_Manual_guide/node0064.html 3 Playfield Hardware / Forming a Basic Playfield Hardware_Manual_guide/node0065.html 3 / Forming a Basic Playfield / Height and Width of the Playfield Hardware_Manual_guide/node0066.html 3 / Forming a Basic Playfield / Bitplanes and Color Hardware_Manual_guide/node0067.html 3 / / Bitplanes and Color / The Color Table Hardware_Manual_guide/node0068.html 3 / / Bitplanes and Color / Selecting the Number of Bitplanes Hardware_Manual_guide/node0069.html 3 / Basic Playfield / Selecting Horizontal and Vertical Resolution Hardware_Manual_guide/node006A.html 3 / Forming a Basic Playfield / Allocating Memory for Bitplanes Hardware_Manual_guide/node006B.html 3 / / Allocating Memory for Bitplanes / NTSC Example of Bitplane Size Hardware_Manual_guide/node006C.html 3 / Basic Playfield / Coding the Bitplanes For Correct Coloring Hardware_Manual_guide/node006D.html 3 / / Coding For Correct Coloring / A One- or Two-Color Playfield Hardware_Manual_guide/node006E.html 3 / / Correct Coloring / A Playfield of Three or More Colors Hardware_Manual_guide/node006F.html 3 / Forming Basic Playfield / Defining the Size of the Display Window Hardware_Manual_guide/node0070.html 3 / / Size Display Window / Setting Display Window Starting Position Hardware_Manual_guide/node0071.html 3 / / Size Display Window / Setting Display Window Stopping Position Hardware_Manual_guide/node0072.html 3 / Basic Playfield / Telling the System How to Fetch and Display Data Hardware_Manual_guide/node0073.html 3 / / How to Fetch and Display Data / in High resolution Mode Hardware_Manual_guide/node0074.html 3 / / How to Fetch and Display Data / Modulo in Interlaced Mode Hardware_Manual_guide/node0075.html 3 / Basic Playfield / Displaying and Redisplaying the Playfield Hardware_Manual_guide/node0076.html 3 / Forming a Basic Playfield / Enabling the Color Display Hardware_Manual_guide/node0077.html 3 / Forming a Basic Playfield / Basic Playfield Summary Hardware_Manual_guide/node0078.html 3 Playfield Hardware / Forming a Dual-playfield Display Hardware_Manual_guide/node0079.html 3 / Dual-playfield / Bitplane Assignment in Dual-Playfield Mode Hardware_Manual_guide/node007A.html 3 / Dual-playfield Display / Color Registers in Dual-Playfield Mode Hardware_Manual_guide/node007B.html 3 / Dual-playfield Display / Dual-Playfield Priority and Control Hardware_Manual_guide/node007C.html 3 / Forming a Dual-playfield Display / Activating Dual-Playfield Mode Hardware_Manual_guide/node007D.html 3 / Forming a Dual-playfield Display / Dual Playfield Summary Hardware_Manual_guide/node007E.html 3 Playfield Hardware / Bitplanes and Display Windows of All Sizes Hardware_Manual_guide/node007F.html 3 / All Sizes / When the Big Picture is Larger than the Display Window Hardware_Manual_guide/node0080.html 3 / / When Picture is Larger than Window / Specifying the Modulo Hardware_Manual_guide/node0081.html 3 / / When Picture is Larger than Window / Specifying the Data Fetch Hardware_Manual_guide/node0082.html 3 / / When Picture is Larger than Display Window / Memory Allocation Hardware_Manual_guide/node0083.html 3 / / Picture Larger / Selecting the Display Window Starting Position Hardware_Manual_guide/node0084.html 3 / / Picture is Larger than Window / Selecting the Stopping Position Hardware_Manual_guide/node0085.html 3 / Bitplanes and Windows of All Sizes / Maximum Display Window Size Hardware_Manual_guide/node0086.html 3 Playfield Hardware / Moving (Scrolling) Playfields Hardware_Manual_guide/node0087.html 3 / Moving (Scrolling) Playfields / Vertical Scrolling Hardware_Manual_guide/node0088.html 3 / Moving (Scrolling) Playfields / Horizontal Scrolling Hardware_Manual_guide/node0089.html 3 / / Horiz. Scrolling / Specifying Data Fetch in Horizontal Scrolling Hardware_Manual_guide/node008A.html 3 / / Horiz. Scrolling / Specifying the Modulo in Horizontal Scrolling Hardware_Manual_guide/node008B.html 3 / / Horizontal Scrolling / Specifying Amount of Delay Hardware_Manual_guide/node008C.html 3 / Moving (Scrolling) Playfields / Scrolling Playfield Summary Hardware_Manual_guide/node008D.html 3 Playfield Hardware / Advanced Topics Hardware_Manual_guide/node008E.html 3 / Advanced Topics / Interactions Among Playfields and Other Objects Hardware_Manual_guide/node008F.html 3 / Advanced Topics / Hold-And-Modify Mode Hardware_Manual_guide/node0090.html 3 / Adv. Topics / Forming a Display with Several Different Playfields Hardware_Manual_guide/node0091.html 3 / Advanced Topics / Using an External Video Source Hardware_Manual_guide/node0092.html 3 Playfield Hardware / Summary of Playfield Registers Hardware_Manual_guide/node0093.html 3 Playfield Hardware / Summary of Color Selection Registers Hardware_Manual_guide/node0094.html 3 / Color Selection Registers / Some Sample Color Register Contents Hardware_Manual_guide/node0095.html 3 / Color Selection Registers / Color Selection in Low Resolution Mode Hardware_Manual_guide/node0096.html 3 / Color Selection / Color Selection in High Resolution Mode Hardware_Manual_guide/node0097.html 3 / Color Selection / Color Selection in Hold-And-Modify Mode Hardware_Manual_guide/node0098.html 3 / Color Selection / Color Selection in Extra Half Brite (EHB) Mode Hardware_Manual_guide/node0099.html Amiga® Hardware Reference Manual: C Enhanced Chip Set Hardware_Manual_guide/node009A.html C Enhanced Chip Set / New Features of the Enhanced Chip Set Hardware_Manual_guide/node009B.html C / New Features of the Enhanced Chip Set / New Memory Limits Hardware_Manual_guide/node009C.html C / New Features of the Enhanced Chip Set / New Blitter Range Hardware_Manual_guide/node009D.html C / New Features of the Enhanced Chip Set / New Mode Resolutions Hardware_Manual_guide/node009E.html C / New Features of the Enhanced Chip Set / New Monitor Scan Rates Hardware_Manual_guide/node009F.html C / New Features of the Enhanced Chip Set / New Genlock Capabilities Hardware_Manual_guide/node00A0.html C / New Features of the Enhanced Chip Set / Built-in A2024 Support Hardware_Manual_guide/node00A1.html C Enhanced Chip Set / ECS Hardware and the Graphics Library Hardware_Manual_guide/node00A2.html C / ECS Hardware and the Graphics Library / Determining Chip Revisions Hardware_Manual_guide/node00A3.html C / ECS Hardware and the Graphics Library / SuperHires Mode Hardware_Manual_guide/node00A4.html C / ECS Graphics Library / SuperHires Mode and Denise Color Registers Hardware_Manual_guide/node00A5.html C / ECS Hardware Graphics Library / SuperHires 70ns Sprite Positioning Hardware_Manual_guide/node00A6.html C / ECS Hardware and Graphics Library / Multi-Sync and Bi-Sync Monitors Hardware_Manual_guide/node00A7.html C / ECS Hardware and the Graphics Library / New BEAMCON0 Register Hardware_Manual_guide/node00A8.html C / ECS Hardware and Graphics Library / Display Window Specification Hardware_Manual_guide/node00A9.html C / ECS Hardware and the Graphics Library / Genlock Extensions Hardware_Manual_guide/node00AA.html C / ECS Hardware and the Graphics Library / Big Blits Hardware_Manual_guide/node00AB.html C / ECS Hardware and the Graphics Library / Other ECS Modifications Hardware_Manual_guide/node00AC.html C / ECS Hardware and Graphics Library / Interpretational Differences Hardware_Manual_guide/node00AD.html C Enhanced Chip Set / ECS Registers Hardware_Manual_guide/node00AE.html Amiga® Hardware Reference Manual: 4 Sprite Hardware Hardware_Manual_guide/node00AF.html 4 Sprite Hardware / What are Sprites? Hardware_Manual_guide/node00B0.html 4 Sprite Hardware / Forming a Sprite Hardware_Manual_guide/node00B1.html 4 / Forming a Sprite / Screen Position Hardware_Manual_guide/node00B2.html 4 / / Screen Position / Horizontal Position Hardware_Manual_guide/node00B3.html 4 / / Screen Position / Vertical Position Hardware_Manual_guide/node00B4.html 4 / / Screen Position / Clipped Sprites Hardware_Manual_guide/node00B5.html 4 / Forming a Sprite / Size of Sprites Hardware_Manual_guide/node00B6.html 4 / Forming a Sprite / Shape of Sprites Hardware_Manual_guide/node00B7.html 4 / Forming a Sprite / Sprite Color Hardware_Manual_guide/node00B8.html 4 / Forming a Sprite / Designing a Sprite Hardware_Manual_guide/node00B9.html 4 / Forming a Sprite / Building the Data Structure Hardware_Manual_guide/node00BA.html 4 / / Building the Data Structure / Sprite Control Word 1 : SPRxPOS Hardware_Manual_guide/node00BB.html 4 / / Building the Data Structure / Sprite Control Word 2 : SPRxCTL Hardware_Manual_guide/node00BC.html 4 / / Building the Data Structure / Sprite Color Descriptor Words Hardware_Manual_guide/node00BD.html 4 / / Building the Data Structure / End-of-data Words Hardware_Manual_guide/node00BE.html 4 Sprite Hardware / Displaying a Sprite Hardware_Manual_guide/node00BF.html 4 / Displaying Sprite / Selecting DMA Channel and Setting Pointers Hardware_Manual_guide/node00C0.html 4 / Displaying a Sprite / Resetting the Address Pointers Hardware_Manual_guide/node00C1.html 4 Sprite Hardware / Moving a Sprite Hardware_Manual_guide/node00C2.html 4 Sprite Hardware / Creating Additional Sprites Hardware_Manual_guide/node00C3.html 4 / Creating Additional Sprites / Sprite Priority Hardware_Manual_guide/node00C4.html 4 Sprite Hardware / Reusing Sprite DMA Channels Hardware_Manual_guide/node00C5.html 4 Sprite Hardware / Overlapped Sprites Hardware_Manual_guide/node00C6.html 4 Sprite Hardware / Attached Sprites Hardware_Manual_guide/node00C7.html 4 Sprite Hardware / Manual Mode Hardware_Manual_guide/node00C8.html 4 Sprite Hardware / Sprite Hardware Details Hardware_Manual_guide/node00C9.html 4 Sprite Hardware / Summary of Sprite Registers Hardware_Manual_guide/node00CA.html 4 / Summary of Sprite Registers / Pointers Hardware_Manual_guide/node00CB.html 4 / / Pointers / SPR0PTH and SPR0PTL Hardware_Manual_guide/node00CC.html 4 / Summary of Sprite Registers / Control Registers Hardware_Manual_guide/node00CD.html 4 / / Control Registers / SPR0POS Hardware_Manual_guide/node00CE.html 4 / / Control Registers / SPR0CTL Hardware_Manual_guide/node00CF.html 4 / Summary of Sprite Registers / Data Registers Hardware_Manual_guide/node00D0.html 4 Sprite Hardware / Summary of Sprite Color Registers Hardware_Manual_guide/node00D1.html 4 / Color Registers / Interactions Among Sprites and Other Objects Hardware_Manual_guide/node00D2.html Amiga® Hardware Reference Manual: D System Memory Maps Hardware_Manual_guide/node00D3.html D System Memory Maps / A1000, A500 and A2000 Memory Map Hardware_Manual_guide/node00D4.html D System Memory Maps / A3000 Memory Map Hardware_Manual_guide/node00D5.html Amiga® Hardware Reference Manual: 5 Audio Hardware Hardware_Manual_guide/node00D6.html 5 Audio Hardware / Introducing Sound Generation Hardware_Manual_guide/node00D7.html 5 / Introducing Sound Generation / The Amiga Sound Hardware Hardware_Manual_guide/node00D8.html 5 Audio Hardware / Forming and Playing a Sound Hardware_Manual_guide/node00D9.html 5 / Forming and Playing a Sound / Deciding Which Channel to Use Hardware_Manual_guide/node00DA.html 5 / Forming and Playing a Sound / Creating the Waveform Data Hardware_Manual_guide/node00DB.html 5 / Forming and Playing a Sound / Telling the System About the Data Hardware_Manual_guide/node00DC.html 5 / Forming and Playing a Sound / Selecting the Volume Hardware_Manual_guide/node00DD.html 5 / Forming and Playing a Sound / Selecting the Data Output Rate Hardware_Manual_guide/node00DE.html 5 / / Data Output Rate / Limitations on Selection of Sampling Period Hardware_Manual_guide/node00DF.html 5 / / Selecting the Data Output Rate / Specifying the Period Value Hardware_Manual_guide/node00E0.html 5 / Forming and Playing a Sound / Playing the Waveform Hardware_Manual_guide/node00E1.html 5 / Forming and Playing a Sound / Stopping the Audio Dma Hardware_Manual_guide/node00E2.html 5 / Forming and Playing a Sound / Audio Summary Hardware_Manual_guide/node00E3.html 5 Audio Hardware / Producing Complex Sounds Hardware_Manual_guide/node00E4.html 5 / Producing Complex Sounds / Joining Tones Hardware_Manual_guide/node00E5.html 5 / / Joining Tones / Audio DMA Example Hardware_Manual_guide/node00E6.html 5 / Producing Complex Sounds / Playing Multiple Tones at the Same Time Hardware_Manual_guide/node00E7.html 5 / Producing Complex Sounds / Modulating Sound Hardware_Manual_guide/node00E8.html 5 Audio Hardware / Producing High-quality Sound Hardware_Manual_guide/node00E9.html 5 / Producing High-quality Sound / Making Waveform Transitions Hardware_Manual_guide/node00EA.html 5 / Producing High-quality Sound / Sampling Rate Hardware_Manual_guide/node00EB.html 5 / Producing High-quality Sound / Efficiency Hardware_Manual_guide/node00EC.html 5 / Producing High-quality Sound / Noise Reduction Hardware_Manual_guide/node00ED.html 5 / Producing High-quality Sound / Aliasing Distortion Hardware_Manual_guide/node00EE.html 5 / Producing High-quality Sound / Low-Pass Filter Hardware_Manual_guide/node00EF.html 5 Audio Hardware / Using Direct (Non-DMA) Audio Output Hardware_Manual_guide/node00F0.html 5 Audio Hardware / The Equal-tempered Musical Scale Hardware_Manual_guide/node00F1.html 5 Audio Hardware / Decibel Values for Volume Ranges Hardware_Manual_guide/node00F2.html 5 Audio Hardware / The Audio State Machine Hardware_Manual_guide/node00F3.html Amiga® Hardware Reference Manual: E I/O Connectors And Interfaces Hardware_Manual_guide/node00F4.html E I/O Connectors And Interfaces / Part 1 - Amiga I/O Connector Pins Hardware_Manual_guide/node00F5.html E / Amiga I/O Connector Pins / RS232 and MIDI Port Hardware_Manual_guide/node00F6.html E / Amiga I/O Connector Pins / Parallel Port Hardware_Manual_guide/node00F7.html E / Amiga I/O Connector Pins / Keyboard Hardware_Manual_guide/node00F8.html E / Amiga I/O Connector Pins / Video Hardware_Manual_guide/node00F9.html E / Amiga I/O Connector Pins / Video Display Enhancer Hardware_Manual_guide/node00FA.html E / Amiga I/O Connector Pins / RF Monitor Hardware_Manual_guide/node00FB.html E / Amiga I/O Connector Pins / External Disk Hardware_Manual_guide/node00FC.html E / Amiga I/O Connector Pins / External SCSI Disk Hardware_Manual_guide/node00FD.html E / Amiga I/O Connector Pins / RAMEX Hardware_Manual_guide/node00FE.html E / Amiga I/O Connector Pins / Expansion Hardware_Manual_guide/node00FF.html E / Amiga I/O Connector Pins / Joy Sticks Hardware_Manual_guide/node0100.html E I/O Connectors And Interfaces / Explanation of Amiga I/O Connectors Hardware_Manual_guide/node0101.html E / Explanation of I/O Connectors / Parallel Interface Specification Hardware_Manual_guide/node0102.html E / / Parallel Interface Specification / Pin Assignment (J8) Hardware_Manual_guide/node0103.html E / / Parallel Interface Specification / Interface Timing Output Cycle Hardware_Manual_guide/node0104.html E / / Parallel Interface Specification / Interface Timing, Input Cycle Hardware_Manual_guide/node0105.html E / Explanation of I/O Connectors / Serial Interface Specification Hardware_Manual_guide/node0106.html E / / Serial Interface Specification / Pin Assignment (J6) Hardware_Manual_guide/node0107.html E / / Serial Interface Specification / Timing Hardware_Manual_guide/node0108.html E / / Serial Interface Specification / Electrical Characteristics Hardware_Manual_guide/node0109.html E / Explanation of I/O Connectors / Game Controller Interface Spec Hardware_Manual_guide/node010A.html E / / Game Controller Interface Specification / Mouse/Trackball Hardware_Manual_guide/node010B.html E / / Game Controller Interface Specification / Digital Joysticks Hardware_Manual_guide/node010C.html E / / Game Controller Interface Specification / Fire Buttons Hardware_Manual_guide/node010D.html E / / Game Controller Interface Spec / Proportional Controllers Hardware_Manual_guide/node010E.html E / / Game Controller Interface Specification / Light Pen Hardware_Manual_guide/node010F.html E / Explanation of Connectors / External Disk Interface Specification Hardware_Manual_guide/node0110.html E / / External Disk Interface Specification / Pin Assignment (J7) Hardware_Manual_guide/node0111.html E / / External Disk Interface Specification / Identification Mode Hardware_Manual_guide/node0112.html E / / External Disk Interface Specification / Limitations Hardware_Manual_guide/node0113.html E I/O Connectors And Interfaces / Part 3 - Internal Connectors Hardware_Manual_guide/node0114.html E / Internal Connectors / Internal Disk Hardware_Manual_guide/node0115.html E / Internal Connectors / Internal Disk Power Hardware_Manual_guide/node0116.html E / Internal Connectors / Internal SCSI Disk Hardware_Manual_guide/node0117.html E Connectors And Interfaces / Port Signal Assignments for 8520 CIAS Hardware_Manual_guide/node0118.html Amiga® Hardware Reference Manual: 6 Blitter Hardware Hardware_Manual_guide/node0119.html 6 Blitter Hardware / What is the Blitter? Hardware_Manual_guide/node011A.html 6 Blitter Hardware / Memory Layout Hardware_Manual_guide/node011B.html 6 Blitter Hardware / DMA Channels Hardware_Manual_guide/node011C.html 6 Blitter Hardware / Function Generator Hardware_Manual_guide/node011D.html 6 / Function Generator / Designing the LF Control Byte with Minterms Hardware_Manual_guide/node011E.html 6 / Function Generator / Designing LF Control Byte with Venn Diagrams Hardware_Manual_guide/node011F.html 6 Blitter Hardware / Shifts and Masks Hardware_Manual_guide/node0120.html 6 Blitter Hardware / Descending Mode Hardware_Manual_guide/node0121.html 6 Blitter Hardware / Copying Arbitrary Regions Hardware_Manual_guide/node0122.html 6 Blitter Hardware / Area Fill Mode Hardware_Manual_guide/node0123.html 6 Blitter Hardware / Blitter Done Flag Hardware_Manual_guide/node0124.html 6 / Blitter Done Flag / Multitasking and the Blitter Hardware_Manual_guide/node0125.html 6 Blitter Hardware / Interrupt Flag Hardware_Manual_guide/node0126.html 6 Blitter Hardware / Zero Flag Hardware_Manual_guide/node0127.html 6 Blitter Hardware / Pipeline Register Hardware_Manual_guide/node0128.html 6 Blitter Hardware / Line Mode Hardware_Manual_guide/node0129.html 6 / Line Mode / Register Summary for Line Mode Hardware_Manual_guide/node012A.html 6 Blitter Hardware / Blitter Speed Hardware_Manual_guide/node012B.html 6 Blitter Hardware / Blitter Operations and System DMA Hardware_Manual_guide/node012C.html 6 Blitter Hardware / Blitter Block Diagram Hardware_Manual_guide/node012D.html 6 Blitter Hardware / Blitter Key Points Hardware_Manual_guide/node012E.html Amiga® Hardware Reference Manual: F 8520 Complex Interface Adapters Hardware_Manual_guide/node012F.html F 8520 Complex Interface Adapters / Chip Register Map Hardware_Manual_guide/node0130.html F 8520 Complex Interface Adapters / Register Functional Description Hardware_Manual_guide/node0131.html F / Register Functional Description / I/O Ports (PRA, PRB, DDRA, DDRB) Hardware_Manual_guide/node0132.html F / Register Functional Description / Handshaking Hardware_Manual_guide/node0133.html F / Register Functional Description / Interval Timers (Timer A, B) Hardware_Manual_guide/node0134.html F / / Interval Timers (Timer A, Timer B) / Start/Stop Hardware_Manual_guide/node0135.html F / / Interval Timers (Timer A, Timer B) / PB on/off Hardware_Manual_guide/node0136.html F / / Interval Timers (Timer A, Timer B) / Toggle/pulse Hardware_Manual_guide/node0137.html F / / Interval Timers (Timer A, Timer B) / One-shot/continuous Hardware_Manual_guide/node0138.html F / / Interval Timers (Timer A, Timer B) / Force load Hardware_Manual_guide/node0139.html F / Register Functional Description / Input Modes Hardware_Manual_guide/node013A.html F / Register Functional Description / Bit Names on Read-Register Hardware_Manual_guide/node013B.html F / Register Functional Description / Bit Names on Write-Register Hardware_Manual_guide/node013C.html F 8520 Complex Interface Adapters / Time of Day Clock Hardware_Manual_guide/node013D.html F / Time of Day Clock / Bit Names for Write Time/Alarm or Read Time Hardware_Manual_guide/node013E.html F 8520 Complex Interface Adapters / Serial Shift Register (SDR) Hardware_Manual_guide/node013F.html F / Serial Shift Register (SDR) / Input Mode Hardware_Manual_guide/node0140.html F / Serial Shift Register (SDR) / Output Mode Hardware_Manual_guide/node0141.html F / Serial Shift Register (SDR) / Bidirectional Feature Hardware_Manual_guide/node0142.html F 8520 Complex Interface Adapters / Interrupt Control Register (ICR) Hardware_Manual_guide/node0143.html F / Interrupt Control Register (ICR) / Read Interrupt Control Register Hardware_Manual_guide/node0144.html F / Interrupt Control Register (ICR) / Write Interrupt Control Mask Hardware_Manual_guide/node0145.html F 8520 Complex Interface Adapters / Control Registers Hardware_Manual_guide/node0146.html F / Control Registers / Control Register A Hardware_Manual_guide/node0147.html F / Control Registers / Bitmap of Register CRA Hardware_Manual_guide/node0148.html F / Control Registers / Control Register B Hardware_Manual_guide/node0149.html F / Control Registers / Bitmap Of Register CRB Hardware_Manual_guide/node014A.html F 8520 Complex Interface Adapters / Port Signal Assignments Hardware_Manual_guide/node014B.html F 8520 Complex Interface Adapters / Hardware Connection Details Hardware_Manual_guide/node014C.html F / Hardware Connection Details / Interface Signals Hardware_Manual_guide/node014D.html F / / Interface Signals / Clock input Hardware_Manual_guide/node014E.html F / / Interface Signals / CS - chip-select input Hardware_Manual_guide/node014F.html F / / Interface Signals / R/W - read/write input Hardware_Manual_guide/node0150.html F / / Interface Signals / RS3-RS0 - address inputs Hardware_Manual_guide/node0151.html F / / Interface Signals / DB7-DB0 - data bus inputs/outputs Hardware_Manual_guide/node0152.html F / / Interface Signals / IRQ - interrupt request output Hardware_Manual_guide/node0153.html F / / Interface Signals / RES - reset input Hardware_Manual_guide/node0154.html Amiga® Hardware Reference Manual: 7 System Control Hardware Hardware_Manual_guide/node0155.html 7 System Control Hardware / Video Priorities Hardware_Manual_guide/node0156.html 7 / Video Priorities / Fixed Sprite Priorities Hardware_Manual_guide/node0157.html 7 / Video Priorities / How Sprites are Grouped Hardware_Manual_guide/node0158.html 7 / Video Priorities / Understanding Video Priorities Hardware_Manual_guide/node0159.html 7 / Video Priorities / Setting the Priority Control Register Hardware_Manual_guide/node015A.html 7 System Control Hardware / Collision Detection Hardware_Manual_guide/node015B.html 7 / Collision Detection / How Collisions are Determined Hardware_Manual_guide/node015C.html 7 / Collision Detection / How To Interpret the Collision Data Hardware_Manual_guide/node015D.html 7 / Collision Detection / How Collision Detection is Controlled Hardware_Manual_guide/node015E.html 7 System Control Hardware / Beam Position Detection Hardware_Manual_guide/node015F.html 7 / Beam Position Detection / Using the Beam Position Counter Hardware_Manual_guide/node0160.html 7 System Control Hardware / Interrupts Hardware_Manual_guide/node0161.html 7 / Interrupts / Nonmaskable Interrupt Hardware_Manual_guide/node0162.html 7 / Interrupts / Maskable Interrupts Hardware_Manual_guide/node0163.html 7 / Interrupts / User Interface to the Interrupt System Hardware_Manual_guide/node0164.html 7 / Interrupts / Interrupt Control Registers Hardware_Manual_guide/node0165.html 7 / Interrupts / Setting and Clearing Bits Hardware_Manual_guide/node0166.html 7 / / Setting and Clearing Bits / Set and Clear Hardware_Manual_guide/node0167.html 7 / / Setting and Clearing Bits / Master Interrupt Enable Hardware_Manual_guide/node0168.html 7 / / Setting and Clearing Bits / External Interrupts Hardware_Manual_guide/node0169.html 7 / / Setting and Clearing Bits / Vertical Blanking Interrupt Hardware_Manual_guide/node016A.html 7 / / Setting and Clearing Bits / Copper Interrupt Hardware_Manual_guide/node016B.html 7 / / Setting and Clearing Bits / Audio Interrupts Hardware_Manual_guide/node016C.html 7 / / Setting and Clearing Bits / Blitter Interrupt Hardware_Manual_guide/node016D.html 7 / / Setting and Clearing Bits / Disk Interrupt Hardware_Manual_guide/node016E.html 7 / / Setting and Clearing Bits / Serial Port Interrupts Hardware_Manual_guide/node016F.html 7 / / Setting and Clearing Bits / Figure 7-4: Interrupt Priorities Hardware_Manual_guide/node0170.html 7 System Control Hardware / DMA Control Hardware_Manual_guide/node0171.html 7 System Control Hardware / Reset and Early Startup Operation Hardware_Manual_guide/node0172.html Amiga® Hardware Reference Manual: G Keyboard Interface Hardware_Manual_guide/node0173.html G Keyboard Interface / Keyboard Communications Hardware_Manual_guide/node0174.html G Keyboard Interface / Keycodes Hardware_Manual_guide/node0175.html G Keyboard Interface / Caps Lock Key Hardware_Manual_guide/node0176.html G Keyboard Interface / Out-of-Sync Condition Hardware_Manual_guide/node0177.html G Keyboard Interface / Power-Up Sequence Hardware_Manual_guide/node0178.html G Keyboard Interface / Reset Warning Hardware_Manual_guide/node0179.html G Keyboard Interface / Hard Reset Hardware_Manual_guide/node017A.html G Keyboard Interface / Matrix Table Hardware_Manual_guide/node017B.html G Keyboard Interface / Special Codes Hardware_Manual_guide/node017C.html Amiga® Hardware Reference Manual: 8 Interface Hardware Hardware_Manual_guide/node017D.html 8 Interface Hardware / Controller Port Interface Hardware_Manual_guide/node017E.html 8 / Controller Port Interface / Registers used with Controller Port Hardware_Manual_guide/node017F.html 8 / Controller Port Interface / Reading Mouse/Trackball Controllers Hardware_Manual_guide/node0180.html 8 / / Reading Mouse/Trackball Controllers / Reading the Counters Hardware_Manual_guide/node0181.html 8 / / Reading Mouse/Trackball Controllers / Counter Limitations Hardware_Manual_guide/node0182.html 8 / / Reading Mouse/Trackball Controllers / Mouse Buttons Hardware_Manual_guide/node0183.html 8 / Controller Port Interface / Reading Digital Joystick Controllers Hardware_Manual_guide/node0184.html 8 / Controller Port Interface / Reading Proportional Controllers Hardware_Manual_guide/node0185.html 8 / / Reading Controllers / Reading Proportional Controller Buttons Hardware_Manual_guide/node0186.html 8 / / Reading Controllers / Interpreting Controller Position Hardware_Manual_guide/node0187.html 8 / / Reading Controllers / Proportional Controller Registers Hardware_Manual_guide/node0188.html 8 / / Reading Proportional Controllers / Potentiometer Specifications Hardware_Manual_guide/node0189.html 8 / Controller Port Interface / Reading A Light Pen Hardware_Manual_guide/node018A.html 8 / / Reading A Light Pen / Reading the Light Pen Registers Hardware_Manual_guide/node018B.html 8 / Controller Port Interface / Digital I/O On The Controller Port Hardware_Manual_guide/node018C.html 8 Interface Hardware / Floppy Disk Controller Hardware_Manual_guide/node018D.html 8 / Floppy Disk Controller / Registers Used by the Disk Subsystem Hardware_Manual_guide/node018E.html 8 / Floppy Disk Controller / Disk Subsystem Timing Hardware_Manual_guide/node018F.html 8 / / Disk Timing / CIAAPRA/PRB - Disk selection, control and sensing Hardware_Manual_guide/node0190.html 8 / / Disk Subsystem Timing / Disk DMA Channel Control Hardware_Manual_guide/node0191.html 8 / / Disk Subsystem Timing / DSKPTH - Pointer to Data Hardware_Manual_guide/node0192.html 8 / / Disk Subsystem Timing / DSKLEN - Length, Direction, DMA Enable Hardware_Manual_guide/node0193.html 8 / / Timing / DSKBYTR - Disk Data Byte and Status Read (read-only) Hardware_Manual_guide/node0194.html 8 / / Timing / ADKCON and ADKCONR - Audio and Disk Control Register Hardware_Manual_guide/node0195.html 8 / / Disk Subsystem Timing / DSKSYNC - Disk Input Synchronizer Hardware_Manual_guide/node0196.html 8 / Floppy Disk Controller / Disk Interrupts Hardware_Manual_guide/node0197.html 8 Interface Hardware / The Keyboard Hardware_Manual_guide/node0198.html 8 / The Keyboard / How the Keyboard Data is Received Hardware_Manual_guide/node0199.html 8 / The Keyboard / Type of Data Received Hardware_Manual_guide/node019A.html 8 / / Type of Data Received / RAW Keycodes -> 00-3F hex Hardware_Manual_guide/node019B.html 8 / / Type Of Data Received / RAW Keycodes -> 40-5F hex Hardware_Manual_guide/node019C.html 8 / / Type Of Data Received / RAW Keycodes -> 60-67 hex Hardware_Manual_guide/node019D.html 8 / / Type Of Data Received / F0-FF hex Hardware_Manual_guide/node019E.html 8 / The Keyboard / Limitations Of The Keyboard Hardware_Manual_guide/node019F.html 8 Interface Hardware / Serial I/O Interface Hardware_Manual_guide/node01A0.html 8 / Serial I/O Interface / Introduction To Serial Circuitry Hardware_Manual_guide/node01A1.html 8 / Serial I/O Interface / Setting The Baud Rate Hardware_Manual_guide/node01A2.html 8 / Serial I/O Interface / Setting The Receive Mode Hardware_Manual_guide/node01A3.html 8 / Serial I/O Interface / Contents Of The Receive Data Register Hardware_Manual_guide/node01A4.html 8 / Serial I/O Interface / How Output Data Is Transmitted Hardware_Manual_guide/node01A5.html 8 / Serial I/O Interface / Specifying The Register Contents Hardware_Manual_guide/node01A6.html 8 Interface Hardware / Parallel I/O Interface Hardware_Manual_guide/node01A7.html 8 Interface Hardware / Display Output Connections Hardware_Manual_guide/node01A8.html Amiga® Hardware Reference Manual: H External Disk Connector Interface Hardware_Manual_guide/node01A9.html H External Disk Connector Interface / Summary Table Hardware_Manual_guide/node01AA.html H External Disk Connector Interface / Signals When Driving a Disk Hardware_Manual_guide/node01AB.html H External Disk Connector Interface / Device I.D. Hardware_Manual_guide/node01AC.html Hard_examples/hw_examples.i Hardware_Manual_guide/node01AD.html Amiga® Hardware Reference Manual: List of Figures Hardware_Manual_guide/node01AE.html Amiga® Hardware Reference Manual: Glossary Hardware_Manual_guide/node01AF.html Glossary / address Hardware_Manual_guide/node01B0.html Glossary / Agnus Hardware_Manual_guide/node01B1.html Glossary / aliasing distortion Hardware_Manual_guide/node01B2.html Glossary / Alt keys Hardware_Manual_guide/node01B3.html Glossary / Amiga keys Hardware_Manual_guide/node01B4.html Glossary / AmigaDOS Hardware_Manual_guide/node01B5.html Glossary / amplitude Hardware_Manual_guide/node01B6.html Glossary / amplitude modulation Hardware_Manual_guide/node01B7.html Glossary / arbitration Hardware_Manual_guide/node01B8.html Glossary / asserted Hardware_Manual_guide/node01B9.html Glossary / atomic cycle Hardware_Manual_guide/node01BA.html Glossary / attach mode Hardware_Manual_guide/node01BB.html Glossary / AUTOCONFIG(TM) Hardware_Manual_guide/node01BC.html Glossary / automatic mode Hardware_Manual_guide/node01BD.html Glossary / backplane Hardware_Manual_guide/node01BE.html Glossary / barrel shifter Hardware_Manual_guide/node01BF.html Glossary / baud rate Hardware_Manual_guide/node01C0.html Glossary / beam counters Hardware_Manual_guide/node01C1.html Glossary / bitmap Hardware_Manual_guide/node01C2.html Glossary / bitplane Hardware_Manual_guide/node01C3.html Glossary / bitplane animation Hardware_Manual_guide/node01C4.html Glossary / blanking interval Hardware_Manual_guide/node01C5.html Glossary / blitter Hardware_Manual_guide/node01C6.html Glossary / burst Hardware_Manual_guide/node01C7.html Glossary / bus cycle Hardware_Manual_guide/node01C8.html Glossary / bus hogging Hardware_Manual_guide/node01C9.html Glossary / bus starvation Hardware_Manual_guide/node01CA.html Glossary / byte Hardware_Manual_guide/node01CB.html Glossary / Chip RAM Hardware_Manual_guide/node01CC.html Glossary / clear Hardware_Manual_guide/node01CD.html Glossary / clipping Hardware_Manual_guide/node01CE.html Glossary / clock Hardware_Manual_guide/node01CF.html Glossary / collision Hardware_Manual_guide/node01D0.html Glossary / color descriptor words Hardware_Manual_guide/node01D1.html Glossary / color indirection Hardware_Manual_guide/node01D2.html Glossary / color register Hardware_Manual_guide/node01D3.html Glossary / color table Hardware_Manual_guide/node01D4.html Glossary / Command Line Interface (Shell or CLI) Hardware_Manual_guide/node01D5.html Glossary / composite video Hardware_Manual_guide/node01D6.html Glossary / controller Hardware_Manual_guide/node01D7.html Glossary / coordinates Hardware_Manual_guide/node01D8.html Glossary / copper Hardware_Manual_guide/node01D9.html Glossary / coprocessor Hardware_Manual_guide/node01DA.html Glossary / cursor keys Hardware_Manual_guide/node01DB.html Glossary / cycle strobe Hardware_Manual_guide/node01DC.html Glossary / data Hardware_Manual_guide/node01DD.html Glossary / data fetch Hardware_Manual_guide/node01DE.html Glossary / delay Hardware_Manual_guide/node01DF.html Glossary / Denise Hardware_Manual_guide/node01E0.html Glossary / depth Hardware_Manual_guide/node01E1.html Glossary / device Hardware_Manual_guide/node01E2.html Glossary / Digital-to-Analog Converter (DAC) Hardware_Manual_guide/node01E3.html Glossary / Direct Memory Access (DMA) Hardware_Manual_guide/node01E4.html Glossary / display field Hardware_Manual_guide/node01E5.html Glossary / display mode Hardware_Manual_guide/node01E6.html Glossary / display time Hardware_Manual_guide/node01E7.html Glossary / display window Hardware_Manual_guide/node01E8.html Glossary / DMA latency Hardware_Manual_guide/node01E9.html Glossary / dual-playfield mode Hardware_Manual_guide/node01EA.html Glossary / Enhanced Chip Set (ECS) Hardware_Manual_guide/node01EB.html Glossary / equal-tempered scale Hardware_Manual_guide/node01EC.html Glossary / Exec Hardware_Manual_guide/node01ED.html Glossary / Fast RAM Hardware_Manual_guide/node01EE.html Glossary / font Hardware_Manual_guide/node01EF.html Glossary / frequency Hardware_Manual_guide/node01F0.html Glossary / frequency modulation Hardware_Manual_guide/node01F1.html Glossary / genlock Hardware_Manual_guide/node01F2.html Glossary / grant Hardware_Manual_guide/node01F3.html Glossary / hidden cycles Hardware_Manual_guide/node01F4.html Glossary / high Hardware_Manual_guide/node01F5.html Glossary / high resolution (Hires) Hardware_Manual_guide/node01F6.html Glossary / hold-and-modify (HAM) Hardware_Manual_guide/node01F7.html Glossary / interlace mode Hardware_Manual_guide/node01F8.html Glossary / interrupt Hardware_Manual_guide/node01F9.html Glossary / joystick Hardware_Manual_guide/node01FA.html Glossary / light pen Hardware_Manual_guide/node01FB.html Glossary / local bus Hardware_Manual_guide/node01FC.html Glossary / longword Hardware_Manual_guide/node01FD.html Glossary / low Hardware_Manual_guide/node01FE.html Glossary / low resolution (Lores) Hardware_Manual_guide/node01FF.html Glossary / manual mode Hardware_Manual_guide/node0200.html Glossary / master Hardware_Manual_guide/node0201.html Glossary / MIDI Hardware_Manual_guide/node0202.html Glossary / microsecond (us) Hardware_Manual_guide/node0203.html Glossary / millisecond (ms) Hardware_Manual_guide/node0204.html Glossary / minterm Hardware_Manual_guide/node0205.html Glossary / modulo Hardware_Manual_guide/node0206.html Glossary / motherboard Hardware_Manual_guide/node0207.html Glossary / mouse Hardware_Manual_guide/node0208.html Glossary / multitasking Hardware_Manual_guide/node0209.html Glossary / nanosecond (ns) Hardware_Manual_guide/node020A.html Glossary / negated Hardware_Manual_guide/node020B.html Glossary / non-interlaced mode Hardware_Manual_guide/node020C.html Glossary / NTSC Hardware_Manual_guide/node020D.html Glossary / nybble Hardware_Manual_guide/node020E.html Glossary / overscan area Hardware_Manual_guide/node020F.html Glossary / paddle controller Hardware_Manual_guide/node0210.html Glossary / PAL Hardware_Manual_guide/node0211.html Glossary / parallel port Hardware_Manual_guide/node0212.html Glossary / Paula Hardware_Manual_guide/node0213.html Glossary / PIC Hardware_Manual_guide/node0214.html Glossary / pitch Hardware_Manual_guide/node0215.html Glossary / pixels Hardware_Manual_guide/node0216.html Glossary / playfield Hardware_Manual_guide/node0217.html Glossary / playfield object Hardware_Manual_guide/node0218.html Glossary / pointer register Hardware_Manual_guide/node0219.html Glossary / polarity Hardware_Manual_guide/node021A.html Glossary / potentiometer Hardware_Manual_guide/node021B.html Glossary / quantization noise Hardware_Manual_guide/node021C.html Glossary / RAM Hardware_Manual_guide/node021D.html Glossary / raster Hardware_Manual_guide/node021E.html Glossary / read-only Hardware_Manual_guide/node021F.html Glossary / request Hardware_Manual_guide/node0220.html Glossary / resolution Hardware_Manual_guide/node0221.html Glossary / ROM Hardware_Manual_guide/node0222.html Glossary / sample Hardware_Manual_guide/node0223.html Glossary / sampling rate Hardware_Manual_guide/node0224.html Glossary / sampling period Hardware_Manual_guide/node0225.html Glossary / scroll Hardware_Manual_guide/node0226.html Glossary / SCSI Hardware_Manual_guide/node0227.html Glossary / serial port Hardware_Manual_guide/node0228.html Glossary / set Hardware_Manual_guide/node0229.html Glossary / Shell Hardware_Manual_guide/node022A.html Glossary / slave Hardware_Manual_guide/node022B.html Glossary / slot Hardware_Manual_guide/node022C.html Glossary / sprite Hardware_Manual_guide/node022D.html Glossary / strobe address Hardware_Manual_guide/node022E.html Glossary / task Hardware_Manual_guide/node022F.html Glossary / termination Hardware_Manual_guide/node0230.html Glossary / timbre Hardware_Manual_guide/node0231.html Glossary / timeout Hardware_Manual_guide/node0232.html Glossary / transparent Hardware_Manual_guide/node0233.html Glossary / tri-state Hardware_Manual_guide/node0234.html Glossary / UART Hardware_Manual_guide/node0235.html Glossary / video priority Hardware_Manual_guide/node0236.html Glossary / video display Hardware_Manual_guide/node0237.html Glossary / write-only Hardware_Manual_guide/node0238.html Glossary / word Hardware_Manual_guide/node0239.html Glossary / Zorro Hardware_Manual_guide/node023A.html Amiga® Hardware Reference Manual: J Custom Chip Pin Allocation List Hardware_Manual_guide/node023B.html J Custom Chip Pin Allocation List / Original Agnus Pin Assignment Hardware_Manual_guide/node023C.html J Custom Chip Pin Allocation List / Denise Pin Assignment Hardware_Manual_guide/node023D.html J Custom Chip Pin Allocation List / Paula Pin Assignment Hardware_Manual_guide/node023E.html J Custom Chip Pin Allocation List / Fat Agnus Pin Assignment Hardware_Manual_guide/node023F.html Amiga® Hardware Reference Manual: List of Tables Hardware_Manual_guide/node0240.html Amiga® Hardware Reference Manual: Index Hardware_Manual_guide/node0241.html Numbers Index Hardware_Manual_guide/node0242.html 68000 Index Hardware_Manual_guide/node0243.html 680x0 Index Hardware_Manual_guide/node0244.html 8520 Index Hardware_Manual_guide/node0245.html A Index Hardware_Manual_guide/node0246.html A1000 Index Hardware_Manual_guide/node0247.html A3000 Index Hardware_Manual_guide/node0248.html ADKCON Index Hardware_Manual_guide/node0249.html Agnus Index Hardware_Manual_guide/node024A.html Audio Index Hardware_Manual_guide/node024B.html B Index Hardware_Manual_guide/node024C.html Beam position Index Hardware_Manual_guide/node024D.html Bitplanes Index Hardware_Manual_guide/node024E.html Blitter Index Hardware_Manual_guide/node024F.html BLTCON0 Index Hardware_Manual_guide/node0250.html BLTCON1 Index Hardware_Manual_guide/node0251.html BPLCON0 Index Hardware_Manual_guide/node0252.html BPLCON2 Index Hardware_Manual_guide/node0253.html C Index Hardware_Manual_guide/node0254.html CIAAPRA Index Hardware_Manual_guide/node0255.html Clock Index Hardware_Manual_guide/node0256.html Collision Index Hardware_Manual_guide/node0257.html Color Index Hardware_Manual_guide/node0258.html Color registers Index Hardware_Manual_guide/node0259.html Color selection Index Hardware_Manual_guide/node025A.html Control register Index Hardware_Manual_guide/node025B.html Controller Port Index Hardware_Manual_guide/node025C.html Controllers Index Hardware_Manual_guide/node025D.html Copper Index Hardware_Manual_guide/node025E.html Custom Chips Index Hardware_Manual_guide/node025F.html D Index Hardware_Manual_guide/node0260.html Data-fetch Index Hardware_Manual_guide/node0261.html Disk Index Hardware_Manual_guide/node0262.html Display window Index Hardware_Manual_guide/node0263.html DMA Index Hardware_Manual_guide/node0264.html DMACON Index Hardware_Manual_guide/node0265.html Dual Playfield Index Hardware_Manual_guide/node0266.html E,F,G,H Index Hardware_Manual_guide/node0267.html Enhanced Chip Set Index Hardware_Manual_guide/node0268.html Genlock Index Hardware_Manual_guide/node0269.html Hardware Connection Index Hardware_Manual_guide/node026A.html High resolution Index Hardware_Manual_guide/node026B.html I,J,K Index Hardware_Manual_guide/node026C.html Interlaced mode Index Hardware_Manual_guide/node026D.html Interrupt Index Hardware_Manual_guide/node026E.html Interrupt Control Register Index Hardware_Manual_guide/node026F.html JOY0DAT/JOY1DAT Index Hardware_Manual_guide/node0270.html Joystick Index Hardware_Manual_guide/node0271.html Keyboard Index Hardware_Manual_guide/node0272.html L,M,N,O Index Hardware_Manual_guide/node0273.html Light Pen Index Hardware_Manual_guide/node0274.html Line Drawing Index Hardware_Manual_guide/node0275.html Memory allocation Index Hardware_Manual_guide/node0276.html Modulo Index Hardware_Manual_guide/node0277.html NTSC Index Hardware_Manual_guide/node0278.html P Index Hardware_Manual_guide/node0279.html PAL Index Hardware_Manual_guide/node027A.html Parallel Port Index Hardware_Manual_guide/node027B.html Playfields Index Hardware_Manual_guide/node027C.html Ports Index Hardware_Manual_guide/node027D.html POTGO / POTINP Index Hardware_Manual_guide/node027E.html Priority Index Hardware_Manual_guide/node027F.html R,S Index Hardware_Manual_guide/node0280.html RAM Index Hardware_Manual_guide/node0281.html Scrolling Index Hardware_Manual_guide/node0282.html Serial Port Index Hardware_Manual_guide/node0283.html Serial Shift Register Index Hardware_Manual_guide/node0284.html Sprites Index Hardware_Manual_guide/node0285.html T,U,V,W,Z Index Hardware_Manual_guide/node0286.html Trackball Index Hardware_Manual_guide/node0287.html VHPOSR Index Hardware_Manual_guide/node0288.html Video Index Hardware_Manual_guide/node0289.html VPOSR Index Hardware_Manual_guide/node028A.html Zorro Expansion Bus Index Hardware_Manual_guide/node028B.html Amiga® Hardware Reference Manual: K Zorro Expansion Bus Hardware_Manual_guide/node028C.html K Zorro Expansion Bus / General Hardware_Manual_guide/node028D.html K / General / Intended Audience Hardware_Manual_guide/node028E.html K / General / Amiga Bus History Hardware_Manual_guide/node028F.html K / General / The Zorro III Rationale Hardware_Manual_guide/node0290.html K Zorro Expansion Bus / Zorro II Compatibility Hardware_Manual_guide/node0291.html K / Zorro II Compatibility / Changes from the A2000 Bus Hardware_Manual_guide/node0292.html K / / Changes from the A2000 Bus / 6800 Bus Interface Hardware_Manual_guide/node0293.html K / / Changes from A2000 Bus / Bus Memory Mapping and Cache Support Hardware_Manual_guide/node0294.html K / / Changes from the A2000 Bus / Bus Synchronization Delays Hardware_Manual_guide/node0295.html K / / Changes from A2000 Bus / Zorro II Master Access to Local Slaves Hardware_Manual_guide/node0296.html K / / Changes from the A2000 Bus / Bus Arbitration and Fairness Hardware_Manual_guide/node0297.html K / / Changes from the A2000 Bus / Intelligent Cycle Spacing Hardware_Manual_guide/node0298.html K / / Changes from the A2000 Bus / Bus Drive and Termination Hardware_Manual_guide/node0299.html K / / Changes from the A2000 Bus / DMA Latency and Overlap Hardware_Manual_guide/node029A.html K / / Changes from the A2000 Bus / Power Supply Differences Hardware_Manual_guide/node029B.html K / Zorro II Compatibility / Zorro II Bus Architecture Hardware_Manual_guide/node029C.html K / Zorro II Compatibility / Signal Description Hardware_Manual_guide/node029D.html K / / Signal Description / Power Connections Hardware_Manual_guide/node029E.html K / / Signal Description / Clock Signals Hardware_Manual_guide/node029F.html K / / Signal Description / System Control Signals Hardware_Manual_guide/node02A0.html K / / Signal Description / Slot Control Signals Hardware_Manual_guide/node02A1.html K / / Signal Description / DMA Control Signals Hardware_Manual_guide/node02A2.html K / / Signal Description / Addressing and Control Signals Hardware_Manual_guide/node02A3.html K Zorro Expansion Bus / Zorro III Bus Architecture Hardware_Manual_guide/node02A4.html K / Zorro III Bus Architecture / Basic Zorro III Bus Cycles Hardware_Manual_guide/node02A5.html K / / Basic Zorro III Bus Cycles / Design Goals Hardware_Manual_guide/node02A6.html K / / Basic Zorro III Bus Cycles / Simple Bus Cycle Operation Hardware_Manual_guide/node02A7.html K / Zorro III Bus Architecture / Advanced Mode Support Logic Hardware_Manual_guide/node02A8.html K / / Advanced Mode Support Logic / Bus Locking Hardware_Manual_guide/node02A9.html K / / Advanced Mode Support Logic / Cache Support Hardware_Manual_guide/node02AA.html K / Zorro III Bus Architecture / Multiple Transfer Cycles Hardware_Manual_guide/node02AB.html K / Zorro III Bus Architecture / Quick Bus Arbitration Hardware_Manual_guide/node02AC.html K / Zorro III Bus Architecture / Quick Interrupts Hardware_Manual_guide/node02AD.html K / Zorro III Bus Architecture / Compatibility With Zorro II Devices Hardware_Manual_guide/node02AE.html K Zorro Expansion Bus / Signal Description Hardware_Manual_guide/node02AF.html K / Signal Description / Power Connections Hardware_Manual_guide/node02B0.html K / Signal Description / Clock Signals Hardware_Manual_guide/node02B1.html K / Signal Description / System Control Signals Hardware_Manual_guide/node02B2.html K / Signal Description / Slot Control Signals Hardware_Manual_guide/node02B3.html K / Signal Description / DMA Control Signals Hardware_Manual_guide/node02B4.html K / Signal Description / Address And Related Control Signals Hardware_Manual_guide/node02B5.html K / Signal Description / Data And Related Control Signals Hardware_Manual_guide/node02B6.html K Zorro Expansion Bus / Timing Hardware_Manual_guide/node02B7.html K / Timing / Standard Read Cycle Timing Hardware_Manual_guide/node02B8.html K / Timing / Standard Write Cycle Timing Hardware_Manual_guide/node02B9.html K / Timing / Multiple Transfer Cycle Timing Hardware_Manual_guide/node02BA.html K / Timing / Quick Interrupt Cycle Timing Hardware_Manual_guide/node02BB.html K Zorro Expansion Bus / Electrical Specifications Hardware_Manual_guide/node02BC.html K / Electrical Specifications / Expansion Bus Loading Hardware_Manual_guide/node02BD.html K / / Expansion Bus Loading / Clock Signals Hardware_Manual_guide/node02BE.html K / / Expansion Bus Loading / Open Collector Signals Hardware_Manual_guide/node02BF.html K / / Expansion Bus Loading / Non-bussed Signals Hardware_Manual_guide/node02C0.html K / Electrical Specifications / Slot Power Availability Hardware_Manual_guide/node02C1.html K / Electrical Specifications / Temperature Range Hardware_Manual_guide/node02C2.html K Zorro Expansion Bus / Mechanical Specifications Hardware_Manual_guide/node02C3.html K / Mechanical Specifications / Basic Zorro III PIC Hardware_Manual_guide/node02C4.html K / Mechanical Specifications / PIC with ISA Option Hardware_Manual_guide/node02C5.html K / Mechanical Specifications / PIC with Video Option Hardware_Manual_guide/node02C6.html K Zorro Expansion Bus / AUTOCONFIG(TM) Hardware_Manual_guide/node02C7.html K / AUTOCONFIG(TM) / The Autoconfig Mechanism Hardware_Manual_guide/node02C8.html K / AUTOCONFIG(TM) / Register Bit Assignments Hardware_Manual_guide/node02C9.html K Zorro Expansion Bus / Physical and Logical Signal Names Hardware_Manual_guide/node02CA.html K Zorro Expansion Bus / Zorro III Implementations Hardware_Manual_guide/node02CB.html Hard_Pics/1-1.pic Hardware_Manual_guide/node02CC.html Hard_examples/lores_playfield.asm Hardware_Manual_guide/node02CD.html Hard_examples/hires_playfield.asm Hardware_Manual_guide/node02CE.html Hard_Pics/3-12.pic Hardware_Manual_guide/node02CF.html Hard_Pics/3-23.pic Hardware_Manual_guide/node02D0.html Hard_Pics/3-24.pic Hardware_Manual_guide/node02D1.html Hard_examples/HAM_playfield.asm Hardware_Manual_guide/node02D2.html Hard_examples/sprite_display.asm Hardware_Manual_guide/node02D3.html Hard_examples/sprite_move.asm Hardware_Manual_guide/node02D4.html Hard_Pics/6-9.pic Hardware_Manual_guide/node02D5.html Hard_Pics/4-11.pic Hardware_Manual_guide/node02D6.html Hard_Pics/4-13.pic Hardware_Manual_guide/node02D7.html Hard_Pics/5-1.pic Hardware_Manual_guide/node02D8.html Hard_Pics/5-2.pic Hardware_Manual_guide/node02D9.html Hard_examples/sinewave.asm Hardware_Manual_guide/node02DA.html Hard_Pics/5-3.pic Hardware_Manual_guide/node02DB.html Hard_Pics/5-4.pic Hardware_Manual_guide/node02DC.html Hard_Pics/5-8.pic Hardware_Manual_guide/node02DD.html Hard_Pics/6-13.pic Hardware_Manual_guide/node02DE.html Hard_examples/clearmem.asm Hardware_Manual_guide/node02DF.html Hard_examples/simpleline.asm Hardware_Manual_guide/node02E0.html Hard_examples/rotatebits.asm Hardware_Manual_guide/node02E1.html Hard_examples/8520_timing.asm Hardware_Manual_guide/node02E2.html Hard_Pics/7-2.pic Hardware_Manual_guide/node02E3.html Hard_examples/coldreboot.asm Hardware_Manual_guide/node02E4.html Hard_Pics/8-1.pic Hardware_Manual_guide/node02E5.html Hard_Pics/8-3.pic Hardware_Manual_guide/node02E6.html Hard_Pics/8-5.pic Hardware_Manual_guide/node02E7.html Hard_Pics/8-6.pic Hardware_Manual_guide/node02E8.html Hard_Pics/8-10.pic Includes_and_Autodocs_2._guide/node0000.html Includes and Autodocs 2.0 Includes_and_Autodocs_2._guide/node0001.html System Header Files 2.0 Includes_and_Autodocs_2._guide/node0002.html clib Includes_and_Autodocs_2._guide/node0003.html devices Includes_and_Autodocs_2._guide/node0004.html dos Includes_and_Autodocs_2._guide/node0005.html exec Includes_and_Autodocs_2._guide/node0006.html graphics Includes_and_Autodocs_2._guide/node0007.html hardware Includes_and_Autodocs_2._guide/node0008.html intuition Includes_and_Autodocs_2._guide/node0009.html libraries Includes_and_Autodocs_2._guide/node000A.html resources Includes_and_Autodocs_2._guide/node000B.html rexx Includes_and_Autodocs_2._guide/node000C.html utility Includes_and_Autodocs_2._guide/node000D.html workbench Includes_and_Autodocs_2._guide/node000E.html Autodocs 2.0 Includes_and_Autodocs_2._guide/node000F.html System References 2.0 Includes_and_Autodocs_2._guide/node0010.html Include File Cross Reference 2.0 Includes_and_Autodocs_2._guide/node0011.html System FD Files 2.0 Includes_and_Autodocs_2._guide/node0012.html Text_Autodocs 2.0 Includes_and_Autodocs_2._guide/node0013.html Includes/clib/alib_protos.h Includes_and_Autodocs_2._guide/node0014.html Includes/clib/intuition_protos.h Includes_and_Autodocs_2._guide/node0015.html Includes/clib/alib_stdio_protos.h Includes_and_Autodocs_2._guide/node0016.html Includes/clib/keymap_protos.h Includes_and_Autodocs_2._guide/node0017.html Includes/clib/all_protos.h Includes_and_Autodocs_2._guide/node0018.html Includes/clib/layers_protos.h Includes_and_Autodocs_2._guide/node0019.html Includes/clib/asl_protos.h Includes_and_Autodocs_2._guide/node001A.html Includes/clib/macros.h Includes_and_Autodocs_2._guide/node001B.html Includes/clib/battclock_protos.h Includes_and_Autodocs_2._guide/node001C.html Includes/clib/mathffp_protos.h Includes_and_Autodocs_2._guide/node001D.html Includes/clib/battmem_protos.h Includes_and_Autodocs_2._guide/node001E.html Includes/clib/mathieeedoubbas_protos.h Includes_and_Autodocs_2._guide/node001F.html Includes/clib/cia_protos.h Includes_and_Autodocs_2._guide/node0020.html Includes/clib/mathieeedoubtrans_protos.h Includes_and_Autodocs_2._guide/node0021.html Includes/clib/commodities_protos.h Includes_and_Autodocs_2._guide/node0022.html Includes/clib/mathieeesingbas_protos.h Includes_and_Autodocs_2._guide/node0023.html Includes/clib/console_protos.h Includes_and_Autodocs_2._guide/node0024.html Includes/clib/mathieeesingtrans_protos.h Includes_and_Autodocs_2._guide/node0025.html Includes/clib/diskfont_protos.h Includes_and_Autodocs_2._guide/node0026.html Includes/clib/mathtrans_protos.h Includes_and_Autodocs_2._guide/node0027.html Includes/clib/disk_protos.h Includes_and_Autodocs_2._guide/node0028.html Includes/clib/misc_protos.h Includes_and_Autodocs_2._guide/node0029.html Includes/clib/dos_protos.h Includes_and_Autodocs_2._guide/node002A.html Includes/clib/potgo_protos.h Includes_and_Autodocs_2._guide/node002B.html Includes/clib/exec_protos.h Includes_and_Autodocs_2._guide/node002C.html Includes/clib/ramdrive_protos.h Includes_and_Autodocs_2._guide/node002D.html Includes/clib/expansion_protos.h Includes_and_Autodocs_2._guide/node002E.html Includes/clib/rexxsyslib_protos.h Includes_and_Autodocs_2._guide/node002F.html Includes/clib/gadtools_protos.h Includes_and_Autodocs_2._guide/node0030.html Includes/clib/timer_protos.h Includes_and_Autodocs_2._guide/node0031.html Includes/clib/graphics_protos.h Includes_and_Autodocs_2._guide/node0032.html Includes/clib/translator_protos.h Includes_and_Autodocs_2._guide/node0033.html Includes/clib/icon_protos.h Includes_and_Autodocs_2._guide/node0034.html Includes/clib/utility_protos.h Includes_and_Autodocs_2._guide/node0035.html Includes/clib/iffparse_protos.h Includes_and_Autodocs_2._guide/node0036.html Includes/clib/wb_protos.h Includes_and_Autodocs_2._guide/node0037.html Includes/clib/input_protos.h Includes_and_Autodocs_2._guide/node0038.html Includes/devices/audio.h Includes_and_Autodocs_2._guide/node0039.html Includes/devices/gameport.h Includes_and_Autodocs_2._guide/node003A.html Includes/devices/keymap.h Includes_and_Autodocs_2._guide/node003B.html Includes/devices/prtgfx.h Includes_and_Autodocs_2._guide/node003C.html Includes/devices/audio.i Includes_and_Autodocs_2._guide/node003D.html Includes/devices/gameport.i Includes_and_Autodocs_2._guide/node003E.html Includes/devices/keymap.i Includes_and_Autodocs_2._guide/node003F.html Includes/devices/prtgfx.i Includes_and_Autodocs_2._guide/node0040.html Includes/devices/bootblock.h Includes_and_Autodocs_2._guide/node0041.html Includes/devices/hardblocks.h Includes_and_Autodocs_2._guide/node0042.html Includes/devices/narrator.h Includes_and_Autodocs_2._guide/node0043.html Includes/devices/scsidisk.h Includes_and_Autodocs_2._guide/node0044.html Includes/devices/bootblock.i Includes_and_Autodocs_2._guide/node0045.html Includes/devices/hardblocks.i Includes_and_Autodocs_2._guide/node0046.html Includes/devices/narrator.i Includes_and_Autodocs_2._guide/node0047.html Includes/devices/scsidisk.i Includes_and_Autodocs_2._guide/node0048.html Includes/devices/clipboard.h Includes_and_Autodocs_2._guide/node0049.html Includes/devices/input.h Includes_and_Autodocs_2._guide/node004A.html Includes/devices/parallel.h Includes_and_Autodocs_2._guide/node004B.html Includes/devices/serial.h Includes_and_Autodocs_2._guide/node004C.html Includes/devices/clipboard.i Includes_and_Autodocs_2._guide/node004D.html Includes/devices/input.i Includes_and_Autodocs_2._guide/node004E.html Includes/devices/parallel.i Includes_and_Autodocs_2._guide/node004F.html Includes/devices/serial.i Includes_and_Autodocs_2._guide/node0050.html Includes/devices/console.h Includes_and_Autodocs_2._guide/node0051.html Includes/devices/inputevent.h Includes_and_Autodocs_2._guide/node0052.html Includes/devices/printer.h Includes_and_Autodocs_2._guide/node0053.html Includes/devices/timer.h Includes_and_Autodocs_2._guide/node0054.html Includes/devices/console.i Includes_and_Autodocs_2._guide/node0055.html Includes/devices/inputevent.i Includes_and_Autodocs_2._guide/node0056.html Includes/devices/printer.i Includes_and_Autodocs_2._guide/node0057.html Includes/devices/timer.i Includes_and_Autodocs_2._guide/node0058.html Includes/devices/conunit.h Includes_and_Autodocs_2._guide/node0059.html Includes/devices/keyboard.h Includes_and_Autodocs_2._guide/node005A.html Includes/devices/prtbase.h Includes_and_Autodocs_2._guide/node005B.html Includes/devices/trackdisk.h Includes_and_Autodocs_2._guide/node005C.html Includes/devices/conunit.i Includes_and_Autodocs_2._guide/node005D.html Includes/devices/keyboard.i Includes_and_Autodocs_2._guide/node005E.html Includes/devices/prtbase.i Includes_and_Autodocs_2._guide/node005F.html Includes/devices/trackdisk.i Includes_and_Autodocs_2._guide/node0060.html Includes/dos/datetime.h Includes_and_Autodocs_2._guide/node0061.html Includes/dos/dosextens.i Includes_and_Autodocs_2._guide/node0062.html Includes/dos/exall.i Includes_and_Autodocs_2._guide/node0063.html Includes/dos/record.h Includes_and_Autodocs_2._guide/node0064.html Includes/dos/datetime.i Includes_and_Autodocs_2._guide/node0065.html Includes/dos/doshunks.h Includes_and_Autodocs_2._guide/node0066.html Includes/dos/filehandler.h Includes_and_Autodocs_2._guide/node0067.html Includes/dos/record.i Includes_and_Autodocs_2._guide/node0068.html Includes/dos/dos.h Includes_and_Autodocs_2._guide/node0069.html Includes/dos/doshunks.i Includes_and_Autodocs_2._guide/node006A.html Includes/dos/filehandler.i Includes_and_Autodocs_2._guide/node006B.html Includes/dos/stdio.h Includes_and_Autodocs_2._guide/node006C.html Includes/dos/dos.i Includes_and_Autodocs_2._guide/node006D.html Includes/dos/dostags.h Includes_and_Autodocs_2._guide/node006E.html Includes/dos/notify.h Includes_and_Autodocs_2._guide/node006F.html Includes/dos/stdio.i Includes_and_Autodocs_2._guide/node0070.html Includes/dos/dosasl.h Includes_and_Autodocs_2._guide/node0071.html Includes/dos/dostags.i Includes_and_Autodocs_2._guide/node0072.html Includes/dos/notify.i Includes_and_Autodocs_2._guide/node0073.html Includes/dos/var.h Includes_and_Autodocs_2._guide/node0074.html Includes/dos/dosasl.i Includes_and_Autodocs_2._guide/node0075.html Includes/dos/dos_lib.i Includes_and_Autodocs_2._guide/node0076.html Includes/dos/rdargs.h Includes_and_Autodocs_2._guide/node0077.html Includes/dos/var.i Includes_and_Autodocs_2._guide/node0078.html Includes/dos/dosextens.h Includes_and_Autodocs_2._guide/node0079.html Includes/dos/exall.h Includes_and_Autodocs_2._guide/node007A.html Includes/dos/rdargs.i Includes_and_Autodocs_2._guide/node007B.html Includes/exec/ables.i Includes_and_Autodocs_2._guide/node007C.html Includes/exec/execbase.i Includes_and_Autodocs_2._guide/node007D.html Includes/exec/lists.h Includes_and_Autodocs_2._guide/node007E.html Includes/exec/resident.i Includes_and_Autodocs_2._guide/node007F.html Includes/exec/alerts.h Includes_and_Autodocs_2._guide/node0080.html Includes/exec/exec_lib.i Includes_and_Autodocs_2._guide/node0081.html Includes/exec/lists.i Includes_and_Autodocs_2._guide/node0082.html Includes/exec/semaphores.h Includes_and_Autodocs_2._guide/node0083.html Includes/exec/alerts.i Includes_and_Autodocs_2._guide/node0084.html Includes/exec/initializers.h Includes_and_Autodocs_2._guide/node0085.html Includes/exec/macros.i Includes_and_Autodocs_2._guide/node0086.html Includes/exec/semaphores.i Includes_and_Autodocs_2._guide/node0087.html Includes/exec/devices.h Includes_and_Autodocs_2._guide/node0088.html Includes/exec/initializers.i Includes_and_Autodocs_2._guide/node0089.html Includes/exec/memory.h Includes_and_Autodocs_2._guide/node008A.html Includes/exec/strings.i Includes_and_Autodocs_2._guide/node008B.html Includes/exec/devices.i Includes_and_Autodocs_2._guide/node008C.html Includes/exec/interrupts.h Includes_and_Autodocs_2._guide/node008D.html Includes/exec/memory.i Includes_and_Autodocs_2._guide/node008E.html Includes/exec/tasks.h Includes_and_Autodocs_2._guide/node008F.html Includes/exec/errors.h Includes_and_Autodocs_2._guide/node0090.html Includes/exec/interrupts.i Includes_and_Autodocs_2._guide/node0091.html Includes/exec/nodes.h Includes_and_Autodocs_2._guide/node0092.html Includes/exec/tasks.i Includes_and_Autodocs_2._guide/node0093.html Includes/exec/errors.i Includes_and_Autodocs_2._guide/node0094.html Includes/exec/io.h Includes_and_Autodocs_2._guide/node0095.html Includes/exec/nodes.i Includes_and_Autodocs_2._guide/node0096.html Includes/exec/types.h Includes_and_Autodocs_2._guide/node0097.html Includes/exec/exec.h Includes_and_Autodocs_2._guide/node0098.html Includes/exec/io.i Includes_and_Autodocs_2._guide/node0099.html Includes/exec/ports.h Includes_and_Autodocs_2._guide/node009A.html Includes/exec/types.i Includes_and_Autodocs_2._guide/node009B.html Includes/exec/exec.i Includes_and_Autodocs_2._guide/node009C.html Includes/exec/libraries.h Includes_and_Autodocs_2._guide/node009D.html Includes/exec/ports.i Includes_and_Autodocs_2._guide/node009E.html Includes/exec/execbase.h Includes_and_Autodocs_2._guide/node009F.html Includes/exec/libraries.i Includes_and_Autodocs_2._guide/node00A0.html Includes/exec/resident.h Includes_and_Autodocs_2._guide/node00A1.html Includes/graphics/clip.h Includes_and_Autodocs_2._guide/node00A2.html Includes/graphics/gels.i Includes_and_Autodocs_2._guide/node00A3.html Includes/graphics/layers.i Includes_and_Autodocs_2._guide/node00A4.html Includes/graphics/sprite.i Includes_and_Autodocs_2._guide/node00A5.html Includes/graphics/clip.i Includes_and_Autodocs_2._guide/node00A6.html Includes/graphics/gfx.h Includes_and_Autodocs_2._guide/node00A7.html Includes/graphics/monitor.h Includes_and_Autodocs_2._guide/node00A8.html Includes/graphics/text.h Includes_and_Autodocs_2._guide/node00A9.html Includes/graphics/collide.h Includes_and_Autodocs_2._guide/node00AA.html Includes/graphics/gfx.i Includes_and_Autodocs_2._guide/node00AB.html Includes/graphics/monitor.i Includes_and_Autodocs_2._guide/node00AC.html Includes/graphics/text.i Includes_and_Autodocs_2._guide/node00AD.html Includes/graphics/copper.h Includes_and_Autodocs_2._guide/node00AE.html Includes/graphics/gfxbase.h Includes_and_Autodocs_2._guide/node00AF.html Includes/graphics/rastport.h Includes_and_Autodocs_2._guide/node00B0.html Includes/graphics/videocontrol.h Includes_and_Autodocs_2._guide/node00B1.html Includes/graphics/copper.i Includes_and_Autodocs_2._guide/node00B2.html Includes/graphics/gfxbase.i Includes_and_Autodocs_2._guide/node00B3.html Includes/graphics/rastport.i Includes_and_Autodocs_2._guide/node00B4.html Includes/graphics/videocontrol.i Includes_and_Autodocs_2._guide/node00B5.html Includes/graphics/display.h Includes_and_Autodocs_2._guide/node00B6.html Includes/graphics/gfxmacros.h Includes_and_Autodocs_2._guide/node00B7.html Includes/graphics/regions.h Includes_and_Autodocs_2._guide/node00B8.html Includes/graphics/view.h Includes_and_Autodocs_2._guide/node00B9.html Includes/graphics/display.i Includes_and_Autodocs_2._guide/node00BA.html Includes/graphics/gfxnodes.h Includes_and_Autodocs_2._guide/node00BB.html Includes/graphics/regions.i Includes_and_Autodocs_2._guide/node00BC.html Includes/graphics/view.i Includes_and_Autodocs_2._guide/node00BD.html Includes/graphics/displayinfo.h Includes_and_Autodocs_2._guide/node00BE.html Includes/graphics/gfxnodes.i Includes_and_Autodocs_2._guide/node00BF.html Includes/graphics/scale.h Includes_and_Autodocs_2._guide/node00C0.html Includes/graphics/displayinfo.i Includes_and_Autodocs_2._guide/node00C1.html Includes/graphics/graphint.h Includes_and_Autodocs_2._guide/node00C2.html Includes/graphics/scale.i Includes_and_Autodocs_2._guide/node00C3.html Includes/graphics/gels.h Includes_and_Autodocs_2._guide/node00C4.html Includes/graphics/layers.h Includes_and_Autodocs_2._guide/node00C5.html Includes/graphics/sprite.h Includes_and_Autodocs_2._guide/node00C6.html Includes/hardware/adkbits.h Includes_and_Autodocs_2._guide/node00C7.html Includes/hardware/cia.h Includes_and_Autodocs_2._guide/node00C8.html Includes/hardware/dmabits.h Includes_and_Autodocs_2._guide/node00C9.html Includes/hardware/adkbits.i Includes_and_Autodocs_2._guide/node00CA.html Includes/hardware/cia.i Includes_and_Autodocs_2._guide/node00CB.html Includes/hardware/dmabits.i Includes_and_Autodocs_2._guide/node00CC.html Includes/hardware/blit.h Includes_and_Autodocs_2._guide/node00CD.html Includes/hardware/custom.h Includes_and_Autodocs_2._guide/node00CE.html Includes/hardware/intbits.h Includes_and_Autodocs_2._guide/node00CF.html Includes/hardware/blit.i Includes_and_Autodocs_2._guide/node00D0.html Includes/hardware/custom.i Includes_and_Autodocs_2._guide/node00D1.html Includes/hardware/intbits.i Includes_and_Autodocs_2._guide/node00D2.html Includes/intuition/cghooks.h Includes_and_Autodocs_2._guide/node00D3.html Includes/intuition/gadgetclass.h Includes_and_Autodocs_2._guide/node00D4.html Includes/intuition/intuition.h Includes_and_Autodocs_2._guide/node00D5.html Includes/intuition/preferences.h Includes_and_Autodocs_2._guide/node00D6.html Includes/intuition/cghooks.i Includes_and_Autodocs_2._guide/node00D7.html Includes/intuition/gadgetclass.i Includes_and_Autodocs_2._guide/node00D8.html Includes/intuition/intuition.i Includes_and_Autodocs_2._guide/node00D9.html Includes/intuition/preferences.i Includes_and_Autodocs_2._guide/node00DA.html Includes/intuition/classes.h Includes_and_Autodocs_2._guide/node00DB.html Includes/intuition/icclass.h Includes_and_Autodocs_2._guide/node00DC.html Includes/intuition/intuitionbase.h Includes_and_Autodocs_2._guide/node00DD.html Includes/intuition/screens.h Includes_and_Autodocs_2._guide/node00DE.html Includes/intuition/classes.i Includes_and_Autodocs_2._guide/node00DF.html Includes/intuition/icclass.i Includes_and_Autodocs_2._guide/node00E0.html Includes/intuition/intuitionbase.i Includes_and_Autodocs_2._guide/node00E1.html Includes/intuition/screens.i Includes_and_Autodocs_2._guide/node00E2.html Includes/intuition/classusr.h Includes_and_Autodocs_2._guide/node00E3.html Includes/intuition/imageclass.h Includes_and_Autodocs_2._guide/node00E4.html Includes/intuition/iobsolete.h Includes_and_Autodocs_2._guide/node00E5.html Includes/intuition/sghooks.h Includes_and_Autodocs_2._guide/node00E6.html Includes/intuition/classusr.i Includes_and_Autodocs_2._guide/node00E7.html Includes/intuition/imageclass.i Includes_and_Autodocs_2._guide/node00E8.html Includes/intuition/iobsolete.i Includes_and_Autodocs_2._guide/node00E9.html Includes/intuition/sghooks.i Includes_and_Autodocs_2._guide/node00EA.html Includes/libraries/asl.h Includes_and_Autodocs_2._guide/node00EB.html Includes/libraries/dosextens.h Includes_and_Autodocs_2._guide/node00EC.html Includes/libraries/iffparse.i Includes_and_Autodocs_2._guide/node00ED.html Includes/libraries/asl.i Includes_and_Autodocs_2._guide/node00EE.html Includes/libraries/dosextens.i Includes_and_Autodocs_2._guide/node00EF.html Includes/libraries/mathffp.h Includes_and_Autodocs_2._guide/node00F0.html Includes/libraries/commodities.h Includes_and_Autodocs_2._guide/node00F1.html Includes/libraries/dos_lib.i Includes_and_Autodocs_2._guide/node00F2.html Includes/libraries/mathieeedp.h Includes_and_Autodocs_2._guide/node00F3.html Includes/libraries/commodities.i Includes_and_Autodocs_2._guide/node00F4.html Includes/libraries/expansion.h Includes_and_Autodocs_2._guide/node00F5.html Includes/libraries/mathieeesp.h Includes_and_Autodocs_2._guide/node00F6.html Includes/libraries/configregs.h Includes_and_Autodocs_2._guide/node00F7.html Includes/libraries/expansion.i Includes_and_Autodocs_2._guide/node00F8.html Includes/libraries/mathlibrary.h Includes_and_Autodocs_2._guide/node00F9.html Includes/libraries/configregs.i Includes_and_Autodocs_2._guide/node00FA.html Includes/libraries/expansionbase.h Includes_and_Autodocs_2._guide/node00FB.html Includes/libraries/mathlibrary.i Includes_and_Autodocs_2._guide/node00FC.html Includes/libraries/configvars.h Includes_and_Autodocs_2._guide/node00FD.html Includes/libraries/expansionbase.i Includes_and_Autodocs_2._guide/node00FE.html Includes/libraries/mathresource.h Includes_and_Autodocs_2._guide/node00FF.html Includes/libraries/configvars.i Includes_and_Autodocs_2._guide/node0100.html Includes/libraries/filehandler.h Includes_and_Autodocs_2._guide/node0101.html Includes/libraries/mathresource.i Includes_and_Autodocs_2._guide/node0102.html Includes/libraries/diskfont.h Includes_and_Autodocs_2._guide/node0103.html Includes/libraries/filehandler.i Includes_and_Autodocs_2._guide/node0104.html Includes/libraries/translator.h Includes_and_Autodocs_2._guide/node0105.html Includes/libraries/diskfont.i Includes_and_Autodocs_2._guide/node0106.html Includes/libraries/gadtools.h Includes_and_Autodocs_2._guide/node0107.html Includes/libraries/translator.i Includes_and_Autodocs_2._guide/node0108.html Includes/libraries/dos.h Includes_and_Autodocs_2._guide/node0109.html Includes/libraries/gadtools.i Includes_and_Autodocs_2._guide/node010A.html Includes/libraries/dos.i Includes_and_Autodocs_2._guide/node010B.html Includes/libraries/iffparse.h Includes_and_Autodocs_2._guide/node010C.html Includes/resources/battclock.h Includes_and_Autodocs_2._guide/node010D.html Includes/resources/cia.h Includes_and_Autodocs_2._guide/node010E.html Includes/resources/misc.h Includes_and_Autodocs_2._guide/node010F.html Includes/resources/battclock.i Includes_and_Autodocs_2._guide/node0110.html Includes/resources/cia.i Includes_and_Autodocs_2._guide/node0111.html Includes/resources/misc.i Includes_and_Autodocs_2._guide/node0112.html Includes/resources/battmem.h Includes_and_Autodocs_2._guide/node0113.html Includes/resources/ciabase.h Includes_and_Autodocs_2._guide/node0114.html Includes/resources/potgo.h Includes_and_Autodocs_2._guide/node0115.html Includes/resources/battmem.i Includes_and_Autodocs_2._guide/node0116.html Includes/resources/ciabase.i Includes_and_Autodocs_2._guide/node0117.html Includes/resources/potgo.i Includes_and_Autodocs_2._guide/node0118.html Includes/resources/battmembitsamiga.h Includes_and_Autodocs_2._guide/node0119.html Includes/resources/disk.h Includes_and_Autodocs_2._guide/node011A.html Includes/resources/battmembitsamiga.i Includes_and_Autodocs_2._guide/node011B.html Includes/resources/disk.i Includes_and_Autodocs_2._guide/node011C.html Includes/resources/battmembitsamix.h Includes_and_Autodocs_2._guide/node011D.html Includes/resources/filesysres.h Includes_and_Autodocs_2._guide/node011E.html Includes/resources/battmembitsamix.i Includes_and_Autodocs_2._guide/node011F.html Includes/resources/filesysres.i Includes_and_Autodocs_2._guide/node0120.html Includes/resources/battmembitsshared.h Includes_and_Autodocs_2._guide/node0121.html Includes/resources/mathresource.h Includes_and_Autodocs_2._guide/node0122.html Includes/resources/battmembitsshared.i Includes_and_Autodocs_2._guide/node0123.html Includes/resources/mathresource.i Includes_and_Autodocs_2._guide/node0124.html Includes/rexx/errors.h Includes_and_Autodocs_2._guide/node0125.html Includes/rexx/rexxio.h Includes_and_Autodocs_2._guide/node0126.html Includes/rexx/rxslib.h Includes_and_Autodocs_2._guide/node0127.html Includes/rexx/storage.h Includes_and_Autodocs_2._guide/node0128.html Includes/rexx/errors.i Includes_and_Autodocs_2._guide/node0129.html Includes/rexx/rexxio.i Includes_and_Autodocs_2._guide/node012A.html Includes/rexx/rxslib.i Includes_and_Autodocs_2._guide/node012B.html Includes/rexx/storage.i Includes_and_Autodocs_2._guide/node012C.html Includes/utility/date.h Includes_and_Autodocs_2._guide/node012D.html Includes/utility/hooks.h Includes_and_Autodocs_2._guide/node012E.html Includes/utility/tagitem.h Includes_and_Autodocs_2._guide/node012F.html Includes/utility/utility.i Includes_and_Autodocs_2._guide/node0130.html Includes/utility/date.i Includes_and_Autodocs_2._guide/node0131.html Includes/utility/hooks.i Includes_and_Autodocs_2._guide/node0132.html Includes/utility/tagitem.i Includes_and_Autodocs_2._guide/node0133.html Includes/workbench/icon.h Includes_and_Autodocs_2._guide/node0134.html Includes/workbench/startup.h Includes_and_Autodocs_2._guide/node0135.html Includes/workbench/workbench.h Includes_and_Autodocs_2._guide/node0136.html Includes/workbench/icon.i Includes_and_Autodocs_2._guide/node0137.html Includes/workbench/startup.i Includes_and_Autodocs_2._guide/node0138.html Includes/workbench/workbench.i Includes_and_Autodocs_2._guide/node0139.html amiga_lib.doc Includes_and_Autodocs_2._guide/node013A.html amiga.lib/AddTOF Includes_and_Autodocs_2._guide/node013B.html amiga.lib/afp Includes_and_Autodocs_2._guide/node013C.html amiga.lib/ArgArrayDone Includes_and_Autodocs_2._guide/node013D.html amiga.lib/ArgArrayInit Includes_and_Autodocs_2._guide/node013E.html amiga.lib/ArgInt Includes_and_Autodocs_2._guide/node013F.html amiga.lib/ArgString Includes_and_Autodocs_2._guide/node0140.html amiga.lib/arnd Includes_and_Autodocs_2._guide/node0141.html amiga.lib/BeginIO Includes_and_Autodocs_2._guide/node0142.html amiga.lib/CallHook Includes_and_Autodocs_2._guide/node0143.html amiga.lib/CallHookA Includes_and_Autodocs_2._guide/node0144.html amiga.lib/CheckRexxMsg Includes_and_Autodocs_2._guide/node0145.html amiga.lib/CoerceMethod Includes_and_Autodocs_2._guide/node0146.html amiga.lib/CoerceMethodA Includes_and_Autodocs_2._guide/node0147.html amiga.lib/CreateExtIO Includes_and_Autodocs_2._guide/node0148.html amiga.lib/CreatePort Includes_and_Autodocs_2._guide/node0149.html amiga.lib/CreateStdIO Includes_and_Autodocs_2._guide/node014A.html amiga.lib/CreateTask Includes_and_Autodocs_2._guide/node014B.html amiga.lib/CxCustom Includes_and_Autodocs_2._guide/node014C.html amiga.lib/CxDebug Includes_and_Autodocs_2._guide/node014D.html amiga.lib/CxFilter Includes_and_Autodocs_2._guide/node014E.html amiga.lib/CxSender Includes_and_Autodocs_2._guide/node014F.html amiga.lib/CxSignal Includes_and_Autodocs_2._guide/node0150.html amiga.lib/CxTranslate Includes_and_Autodocs_2._guide/node0151.html amiga.lib/dbf Includes_and_Autodocs_2._guide/node0152.html amiga.lib/DeleteExtIO Includes_and_Autodocs_2._guide/node0153.html amiga.lib/DeletePort Includes_and_Autodocs_2._guide/node0154.html amiga.lib/DeleteStdIO Includes_and_Autodocs_2._guide/node0155.html amiga.lib/DeleteTask Includes_and_Autodocs_2._guide/node0156.html amiga.lib/DoMethod Includes_and_Autodocs_2._guide/node0157.html amiga.lib/DoMethodA Includes_and_Autodocs_2._guide/node0158.html amiga.lib/DoSuperMethod Includes_and_Autodocs_2._guide/node0159.html amiga.lib/DoSuperMethodA Includes_and_Autodocs_2._guide/node015A.html amiga.lib/FastRand Includes_and_Autodocs_2._guide/node015B.html amiga.lib/fpa Includes_and_Autodocs_2._guide/node015C.html amiga.lib/FreeIEvents Includes_and_Autodocs_2._guide/node015D.html amiga.lib/GetRexxVar Includes_and_Autodocs_2._guide/node015E.html amiga.lib/HookEntry Includes_and_Autodocs_2._guide/node015F.html amiga.lib/HotKey Includes_and_Autodocs_2._guide/node0160.html amiga.lib/InvertString Includes_and_Autodocs_2._guide/node0161.html amiga.lib/NewList Includes_and_Autodocs_2._guide/node0162.html amiga.lib/printf Includes_and_Autodocs_2._guide/node0163.html amiga.lib/RangeRand Includes_and_Autodocs_2._guide/node0164.html amiga.lib/RemTOF Includes_and_Autodocs_2._guide/node0165.html amiga.lib/SetRexxVar Includes_and_Autodocs_2._guide/node0166.html amiga.lib/SetSuperAttrs Includes_and_Autodocs_2._guide/node0167.html amiga.lib/sprintf Includes_and_Autodocs_2._guide/node0168.html amiga.lib/stdio Includes_and_Autodocs_2._guide/node0169.html amiga.lib/TimeDelay Includes_and_Autodocs_2._guide/node016A.html ddebug_lib.doc Includes_and_Autodocs_2._guide/node016B.html DDoFmt Includes_and_Autodocs_2._guide/node016C.html DGetChar Includes_and_Autodocs_2._guide/node016D.html DGetNum Includes_and_Autodocs_2._guide/node016E.html DMayGetChar Includes_and_Autodocs_2._guide/node016F.html DPutChar Includes_and_Autodocs_2._guide/node0170.html DPutFmt Includes_and_Autodocs_2._guide/node0171.html DPutStr Includes_and_Autodocs_2._guide/node0172.html KCmpStr Includes_and_Autodocs_2._guide/node0173.html debug_lib.doc Includes_and_Autodocs_2._guide/node0174.html debug.lib/KCmpStr Includes_and_Autodocs_2._guide/node0175.html debug.lib/KGetChar Includes_and_Autodocs_2._guide/node0176.html debug.lib/KGetNum Includes_and_Autodocs_2._guide/node0177.html debug.lib/KMayGetChar Includes_and_Autodocs_2._guide/node0178.html debug.lib/KPrintF Includes_and_Autodocs_2._guide/node0179.html debug.lib/KPutChar Includes_and_Autodocs_2._guide/node017A.html debug.lib/KPutStr Includes_and_Autodocs_2._guide/node017B.html asl.doc Includes_and_Autodocs_2._guide/node017C.html asl.library/AllocAslRequest Includes_and_Autodocs_2._guide/node017D.html asl.library/AllocFileRequest Includes_and_Autodocs_2._guide/node017E.html asl.library/AslRequest Includes_and_Autodocs_2._guide/node017F.html asl.library/FreeAslRequest Includes_and_Autodocs_2._guide/node0180.html asl.library/FreeFileRequest Includes_and_Autodocs_2._guide/node0181.html asl.library/RequestFile Includes_and_Autodocs_2._guide/node0182.html icon.doc Includes_and_Autodocs_2._guide/node0183.html icon.library/AddFreeList Includes_and_Autodocs_2._guide/node0184.html icon.library/BumpRevision Includes_and_Autodocs_2._guide/node0185.html icon.library/DeleteDiskObject Includes_and_Autodocs_2._guide/node0186.html icon.library/FindToolType Includes_and_Autodocs_2._guide/node0187.html icon.library/FreeDiskObject Includes_and_Autodocs_2._guide/node0188.html icon.library/FreeFreeList Includes_and_Autodocs_2._guide/node0189.html icon.library/GetDefDiskObject Includes_and_Autodocs_2._guide/node018A.html icon.library/GetDiskObject Includes_and_Autodocs_2._guide/node018B.html icon.library/GetDiskObjectNew Includes_and_Autodocs_2._guide/node018C.html icon.library/MatchToolValue Includes_and_Autodocs_2._guide/node018D.html icon.library/PutDefDiskObject Includes_and_Autodocs_2._guide/node018E.html icon.library/PutDiskObject Includes_and_Autodocs_2._guide/node018F.html mathieeesingbas.doc Includes_and_Autodocs_2._guide/node0190.html mathieeesingbas.library/IEEESPAbs Includes_and_Autodocs_2._guide/node0191.html mathieeesingbas.library/IEEESPAdd Includes_and_Autodocs_2._guide/node0192.html mathieeesingbas.library/IEEESPCeil Includes_and_Autodocs_2._guide/node0193.html mathieeesingbas.library/IEEESPCmp Includes_and_Autodocs_2._guide/node0194.html mathieeesingbas.library/IEEESPDiv Includes_and_Autodocs_2._guide/node0195.html mathieeesingbas.library/IEEESPFix Includes_and_Autodocs_2._guide/node0196.html mathieeesingbas.library/IEEESPFloor Includes_and_Autodocs_2._guide/node0197.html mathieeesingbas.library/IEEESPFlt Includes_and_Autodocs_2._guide/node0198.html mathieeesingbas.library/IEEESPMul Includes_and_Autodocs_2._guide/node0199.html mathieeesingbas.library/IEEESPNeg Includes_and_Autodocs_2._guide/node019A.html mathieeesingbas.library/IEEESPSub Includes_and_Autodocs_2._guide/node019B.html mathieeesingbas.library/IEEESPTst Includes_and_Autodocs_2._guide/node019C.html commodities.doc Includes_and_Autodocs_2._guide/node019D.html commodities.library/ActivateCxObj Includes_and_Autodocs_2._guide/node019E.html commodities.library/AddIEvents Includes_and_Autodocs_2._guide/node019F.html commodities.library/AttachCxObj Includes_and_Autodocs_2._guide/node01A0.html commodities.library/ClearCxObjError Includes_and_Autodocs_2._guide/node01A1.html commodities.library/CreateCxObj Includes_and_Autodocs_2._guide/node01A2.html commodities.library/CxBroker Includes_and_Autodocs_2._guide/node01A3.html commodities.library/CxMsgData Includes_and_Autodocs_2._guide/node01A4.html commodities.library/CxMsgID Includes_and_Autodocs_2._guide/node01A5.html commodities.library/CxMsgType Includes_and_Autodocs_2._guide/node01A6.html commodities.library/CxObjError Includes_and_Autodocs_2._guide/node01A7.html commodities.library/CxObjType Includes_and_Autodocs_2._guide/node01A8.html commodities.library/DeleteCxObj Includes_and_Autodocs_2._guide/node01A9.html commodities.library/DeleteCxObjAll Includes_and_Autodocs_2._guide/node01AA.html commodities.library/DisposeCxMsg Includes_and_Autodocs_2._guide/node01AB.html commodities.library/DivertCxMsg Includes_and_Autodocs_2._guide/node01AC.html commodities.library/EnqueueCxObj Includes_and_Autodocs_2._guide/node01AD.html commodities.library/InsertCxObj Includes_and_Autodocs_2._guide/node01AE.html commodities.library/InvertKeyMap Includes_and_Autodocs_2._guide/node01AF.html commodities.library/ParseIX Includes_and_Autodocs_2._guide/node01B0.html commodities.library/RemoveCxObj Includes_and_Autodocs_2._guide/node01B1.html commodities.library/RouteCxMsg Includes_and_Autodocs_2._guide/node01B2.html commodities.library/SetCxObjPri Includes_and_Autodocs_2._guide/node01B3.html commodities.library/SetFilter Includes_and_Autodocs_2._guide/node01B4.html commodities.library/SetFilterIX Includes_and_Autodocs_2._guide/node01B5.html commodities.library/SetTranslate Includes_and_Autodocs_2._guide/node01B6.html iffparse.doc Includes_and_Autodocs_2._guide/node01B7.html HookEntry Includes_and_Autodocs_2._guide/node01B8.html iffparse.library/AllocIFF Includes_and_Autodocs_2._guide/node01B9.html iffparse.library/AllocLocalItem Includes_and_Autodocs_2._guide/node01BA.html iffparse.library/CloseClipboard Includes_and_Autodocs_2._guide/node01BB.html iffparse.library/CloseIFF Includes_and_Autodocs_2._guide/node01BC.html iffparse.library/CollectionChunk Includes_and_Autodocs_2._guide/node01BD.html iffparse.library/CollectionChunks Includes_and_Autodocs_2._guide/node01BE.html iffparse.library/CurrentChunk Includes_and_Autodocs_2._guide/node01BF.html iffparse.library/EntryHandler Includes_and_Autodocs_2._guide/node01C0.html iffparse.library/ExitHandler Includes_and_Autodocs_2._guide/node01C1.html iffparse.library/FindCollection Includes_and_Autodocs_2._guide/node01C2.html iffparse.library/FindLocalItem Includes_and_Autodocs_2._guide/node01C3.html iffparse.library/FindProp Includes_and_Autodocs_2._guide/node01C4.html iffparse.library/FindPropContext Includes_and_Autodocs_2._guide/node01C5.html iffparse.library/FreeIFF Includes_and_Autodocs_2._guide/node01C6.html iffparse.library/FreeLocalItem Includes_and_Autodocs_2._guide/node01C7.html iffparse.library/GoodID Includes_and_Autodocs_2._guide/node01C8.html iffparse.library/GoodType Includes_and_Autodocs_2._guide/node01C9.html iffparse.library/IDtoStr Includes_and_Autodocs_2._guide/node01CA.html iffparse.library/InitIFF Includes_and_Autodocs_2._guide/node01CB.html iffparse.library/InitIFFasClip Includes_and_Autodocs_2._guide/node01CC.html iffparse.library/InitIFFasDOS Includes_and_Autodocs_2._guide/node01CD.html iffparse.library/LocalItemData Includes_and_Autodocs_2._guide/node01CE.html iffparse.library/OpenClipboard Includes_and_Autodocs_2._guide/node01CF.html iffparse.library/OpenIFF Includes_and_Autodocs_2._guide/node01D0.html iffparse.library/ParentChunk Includes_and_Autodocs_2._guide/node01D1.html iffparse.library/ParseIFF Includes_and_Autodocs_2._guide/node01D2.html iffparse.library/PopChunk Includes_and_Autodocs_2._guide/node01D3.html iffparse.library/PropChunk Includes_and_Autodocs_2._guide/node01D4.html iffparse.library/PropChunks Includes_and_Autodocs_2._guide/node01D5.html iffparse.library/PushChunk Includes_and_Autodocs_2._guide/node01D6.html iffparse.library/ReadChunkBytes Includes_and_Autodocs_2._guide/node01D7.html iffparse.library/ReadChunkRecords Includes_and_Autodocs_2._guide/node01D8.html iffparse.library/SetLocalItemPurge Includes_and_Autodocs_2._guide/node01D9.html iffparse.library/StopChunk Includes_and_Autodocs_2._guide/node01DA.html iffparse.library/StopChunks Includes_and_Autodocs_2._guide/node01DB.html iffparse.library/StopOnExit Includes_and_Autodocs_2._guide/node01DC.html iffparse.library/StoreItemInContext Includes_and_Autodocs_2._guide/node01DD.html iffparse.library/StoreLocalItem Includes_and_Autodocs_2._guide/node01DE.html iffparse.library/WriteChunkBytes Includes_and_Autodocs_2._guide/node01DF.html iffparse.library/WriteChunkRecords Includes_and_Autodocs_2._guide/node01E0.html mathieeesingtrans.doc Includes_and_Autodocs_2._guide/node01E1.html mathieeesingtrans.library/IEEESPAcos Includes_and_Autodocs_2._guide/node01E2.html mathieeesingtrans.library/IEEESPAsin Includes_and_Autodocs_2._guide/node01E3.html mathieeesingtrans.library/IEEESPAtan Includes_and_Autodocs_2._guide/node01E4.html mathieeesingtrans.library/IEEESPCos Includes_and_Autodocs_2._guide/node01E5.html mathieeesingtrans.library/IEEESPCosh Includes_and_Autodocs_2._guide/node01E6.html mathieeesingtrans.library/IEEESPExp Includes_and_Autodocs_2._guide/node01E7.html mathieeesingtrans.library/IEEESPFieee Includes_and_Autodocs_2._guide/node01E8.html mathieeesingtrans.library/IEEESPLog Includes_and_Autodocs_2._guide/node01E9.html mathieeesingtrans.library/IEEESPLog10 Includes_and_Autodocs_2._guide/node01EA.html mathieeesingtrans.library/IEEESPPow Includes_and_Autodocs_2._guide/node01EB.html mathieeesingtrans.library/IEEESPSin Includes_and_Autodocs_2._guide/node01EC.html mathieeesingtrans.library/IEEESPSincos Includes_and_Autodocs_2._guide/node01ED.html mathieeesingtrans.library/IEEESPSinh Includes_and_Autodocs_2._guide/node01EE.html mathieeesingtrans.library/IEEESPSqrt Includes_and_Autodocs_2._guide/node01EF.html mathieeesingtrans.library/IEEESPTan Includes_and_Autodocs_2._guide/node01F0.html mathieeesingtrans.library/IEEESPTanh Includes_and_Autodocs_2._guide/node01F1.html mathieeesingtrans.library/IEEESPTieee Includes_and_Autodocs_2._guide/node01F2.html diskfont.doc Includes_and_Autodocs_2._guide/node01F3.html diskfont.library/AvailFonts Includes_and_Autodocs_2._guide/node01F4.html diskfont.library/DisposeFontContents Includes_and_Autodocs_2._guide/node01F5.html diskfont.library/NewFontContents Includes_and_Autodocs_2._guide/node01F6.html diskfont.library/NewScaledDiskFont Includes_and_Autodocs_2._guide/node01F7.html diskfont.library/OpenDiskFont Includes_and_Autodocs_2._guide/node01F8.html intuition.doc Includes_and_Autodocs_2._guide/node01F9.html intuition.library/ActivateGadget Includes_and_Autodocs_2._guide/node01FA.html intuition.library/ActivateWindow Includes_and_Autodocs_2._guide/node01FB.html intuition.library/AddClass Includes_and_Autodocs_2._guide/node01FC.html intuition.library/AddGadget Includes_and_Autodocs_2._guide/node01FD.html intuition.library/AddGList Includes_and_Autodocs_2._guide/node01FE.html intuition.library/AllocRemember Includes_and_Autodocs_2._guide/node01FF.html intuition.library/AutoRequest Includes_and_Autodocs_2._guide/node0200.html intuition.library/BeginRefresh Includes_and_Autodocs_2._guide/node0201.html intuition.library/BuildEasyRequestArgs Includes_and_Autodocs_2._guide/node0202.html intuition.library/BuildSysRequest Includes_and_Autodocs_2._guide/node0203.html intuition.library/ChangeWindowBox Includes_and_Autodocs_2._guide/node0204.html intuition.library/ClearDMRequest Includes_and_Autodocs_2._guide/node0205.html intuition.library/ClearMenuStrip Includes_and_Autodocs_2._guide/node0206.html intuition.library/ClearPointer Includes_and_Autodocs_2._guide/node0207.html intuition.library/CloseScreen Includes_and_Autodocs_2._guide/node0208.html intuition.library/CloseWindow Includes_and_Autodocs_2._guide/node0209.html intuition.library/CloseWorkBench Includes_and_Autodocs_2._guide/node020A.html intuition.library/CurrentTime Includes_and_Autodocs_2._guide/node020B.html intuition.library/DisplayAlert Includes_and_Autodocs_2._guide/node020C.html intuition.library/DisplayBeep Includes_and_Autodocs_2._guide/node020D.html intuition.library/DisposeObject Includes_and_Autodocs_2._guide/node020E.html intuition.library/DoubleClick Includes_and_Autodocs_2._guide/node020F.html intuition.library/DrawBorder Includes_and_Autodocs_2._guide/node0210.html intuition.library/DrawImage Includes_and_Autodocs_2._guide/node0211.html intuition.library/DrawImageState Includes_and_Autodocs_2._guide/node0212.html intuition.library/EasyRequestArgs Includes_and_Autodocs_2._guide/node0213.html intuition.library/EndRefresh Includes_and_Autodocs_2._guide/node0214.html intuition.library/EndRequest Includes_and_Autodocs_2._guide/node0215.html intuition.library/EraseImage Includes_and_Autodocs_2._guide/node0216.html intuition.library/FreeClass Includes_and_Autodocs_2._guide/node0217.html intuition.library/FreeRemember Includes_and_Autodocs_2._guide/node0218.html intuition.library/FreeScreenDrawInfo Includes_and_Autodocs_2._guide/node0219.html intuition.library/FreeSysRequest Includes_and_Autodocs_2._guide/node021A.html intuition.library/GadgetMouse Includes_and_Autodocs_2._guide/node021B.html intuition.library/GetAttr Includes_and_Autodocs_2._guide/node021C.html intuition.library/GetDefaultPubScreen Includes_and_Autodocs_2._guide/node021D.html intuition.library/GetDefPrefs Includes_and_Autodocs_2._guide/node021E.html intuition.library/GetPrefs Includes_and_Autodocs_2._guide/node021F.html intuition.library/GetScreenData Includes_and_Autodocs_2._guide/node0220.html intuition.library/GetScreenDrawInfo Includes_and_Autodocs_2._guide/node0221.html intuition.library/InitRequester Includes_and_Autodocs_2._guide/node0222.html intuition.library/IntuiTextLength Includes_and_Autodocs_2._guide/node0223.html intuition.library/ItemAddress Includes_and_Autodocs_2._guide/node0224.html intuition.library/LockIBase Includes_and_Autodocs_2._guide/node0225.html intuition.library/LockPubScreen Includes_and_Autodocs_2._guide/node0226.html intuition.library/LockPubScreenList Includes_and_Autodocs_2._guide/node0227.html intuition.library/MakeClass Includes_and_Autodocs_2._guide/node0228.html intuition.library/MakeScreen Includes_and_Autodocs_2._guide/node0229.html intuition.library/ModifyIDCMP Includes_and_Autodocs_2._guide/node022A.html intuition.library/ModifyProp Includes_and_Autodocs_2._guide/node022B.html intuition.library/MoveScreen Includes_and_Autodocs_2._guide/node022C.html intuition.library/MoveWindow Includes_and_Autodocs_2._guide/node022D.html intuition.library/MoveWindowInFrontOf Includes_and_Autodocs_2._guide/node022E.html intuition.library/NewModifyProp Includes_and_Autodocs_2._guide/node022F.html intuition.library/NewObject Includes_and_Autodocs_2._guide/node0230.html intuition.library/NextObject Includes_and_Autodocs_2._guide/node0231.html intuition.library/NextPubScreen Includes_and_Autodocs_2._guide/node0232.html intuition.library/ObtainGIRPort Includes_and_Autodocs_2._guide/node0233.html intuition.library/OffGadget Includes_and_Autodocs_2._guide/node0234.html intuition.library/OffMenu Includes_and_Autodocs_2._guide/node0235.html intuition.library/OnGadget Includes_and_Autodocs_2._guide/node0236.html intuition.library/OnMenu Includes_and_Autodocs_2._guide/node0237.html intuition.library/OpenScreen Includes_and_Autodocs_2._guide/node0238.html intuition.library/OpenScreenTagList Includes_and_Autodocs_2._guide/node0239.html intuition.library/OpenWindow Includes_and_Autodocs_2._guide/node023A.html intuition.library/OpenWindowTagList Includes_and_Autodocs_2._guide/node023B.html intuition.library/OpenWorkBench Includes_and_Autodocs_2._guide/node023C.html intuition.library/PointInImage Includes_and_Autodocs_2._guide/node023D.html intuition.library/PrintIText Includes_and_Autodocs_2._guide/node023E.html intuition.library/PubScreenStatus Includes_and_Autodocs_2._guide/node023F.html intuition.library/QueryOverscan Includes_and_Autodocs_2._guide/node0240.html intuition.library/RefreshGadgets Includes_and_Autodocs_2._guide/node0241.html intuition.library/RefreshGList Includes_and_Autodocs_2._guide/node0242.html intuition.library/RefreshWindowFrame Includes_and_Autodocs_2._guide/node0243.html intuition.library/ReleaseGIRPort Includes_and_Autodocs_2._guide/node0244.html intuition.library/RemakeDisplay Includes_and_Autodocs_2._guide/node0245.html intuition.library/RemoveClass Includes_and_Autodocs_2._guide/node0246.html intuition.library/RemoveGadget Includes_and_Autodocs_2._guide/node0247.html intuition.library/RemoveGList Includes_and_Autodocs_2._guide/node0248.html intuition.library/ReportMouse Includes_and_Autodocs_2._guide/node0249.html intuition.library/Request Includes_and_Autodocs_2._guide/node024A.html intuition.library/ResetMenuStrip Includes_and_Autodocs_2._guide/node024B.html intuition.library/RethinkDisplay Includes_and_Autodocs_2._guide/node024C.html intuition.library/ScreenToBack Includes_and_Autodocs_2._guide/node024D.html intuition.library/ScreenToFront Includes_and_Autodocs_2._guide/node024E.html intuition.library/SetAttrsA Includes_and_Autodocs_2._guide/node024F.html intuition.library/SetDefaultPubScreen Includes_and_Autodocs_2._guide/node0250.html intuition.library/SetDMRequest Includes_and_Autodocs_2._guide/node0251.html intuition.library/SetEditHook Includes_and_Autodocs_2._guide/node0252.html intuition.library/SetGadgetAttrsA Includes_and_Autodocs_2._guide/node0253.html intuition.library/SetMenuStrip Includes_and_Autodocs_2._guide/node0254.html intuition.library/SetMouseQueue Includes_and_Autodocs_2._guide/node0255.html intuition.library/SetPointer Includes_and_Autodocs_2._guide/node0256.html intuition.library/SetPrefs Includes_and_Autodocs_2._guide/node0257.html intuition.library/SetPubScreenModes Includes_and_Autodocs_2._guide/node0258.html intuition.library/SetWindowTitles Includes_and_Autodocs_2._guide/node0259.html intuition.library/ShowTitle Includes_and_Autodocs_2._guide/node025A.html intuition.library/SizeWindow Includes_and_Autodocs_2._guide/node025B.html intuition.library/SysReqHandler Includes_and_Autodocs_2._guide/node025C.html intuition.library/UnlockIBase Includes_and_Autodocs_2._guide/node025D.html intuition.library/UnlockPubScreen Includes_and_Autodocs_2._guide/node025E.html intuition.library/UnlockPubScreenList Includes_and_Autodocs_2._guide/node025F.html intuition.library/ViewAddress Includes_and_Autodocs_2._guide/node0260.html intuition.library/ViewPortAddress Includes_and_Autodocs_2._guide/node0261.html intuition.library/WBenchToBack Includes_and_Autodocs_2._guide/node0262.html intuition.library/WBenchToFront Includes_and_Autodocs_2._guide/node0263.html intuition.library/WindowLimits Includes_and_Autodocs_2._guide/node0264.html intuition.library/WindowToBack Includes_and_Autodocs_2._guide/node0265.html intuition.library/WindowToFront Includes_and_Autodocs_2._guide/node0266.html intuition.library/ZipWindow Includes_and_Autodocs_2._guide/node0267.html mathtrans.doc Includes_and_Autodocs_2._guide/node0268.html mathtrans.library/SPAcos Includes_and_Autodocs_2._guide/node0269.html mathtrans.library/SPAsin Includes_and_Autodocs_2._guide/node026A.html mathtrans.library/SPAtan Includes_and_Autodocs_2._guide/node026B.html mathtrans.library/SPCos Includes_and_Autodocs_2._guide/node026C.html mathtrans.library/SPCosh Includes_and_Autodocs_2._guide/node026D.html mathtrans.library/SPExp Includes_and_Autodocs_2._guide/node026E.html mathtrans.library/SPFieee Includes_and_Autodocs_2._guide/node026F.html mathtrans.library/SPLog Includes_and_Autodocs_2._guide/node0270.html mathtrans.library/SPLog10 Includes_and_Autodocs_2._guide/node0271.html mathtrans.library/SPPow Includes_and_Autodocs_2._guide/node0272.html mathtrans.library/SPSin Includes_and_Autodocs_2._guide/node0273.html mathtrans.library/SPSincos Includes_and_Autodocs_2._guide/node0274.html mathtrans.library/SPSinh Includes_and_Autodocs_2._guide/node0275.html mathtrans.library/SPSqrt Includes_and_Autodocs_2._guide/node0276.html mathtrans.library/SPTan Includes_and_Autodocs_2._guide/node0277.html mathtrans.library/SPTanh Includes_and_Autodocs_2._guide/node0278.html mathtrans.library/SPTieee Includes_and_Autodocs_2._guide/node0279.html dos.doc Includes_and_Autodocs_2._guide/node027A.html dos.library/AbortPkt Includes_and_Autodocs_2._guide/node027B.html dos.library/AddBuffers Includes_and_Autodocs_2._guide/node027C.html dos.library/AddDosEntry Includes_and_Autodocs_2._guide/node027D.html dos.library/AddPart Includes_and_Autodocs_2._guide/node027E.html dos.library/AddSegment Includes_and_Autodocs_2._guide/node027F.html dos.library/AllocDosObject Includes_and_Autodocs_2._guide/node0280.html dos.library/AssignAdd Includes_and_Autodocs_2._guide/node0281.html dos.library/AssignLate Includes_and_Autodocs_2._guide/node0282.html dos.library/AssignLock Includes_and_Autodocs_2._guide/node0283.html dos.library/AssignPath Includes_and_Autodocs_2._guide/node0284.html dos.library/AttemptLockDosList Includes_and_Autodocs_2._guide/node0285.html dos.library/ChangeMode Includes_and_Autodocs_2._guide/node0286.html dos.library/CheckSignal Includes_and_Autodocs_2._guide/node0287.html dos.library/Cli Includes_and_Autodocs_2._guide/node0288.html dos.library/CliInitNewcli Includes_and_Autodocs_2._guide/node0289.html dos.library/CliInitRun Includes_and_Autodocs_2._guide/node028A.html dos.library/Close Includes_and_Autodocs_2._guide/node028B.html dos.library/CompareDates Includes_and_Autodocs_2._guide/node028C.html dos.library/CreateDir Includes_and_Autodocs_2._guide/node028D.html dos.library/CreateNewProc Includes_and_Autodocs_2._guide/node028E.html dos.library/CreateProc Includes_and_Autodocs_2._guide/node028F.html dos.library/CurrentDir Includes_and_Autodocs_2._guide/node0290.html dos.library/DateStamp Includes_and_Autodocs_2._guide/node0291.html dos.library/DateToStr Includes_and_Autodocs_2._guide/node0292.html dos.library/Delay Includes_and_Autodocs_2._guide/node0293.html dos.library/DeleteFile Includes_and_Autodocs_2._guide/node0294.html dos.library/DeleteVar Includes_and_Autodocs_2._guide/node0295.html dos.library/DeviceProc Includes_and_Autodocs_2._guide/node0296.html dos.library/DoPkt Includes_and_Autodocs_2._guide/node0297.html dos.library/DupLock Includes_and_Autodocs_2._guide/node0298.html dos.library/DupLockFromFH Includes_and_Autodocs_2._guide/node0299.html dos.library/EndNotify Includes_and_Autodocs_2._guide/node029A.html dos.library/ErrorReport Includes_and_Autodocs_2._guide/node029B.html dos.library/ExAll Includes_and_Autodocs_2._guide/node029C.html dos.library/Examine Includes_and_Autodocs_2._guide/node029D.html dos.library/ExamineFH Includes_and_Autodocs_2._guide/node029E.html dos.library/Execute Includes_and_Autodocs_2._guide/node029F.html dos.library/Exit Includes_and_Autodocs_2._guide/node02A0.html dos.library/ExNext Includes_and_Autodocs_2._guide/node02A1.html dos.library/Fault Includes_and_Autodocs_2._guide/node02A2.html dos.library/FGetC Includes_and_Autodocs_2._guide/node02A3.html dos.library/FGets Includes_and_Autodocs_2._guide/node02A4.html dos.library/FilePart Includes_and_Autodocs_2._guide/node02A5.html dos.library/FindArg Includes_and_Autodocs_2._guide/node02A6.html dos.library/FindCliProc Includes_and_Autodocs_2._guide/node02A7.html dos.library/FindDosEntry Includes_and_Autodocs_2._guide/node02A8.html dos.library/FindSegment Includes_and_Autodocs_2._guide/node02A9.html dos.library/FindVar Includes_and_Autodocs_2._guide/node02AA.html dos.library/Flush Includes_and_Autodocs_2._guide/node02AB.html dos.library/Format Includes_and_Autodocs_2._guide/node02AC.html dos.library/FPutC Includes_and_Autodocs_2._guide/node02AD.html dos.library/FPuts Includes_and_Autodocs_2._guide/node02AE.html dos.library/FRead Includes_and_Autodocs_2._guide/node02AF.html dos.library/FreeArgs Includes_and_Autodocs_2._guide/node02B0.html dos.library/FreeDeviceProc Includes_and_Autodocs_2._guide/node02B1.html dos.library/FreeDosEntry Includes_and_Autodocs_2._guide/node02B2.html dos.library/FreeDosObject Includes_and_Autodocs_2._guide/node02B3.html dos.library/FWrite Includes_and_Autodocs_2._guide/node02B4.html dos.library/GetArgStr Includes_and_Autodocs_2._guide/node02B5.html dos.library/GetConsoleTask Includes_and_Autodocs_2._guide/node02B6.html dos.library/GetCurrentDirName Includes_and_Autodocs_2._guide/node02B7.html dos.library/GetDeviceProc Includes_and_Autodocs_2._guide/node02B8.html dos.library/GetFileSysTask Includes_and_Autodocs_2._guide/node02B9.html dos.library/GetProgramDir Includes_and_Autodocs_2._guide/node02BA.html dos.library/GetProgramName Includes_and_Autodocs_2._guide/node02BB.html dos.library/GetPrompt Includes_and_Autodocs_2._guide/node02BC.html dos.library/GetVar Includes_and_Autodocs_2._guide/node02BD.html dos.library/Info Includes_and_Autodocs_2._guide/node02BE.html dos.library/Inhibit Includes_and_Autodocs_2._guide/node02BF.html dos.library/Input Includes_and_Autodocs_2._guide/node02C0.html dos.library/InternalLoadSeg Includes_and_Autodocs_2._guide/node02C1.html dos.library/InternalUnLoadSeg Includes_and_Autodocs_2._guide/node02C2.html dos.library/IoErr Includes_and_Autodocs_2._guide/node02C3.html dos.library/IsFileSystem Includes_and_Autodocs_2._guide/node02C4.html dos.library/IsInteractive Includes_and_Autodocs_2._guide/node02C5.html dos.library/LoadSeg Includes_and_Autodocs_2._guide/node02C6.html dos.library/Lock Includes_and_Autodocs_2._guide/node02C7.html dos.library/LockDosList Includes_and_Autodocs_2._guide/node02C8.html dos.library/LockRecord Includes_and_Autodocs_2._guide/node02C9.html dos.library/LockRecords Includes_and_Autodocs_2._guide/node02CA.html dos.library/MakeDosEntry Includes_and_Autodocs_2._guide/node02CB.html dos.library/MakeLink Includes_and_Autodocs_2._guide/node02CC.html dos.library/MatchEnd Includes_and_Autodocs_2._guide/node02CD.html dos.library/MatchFirst Includes_and_Autodocs_2._guide/node02CE.html dos.library/MatchNext Includes_and_Autodocs_2._guide/node02CF.html dos.library/MatchPattern Includes_and_Autodocs_2._guide/node02D0.html dos.library/MatchPatternNoCase Includes_and_Autodocs_2._guide/node02D1.html dos.library/MaxCli Includes_and_Autodocs_2._guide/node02D2.html dos.library/NameFromFH Includes_and_Autodocs_2._guide/node02D3.html dos.library/NameFromLock Includes_and_Autodocs_2._guide/node02D4.html dos.library/NewLoadSeg Includes_and_Autodocs_2._guide/node02D5.html dos.library/NextDosEntry Includes_and_Autodocs_2._guide/node02D6.html dos.library/Open Includes_and_Autodocs_2._guide/node02D7.html dos.library/OpenFromLock Includes_and_Autodocs_2._guide/node02D8.html dos.library/Output Includes_and_Autodocs_2._guide/node02D9.html dos.library/ParentDir Includes_and_Autodocs_2._guide/node02DA.html dos.library/ParentOfFH Includes_and_Autodocs_2._guide/node02DB.html dos.library/ParsePattern Includes_and_Autodocs_2._guide/node02DC.html dos.library/ParsePatternNoCase Includes_and_Autodocs_2._guide/node02DD.html dos.library/PathPart Includes_and_Autodocs_2._guide/node02DE.html dos.library/PrintFault Includes_and_Autodocs_2._guide/node02DF.html dos.library/PutStr Includes_and_Autodocs_2._guide/node02E0.html dos.library/Read Includes_and_Autodocs_2._guide/node02E1.html dos.library/ReadArgs Includes_and_Autodocs_2._guide/node02E2.html dos.library/ReadItem Includes_and_Autodocs_2._guide/node02E3.html dos.library/ReadLink Includes_and_Autodocs_2._guide/node02E4.html dos.library/Relabel Includes_and_Autodocs_2._guide/node02E5.html dos.library/RemAssignList Includes_and_Autodocs_2._guide/node02E6.html dos.library/RemDosEntry Includes_and_Autodocs_2._guide/node02E7.html dos.library/RemSegment Includes_and_Autodocs_2._guide/node02E8.html dos.library/Rename Includes_and_Autodocs_2._guide/node02E9.html dos.library/ReplyPkt Includes_and_Autodocs_2._guide/node02EA.html dos.library/RunCommand Includes_and_Autodocs_2._guide/node02EB.html dos.library/SameDevice Includes_and_Autodocs_2._guide/node02EC.html dos.library/SameLock Includes_and_Autodocs_2._guide/node02ED.html dos.library/Seek Includes_and_Autodocs_2._guide/node02EE.html dos.library/SelectInput Includes_and_Autodocs_2._guide/node02EF.html dos.library/SelectOutput Includes_and_Autodocs_2._guide/node02F0.html dos.library/SendPkt Includes_and_Autodocs_2._guide/node02F1.html dos.library/SetArgStr Includes_and_Autodocs_2._guide/node02F2.html dos.library/SetComment Includes_and_Autodocs_2._guide/node02F3.html dos.library/SetConsoleTask Includes_and_Autodocs_2._guide/node02F4.html dos.library/SetCurrentDirName Includes_and_Autodocs_2._guide/node02F5.html dos.library/SetFileDate Includes_and_Autodocs_2._guide/node02F6.html dos.library/SetFileSize Includes_and_Autodocs_2._guide/node02F7.html dos.library/SetFileSysTask Includes_and_Autodocs_2._guide/node02F8.html dos.library/SetIoErr Includes_and_Autodocs_2._guide/node02F9.html dos.library/SetMode Includes_and_Autodocs_2._guide/node02FA.html dos.library/SetProgramDir Includes_and_Autodocs_2._guide/node02FB.html dos.library/SetProgramName Includes_and_Autodocs_2._guide/node02FC.html dos.library/SetPrompt Includes_and_Autodocs_2._guide/node02FD.html dos.library/SetProtection Includes_and_Autodocs_2._guide/node02FE.html dos.library/SetVar Includes_and_Autodocs_2._guide/node02FF.html dos.library/SetVBuf Includes_and_Autodocs_2._guide/node0300.html dos.library/SplitName Includes_and_Autodocs_2._guide/node0301.html dos.library/StartNotify Includes_and_Autodocs_2._guide/node0302.html dos.library/StrToDate Includes_and_Autodocs_2._guide/node0303.html dos.library/StrToLong Includes_and_Autodocs_2._guide/node0304.html dos.library/SystemTagList Includes_and_Autodocs_2._guide/node0305.html dos.library/UnGetC Includes_and_Autodocs_2._guide/node0306.html dos.library/UnLoadSeg Includes_and_Autodocs_2._guide/node0307.html dos.library/UnLock Includes_and_Autodocs_2._guide/node0308.html dos.library/UnLockDosList Includes_and_Autodocs_2._guide/node0309.html dos.library/UnLockRecord Includes_and_Autodocs_2._guide/node030A.html dos.library/UnLockRecords Includes_and_Autodocs_2._guide/node030B.html dos.library/VFPrintf Includes_and_Autodocs_2._guide/node030C.html dos.library/VFWritef Includes_and_Autodocs_2._guide/node030D.html dos.library/VPrintf Includes_and_Autodocs_2._guide/node030E.html dos.library/WaitForChar Includes_and_Autodocs_2._guide/node030F.html dos.library/WaitPkt Includes_and_Autodocs_2._guide/node0310.html dos.library/Write Includes_and_Autodocs_2._guide/node0311.html dos.library/WriteChars Includes_and_Autodocs_2._guide/node0312.html keymap.doc Includes_and_Autodocs_2._guide/node0313.html keymap.library/AskKeyMapDefault Includes_and_Autodocs_2._guide/node0314.html keymap.library/MapANSI Includes_and_Autodocs_2._guide/node0315.html keymap.library/MapRawKey Includes_and_Autodocs_2._guide/node0316.html keymap.library/SetKeyMapDefault Includes_and_Autodocs_2._guide/node0317.html rexxsyslib.doc Includes_and_Autodocs_2._guide/node0318.html rexxsyslib.library/ClearRexxMsg Includes_and_Autodocs_2._guide/node0319.html rexxsyslib.library/CreateArgstring Includes_and_Autodocs_2._guide/node031A.html rexxsyslib.library/CreateRexxMsg Includes_and_Autodocs_2._guide/node031B.html rexxsyslib.library/DeleteArgstring Includes_and_Autodocs_2._guide/node031C.html rexxsyslib.library/DeleteRexxMsg Includes_and_Autodocs_2._guide/node031D.html rexxsyslib.library/FillRexxMsg Includes_and_Autodocs_2._guide/node031E.html rexxsyslib.library/IsRexxMsg Includes_and_Autodocs_2._guide/node031F.html rexxsyslib.library/LengthArgstring Includes_and_Autodocs_2._guide/node0320.html rexxsyslib.library/LockRexxBase Includes_and_Autodocs_2._guide/node0321.html rexxsyslib.library/UnlockRexxBase Includes_and_Autodocs_2._guide/node0322.html exec.doc Includes_and_Autodocs_2._guide/node0323.html exec.library/AbortIO Includes_and_Autodocs_2._guide/node0324.html exec.library/AddDevice Includes_and_Autodocs_2._guide/node0325.html exec.library/AddHead Includes_and_Autodocs_2._guide/node0326.html exec.library/AddIntServer Includes_and_Autodocs_2._guide/node0327.html exec.library/AddLibrary Includes_and_Autodocs_2._guide/node0328.html exec.library/AddMemList Includes_and_Autodocs_2._guide/node0329.html exec.library/AddPort Includes_and_Autodocs_2._guide/node032A.html exec.library/AddResource Includes_and_Autodocs_2._guide/node032B.html exec.library/AddSemaphore Includes_and_Autodocs_2._guide/node032C.html exec.library/AddTail Includes_and_Autodocs_2._guide/node032D.html exec.library/AddTask Includes_and_Autodocs_2._guide/node032E.html exec.library/Alert Includes_and_Autodocs_2._guide/node032F.html exec.library/AllocAbs Includes_and_Autodocs_2._guide/node0330.html exec.library/Allocate Includes_and_Autodocs_2._guide/node0331.html exec.library/AllocEntry Includes_and_Autodocs_2._guide/node0332.html exec.library/AllocMem Includes_and_Autodocs_2._guide/node0333.html exec.library/AllocSignal Includes_and_Autodocs_2._guide/node0334.html exec.library/AllocTrap Includes_and_Autodocs_2._guide/node0335.html exec.library/AllocVec Includes_and_Autodocs_2._guide/node0336.html exec.library/AttemptSemaphore Includes_and_Autodocs_2._guide/node0337.html exec.library/AvailMem Includes_and_Autodocs_2._guide/node0338.html exec.library/CacheClearE Includes_and_Autodocs_2._guide/node0339.html exec.library/CacheClearU Includes_and_Autodocs_2._guide/node033A.html exec.library/CacheControl Includes_and_Autodocs_2._guide/node033B.html exec.library/CachePostDMA Includes_and_Autodocs_2._guide/node033C.html exec.library/CachePreDMA Includes_and_Autodocs_2._guide/node033D.html exec.library/Cause Includes_and_Autodocs_2._guide/node033E.html exec.library/CheckIO Includes_and_Autodocs_2._guide/node033F.html exec.library/CloseDevice Includes_and_Autodocs_2._guide/node0340.html exec.library/CloseLibrary Includes_and_Autodocs_2._guide/node0341.html exec.library/ColdReboot Includes_and_Autodocs_2._guide/node0342.html exec.library/CopyMem Includes_and_Autodocs_2._guide/node0343.html exec.library/CopyMemQuick Includes_and_Autodocs_2._guide/node0344.html exec.library/CreateIORequest Includes_and_Autodocs_2._guide/node0345.html exec.library/CreateMsgPort Includes_and_Autodocs_2._guide/node0346.html exec.library/Deallocate Includes_and_Autodocs_2._guide/node0347.html exec.library/Debug Includes_and_Autodocs_2._guide/node0348.html exec.library/DeleteIORequest Includes_and_Autodocs_2._guide/node0349.html exec.library/DeleteMsgPort Includes_and_Autodocs_2._guide/node034A.html exec.library/Disable Includes_and_Autodocs_2._guide/node034B.html exec.library/DoIO Includes_and_Autodocs_2._guide/node034C.html exec.library/Enable Includes_and_Autodocs_2._guide/node034D.html exec.library/Enqueue Includes_and_Autodocs_2._guide/node034E.html exec.library/FindName Includes_and_Autodocs_2._guide/node034F.html exec.library/FindPort Includes_and_Autodocs_2._guide/node0350.html exec.library/FindResident Includes_and_Autodocs_2._guide/node0351.html exec.library/FindSemaphore Includes_and_Autodocs_2._guide/node0352.html exec.library/FindTask Includes_and_Autodocs_2._guide/node0353.html exec.library/Forbid Includes_and_Autodocs_2._guide/node0354.html exec.library/FreeEntry Includes_and_Autodocs_2._guide/node0355.html exec.library/FreeMem Includes_and_Autodocs_2._guide/node0356.html exec.library/FreeSignal Includes_and_Autodocs_2._guide/node0357.html exec.library/FreeTrap Includes_and_Autodocs_2._guide/node0358.html exec.library/FreeVec Includes_and_Autodocs_2._guide/node0359.html exec.library/GetCC Includes_and_Autodocs_2._guide/node035A.html exec.library/GetMsg Includes_and_Autodocs_2._guide/node035B.html exec.library/InitCode Includes_and_Autodocs_2._guide/node035C.html exec.library/InitResident Includes_and_Autodocs_2._guide/node035D.html exec.library/InitSemaphore Includes_and_Autodocs_2._guide/node035E.html exec.library/InitStruct Includes_and_Autodocs_2._guide/node035F.html exec.library/Insert Includes_and_Autodocs_2._guide/node0360.html exec.library/MakeFunctions Includes_and_Autodocs_2._guide/node0361.html exec.library/MakeLibrary Includes_and_Autodocs_2._guide/node0362.html exec.library/ObtainSemaphore Includes_and_Autodocs_2._guide/node0363.html exec.library/ObtainSemaphoreList Includes_and_Autodocs_2._guide/node0364.html exec.library/ObtainSemaphoreShared Includes_and_Autodocs_2._guide/node0365.html exec.library/OldOpenLibrary Includes_and_Autodocs_2._guide/node0366.html exec.library/OpenDevice Includes_and_Autodocs_2._guide/node0367.html exec.library/OpenLibrary Includes_and_Autodocs_2._guide/node0368.html exec.library/OpenResource Includes_and_Autodocs_2._guide/node0369.html exec.library/Permit Includes_and_Autodocs_2._guide/node036A.html exec.library/Procure Includes_and_Autodocs_2._guide/node036B.html exec.library/PutMsg Includes_and_Autodocs_2._guide/node036C.html exec.library/RawDoFmt Includes_and_Autodocs_2._guide/node036D.html exec.library/ReleaseSemaphore Includes_and_Autodocs_2._guide/node036E.html exec.library/ReleaseSemaphoreList Includes_and_Autodocs_2._guide/node036F.html exec.library/RemDevice Includes_and_Autodocs_2._guide/node0370.html exec.library/RemHead Includes_and_Autodocs_2._guide/node0371.html exec.library/RemIntServer Includes_and_Autodocs_2._guide/node0372.html exec.library/RemLibrary Includes_and_Autodocs_2._guide/node0373.html exec.library/Remove Includes_and_Autodocs_2._guide/node0374.html exec.library/RemPort Includes_and_Autodocs_2._guide/node0375.html exec.library/RemResource Includes_and_Autodocs_2._guide/node0376.html exec.library/RemSemaphore Includes_and_Autodocs_2._guide/node0377.html exec.library/RemTail Includes_and_Autodocs_2._guide/node0378.html exec.library/RemTask Includes_and_Autodocs_2._guide/node0379.html exec.library/ReplyMsg Includes_and_Autodocs_2._guide/node037A.html exec.library/SendIO Includes_and_Autodocs_2._guide/node037B.html exec.library/SetExcept Includes_and_Autodocs_2._guide/node037C.html exec.library/SetFunction Includes_and_Autodocs_2._guide/node037D.html exec.library/SetIntVector Includes_and_Autodocs_2._guide/node037E.html exec.library/SetSignal Includes_and_Autodocs_2._guide/node037F.html exec.library/SetSR Includes_and_Autodocs_2._guide/node0380.html exec.library/SetTaskPri Includes_and_Autodocs_2._guide/node0381.html exec.library/Signal Includes_and_Autodocs_2._guide/node0382.html exec.library/StackSwap Includes_and_Autodocs_2._guide/node0383.html exec.library/SumKickData Includes_and_Autodocs_2._guide/node0384.html exec.library/SumLibrary Includes_and_Autodocs_2._guide/node0385.html exec.library/SuperState Includes_and_Autodocs_2._guide/node0386.html exec.library/Supervisor Includes_and_Autodocs_2._guide/node0387.html exec.library/TypeOfMem Includes_and_Autodocs_2._guide/node0388.html exec.library/UserState Includes_and_Autodocs_2._guide/node0389.html exec.library/Vacate Includes_and_Autodocs_2._guide/node038A.html exec.library/Wait Includes_and_Autodocs_2._guide/node038B.html exec.library/WaitIO Includes_and_Autodocs_2._guide/node038C.html exec.library/WaitPort Includes_and_Autodocs_2._guide/node038D.html layers.doc Includes_and_Autodocs_2._guide/node038E.html layers.library/BeginUpdate Includes_and_Autodocs_2._guide/node038F.html layers.library/BehindLayer Includes_and_Autodocs_2._guide/node0390.html layers.library/CreateBehindHookLayer Includes_and_Autodocs_2._guide/node0391.html layers.library/CreateBehindLayer Includes_and_Autodocs_2._guide/node0392.html layers.library/CreateUpfrontHookLayer Includes_and_Autodocs_2._guide/node0393.html layers.library/CreateUpfrontLayer Includes_and_Autodocs_2._guide/node0394.html layers.library/DeleteLayer Includes_and_Autodocs_2._guide/node0395.html layers.library/DisposeLayerInfo Includes_and_Autodocs_2._guide/node0396.html layers.library/EndUpdate Includes_and_Autodocs_2._guide/node0397.html layers.library/FattenLayerInfo Includes_and_Autodocs_2._guide/node0398.html layers.library/InitLayers Includes_and_Autodocs_2._guide/node0399.html layers.library/InstallClipRegion Includes_and_Autodocs_2._guide/node039A.html layers.library/InstallLayerHook Includes_and_Autodocs_2._guide/node039B.html layers.library/LockLayer Includes_and_Autodocs_2._guide/node039C.html layers.library/LockLayerInfo Includes_and_Autodocs_2._guide/node039D.html layers.library/LockLayers Includes_and_Autodocs_2._guide/node039E.html layers.library/MoveLayer Includes_and_Autodocs_2._guide/node039F.html layers.library/MoveLayerInFrontOf Includes_and_Autodocs_2._guide/node03A0.html layers.library/MoveSizeLayer Includes_and_Autodocs_2._guide/node03A1.html layers.library/NewLayerInfo Includes_and_Autodocs_2._guide/node03A2.html layers.library/ScrollLayer Includes_and_Autodocs_2._guide/node03A3.html layers.library/SizeLayer Includes_and_Autodocs_2._guide/node03A4.html layers.library/SwapBitsRastPortClipRect Includes_and_Autodocs_2._guide/node03A5.html layers.library/ThinLayerInfo Includes_and_Autodocs_2._guide/node03A6.html layers.library/UnlockLayer Includes_and_Autodocs_2._guide/node03A7.html layers.library/UnlockLayerInfo Includes_and_Autodocs_2._guide/node03A8.html layers.library/UnlockLayers Includes_and_Autodocs_2._guide/node03A9.html layers.library/UpfrontLayer Includes_and_Autodocs_2._guide/node03AA.html layers.library/WhichLayer Includes_and_Autodocs_2._guide/node03AB.html translator.doc Includes_and_Autodocs_2._guide/node03AC.html translator.library/Translate Includes_and_Autodocs_2._guide/node03AD.html expansion.doc Includes_and_Autodocs_2._guide/node03AE.html expansion.library/AddBootNode Includes_and_Autodocs_2._guide/node03AF.html expansion.library/AddConfigDev Includes_and_Autodocs_2._guide/node03B0.html expansion.library/AddDosNode Includes_and_Autodocs_2._guide/node03B1.html expansion.library/AllocConfigDev Includes_and_Autodocs_2._guide/node03B2.html expansion.library/AllocExpansionMem Includes_and_Autodocs_2._guide/node03B3.html expansion.library/ConfigBoard Includes_and_Autodocs_2._guide/node03B4.html expansion.library/FindConfigDev Includes_and_Autodocs_2._guide/node03B5.html expansion.library/FreeConfigDev Includes_and_Autodocs_2._guide/node03B6.html expansion.library/FreeExpansionMem Includes_and_Autodocs_2._guide/node03B7.html expansion.library/GetCurrentBinding Includes_and_Autodocs_2._guide/node03B8.html expansion.library/MakeDosNode Includes_and_Autodocs_2._guide/node03B9.html expansion.library/ObtainConfigBinding Includes_and_Autodocs_2._guide/node03BA.html expansion.library/ReadExpansionByte Includes_and_Autodocs_2._guide/node03BB.html expansion.library/ReadExpansionRom Includes_and_Autodocs_2._guide/node03BC.html expansion.library/ReleaseConfigBinding Includes_and_Autodocs_2._guide/node03BD.html expansion.library/RemConfigDev Includes_and_Autodocs_2._guide/node03BE.html expansion.library/SetCurrentBinding Includes_and_Autodocs_2._guide/node03BF.html expansion.library/WriteExpansionByte Includes_and_Autodocs_2._guide/node03C0.html mathffp.doc Includes_and_Autodocs_2._guide/node03C1.html mathffp.library/SPAbs Includes_and_Autodocs_2._guide/node03C2.html mathffp.library/SPAdd Includes_and_Autodocs_2._guide/node03C3.html mathffp.library/SPCeil Includes_and_Autodocs_2._guide/node03C4.html mathffp.library/SPCmp Includes_and_Autodocs_2._guide/node03C5.html mathffp.library/SPDiv Includes_and_Autodocs_2._guide/node03C6.html mathffp.library/SPFix Includes_and_Autodocs_2._guide/node03C7.html mathffp.library/SPFloor Includes_and_Autodocs_2._guide/node03C8.html mathffp.library/SPFlt Includes_and_Autodocs_2._guide/node03C9.html mathffp.library/SPMul Includes_and_Autodocs_2._guide/node03CA.html mathffp.library/SPNeg Includes_and_Autodocs_2._guide/node03CB.html mathffp.library/SPSub Includes_and_Autodocs_2._guide/node03CC.html mathffp.library/SPTst Includes_and_Autodocs_2._guide/node03CD.html utility.doc Includes_and_Autodocs_2._guide/node03CE.html utility.library/AllocateTagItems Includes_and_Autodocs_2._guide/node03CF.html utility.library/Amiga2Date Includes_and_Autodocs_2._guide/node03D0.html utility.library/CallHookPkt Includes_and_Autodocs_2._guide/node03D1.html utility.library/CheckDate Includes_and_Autodocs_2._guide/node03D2.html utility.library/CloneTagItems Includes_and_Autodocs_2._guide/node03D3.html utility.library/Date2Amiga Includes_and_Autodocs_2._guide/node03D4.html utility.library/FilterTagChanges Includes_and_Autodocs_2._guide/node03D5.html utility.library/FilterTagItems Includes_and_Autodocs_2._guide/node03D6.html utility.library/FindTagItem Includes_and_Autodocs_2._guide/node03D7.html utility.library/FreeTagItems Includes_and_Autodocs_2._guide/node03D8.html utility.library/GetTagData Includes_and_Autodocs_2._guide/node03D9.html utility.library/MapTags Includes_and_Autodocs_2._guide/node03DA.html utility.library/NextTagItem Includes_and_Autodocs_2._guide/node03DB.html utility.library/PackBoolTags Includes_and_Autodocs_2._guide/node03DC.html utility.library/RefreshTagItemClones Includes_and_Autodocs_2._guide/node03DD.html utility.library/SDivMod32 Includes_and_Autodocs_2._guide/node03DE.html utility.library/SMult32 Includes_and_Autodocs_2._guide/node03DF.html utility.library/Stricmp Includes_and_Autodocs_2._guide/node03E0.html utility.library/Strnicmp Includes_and_Autodocs_2._guide/node03E1.html utility.library/TagInArray Includes_and_Autodocs_2._guide/node03E2.html utility.library/ToLower Includes_and_Autodocs_2._guide/node03E3.html utility.library/ToUpper Includes_and_Autodocs_2._guide/node03E4.html utility.library/UDivMod32 Includes_and_Autodocs_2._guide/node03E5.html utility.library/UMult32 Includes_and_Autodocs_2._guide/node03E6.html gadtools.doc Includes_and_Autodocs_2._guide/node03E7.html gadtools.library/CreateContext Includes_and_Autodocs_2._guide/node03E8.html gadtools.library/CreateGadgetA Includes_and_Autodocs_2._guide/node03E9.html gadtools.library/CreateMenusA Includes_and_Autodocs_2._guide/node03EA.html gadtools.library/DrawBevelBoxA Includes_and_Autodocs_2._guide/node03EB.html gadtools.library/FreeGadgets Includes_and_Autodocs_2._guide/node03EC.html gadtools.library/FreeMenus Includes_and_Autodocs_2._guide/node03ED.html gadtools.library/FreeVisualInfo Includes_and_Autodocs_2._guide/node03EE.html gadtools.library/GetVisualInfoA Includes_and_Autodocs_2._guide/node03EF.html gadtools.library/GT_BeginRefresh Includes_and_Autodocs_2._guide/node03F0.html gadtools.library/GT_EndRefresh Includes_and_Autodocs_2._guide/node03F1.html gadtools.library/GT_FilterIMsg Includes_and_Autodocs_2._guide/node03F2.html gadtools.library/GT_GetIMsg Includes_and_Autodocs_2._guide/node03F3.html gadtools.library/GT_PostFilterIMsg Includes_and_Autodocs_2._guide/node03F4.html gadtools.library/GT_RefreshWindow Includes_and_Autodocs_2._guide/node03F5.html gadtools.library/GT_ReplyIMsg Includes_and_Autodocs_2._guide/node03F6.html gadtools.library/GT_SetGadgetAttrsA Includes_and_Autodocs_2._guide/node03F7.html gadtools.library/LayoutMenuItemsA Includes_and_Autodocs_2._guide/node03F8.html gadtools.library/LayoutMenusA Includes_and_Autodocs_2._guide/node03F9.html mathieeedoubbas.doc Includes_and_Autodocs_2._guide/node03FA.html mathieeedoubbas.library/IEEEDPAbs Includes_and_Autodocs_2._guide/node03FB.html mathieeedoubbas.library/IEEEDPAdd Includes_and_Autodocs_2._guide/node03FC.html mathieeedoubbas.library/IEEEDPCeil Includes_and_Autodocs_2._guide/node03FD.html mathieeedoubbas.library/IEEEDPCmp Includes_and_Autodocs_2._guide/node03FE.html mathieeedoubbas.library/IEEEDPDiv Includes_and_Autodocs_2._guide/node03FF.html mathieeedoubbas.library/IEEEDPFix Includes_and_Autodocs_2._guide/node0400.html mathieeedoubbas.library/IEEEDPFloor Includes_and_Autodocs_2._guide/node0401.html mathieeedoubbas.library/IEEEDPFlt Includes_and_Autodocs_2._guide/node0402.html mathieeedoubbas.library/IEEEDPMul Includes_and_Autodocs_2._guide/node0403.html mathieeedoubbas.library/IEEEDPNeg Includes_and_Autodocs_2._guide/node0404.html mathieeedoubbas.library/IEEEDPSub Includes_and_Autodocs_2._guide/node0405.html mathieeedoubbas.library/IEEEDPTst Includes_and_Autodocs_2._guide/node0406.html wb.doc Includes_and_Autodocs_2._guide/node0407.html workbench.library/AddAppIconA Includes_and_Autodocs_2._guide/node0408.html workbench.library/AddAppMenuItemA Includes_and_Autodocs_2._guide/node0409.html workbench.library/AddAppWindowA Includes_and_Autodocs_2._guide/node040A.html workbench.library/RemoveAppIcon Includes_and_Autodocs_2._guide/node040B.html workbench.library/RemoveAppMenuItem Includes_and_Autodocs_2._guide/node040C.html workbench.library/RemoveAppWindow Includes_and_Autodocs_2._guide/node040D.html graphics.doc Includes_and_Autodocs_2._guide/node040E.html graphics.library/AddAnimOb Includes_and_Autodocs_2._guide/node040F.html graphics.library/AddBob Includes_and_Autodocs_2._guide/node0410.html graphics.library/AddFont Includes_and_Autodocs_2._guide/node0411.html graphics.library/AddVSprite Includes_and_Autodocs_2._guide/node0412.html graphics.library/AllocRaster Includes_and_Autodocs_2._guide/node0413.html graphics.library/AndRectRegion Includes_and_Autodocs_2._guide/node0414.html graphics.library/AndRegionRegion Includes_and_Autodocs_2._guide/node0415.html graphics.library/Animate Includes_and_Autodocs_2._guide/node0416.html graphics.library/AreaCircle Includes_and_Autodocs_2._guide/node0417.html graphics.library/AreaDraw Includes_and_Autodocs_2._guide/node0418.html graphics.library/AreaEllipse Includes_and_Autodocs_2._guide/node0419.html graphics.library/AreaEnd Includes_and_Autodocs_2._guide/node041A.html graphics.library/AreaMove Includes_and_Autodocs_2._guide/node041B.html graphics.library/AskFont Includes_and_Autodocs_2._guide/node041C.html graphics.library/AskSoftStyle Includes_and_Autodocs_2._guide/node041D.html graphics.library/AttemptLockLayerRom Includes_and_Autodocs_2._guide/node041E.html graphics.library/BitMapScale Includes_and_Autodocs_2._guide/node041F.html graphics.library/BltBitMap Includes_and_Autodocs_2._guide/node0420.html graphics.library/BltBitMapRastPort Includes_and_Autodocs_2._guide/node0421.html graphics.library/BltClear Includes_and_Autodocs_2._guide/node0422.html graphics.library/BltMaskBitMapRastPort Includes_and_Autodocs_2._guide/node0423.html graphics.library/BltPattern Includes_and_Autodocs_2._guide/node0424.html graphics.library/BltTemplate Includes_and_Autodocs_2._guide/node0425.html graphics.library/CBump Includes_and_Autodocs_2._guide/node0426.html graphics.library/CEND Includes_and_Autodocs_2._guide/node0427.html graphics.library/ChangeSprite Includes_and_Autodocs_2._guide/node0428.html graphics.library/CINIT Includes_and_Autodocs_2._guide/node0429.html graphics.library/ClearEOL Includes_and_Autodocs_2._guide/node042A.html graphics.library/ClearRectRegion Includes_and_Autodocs_2._guide/node042B.html graphics.library/ClearRegion Includes_and_Autodocs_2._guide/node042C.html graphics.library/ClearScreen Includes_and_Autodocs_2._guide/node042D.html graphics.library/ClipBlit Includes_and_Autodocs_2._guide/node042E.html graphics.library/CloseFont Includes_and_Autodocs_2._guide/node042F.html graphics.library/CloseMonitor Includes_and_Autodocs_2._guide/node0430.html graphics.library/CMOVE Includes_and_Autodocs_2._guide/node0431.html graphics.library/CopySBitMap Includes_and_Autodocs_2._guide/node0432.html graphics.library/CWAIT Includes_and_Autodocs_2._guide/node0433.html graphics.library/DisownBlitter Includes_and_Autodocs_2._guide/node0434.html graphics.library/DisposeRegion Includes_and_Autodocs_2._guide/node0435.html graphics.library/DoCollision Includes_and_Autodocs_2._guide/node0436.html graphics.library/Draw Includes_and_Autodocs_2._guide/node0437.html graphics.library/DrawEllipse Includes_and_Autodocs_2._guide/node0438.html graphics.library/DrawGList Includes_and_Autodocs_2._guide/node0439.html graphics.library/EraseRect Includes_and_Autodocs_2._guide/node043A.html graphics.library/ExtendFont Includes_and_Autodocs_2._guide/node043B.html graphics.library/FindDisplayInfo Includes_and_Autodocs_2._guide/node043C.html graphics.library/Flood Includes_and_Autodocs_2._guide/node043D.html graphics.library/FontExtent Includes_and_Autodocs_2._guide/node043E.html graphics.library/FreeColorMap Includes_and_Autodocs_2._guide/node043F.html graphics.library/FreeCopList Includes_and_Autodocs_2._guide/node0440.html graphics.library/FreeCprList Includes_and_Autodocs_2._guide/node0441.html graphics.library/FreeGBuffers Includes_and_Autodocs_2._guide/node0442.html graphics.library/FreeRaster Includes_and_Autodocs_2._guide/node0443.html graphics.library/FreeSprite Includes_and_Autodocs_2._guide/node0444.html graphics.library/FreeVPortCopLists Includes_and_Autodocs_2._guide/node0445.html graphics.library/GetColorMap Includes_and_Autodocs_2._guide/node0446.html graphics.library/GetDisplayInfoData Includes_and_Autodocs_2._guide/node0447.html graphics.library/GetGBuffers Includes_and_Autodocs_2._guide/node0448.html graphics.library/GetRGB4 Includes_and_Autodocs_2._guide/node0449.html graphics.library/GetSprite Includes_and_Autodocs_2._guide/node044A.html graphics.library/GetVPModeID Includes_and_Autodocs_2._guide/node044B.html graphics.library/GfxAssociate Includes_and_Autodocs_2._guide/node044C.html graphics.library/GfxFree Includes_and_Autodocs_2._guide/node044D.html graphics.library/GfxLookUP Includes_and_Autodocs_2._guide/node044E.html graphics.library/GfxNew Includes_and_Autodocs_2._guide/node044F.html graphics.library/InitArea Includes_and_Autodocs_2._guide/node0450.html graphics.library/InitBitMap Includes_and_Autodocs_2._guide/node0451.html graphics.library/InitGels Includes_and_Autodocs_2._guide/node0452.html graphics.library/InitGMasks Includes_and_Autodocs_2._guide/node0453.html graphics.library/InitMasks Includes_and_Autodocs_2._guide/node0454.html graphics.library/InitRastPort Includes_and_Autodocs_2._guide/node0455.html graphics.library/InitTmpRas Includes_and_Autodocs_2._guide/node0456.html graphics.library/InitView Includes_and_Autodocs_2._guide/node0457.html graphics.library/InitVPort Includes_and_Autodocs_2._guide/node0458.html graphics.library/LoadRGB4 Includes_and_Autodocs_2._guide/node0459.html graphics.library/LoadView Includes_and_Autodocs_2._guide/node045A.html graphics.library/LockLayerRom Includes_and_Autodocs_2._guide/node045B.html graphics.library/MakeVPort Includes_and_Autodocs_2._guide/node045C.html graphics.library/ModeNotAvailable Includes_and_Autodocs_2._guide/node045D.html graphics.library/Move Includes_and_Autodocs_2._guide/node045E.html graphics.library/MoveSprite Includes_and_Autodocs_2._guide/node045F.html graphics.library/MrgCop Includes_and_Autodocs_2._guide/node0460.html graphics.library/NewRegion Includes_and_Autodocs_2._guide/node0461.html graphics.library/NextDisplayInfo Includes_and_Autodocs_2._guide/node0462.html graphics.library/OpenFont Includes_and_Autodocs_2._guide/node0463.html graphics.library/OpenMonitor Includes_and_Autodocs_2._guide/node0464.html graphics.library/OrRectRegion Includes_and_Autodocs_2._guide/node0465.html graphics.library/OrRegionRegion Includes_and_Autodocs_2._guide/node0466.html graphics.library/OwnBlitter Includes_and_Autodocs_2._guide/node0467.html graphics.library/PolyDraw Includes_and_Autodocs_2._guide/node0468.html graphics.library/QBlit Includes_and_Autodocs_2._guide/node0469.html graphics.library/QBSBlit Includes_and_Autodocs_2._guide/node046A.html graphics.library/ReadPixel Includes_and_Autodocs_2._guide/node046B.html graphics.library/ReadPixelArray8 Includes_and_Autodocs_2._guide/node046C.html graphics.library/ReadPixelLine8 Includes_and_Autodocs_2._guide/node046D.html graphics.library/RectFill Includes_and_Autodocs_2._guide/node046E.html graphics.library/RemBob Includes_and_Autodocs_2._guide/node046F.html graphics.library/RemFont Includes_and_Autodocs_2._guide/node0470.html graphics.library/RemIBob Includes_and_Autodocs_2._guide/node0471.html graphics.library/RemVSprite Includes_and_Autodocs_2._guide/node0472.html graphics.library/ScalerDiv Includes_and_Autodocs_2._guide/node0473.html graphics.library/ScrollRaster Includes_and_Autodocs_2._guide/node0474.html graphics.library/ScrollVPort Includes_and_Autodocs_2._guide/node0475.html graphics.library/SetAPen Includes_and_Autodocs_2._guide/node0476.html graphics.library/SetBPen Includes_and_Autodocs_2._guide/node0477.html graphics.library/SetCollision Includes_and_Autodocs_2._guide/node0478.html graphics.library/SetDrMd Includes_and_Autodocs_2._guide/node0479.html graphics.library/SetFont Includes_and_Autodocs_2._guide/node047A.html graphics.library/SetOPen Includes_and_Autodocs_2._guide/node047B.html graphics.library/SetRast Includes_and_Autodocs_2._guide/node047C.html graphics.library/SetRGB4 Includes_and_Autodocs_2._guide/node047D.html graphics.library/SetRGB4CM Includes_and_Autodocs_2._guide/node047E.html graphics.library/SetSoftStyle Includes_and_Autodocs_2._guide/node047F.html graphics.library/SortGList Includes_and_Autodocs_2._guide/node0480.html graphics.library/StripFont Includes_and_Autodocs_2._guide/node0481.html graphics.library/SyncSBitMap Includes_and_Autodocs_2._guide/node0482.html graphics.library/Text Includes_and_Autodocs_2._guide/node0483.html graphics.library/TextExtent Includes_and_Autodocs_2._guide/node0484.html graphics.library/TextFit Includes_and_Autodocs_2._guide/node0485.html graphics.library/TextLength Includes_and_Autodocs_2._guide/node0486.html graphics.library/UnlockLayerRom Includes_and_Autodocs_2._guide/node0487.html graphics.library/VBeamPos Includes_and_Autodocs_2._guide/node0488.html graphics.library/VideoControl Includes_and_Autodocs_2._guide/node0489.html graphics.library/WaitBlit Includes_and_Autodocs_2._guide/node048A.html graphics.library/WaitBOVP Includes_and_Autodocs_2._guide/node048B.html graphics.library/WaitTOF Includes_and_Autodocs_2._guide/node048C.html graphics.library/WeighTAMatch Includes_and_Autodocs_2._guide/node048D.html graphics.library/WritePixel Includes_and_Autodocs_2._guide/node048E.html graphics.library/WritePixelArray8 Includes_and_Autodocs_2._guide/node048F.html graphics.library/WritePixelLine8 Includes_and_Autodocs_2._guide/node0490.html graphics.library/XorRectRegion Includes_and_Autodocs_2._guide/node0491.html graphics.library/XorRegionRegion Includes_and_Autodocs_2._guide/node0492.html mathieeedoubtrans.doc Includes_and_Autodocs_2._guide/node0493.html mathieeedoubtrans.library/IEEEDPAcos Includes_and_Autodocs_2._guide/node0494.html mathieeedoubtrans.library/IEEEDPAsin Includes_and_Autodocs_2._guide/node0495.html mathieeedoubtrans.library/IEEEDPAtan Includes_and_Autodocs_2._guide/node0496.html mathieeedoubtrans.library/IEEEDPCos Includes_and_Autodocs_2._guide/node0497.html mathieeedoubtrans.library/IEEEDPCosh Includes_and_Autodocs_2._guide/node0498.html mathieeedoubtrans.library/IEEEDPExp Includes_and_Autodocs_2._guide/node0499.html mathieeedoubtrans.library/IEEEDPFieee Includes_and_Autodocs_2._guide/node049A.html mathieeedoubtrans.library/IEEEDPLog Includes_and_Autodocs_2._guide/node049B.html mathieeedoubtrans.library/IEEEDPLog10 Includes_and_Autodocs_2._guide/node049C.html mathieeedoubtrans.library/IEEEDPPow Includes_and_Autodocs_2._guide/node049D.html mathieeedoubtrans.library/IEEEDPSin Includes_and_Autodocs_2._guide/node049E.html mathieeedoubtrans.library/IEEEDPSincos Includes_and_Autodocs_2._guide/node049F.html mathieeedoubtrans.library/IEEEDPSinh Includes_and_Autodocs_2._guide/node04A0.html mathieeedoubtrans.library/IEEEDPSqrt Includes_and_Autodocs_2._guide/node04A1.html mathieeedoubtrans.library/IEEEDPTan Includes_and_Autodocs_2._guide/node04A2.html mathieeedoubtrans.library/IEEEDPTanh Includes_and_Autodocs_2._guide/node04A3.html mathieeedoubtrans.library/IEEEDPTieee Includes_and_Autodocs_2._guide/node04A4.html audio.doc Includes_and_Autodocs_2._guide/node04A5.html audio.device/AbortIO Includes_and_Autodocs_2._guide/node04A6.html audio.device/ADCMD_ALLOCATE Includes_and_Autodocs_2._guide/node04A7.html audio.device/ADCMD_FINISH Includes_and_Autodocs_2._guide/node04A8.html audio.device/ADCMD_FREE Includes_and_Autodocs_2._guide/node04A9.html audio.device/ADCMD_LOCK Includes_and_Autodocs_2._guide/node04AA.html audio.device/ADCMD_PERVOL Includes_and_Autodocs_2._guide/node04AB.html audio.device/ADCMD_SETPREC Includes_and_Autodocs_2._guide/node04AC.html audio.device/ADCMD_WAITCYCLE Includes_and_Autodocs_2._guide/node04AD.html audio.device/BeginIO Includes_and_Autodocs_2._guide/node04AE.html audio.device/CloseDevice Includes_and_Autodocs_2._guide/node04AF.html audio.device/CMD_CLEAR Includes_and_Autodocs_2._guide/node04B0.html audio.device/CMD_FLUSH Includes_and_Autodocs_2._guide/node04B1.html audio.device/CMD_READ Includes_and_Autodocs_2._guide/node04B2.html audio.device/CMD_RESET Includes_and_Autodocs_2._guide/node04B3.html audio.device/CMD_START Includes_and_Autodocs_2._guide/node04B4.html audio.device/CMD_STOP Includes_and_Autodocs_2._guide/node04B5.html audio.device/CMD_UPDATE Includes_and_Autodocs_2._guide/node04B6.html audio.device/CMD_WRITE Includes_and_Autodocs_2._guide/node04B7.html audio.device/Expunge Includes_and_Autodocs_2._guide/node04B8.html audio.device/OpenDevice Includes_and_Autodocs_2._guide/node04B9.html gameport.doc Includes_and_Autodocs_2._guide/node04BA.html gameport.device/GPD_ASKCTYPE Includes_and_Autodocs_2._guide/node04BB.html gameport.device/GPD_ASKTRIGGER Includes_and_Autodocs_2._guide/node04BC.html gameport.device/GPD_READEVENT Includes_and_Autodocs_2._guide/node04BD.html gameport.device/GPD_SETCTYPE Includes_and_Autodocs_2._guide/node04BE.html gameport.device/GPD_SETTRIGGER Includes_and_Autodocs_2._guide/node04BF.html narrator.doc Includes_and_Autodocs_2._guide/node04C0.html narrator.device/AbortIO Includes_and_Autodocs_2._guide/node04C1.html narrator.device/CloseDevice Includes_and_Autodocs_2._guide/node04C2.html narrator.device/CMD_FLUSH Includes_and_Autodocs_2._guide/node04C3.html narrator.device/CMD_Read Includes_and_Autodocs_2._guide/node04C4.html narrator.device/CMD_RESET Includes_and_Autodocs_2._guide/node04C5.html narrator.device/CMD_START Includes_and_Autodocs_2._guide/node04C6.html narrator.device/CMD_STOP Includes_and_Autodocs_2._guide/node04C7.html narrator.device/CMD_WRITE Includes_and_Autodocs_2._guide/node04C8.html narrator.device/OpenDevice Includes_and_Autodocs_2._guide/node04C9.html serial.doc Includes_and_Autodocs_2._guide/node04CA.html serial.device/AbortIO Includes_and_Autodocs_2._guide/node04CB.html serial.device/BeginIO Includes_and_Autodocs_2._guide/node04CC.html serial.device/CloseDevice Includes_and_Autodocs_2._guide/node04CD.html serial.device/CMD_CLEAR Includes_and_Autodocs_2._guide/node04CE.html serial.device/CMD_FLUSH Includes_and_Autodocs_2._guide/node04CF.html serial.device/CMD_READ Includes_and_Autodocs_2._guide/node04D0.html serial.device/CMD_RESET Includes_and_Autodocs_2._guide/node04D1.html serial.device/CMD_START Includes_and_Autodocs_2._guide/node04D2.html serial.device/CMD_STOP Includes_and_Autodocs_2._guide/node04D3.html serial.device/CMD_WRITE Includes_and_Autodocs_2._guide/node04D4.html serial.device/OpenDevice Includes_and_Autodocs_2._guide/node04D5.html serial.device/SDCMD_BREAK Includes_and_Autodocs_2._guide/node04D6.html serial.device/SDCMD_QUERY Includes_and_Autodocs_2._guide/node04D7.html serial.device/SDCMD_SETPARAMS Includes_and_Autodocs_2._guide/node04D8.html clipboard.doc Includes_and_Autodocs_2._guide/node04D9.html clipboard.device/CBD_CHANGEHOOK Includes_and_Autodocs_2._guide/node04DA.html clipboard.device/CBD_CURRENTREADID Includes_and_Autodocs_2._guide/node04DB.html clipboard.device/CBD_CURRENTWRITEID Includes_and_Autodocs_2._guide/node04DC.html clipboard.device/CBD_POST Includes_and_Autodocs_2._guide/node04DD.html clipboard.device/CMD_READ Includes_and_Autodocs_2._guide/node04DE.html clipboard.device/CMD_UPDATE Includes_and_Autodocs_2._guide/node04DF.html clipboard.device/CMD_WRITE Includes_and_Autodocs_2._guide/node04E0.html input.doc Includes_and_Autodocs_2._guide/node04E1.html input.device/IND_ADDHANDLER Includes_and_Autodocs_2._guide/node04E2.html input.device/IND_REMHANDLER Includes_and_Autodocs_2._guide/node04E3.html input.device/IND_SETMPORT Includes_and_Autodocs_2._guide/node04E4.html input.device/IND_SETMTRIG Includes_and_Autodocs_2._guide/node04E5.html input.device/IND_SETMTYPE Includes_and_Autodocs_2._guide/node04E6.html input.device/IND_SETPERIOD Includes_and_Autodocs_2._guide/node04E7.html input.device/IND_SETTHRESH Includes_and_Autodocs_2._guide/node04E8.html input.device/IND_WRITEEVENT Includes_and_Autodocs_2._guide/node04E9.html input.device/PeekQualifier Includes_and_Autodocs_2._guide/node04EA.html parallel.doc Includes_and_Autodocs_2._guide/node04EB.html parallel.device/CMD_CLEAR Includes_and_Autodocs_2._guide/node04EC.html parallel.device/CMD_FLUSH Includes_and_Autodocs_2._guide/node04ED.html parallel.device/CMD_READ Includes_and_Autodocs_2._guide/node04EE.html parallel.device/CMD_RESET Includes_and_Autodocs_2._guide/node04EF.html parallel.device/CMD_START Includes_and_Autodocs_2._guide/node04F0.html parallel.device/CMD_STOP Includes_and_Autodocs_2._guide/node04F1.html parallel.device/CMD_WRITE Includes_and_Autodocs_2._guide/node04F2.html parallel.device/OpenDevice Includes_and_Autodocs_2._guide/node04F3.html parallel.device/PDCMD_QUERY Includes_and_Autodocs_2._guide/node04F4.html parallel.device/PDCMD_SETPARAMS Includes_and_Autodocs_2._guide/node04F5.html timer.doc Includes_and_Autodocs_2._guide/node04F6.html timer.device/--background-- Includes_and_Autodocs_2._guide/node04F7.html timer.device/AbortIO Includes_and_Autodocs_2._guide/node04F8.html timer.device/AddTime Includes_and_Autodocs_2._guide/node04F9.html timer.device/CmpTime Includes_and_Autodocs_2._guide/node04FA.html timer.device/GetSysTime Includes_and_Autodocs_2._guide/node04FB.html timer.device/ReadEClock Includes_and_Autodocs_2._guide/node04FC.html timer.device/SubTime Includes_and_Autodocs_2._guide/node04FD.html timer.device/TR_ADDREQUEST Includes_and_Autodocs_2._guide/node04FE.html timer.device/TR_GETSYSTIME Includes_and_Autodocs_2._guide/node04FF.html timer.device/TR_SETSYSTIME Includes_and_Autodocs_2._guide/node0500.html console.doc Includes_and_Autodocs_2._guide/node0501.html console.device/CD_ASKDEFAULTKEYMAP Includes_and_Autodocs_2._guide/node0502.html console.device/CD_ASKKEYMAP Includes_and_Autodocs_2._guide/node0503.html console.device/CD_SETDEFAULTKEYMAP Includes_and_Autodocs_2._guide/node0504.html console.device/CD_SETKEYMAP Includes_and_Autodocs_2._guide/node0505.html console.device/CDInputHandler Includes_and_Autodocs_2._guide/node0506.html console.device/CMD_CLEAR Includes_and_Autodocs_2._guide/node0507.html console.device/CMD_READ Includes_and_Autodocs_2._guide/node0508.html console.device/CMD_WRITE Includes_and_Autodocs_2._guide/node0509.html console.device/OpenDevice Includes_and_Autodocs_2._guide/node050A.html console.device/RawKeyConvert Includes_and_Autodocs_2._guide/node050B.html keyboard.doc Includes_and_Autodocs_2._guide/node050C.html keyboard.device/CMD_CLEAR Includes_and_Autodocs_2._guide/node050D.html keyboard.device/KBD_ADDRESETHANDLER Includes_and_Autodocs_2._guide/node050E.html keyboard.device/KBD_READEVENT Includes_and_Autodocs_2._guide/node050F.html keyboard.device/KBD_READMATRIX Includes_and_Autodocs_2._guide/node0510.html keyboard.device/KBD_REMRESETHANDLER Includes_and_Autodocs_2._guide/node0511.html keyboard.device/KBD_RESETHANDLERDONE Includes_and_Autodocs_2._guide/node0512.html printer.doc Includes_and_Autodocs_2._guide/node0513.html printer.device/CMD_FLUSH Includes_and_Autodocs_2._guide/node0514.html printer.device/CMD_INVALID Includes_and_Autodocs_2._guide/node0515.html printer.device/CMD_RESET Includes_and_Autodocs_2._guide/node0516.html printer.device/CMD_START Includes_and_Autodocs_2._guide/node0517.html printer.device/CMD_STOP Includes_and_Autodocs_2._guide/node0518.html printer.device/CMD_WRITE Includes_and_Autodocs_2._guide/node0519.html printer.device/PRD_DUMPRPORT Includes_and_Autodocs_2._guide/node051A.html printer.device/PRD_PRTCOMMAND Includes_and_Autodocs_2._guide/node051B.html printer.device/PRD_QUERY Includes_and_Autodocs_2._guide/node051C.html printer.device/PRD_RAWWRITE Includes_and_Autodocs_2._guide/node051D.html printer.device/PWrite Includes_and_Autodocs_2._guide/node051E.html trackdisk.doc Includes_and_Autodocs_2._guide/node051F.html trackdisk.device/CMD_CLEAR Includes_and_Autodocs_2._guide/node0520.html trackdisk.device/CMD_READ Includes_and_Autodocs_2._guide/node0521.html trackdisk.device/CMD_UPDATE Includes_and_Autodocs_2._guide/node0522.html trackdisk.device/CMD_WRITE Includes_and_Autodocs_2._guide/node0523.html trackdisk.device/TD_ADDCHANGEINT Includes_and_Autodocs_2._guide/node0524.html trackdisk.device/TD_CHANGENUM Includes_and_Autodocs_2._guide/node0525.html trackdisk.device/TD_CHANGESTATE Includes_and_Autodocs_2._guide/node0526.html trackdisk.device/TD_EJECT Includes_and_Autodocs_2._guide/node0527.html trackdisk.device/TD_FORMAT Includes_and_Autodocs_2._guide/node0528.html trackdisk.device/TD_GETDRIVETYPE Includes_and_Autodocs_2._guide/node0529.html trackdisk.device/TD_GETGEOMETRY Includes_and_Autodocs_2._guide/node052A.html trackdisk.device/TD_GETNUMTRACKS Includes_and_Autodocs_2._guide/node052B.html trackdisk.device/TD_MOTOR Includes_and_Autodocs_2._guide/node052C.html trackdisk.device/TD_PROTSTATUS Includes_and_Autodocs_2._guide/node052D.html trackdisk.device/TD_RAWREAD Includes_and_Autodocs_2._guide/node052E.html trackdisk.device/TD_RAWWRITE Includes_and_Autodocs_2._guide/node052F.html trackdisk.device/TD_REMCHANGEINT Includes_and_Autodocs_2._guide/node0530.html trackdisk.device/TD_SEEK Includes_and_Autodocs_2._guide/node0531.html battclock.doc Includes_and_Autodocs_2._guide/node0532.html battclock.resource/ReadBattClock Includes_and_Autodocs_2._guide/node0533.html battclock.resource/ResetBattClock Includes_and_Autodocs_2._guide/node0534.html battclock.resource/WriteBattClock Includes_and_Autodocs_2._guide/node0535.html cia.doc Includes_and_Autodocs_2._guide/node0536.html cia.resource/AbleICR Includes_and_Autodocs_2._guide/node0537.html cia.resource/AddICRVector Includes_and_Autodocs_2._guide/node0538.html cia.resource/RemICRVector Includes_and_Autodocs_2._guide/node0539.html cia.resource/SetICR Includes_and_Autodocs_2._guide/node053A.html filesysres.doc Includes_and_Autodocs_2._guide/node053B.html FileSystem.resource/--background-- Includes_and_Autodocs_2._guide/node053C.html potgo.doc Includes_and_Autodocs_2._guide/node053D.html potgo.resource/AllocPotBits Includes_and_Autodocs_2._guide/node053E.html potgo.resource/FreePotBits Includes_and_Autodocs_2._guide/node053F.html potgo.resource/WritePotgo Includes_and_Autodocs_2._guide/node0540.html battmem.doc Includes_and_Autodocs_2._guide/node0541.html battmem.resource/ObtainBattSemaphore Includes_and_Autodocs_2._guide/node0542.html battmem.resource/ReadBattMem Includes_and_Autodocs_2._guide/node0543.html battmem.resource/ReleaseBattSemaphore Includes_and_Autodocs_2._guide/node0544.html battmem.resource/WriteBattMem Includes_and_Autodocs_2._guide/node0545.html disk.doc Includes_and_Autodocs_2._guide/node0546.html disk.resource/AllocUnit Includes_and_Autodocs_2._guide/node0547.html disk.resource/FreeUnit Includes_and_Autodocs_2._guide/node0548.html disk.resource/GetUnit Includes_and_Autodocs_2._guide/node0549.html disk.resource/GetUnitID Includes_and_Autodocs_2._guide/node054A.html disk.resource/GiveUnit Includes_and_Autodocs_2._guide/node054B.html disk.resource/ReadUnitID Includes_and_Autodocs_2._guide/node054C.html misc.doc Includes_and_Autodocs_2._guide/node054D.html misc.resource/AllocMiscResource Includes_and_Autodocs_2._guide/node054E.html misc.resource/FreeMiscResource Includes_and_Autodocs_2._guide/node054F.html 2.0 Function Index Includes_and_Autodocs_2._guide/node0550.html References/Function.offs Includes_and_Autodocs_2._guide/node0551.html References/Structure.offs Includes_and_Autodocs_2._guide/node0552.html 2.0 Structure Index Includes_and_Autodocs_2._guide/node0553.html 2.0 IncludeXREF: A Includes_and_Autodocs_2._guide/node0554.html 2.0 IncludeXREF: B Includes_and_Autodocs_2._guide/node0555.html 2.0 IncludeXREF: C Includes_and_Autodocs_2._guide/node0556.html 2.0 IncludeXREF: D Includes_and_Autodocs_2._guide/node0557.html 2.0 IncludeXREF: E Includes_and_Autodocs_2._guide/node0558.html 2.0 IncludeXREF: F Includes_and_Autodocs_2._guide/node0559.html 2.0 IncludeXREF: G Includes_and_Autodocs_2._guide/node055A.html 2.0 IncludeXREF: H Includes_and_Autodocs_2._guide/node055B.html 2.0 IncludeXREF: I Includes_and_Autodocs_2._guide/node055C.html 2.0 IncludeXREF: J Includes_and_Autodocs_2._guide/node055D.html 2.0 IncludeXREF: K Includes_and_Autodocs_2._guide/node055E.html 2.0 IncludeXREF: L Includes_and_Autodocs_2._guide/node055F.html 2.0 IncludeXREF: M Includes_and_Autodocs_2._guide/node0560.html 2.0 IncludeXREF: N Includes_and_Autodocs_2._guide/node0561.html 2.0 IncludeXREF: O Includes_and_Autodocs_2._guide/node0562.html 2.0 IncludeXREF: P Includes_and_Autodocs_2._guide/node0563.html 2.0 IncludeXREF: Q Includes_and_Autodocs_2._guide/node0564.html 2.0 IncludeXREF: R Includes_and_Autodocs_2._guide/node0565.html 2.0 IncludeXREF: S Includes_and_Autodocs_2._guide/node0566.html 2.0 IncludeXREF: T Includes_and_Autodocs_2._guide/node0567.html 2.0 IncludeXREF: U Includes_and_Autodocs_2._guide/node0568.html 2.0 IncludeXREF: V Includes_and_Autodocs_2._guide/node0569.html 2.0 IncludeXREF: W Includes_and_Autodocs_2._guide/node056A.html 2.0 IncludeXREF: X Includes_and_Autodocs_2._guide/node056B.html 2.0 IncludeXREF: Y Includes_and_Autodocs_2._guide/node056C.html 2.0 IncludeXREF: Z Includes_and_Autodocs_2._guide/node056D.html FD/asl_lib.fd Includes_and_Autodocs_2._guide/node056E.html FD/icon_lib.fd Includes_and_Autodocs_2._guide/node056F.html FD/potgo_lib.fd Includes_and_Autodocs_2._guide/node0570.html FD/battclock_lib.fd Includes_and_Autodocs_2._guide/node0571.html FD/iffparse_lib.fd Includes_and_Autodocs_2._guide/node0572.html FD/ramdrive_lib.fd Includes_and_Autodocs_2._guide/node0573.html FD/battmem_lib.fd Includes_and_Autodocs_2._guide/node0574.html FD/input_lib.fd Includes_and_Autodocs_2._guide/node0575.html FD/rexxsyslib_lib.fd Includes_and_Autodocs_2._guide/node0576.html FD/cia_lib.fd Includes_and_Autodocs_2._guide/node0577.html FD/intuition_lib.fd Includes_and_Autodocs_2._guide/node0578.html FD/timer_lib.fd Includes_and_Autodocs_2._guide/node0579.html FD/commodities_lib.fd Includes_and_Autodocs_2._guide/node057A.html FD/keymap_lib.fd Includes_and_Autodocs_2._guide/node057B.html FD/translator_lib.fd Includes_and_Autodocs_2._guide/node057C.html FD/console_lib.fd Includes_and_Autodocs_2._guide/node057D.html FD/layers_lib.fd Includes_and_Autodocs_2._guide/node057E.html FD/utility_lib.fd Includes_and_Autodocs_2._guide/node057F.html FD/disk_lib.fd Includes_and_Autodocs_2._guide/node0580.html FD/mathffp_lib.fd Includes_and_Autodocs_2._guide/node0581.html FD/wb_lib.fd Includes_and_Autodocs_2._guide/node0582.html FD/diskfont_lib.fd Includes_and_Autodocs_2._guide/node0583.html FD/mathieeedoubbas_lib.fd Includes_and_Autodocs_2._guide/node0584.html FD/dos_lib.fd Includes_and_Autodocs_2._guide/node0585.html FD/mathieeedoubtrans_lib.fd Includes_and_Autodocs_2._guide/node0586.html FD/exec_lib.fd Includes_and_Autodocs_2._guide/node0587.html FD/mathieeesingbas_lib.fd Includes_and_Autodocs_2._guide/node0588.html FD/expansion_lib.fd Includes_and_Autodocs_2._guide/node0589.html FD/mathieeesingtrans_lib.fd Includes_and_Autodocs_2._guide/node058A.html FD/gadtools_lib.fd Includes_and_Autodocs_2._guide/node058B.html FD/mathtrans_lib.fd Includes_and_Autodocs_2._guide/node058C.html FD/graphics_lib.fd Includes_and_Autodocs_2._guide/node058D.html FD/misc_lib.fd Includes_and_Autodocs_2._guide/node058E.html Text_Autodocs/amiga_lib.doc Includes_and_Autodocs_2._guide/node058F.html Text_Autodocs/ddebug_lib.doc Includes_and_Autodocs_2._guide/node0590.html Text_Autodocs/debug_lib.doc Includes_and_Autodocs_2._guide/node0591.html Text_Autodocs/asl.doc Includes_and_Autodocs_2._guide/node0592.html Text_Autodocs/icon.doc Includes_and_Autodocs_2._guide/node0593.html Text_Autodocs/mathieeesingbas.doc Includes_and_Autodocs_2._guide/node0594.html Text_Autodocs/commodities.doc Includes_and_Autodocs_2._guide/node0595.html Text_Autodocs/iffparse.doc Includes_and_Autodocs_2._guide/node0596.html Text_Autodocs/mathieeesingtrans.doc Includes_and_Autodocs_2._guide/node0597.html Text_Autodocs/diskfont.doc Includes_and_Autodocs_2._guide/node0598.html Text_Autodocs/intuition.doc Includes_and_Autodocs_2._guide/node0599.html Text_Autodocs/mathtrans.doc Includes_and_Autodocs_2._guide/node059A.html Text_Autodocs/dos.doc Includes_and_Autodocs_2._guide/node059B.html Text_Autodocs/keymap.doc Includes_and_Autodocs_2._guide/node059C.html Text_Autodocs/rexxsyslib.doc Includes_and_Autodocs_2._guide/node059D.html Text_Autodocs/exec.doc Includes_and_Autodocs_2._guide/node059E.html Text_Autodocs/layers.doc Includes_and_Autodocs_2._guide/node059F.html Text_Autodocs/translator.doc Includes_and_Autodocs_2._guide/node05A0.html Text_Autodocs/expansion.doc Includes_and_Autodocs_2._guide/node05A1.html Text_Autodocs/mathffp.doc Includes_and_Autodocs_2._guide/node05A2.html Text_Autodocs/utility.doc Includes_and_Autodocs_2._guide/node05A3.html Text_Autodocs/gadtools.doc Includes_and_Autodocs_2._guide/node05A4.html Text_Autodocs/mathieeedoubbas.doc Includes_and_Autodocs_2._guide/node05A5.html Text_Autodocs/wb.doc Includes_and_Autodocs_2._guide/node05A6.html Text_Autodocs/graphics.doc Includes_and_Autodocs_2._guide/node05A7.html Text_Autodocs/mathieeedoubtrans.doc Includes_and_Autodocs_2._guide/node05A8.html Text_Autodocs/audio.doc Includes_and_Autodocs_2._guide/node05A9.html Text_Autodocs/gameport.doc Includes_and_Autodocs_2._guide/node05AA.html Text_Autodocs/narrator.doc Includes_and_Autodocs_2._guide/node05AB.html Text_Autodocs/serial.doc Includes_and_Autodocs_2._guide/node05AC.html Text_Autodocs/clipboard.doc Includes_and_Autodocs_2._guide/node05AD.html Text_Autodocs/input.doc Includes_and_Autodocs_2._guide/node05AE.html Text_Autodocs/parallel.doc Includes_and_Autodocs_2._guide/node05AF.html Text_Autodocs/timer.doc Includes_and_Autodocs_2._guide/node05B0.html Text_Autodocs/console.doc Includes_and_Autodocs_2._guide/node05B1.html Text_Autodocs/keyboard.doc Includes_and_Autodocs_2._guide/node05B2.html Text_Autodocs/printer.doc Includes_and_Autodocs_2._guide/node05B3.html Text_Autodocs/trackdisk.doc Includes_and_Autodocs_2._guide/node05B4.html Text_Autodocs/battclock.doc Includes_and_Autodocs_2._guide/node05B5.html Text_Autodocs/cia.doc Includes_and_Autodocs_2._guide/node05B6.html Text_Autodocs/filesysres.doc Includes_and_Autodocs_2._guide/node05B7.html Text_Autodocs/potgo.doc Includes_and_Autodocs_2._guide/node05B8.html Text_Autodocs/battmem.doc Includes_and_Autodocs_2._guide/node05B9.html Text_Autodocs/disk.doc Includes_and_Autodocs_2._guide/node05BA.html Text_Autodocs/misc.doc Includes_and_Autodocs_3._guide/node0000.html Autodocs Table of Contents Includes_and_Autodocs_3._guide/node0001.html Library Function Index Includes_and_Autodocs_3._guide/node0002.html Device Command Index Includes_and_Autodocs_3._guide/node0003.html C Structure Index Includes_and_Autodocs_3._guide/node0004.html amigaguide.doc Includes_and_Autodocs_3._guide/node0005.html amigaguide.library/--background-- Includes_and_Autodocs_3._guide/node0006.html amigaguide.library/--rexxhost-- Includes_and_Autodocs_3._guide/node0007.html amigaguide.library/AddAmigaGuideHostA Includes_and_Autodocs_3._guide/node0008.html amigaguide.library/AmigaGuideSignal Includes_and_Autodocs_3._guide/node0009.html amigaguide.library/CloseAmigaGuide Includes_and_Autodocs_3._guide/node000A.html amigaguide.library/GetAmigaGuideAttr Includes_and_Autodocs_3._guide/node000B.html amigaguide.library/GetAmigaGuideMsg Includes_and_Autodocs_3._guide/node000C.html amigaguide.library/GetAmigaGuideString Includes_and_Autodocs_3._guide/node000D.html amigaguide.library/LockAmigaGuideBase Includes_and_Autodocs_3._guide/node000E.html amigaguide.library/OpenAmigaGuideA Includes_and_Autodocs_3._guide/node000F.html amigaguide.library/OpenAmigaGuideAsyncAmigaguide.library/OpenAmigaGuideAsyncA Includes_and_Autodocs_3._guide/node0010.html amigaguide.library/RemoveAmigaGuideHostAgaguide.library/RemoveAmigaGuideHostA Includes_and_Autodocs_3._guide/node0011.html amigaguide.library/ReplyAmigaGuideMsg Includes_and_Autodocs_3._guide/node0012.html amigaguide.library/SendAmigaGuideCmdA Includes_and_Autodocs_3._guide/node0013.html amigaguide.library/SendAmigaGuideContextAguide.library/SendAmigaGuideContextA Includes_and_Autodocs_3._guide/node0014.html amigaguide.library/SetAmigaGuideAttrsA Includes_and_Autodocs_3._guide/node0015.html amigaguide.library/SetAmigaGuideContextAgaguide.library/SetAmigaGuideContextA Includes_and_Autodocs_3._guide/node0016.html amigaguide.library/UnlockAmigaGuideBasemigaguide.library/UnlockAmigaGuideBase Includes_and_Autodocs_3._guide/node0017.html amigaguide_dtc.doc Includes_and_Autodocs_3._guide/node0018.html amigaguide.class/GetAGString Includes_and_Autodocs_3._guide/node0019.html amigaguide/amigaguide.datatype Includes_and_Autodocs_3._guide/node001A.html amiga_lib.doc Includes_and_Autodocs_3._guide/node001B.html amiga.lib/ACrypt Includes_and_Autodocs_3._guide/node001C.html amiga.lib/AddTOF Includes_and_Autodocs_3._guide/node001D.html amiga.lib/afp Includes_and_Autodocs_3._guide/node001E.html amiga.lib/ArgArrayDone Includes_and_Autodocs_3._guide/node001F.html amiga.lib/ArgArrayInit Includes_and_Autodocs_3._guide/node0020.html amiga.lib/ArgInt Includes_and_Autodocs_3._guide/node0021.html amiga.lib/ArgString Includes_and_Autodocs_3._guide/node0022.html amiga.lib/arnd Includes_and_Autodocs_3._guide/node0023.html amiga.lib/BeginIO Includes_and_Autodocs_3._guide/node0024.html amiga.lib/CallHook Includes_and_Autodocs_3._guide/node0025.html amiga.lib/CallHookA Includes_and_Autodocs_3._guide/node0026.html amiga.lib/CheckRexxMsg Includes_and_Autodocs_3._guide/node0027.html amiga.lib/CoerceMethod Includes_and_Autodocs_3._guide/node0028.html amiga.lib/CoerceMethodA Includes_and_Autodocs_3._guide/node0029.html amiga.lib/CreateExtIO Includes_and_Autodocs_3._guide/node002A.html amiga.lib/CreatePort Includes_and_Autodocs_3._guide/node002B.html amiga.lib/CreateStdIO Includes_and_Autodocs_3._guide/node002C.html amiga.lib/CreateTask Includes_and_Autodocs_3._guide/node002D.html amiga.lib/CxCustom Includes_and_Autodocs_3._guide/node002E.html amiga.lib/CxDebug Includes_and_Autodocs_3._guide/node002F.html amiga.lib/CxFilter Includes_and_Autodocs_3._guide/node0030.html amiga.lib/CxSender Includes_and_Autodocs_3._guide/node0031.html amiga.lib/CxSignal Includes_and_Autodocs_3._guide/node0032.html amiga.lib/CxTranslate Includes_and_Autodocs_3._guide/node0033.html amiga.lib/dbf Includes_and_Autodocs_3._guide/node0034.html amiga.lib/DeleteExtIO Includes_and_Autodocs_3._guide/node0035.html amiga.lib/DeletePort Includes_and_Autodocs_3._guide/node0036.html amiga.lib/DeleteStdIO Includes_and_Autodocs_3._guide/node0037.html amiga.lib/DeleteTask Includes_and_Autodocs_3._guide/node0038.html amiga.lib/DoMethod Includes_and_Autodocs_3._guide/node0039.html amiga.lib/DoMethodA Includes_and_Autodocs_3._guide/node003A.html amiga.lib/DoSuperMethod Includes_and_Autodocs_3._guide/node003B.html amiga.lib/DoSuperMethodA Includes_and_Autodocs_3._guide/node003C.html amiga.lib/FastRand Includes_and_Autodocs_3._guide/node003D.html amiga.lib/fpa Includes_and_Autodocs_3._guide/node003E.html amiga.lib/FreeIEvents Includes_and_Autodocs_3._guide/node003F.html amiga.lib/GetRexxVar Includes_and_Autodocs_3._guide/node0040.html amiga.lib/HookEntry Includes_and_Autodocs_3._guide/node0041.html amiga.lib/HotKey Includes_and_Autodocs_3._guide/node0042.html amiga.lib/InvertString Includes_and_Autodocs_3._guide/node0043.html amiga.lib/LibAllocPooled Includes_and_Autodocs_3._guide/node0044.html amiga.lib/LibCreatePool Includes_and_Autodocs_3._guide/node0045.html amiga.lib/LibDeletePool Includes_and_Autodocs_3._guide/node0046.html amiga.lib/LibFreePooled Includes_and_Autodocs_3._guide/node0047.html amiga.lib/NewList Includes_and_Autodocs_3._guide/node0048.html amiga.lib/printf Includes_and_Autodocs_3._guide/node0049.html amiga.lib/RangeRand Includes_and_Autodocs_3._guide/node004A.html amiga.lib/RemTOF Includes_and_Autodocs_3._guide/node004B.html amiga.lib/SetRexxVar Includes_and_Autodocs_3._guide/node004C.html amiga.lib/SetSuperAttrs Includes_and_Autodocs_3._guide/node004D.html amiga.lib/sprintf Includes_and_Autodocs_3._guide/node004E.html amiga.lib/stdio Includes_and_Autodocs_3._guide/node004F.html amiga.lib/TimeDelay Includes_and_Autodocs_3._guide/node0050.html animation_dtc.doc Includes_and_Autodocs_3._guide/node0051.html animation.datatype/animation.datatype Includes_and_Autodocs_3._guide/node0052.html arexx_cl.doc Includes_and_Autodocs_3._guide/node0053.html arexx_cl/--datasheet-- Includes_and_Autodocs_3._guide/node0054.html arexx_cl/AM_EXECUTE Includes_and_Autodocs_3._guide/node0055.html arexx_cl/AM_HANDLEINPUT Includes_and_Autodocs_3._guide/node0056.html asl.doc Includes_and_Autodocs_3._guide/node0057.html asl.library/AbortAslRequest Includes_and_Autodocs_3._guide/node0058.html asl.library/ActivateAslRequest Includes_and_Autodocs_3._guide/node0059.html asl.library/AllocAslRequest Includes_and_Autodocs_3._guide/node005A.html asl.library/AllocFileRequest Includes_and_Autodocs_3._guide/node005B.html asl.library/AslRequest Includes_and_Autodocs_3._guide/node005C.html asl.library/FreeAslRequest Includes_and_Autodocs_3._guide/node005D.html asl.library/FreeFileRequest Includes_and_Autodocs_3._guide/node005E.html asl.library/RequestFile Includes_and_Autodocs_3._guide/node005F.html audio.doc Includes_and_Autodocs_3._guide/node0060.html audio.device/AbortIO Includes_and_Autodocs_3._guide/node0061.html audio.device/ADCMD_ALLOCATE Includes_and_Autodocs_3._guide/node0062.html audio.device/ADCMD_FINISH Includes_and_Autodocs_3._guide/node0063.html audio.device/ADCMD_FREE Includes_and_Autodocs_3._guide/node0064.html audio.device/ADCMD_LOCK Includes_and_Autodocs_3._guide/node0065.html audio.device/ADCMD_PERVOL Includes_and_Autodocs_3._guide/node0066.html audio.device/ADCMD_SETPREC Includes_and_Autodocs_3._guide/node0067.html audio.device/ADCMD_WAITCYCLE Includes_and_Autodocs_3._guide/node0068.html audio.device/BeginIO Includes_and_Autodocs_3._guide/node0069.html audio.device/CloseDevice Includes_and_Autodocs_3._guide/node006A.html audio.device/CMD_CLEAR Includes_and_Autodocs_3._guide/node006B.html audio.device/CMD_FLUSH Includes_and_Autodocs_3._guide/node006C.html audio.device/CMD_READ Includes_and_Autodocs_3._guide/node006D.html audio.device/CMD_RESET Includes_and_Autodocs_3._guide/node006E.html audio.device/CMD_START Includes_and_Autodocs_3._guide/node006F.html audio.device/CMD_STOP Includes_and_Autodocs_3._guide/node0070.html audio.device/CMD_UPDATE Includes_and_Autodocs_3._guide/node0071.html audio.device/CMD_WRITE Includes_and_Autodocs_3._guide/node0072.html audio.device/Expunge Includes_and_Autodocs_3._guide/node0073.html audio.device/OpenDevice Includes_and_Autodocs_3._guide/node0074.html battclock.doc Includes_and_Autodocs_3._guide/node0075.html battclock.resource/ReadBattClock Includes_and_Autodocs_3._guide/node0076.html battclock.resource/ResetBattClock Includes_and_Autodocs_3._guide/node0077.html battclock.resource/WriteBattClock Includes_and_Autodocs_3._guide/node0078.html battmem.doc Includes_and_Autodocs_3._guide/node0079.html battmem.resource/ObtainBattSemaphore Includes_and_Autodocs_3._guide/node007A.html battmem.resource/ReadBattMem Includes_and_Autodocs_3._guide/node007B.html battmem.resource/ReleaseBattSemaphore Includes_and_Autodocs_3._guide/node007C.html battmem.resource/WriteBattMem Includes_and_Autodocs_3._guide/node007D.html bevel_ic.doc Includes_and_Autodocs_3._guide/node007E.html bevel_ic/--datasheet-- Includes_and_Autodocs_3._guide/node007F.html bevel_ic/--styleguide-- Includes_and_Autodocs_3._guide/node0080.html bevel_ic/BEVEL_GetClass Includes_and_Autodocs_3._guide/node0081.html bitmap_ic.doc Includes_and_Autodocs_3._guide/node0082.html bitmap_id/--datasheet-- Includes_and_Autodocs_3._guide/node0083.html bitmap_ic/BITMAP_GetClass Includes_and_Autodocs_3._guide/node0084.html bullet.doc Includes_and_Autodocs_3._guide/node0085.html bullet.library/--background-- Includes_and_Autodocs_3._guide/node0086.html bullet.library/CloseEngine Includes_and_Autodocs_3._guide/node0087.html bullet.library/ObtainInfoA Includes_and_Autodocs_3._guide/node0088.html bullet.library/OpenEngine Includes_and_Autodocs_3._guide/node0089.html bullet.library/ReleaseInfoA Includes_and_Autodocs_3._guide/node008A.html bullet.library/SetInfoA Includes_and_Autodocs_3._guide/node008B.html button_gc.doc Includes_and_Autodocs_3._guide/node008C.html button_gc/--datasheet-- Includes_and_Autodocs_3._guide/node008D.html button_gc/BUTTON_GetClass Includes_and_Autodocs_3._guide/node008E.html cardres.doc Includes_and_Autodocs_3._guide/node008F.html card.resource/BeginCardAccess Includes_and_Autodocs_3._guide/node0090.html card.resource/CardAccessSpeed Includes_and_Autodocs_3._guide/node0091.html card.resource/CardChangeCount Includes_and_Autodocs_3._guide/node0092.html card.resource/CardForceChange Includes_and_Autodocs_3._guide/node0093.html card.resource/CardInterface Includes_and_Autodocs_3._guide/node0094.html card.resource/CardMiscControl Includes_and_Autodocs_3._guide/node0095.html card.resource/CardProgramVoltage Includes_and_Autodocs_3._guide/node0096.html card.resource/CardResetCard Includes_and_Autodocs_3._guide/node0097.html card.resource/CardResetRemove Includes_and_Autodocs_3._guide/node0098.html card.resource/CopyTuple Includes_and_Autodocs_3._guide/node0099.html card.resource/DeviceTuple Includes_and_Autodocs_3._guide/node009A.html card.resource/EndCardAccess Includes_and_Autodocs_3._guide/node009B.html card.resource/GetCardMap Includes_and_Autodocs_3._guide/node009C.html card.resource/IfAmigaXIP Includes_and_Autodocs_3._guide/node009D.html card.resource/OwnCard Includes_and_Autodocs_3._guide/node009E.html card.resource/ReadCardStatus Includes_and_Autodocs_3._guide/node009F.html card.resource/ReleaseCard Includes_and_Autodocs_3._guide/node00A0.html cd.doc Includes_and_Autodocs_3._guide/node00A1.html cd.device/CD_ADDCHANGEINT Includes_and_Autodocs_3._guide/node00A2.html cd.device/CD_ADDFRAMEINT Includes_and_Autodocs_3._guide/node00A3.html cd.device/CD_ATTENUATE Includes_and_Autodocs_3._guide/node00A4.html cd.device/CD_CHANGENUM Includes_and_Autodocs_3._guide/node00A5.html cd.device/CD_CHANGESTATE Includes_and_Autodocs_3._guide/node00A6.html cd.device/CD_CONFIG Includes_and_Autodocs_3._guide/node00A7.html cd.device/CD_EJECT Includes_and_Autodocs_3._guide/node00A8.html cd.device/CD_GETGEOMETRY Includes_and_Autodocs_3._guide/node00A9.html cd.device/CD_INFO Includes_and_Autodocs_3._guide/node00AA.html cd.device/CD_MOTOR Includes_and_Autodocs_3._guide/node00AB.html cd.device/CD_PAUSE Includes_and_Autodocs_3._guide/node00AC.html cd.device/CD_PLAYLSN Includes_and_Autodocs_3._guide/node00AD.html cd.device/CD_PLAYMSF Includes_and_Autodocs_3._guide/node00AE.html cd.device/CD_PLAYTRACK Includes_and_Autodocs_3._guide/node00AF.html cd.device/CD_PROTSTATUS Includes_and_Autodocs_3._guide/node00B0.html cd.device/CD_QCODELSN Includes_and_Autodocs_3._guide/node00B1.html cd.device/CD_QCODEMSF Includes_and_Autodocs_3._guide/node00B2.html cd.device/CD_READ Includes_and_Autodocs_3._guide/node00B3.html cd.device/CD_READXL Includes_and_Autodocs_3._guide/node00B4.html cd.device/CD_REMCHANGEINT Includes_and_Autodocs_3._guide/node00B5.html cd.device/CD_REMFRAMEINT Includes_and_Autodocs_3._guide/node00B6.html cd.device/CD_SEARCH Includes_and_Autodocs_3._guide/node00B7.html cd.device/CD_SEEK Includes_and_Autodocs_3._guide/node00B8.html cd.device/CD_TOCLSN Includes_and_Autodocs_3._guide/node00B9.html cd.device/CD_TOCMSF Includes_and_Autodocs_3._guide/node00BA.html cd.device/CloseDevice Includes_and_Autodocs_3._guide/node00BB.html cd.device/OpenDevice Includes_and_Autodocs_3._guide/node00BC.html checkbox_gc.doc Includes_and_Autodocs_3._guide/node00BD.html checkbox_gc/--datasheet-- Includes_and_Autodocs_3._guide/node00BE.html checkbox_gc/CHECKBOX_GetClass Includes_and_Autodocs_3._guide/node00BF.html chooser_gc.doc Includes_and_Autodocs_3._guide/node00C0.html chooser_gc/--datasheet-- Includes_and_Autodocs_3._guide/node00C1.html chooser_gc/--styleguide-- Includes_and_Autodocs_3._guide/node00C2.html chooser_gc/CHOOSER_GetClass Includes_and_Autodocs_3._guide/node00C3.html chooser_gc/AllocChooserNodeA Includes_and_Autodocs_3._guide/node00C4.html chooser_gc/FreeChooserNode Includes_and_Autodocs_3._guide/node00C5.html chooser_gc/GetChooserNodeAttrsA Includes_and_Autodocs_3._guide/node00C6.html chooser_gc/SetChooserNodeAttrsA Includes_and_Autodocs_3._guide/node00C7.html cia.doc Includes_and_Autodocs_3._guide/node00C8.html cia.resource/AbleICR Includes_and_Autodocs_3._guide/node00C9.html cia.resource/AddICRVector Includes_and_Autodocs_3._guide/node00CA.html cia.resource/RemICRVector Includes_and_Autodocs_3._guide/node00CB.html cia.resource/SetICR Includes_and_Autodocs_3._guide/node00CC.html clicktab_gc.doc Includes_and_Autodocs_3._guide/node00CD.html clicktab_gc/--datasheet-- Includes_and_Autodocs_3._guide/node00CE.html clicktab_gc/CLICKTAB_GetClass Includes_and_Autodocs_3._guide/node00CF.html clicktab_gc/AllocClickTabNodeA Includes_and_Autodocs_3._guide/node00D0.html clicktab_gc/FreeClickTabNode Includes_and_Autodocs_3._guide/node00D1.html clicktab_gc/GetClickTabNodeAttrsA Includes_and_Autodocs_3._guide/node00D2.html clicktab_gc/SetClickTabNodeAttrsA Includes_and_Autodocs_3._guide/node00D3.html clipboard.doc Includes_and_Autodocs_3._guide/node00D4.html clipboard.device/CBD_CHANGEHOOK Includes_and_Autodocs_3._guide/node00D5.html clipboard.device/CBD_CURRENTREADID Includes_and_Autodocs_3._guide/node00D6.html clipboard.device/CBD_CURRENTWRITEID Includes_and_Autodocs_3._guide/node00D7.html clipboard.device/CBD_POST Includes_and_Autodocs_3._guide/node00D8.html clipboard.device/CMD_READ Includes_and_Autodocs_3._guide/node00D9.html clipboard.device/CMD_UPDATE Includes_and_Autodocs_3._guide/node00DA.html clipboard.device/CMD_WRITE Includes_and_Autodocs_3._guide/node00DB.html colorwheel_gc.doc Includes_and_Autodocs_3._guide/node00DC.html colorwheel.gadget/colorwheel.gadget Includes_and_Autodocs_3._guide/node00DD.html colorwheel.gadget/ConvertHSBToRGB Includes_and_Autodocs_3._guide/node00DE.html colorwheel.gadget/ConvertRGBToHSB Includes_and_Autodocs_3._guide/node00DF.html commodities.doc Includes_and_Autodocs_3._guide/node00E0.html commodities.library/ActivateCxObj Includes_and_Autodocs_3._guide/node00E1.html commodities.library/AddIEvents Includes_and_Autodocs_3._guide/node00E2.html commodities.library/AttachCxObj Includes_and_Autodocs_3._guide/node00E3.html commodities.library/ClearCxObjError Includes_and_Autodocs_3._guide/node00E4.html commodities.library/CreateCxObj Includes_and_Autodocs_3._guide/node00E5.html commodities.library/CxBroker Includes_and_Autodocs_3._guide/node00E6.html commodities.library/CxMsgData Includes_and_Autodocs_3._guide/node00E7.html commodities.library/CxMsgID Includes_and_Autodocs_3._guide/node00E8.html commodities.library/CxMsgType Includes_and_Autodocs_3._guide/node00E9.html commodities.library/CxObjError Includes_and_Autodocs_3._guide/node00EA.html commodities.library/CxObjType Includes_and_Autodocs_3._guide/node00EB.html commodities.library/DeleteCxObj Includes_and_Autodocs_3._guide/node00EC.html commodities.library/DeleteCxObjAll Includes_and_Autodocs_3._guide/node00ED.html commodities.library/DisposeCxMsg Includes_and_Autodocs_3._guide/node00EE.html commodities.library/DivertCxMsg Includes_and_Autodocs_3._guide/node00EF.html commodities.library/EnqueueCxObj Includes_and_Autodocs_3._guide/node00F0.html commodities.library/InsertCxObj Includes_and_Autodocs_3._guide/node00F1.html commodities.library/InvertKeyMap Includes_and_Autodocs_3._guide/node00F2.html commodities.library/MatchIX Includes_and_Autodocs_3._guide/node00F3.html commodities.library/ParseIX Includes_and_Autodocs_3._guide/node00F4.html commodities.library/RemoveCxObj Includes_and_Autodocs_3._guide/node00F5.html commodities.library/RouteCxMsg Includes_and_Autodocs_3._guide/node00F6.html commodities.library/SetCxObjPri Includes_and_Autodocs_3._guide/node00F7.html commodities.library/SetFilter Includes_and_Autodocs_3._guide/node00F8.html commodities.library/SetFilterIX Includes_and_Autodocs_3._guide/node00F9.html commodities.library/SetTranslate Includes_and_Autodocs_3._guide/node00FA.html console.doc Includes_and_Autodocs_3._guide/node00FB.html console.device/CD_ASKDEFAULTKEYMAP Includes_and_Autodocs_3._guide/node00FC.html console.device/CD_ASKKEYMAP Includes_and_Autodocs_3._guide/node00FD.html console.device/CD_SETDEFAULTKEYMAP Includes_and_Autodocs_3._guide/node00FE.html console.device/CD_SETKEYMAP Includes_and_Autodocs_3._guide/node00FF.html console.device/CDInputHandler Includes_and_Autodocs_3._guide/node0100.html console.device/CMD_CLEAR Includes_and_Autodocs_3._guide/node0101.html console.device/CMD_READ Includes_and_Autodocs_3._guide/node0102.html console.device/CMD_WRITE Includes_and_Autodocs_3._guide/node0103.html console.device/OpenDevice Includes_and_Autodocs_3._guide/node0104.html console.device/RawKeyConvert Includes_and_Autodocs_3._guide/node0105.html datatypes.doc Includes_and_Autodocs_3._guide/node0106.html datatypes.library/--background-- Includes_and_Autodocs_3._guide/node0107.html datatypes.library/--rexxhost-- Includes_and_Autodocs_3._guide/node0108.html datatypes.library/AddDTObject Includes_and_Autodocs_3._guide/node0109.html datatypes.library/DisposeDTObject Includes_and_Autodocs_3._guide/node010A.html datatypes.library/DoAsyncLayout Includes_and_Autodocs_3._guide/node010B.html datatypes.library/DoDTMethodA Includes_and_Autodocs_3._guide/node010C.html datatypes.library/DrawDTObjectA Includes_and_Autodocs_3._guide/node010D.html datatypes.library/GetDTAttrsA Includes_and_Autodocs_3._guide/node010E.html datatypes.library/GetDTMethods Includes_and_Autodocs_3._guide/node010F.html datatypes.library/GetDTString Includes_and_Autodocs_3._guide/node0110.html datatypes.library/GetDTTriggerMethods Includes_and_Autodocs_3._guide/node0111.html datatypes.library/NewDTObjectA Includes_and_Autodocs_3._guide/node0112.html datatypes.library/ObtainDataTypeA Includes_and_Autodocs_3._guide/node0113.html datatypes.library/ObtainDTDrawInfoA Includes_and_Autodocs_3._guide/node0114.html datatypes.library/PrintDTObjectA Includes_and_Autodocs_3._guide/node0115.html datatypes.library/RefreshDTObjectA Includes_and_Autodocs_3._guide/node0116.html datatypes.library/ReleaseDataType Includes_and_Autodocs_3._guide/node0117.html datatypes.library/ReleaseDTDrawInfo Includes_and_Autodocs_3._guide/node0118.html datatypes.library/RemoveDTObject Includes_and_Autodocs_3._guide/node0119.html datatypes.library/SetDTAttrsA Includes_and_Autodocs_3._guide/node011A.html ddebug_lib.doc Includes_and_Autodocs_3._guide/node011B.html ddebug.lib/DDoFmt Includes_and_Autodocs_3._guide/node011C.html ddebug.lib/DGetChar Includes_and_Autodocs_3._guide/node011D.html ddebug.lib/DGetNum Includes_and_Autodocs_3._guide/node011E.html ddebug.lib/DMayGetChar Includes_and_Autodocs_3._guide/node011F.html ddebug.lib/DPutChar Includes_and_Autodocs_3._guide/node0120.html ddebug.lib/DPutFmt Includes_and_Autodocs_3._guide/node0121.html ddebug.lib/DPutStr Includes_and_Autodocs_3._guide/node0122.html ddebug.lib/KCmpStr Includes_and_Autodocs_3._guide/node0123.html debug_lib.doc Includes_and_Autodocs_3._guide/node0124.html debug.lib/KCmpStr Includes_and_Autodocs_3._guide/node0125.html debug.lib/KGetChar Includes_and_Autodocs_3._guide/node0126.html debug.lib/KGetNum Includes_and_Autodocs_3._guide/node0127.html debug.lib/KMayGetChar Includes_and_Autodocs_3._guide/node0128.html debug.lib/KPrintF Includes_and_Autodocs_3._guide/node0129.html debug.lib/KPutChar Includes_and_Autodocs_3._guide/node012A.html debug.lib/KPutStr Includes_and_Autodocs_3._guide/node012B.html disk.doc Includes_and_Autodocs_3._guide/node012C.html disk.resource/AllocUnit Includes_and_Autodocs_3._guide/node012D.html disk.resource/FreeUnit Includes_and_Autodocs_3._guide/node012E.html disk.resource/GetUnit Includes_and_Autodocs_3._guide/node012F.html disk.resource/GetUnitID Includes_and_Autodocs_3._guide/node0130.html disk.resource/GiveUnit Includes_and_Autodocs_3._guide/node0131.html disk.resource/ReadUnitID Includes_and_Autodocs_3._guide/node0132.html diskfont.doc Includes_and_Autodocs_3._guide/node0133.html diskfont.library/AvailFonts Includes_and_Autodocs_3._guide/node0134.html diskfont.library/DisposeFontContents Includes_and_Autodocs_3._guide/node0135.html diskfont.library/NewFontContents Includes_and_Autodocs_3._guide/node0136.html diskfont.library/NewScaledDiskFont Includes_and_Autodocs_3._guide/node0137.html diskfont.library/OpenDiskFont Includes_and_Autodocs_3._guide/node0138.html dos.doc Includes_and_Autodocs_3._guide/node0139.html dos.library/AbortPkt Includes_and_Autodocs_3._guide/node013A.html dos.library/AddBuffers Includes_and_Autodocs_3._guide/node013B.html dos.library/AddDosEntry Includes_and_Autodocs_3._guide/node013C.html dos.library/AddPart Includes_and_Autodocs_3._guide/node013D.html dos.library/AddSegment Includes_and_Autodocs_3._guide/node013E.html dos.library/AllocDosObject Includes_and_Autodocs_3._guide/node013F.html dos.library/AssignAdd Includes_and_Autodocs_3._guide/node0140.html dos.library/AssignLate Includes_and_Autodocs_3._guide/node0141.html dos.library/AssignLock Includes_and_Autodocs_3._guide/node0142.html dos.library/AssignPath Includes_and_Autodocs_3._guide/node0143.html dos.library/AttemptLockDosList Includes_and_Autodocs_3._guide/node0144.html dos.library/ChangeMode Includes_and_Autodocs_3._guide/node0145.html dos.library/CheckSignal Includes_and_Autodocs_3._guide/node0146.html dos.library/Cli Includes_and_Autodocs_3._guide/node0147.html dos.library/CliInitNewcli Includes_and_Autodocs_3._guide/node0148.html dos.library/CliInitRun Includes_and_Autodocs_3._guide/node0149.html dos.library/Close Includes_and_Autodocs_3._guide/node014A.html dos.library/CompareDates Includes_and_Autodocs_3._guide/node014B.html dos.library/CreateDir Includes_and_Autodocs_3._guide/node014C.html dos.library/CreateNewProc Includes_and_Autodocs_3._guide/node014D.html dos.library/CreateProc Includes_and_Autodocs_3._guide/node014E.html dos.library/CurrentDir Includes_and_Autodocs_3._guide/node014F.html dos.library/DateStamp Includes_and_Autodocs_3._guide/node0150.html dos.library/DateToStr Includes_and_Autodocs_3._guide/node0151.html dos.library/Delay Includes_and_Autodocs_3._guide/node0152.html dos.library/DeleteFile Includes_and_Autodocs_3._guide/node0153.html dos.library/DeleteVar Includes_and_Autodocs_3._guide/node0154.html dos.library/DeviceProc Includes_and_Autodocs_3._guide/node0155.html dos.library/DoPkt Includes_and_Autodocs_3._guide/node0156.html dos.library/DupLock Includes_and_Autodocs_3._guide/node0157.html dos.library/DupLockFromFH Includes_and_Autodocs_3._guide/node0158.html dos.library/EndNotify Includes_and_Autodocs_3._guide/node0159.html dos.library/ErrorReport Includes_and_Autodocs_3._guide/node015A.html dos.library/ExAll Includes_and_Autodocs_3._guide/node015B.html dos.library/ExAllEnd Includes_and_Autodocs_3._guide/node015C.html dos.library/Examine Includes_and_Autodocs_3._guide/node015D.html dos.library/ExamineFH Includes_and_Autodocs_3._guide/node015E.html dos.library/Execute Includes_and_Autodocs_3._guide/node015F.html dos.library/Exit Includes_and_Autodocs_3._guide/node0160.html dos.library/ExNext Includes_and_Autodocs_3._guide/node0161.html dos.library/Fault Includes_and_Autodocs_3._guide/node0162.html dos.library/FGetC Includes_and_Autodocs_3._guide/node0163.html dos.library/FGets Includes_and_Autodocs_3._guide/node0164.html dos.library/FilePart Includes_and_Autodocs_3._guide/node0165.html dos.library/FindArg Includes_and_Autodocs_3._guide/node0166.html dos.library/FindCliProc Includes_and_Autodocs_3._guide/node0167.html dos.library/FindDosEntry Includes_and_Autodocs_3._guide/node0168.html dos.library/FindSegment Includes_and_Autodocs_3._guide/node0169.html dos.library/FindVar Includes_and_Autodocs_3._guide/node016A.html dos.library/Flush Includes_and_Autodocs_3._guide/node016B.html dos.library/Format Includes_and_Autodocs_3._guide/node016C.html dos.library/FPutC Includes_and_Autodocs_3._guide/node016D.html dos.library/FPuts Includes_and_Autodocs_3._guide/node016E.html dos.library/FRead Includes_and_Autodocs_3._guide/node016F.html dos.library/FreeArgs Includes_and_Autodocs_3._guide/node0170.html dos.library/FreeDeviceProc Includes_and_Autodocs_3._guide/node0171.html dos.library/FreeDosEntry Includes_and_Autodocs_3._guide/node0172.html dos.library/FreeDosObject Includes_and_Autodocs_3._guide/node0173.html dos.library/FWrite Includes_and_Autodocs_3._guide/node0174.html dos.library/GetArgStr Includes_and_Autodocs_3._guide/node0175.html dos.library/GetConsoleTask Includes_and_Autodocs_3._guide/node0176.html dos.library/GetCurrentDirName Includes_and_Autodocs_3._guide/node0177.html dos.library/GetDeviceProc Includes_and_Autodocs_3._guide/node0178.html dos.library/GetFileSysTask Includes_and_Autodocs_3._guide/node0179.html dos.library/GetProgramDir Includes_and_Autodocs_3._guide/node017A.html dos.library/GetProgramName Includes_and_Autodocs_3._guide/node017B.html dos.library/GetPrompt Includes_and_Autodocs_3._guide/node017C.html dos.library/GetVar Includes_and_Autodocs_3._guide/node017D.html dos.library/Info Includes_and_Autodocs_3._guide/node017E.html dos.library/Inhibit Includes_and_Autodocs_3._guide/node017F.html dos.library/Input Includes_and_Autodocs_3._guide/node0180.html dos.library/InternalLoadSeg Includes_and_Autodocs_3._guide/node0181.html dos.library/InternalUnLoadSeg Includes_and_Autodocs_3._guide/node0182.html dos.library/IoErr Includes_and_Autodocs_3._guide/node0183.html dos.library/IsFileSystem Includes_and_Autodocs_3._guide/node0184.html dos.library/IsInteractive Includes_and_Autodocs_3._guide/node0185.html dos.library/LoadSeg Includes_and_Autodocs_3._guide/node0186.html dos.library/Lock Includes_and_Autodocs_3._guide/node0187.html dos.library/LockDosList Includes_and_Autodocs_3._guide/node0188.html dos.library/LockRecord Includes_and_Autodocs_3._guide/node0189.html dos.library/LockRecords Includes_and_Autodocs_3._guide/node018A.html dos.library/MakeDosEntry Includes_and_Autodocs_3._guide/node018B.html dos.library/MakeLink Includes_and_Autodocs_3._guide/node018C.html dos.library/MatchEnd Includes_and_Autodocs_3._guide/node018D.html dos.library/MatchFirst Includes_and_Autodocs_3._guide/node018E.html dos.library/MatchNext Includes_and_Autodocs_3._guide/node018F.html dos.library/MatchPattern Includes_and_Autodocs_3._guide/node0190.html dos.library/MatchPatternNoCase Includes_and_Autodocs_3._guide/node0191.html dos.library/MaxCli Includes_and_Autodocs_3._guide/node0192.html dos.library/NameFromFH Includes_and_Autodocs_3._guide/node0193.html dos.library/NameFromLock Includes_and_Autodocs_3._guide/node0194.html dos.library/NewLoadSeg Includes_and_Autodocs_3._guide/node0195.html dos.library/NextDosEntry Includes_and_Autodocs_3._guide/node0196.html dos.library/Open Includes_and_Autodocs_3._guide/node0197.html dos.library/OpenFromLock Includes_and_Autodocs_3._guide/node0198.html dos.library/Output Includes_and_Autodocs_3._guide/node0199.html dos.library/ParentDir Includes_and_Autodocs_3._guide/node019A.html dos.library/ParentOfFH Includes_and_Autodocs_3._guide/node019B.html dos.library/ParsePattern Includes_and_Autodocs_3._guide/node019C.html dos.library/ParsePatternNoCase Includes_and_Autodocs_3._guide/node019D.html dos.library/PathPart Includes_and_Autodocs_3._guide/node019E.html dos.library/PrintFault Includes_and_Autodocs_3._guide/node019F.html dos.library/PutStr Includes_and_Autodocs_3._guide/node01A0.html dos.library/Read Includes_and_Autodocs_3._guide/node01A1.html dos.library/ReadArgs Includes_and_Autodocs_3._guide/node01A2.html dos.library/ReadItem Includes_and_Autodocs_3._guide/node01A3.html dos.library/ReadLink Includes_and_Autodocs_3._guide/node01A4.html dos.library/Relabel Includes_and_Autodocs_3._guide/node01A5.html dos.library/RemAssignList Includes_and_Autodocs_3._guide/node01A6.html dos.library/RemDosEntry Includes_and_Autodocs_3._guide/node01A7.html dos.library/RemSegment Includes_and_Autodocs_3._guide/node01A8.html dos.library/Rename Includes_and_Autodocs_3._guide/node01A9.html dos.library/ReplyPkt Includes_and_Autodocs_3._guide/node01AA.html dos.library/RunCommand Includes_and_Autodocs_3._guide/node01AB.html dos.library/SameDevice Includes_and_Autodocs_3._guide/node01AC.html dos.library/SameLock Includes_and_Autodocs_3._guide/node01AD.html dos.library/Seek Includes_and_Autodocs_3._guide/node01AE.html dos.library/SelectInput Includes_and_Autodocs_3._guide/node01AF.html dos.library/SelectOutput Includes_and_Autodocs_3._guide/node01B0.html dos.library/SendPkt Includes_and_Autodocs_3._guide/node01B1.html dos.library/SetArgStr Includes_and_Autodocs_3._guide/node01B2.html dos.library/SetComment Includes_and_Autodocs_3._guide/node01B3.html dos.library/SetConsoleTask Includes_and_Autodocs_3._guide/node01B4.html dos.library/SetCurrentDirName Includes_and_Autodocs_3._guide/node01B5.html dos.library/SetFileDate Includes_and_Autodocs_3._guide/node01B6.html dos.library/SetFileSize Includes_and_Autodocs_3._guide/node01B7.html dos.library/SetFileSysTask Includes_and_Autodocs_3._guide/node01B8.html dos.library/SetIoErr Includes_and_Autodocs_3._guide/node01B9.html dos.library/SetMode Includes_and_Autodocs_3._guide/node01BA.html dos.library/SetOwner Includes_and_Autodocs_3._guide/node01BB.html dos.library/SetProgramDir Includes_and_Autodocs_3._guide/node01BC.html dos.library/SetProgramName Includes_and_Autodocs_3._guide/node01BD.html dos.library/SetPrompt Includes_and_Autodocs_3._guide/node01BE.html dos.library/SetProtection Includes_and_Autodocs_3._guide/node01BF.html dos.library/SetVar Includes_and_Autodocs_3._guide/node01C0.html dos.library/SetVBuf Includes_and_Autodocs_3._guide/node01C1.html dos.library/SplitName Includes_and_Autodocs_3._guide/node01C2.html dos.library/StartNotify Includes_and_Autodocs_3._guide/node01C3.html dos.library/StrToDate Includes_and_Autodocs_3._guide/node01C4.html dos.library/StrToLong Includes_and_Autodocs_3._guide/node01C5.html dos.library/SystemTagList Includes_and_Autodocs_3._guide/node01C6.html dos.library/UnGetC Includes_and_Autodocs_3._guide/node01C7.html dos.library/UnLoadSeg Includes_and_Autodocs_3._guide/node01C8.html dos.library/UnLock Includes_and_Autodocs_3._guide/node01C9.html dos.library/UnLockDosList Includes_and_Autodocs_3._guide/node01CA.html dos.library/UnLockRecord Includes_and_Autodocs_3._guide/node01CB.html dos.library/UnLockRecords Includes_and_Autodocs_3._guide/node01CC.html dos.library/VFPrintf Includes_and_Autodocs_3._guide/node01CD.html dos.library/VFWritef Includes_and_Autodocs_3._guide/node01CE.html dos.library/VPrintf Includes_and_Autodocs_3._guide/node01CF.html dos.library/WaitForChar Includes_and_Autodocs_3._guide/node01D0.html dos.library/WaitPkt Includes_and_Autodocs_3._guide/node01D1.html dos.library/Write Includes_and_Autodocs_3._guide/node01D2.html dos.library/WriteChars Includes_and_Autodocs_3._guide/node01D3.html drawlist_ic.doc Includes_and_Autodocs_3._guide/node01D4.html drawlist_ic/--datasheet-- Includes_and_Autodocs_3._guide/node01D5.html drawlist_ic/DRAWLIST_GetClass Includes_and_Autodocs_3._guide/node01D6.html exec.doc Includes_and_Autodocs_3._guide/node01D7.html exec.library/AbortIO Includes_and_Autodocs_3._guide/node01D8.html exec.library/AddDevice Includes_and_Autodocs_3._guide/node01D9.html exec.library/AddHead Includes_and_Autodocs_3._guide/node01DA.html exec.library/AddIntServer Includes_and_Autodocs_3._guide/node01DB.html exec.library/AddLibrary Includes_and_Autodocs_3._guide/node01DC.html exec.library/AddMemHandler Includes_and_Autodocs_3._guide/node01DD.html exec.library/AddMemList Includes_and_Autodocs_3._guide/node01DE.html exec.library/AddPort Includes_and_Autodocs_3._guide/node01DF.html exec.library/AddResource Includes_and_Autodocs_3._guide/node01E0.html exec.library/AddSemaphore Includes_and_Autodocs_3._guide/node01E1.html exec.library/AddTail Includes_and_Autodocs_3._guide/node01E2.html exec.library/AddTask Includes_and_Autodocs_3._guide/node01E3.html exec.library/Alert Includes_and_Autodocs_3._guide/node01E4.html exec.library/AllocAbs Includes_and_Autodocs_3._guide/node01E5.html exec.library/Allocate Includes_and_Autodocs_3._guide/node01E6.html exec.library/AllocEntry Includes_and_Autodocs_3._guide/node01E7.html exec.library/AllocMem Includes_and_Autodocs_3._guide/node01E8.html exec.library/AllocPooled Includes_and_Autodocs_3._guide/node01E9.html exec.library/AllocSignal Includes_and_Autodocs_3._guide/node01EA.html exec.library/AllocTrap Includes_and_Autodocs_3._guide/node01EB.html exec.library/AllocVec Includes_and_Autodocs_3._guide/node01EC.html exec.library/AttemptSemaphore Includes_and_Autodocs_3._guide/node01ED.html exec.library/AttemptSemaphoreShared Includes_and_Autodocs_3._guide/node01EE.html exec.library/AvailMem Includes_and_Autodocs_3._guide/node01EF.html exec.library/CacheClearE Includes_and_Autodocs_3._guide/node01F0.html exec.library/CacheClearU Includes_and_Autodocs_3._guide/node01F1.html exec.library/CacheControl Includes_and_Autodocs_3._guide/node01F2.html exec.library/CachePostDMA Includes_and_Autodocs_3._guide/node01F3.html exec.library/CachePreDMA Includes_and_Autodocs_3._guide/node01F4.html exec.library/Cause Includes_and_Autodocs_3._guide/node01F5.html exec.library/CheckIO Includes_and_Autodocs_3._guide/node01F6.html exec.library/CloseDevice Includes_and_Autodocs_3._guide/node01F7.html exec.library/CloseLibrary Includes_and_Autodocs_3._guide/node01F8.html exec.library/ColdReboot Includes_and_Autodocs_3._guide/node01F9.html exec.library/CopyMem Includes_and_Autodocs_3._guide/node01FA.html exec.library/CopyMemQuick Includes_and_Autodocs_3._guide/node01FB.html exec.library/CreateIORequest Includes_and_Autodocs_3._guide/node01FC.html exec.library/CreateMsgPort Includes_and_Autodocs_3._guide/node01FD.html exec.library/CreatePool Includes_and_Autodocs_3._guide/node01FE.html exec.library/Deallocate Includes_and_Autodocs_3._guide/node01FF.html exec.library/Debug Includes_and_Autodocs_3._guide/node0200.html exec.library/DeleteIORequest Includes_and_Autodocs_3._guide/node0201.html exec.library/DeleteMsgPort Includes_and_Autodocs_3._guide/node0202.html exec.library/DeletePool Includes_and_Autodocs_3._guide/node0203.html exec.library/Disable Includes_and_Autodocs_3._guide/node0204.html exec.library/DoIO Includes_and_Autodocs_3._guide/node0205.html exec.library/Enable Includes_and_Autodocs_3._guide/node0206.html exec.library/Enqueue Includes_and_Autodocs_3._guide/node0207.html exec.library/FindName Includes_and_Autodocs_3._guide/node0208.html exec.library/FindPort Includes_and_Autodocs_3._guide/node0209.html exec.library/FindResident Includes_and_Autodocs_3._guide/node020A.html exec.library/FindSemaphore Includes_and_Autodocs_3._guide/node020B.html exec.library/FindTask Includes_and_Autodocs_3._guide/node020C.html exec.library/Forbid Includes_and_Autodocs_3._guide/node020D.html exec.library/FreeEntry Includes_and_Autodocs_3._guide/node020E.html exec.library/FreeMem Includes_and_Autodocs_3._guide/node020F.html exec.library/FreePooled Includes_and_Autodocs_3._guide/node0210.html exec.library/FreeSignal Includes_and_Autodocs_3._guide/node0211.html exec.library/FreeTrap Includes_and_Autodocs_3._guide/node0212.html exec.library/FreeVec Includes_and_Autodocs_3._guide/node0213.html exec.library/GetCC Includes_and_Autodocs_3._guide/node0214.html exec.library/GetMsg Includes_and_Autodocs_3._guide/node0215.html exec.library/InitCode Includes_and_Autodocs_3._guide/node0216.html exec.library/InitResident Includes_and_Autodocs_3._guide/node0217.html exec.library/InitSemaphore Includes_and_Autodocs_3._guide/node0218.html exec.library/InitStruct Includes_and_Autodocs_3._guide/node0219.html exec.library/Insert Includes_and_Autodocs_3._guide/node021A.html exec.library/MakeFunctions Includes_and_Autodocs_3._guide/node021B.html exec.library/MakeLibrary Includes_and_Autodocs_3._guide/node021C.html exec.library/ObtainQuickVector Includes_and_Autodocs_3._guide/node021D.html exec.library/ObtainSemaphore Includes_and_Autodocs_3._guide/node021E.html exec.library/ObtainSemaphoreList Includes_and_Autodocs_3._guide/node021F.html exec.library/ObtainSemaphoreShared Includes_and_Autodocs_3._guide/node0220.html exec.library/OldOpenLibrary Includes_and_Autodocs_3._guide/node0221.html exec.library/OpenDevice Includes_and_Autodocs_3._guide/node0222.html exec.library/OpenLibrary Includes_and_Autodocs_3._guide/node0223.html exec.library/OpenResource Includes_and_Autodocs_3._guide/node0224.html exec.library/Permit Includes_and_Autodocs_3._guide/node0225.html exec.library/Procure Includes_and_Autodocs_3._guide/node0226.html exec.library/PutMsg Includes_and_Autodocs_3._guide/node0227.html exec.library/RawDoFmt Includes_and_Autodocs_3._guide/node0228.html exec.library/ReleaseSemaphore Includes_and_Autodocs_3._guide/node0229.html exec.library/ReleaseSemaphoreList Includes_and_Autodocs_3._guide/node022A.html exec.library/RemDevice Includes_and_Autodocs_3._guide/node022B.html exec.library/RemHead Includes_and_Autodocs_3._guide/node022C.html exec.library/RemIntServer Includes_and_Autodocs_3._guide/node022D.html exec.library/RemLibrary Includes_and_Autodocs_3._guide/node022E.html exec.library/RemMemHandler Includes_and_Autodocs_3._guide/node022F.html exec.library/Remove Includes_and_Autodocs_3._guide/node0230.html exec.library/RemPort Includes_and_Autodocs_3._guide/node0231.html exec.library/RemResource Includes_and_Autodocs_3._guide/node0232.html exec.library/RemSemaphore Includes_and_Autodocs_3._guide/node0233.html exec.library/RemTail Includes_and_Autodocs_3._guide/node0234.html exec.library/RemTask Includes_and_Autodocs_3._guide/node0235.html exec.library/ReplyMsg Includes_and_Autodocs_3._guide/node0236.html exec.library/SendIO Includes_and_Autodocs_3._guide/node0237.html exec.library/SetExcept Includes_and_Autodocs_3._guide/node0238.html exec.library/SetFunction Includes_and_Autodocs_3._guide/node0239.html exec.library/SetIntVector Includes_and_Autodocs_3._guide/node023A.html exec.library/SetSignal Includes_and_Autodocs_3._guide/node023B.html exec.library/SetSR Includes_and_Autodocs_3._guide/node023C.html exec.library/SetTaskPri Includes_and_Autodocs_3._guide/node023D.html exec.library/Signal Includes_and_Autodocs_3._guide/node023E.html exec.library/StackSwap Includes_and_Autodocs_3._guide/node023F.html exec.library/SumKickData Includes_and_Autodocs_3._guide/node0240.html exec.library/SumLibrary Includes_and_Autodocs_3._guide/node0241.html exec.library/SuperState Includes_and_Autodocs_3._guide/node0242.html exec.library/Supervisor Includes_and_Autodocs_3._guide/node0243.html exec.library/TypeOfMem Includes_and_Autodocs_3._guide/node0244.html exec.library/UserState Includes_and_Autodocs_3._guide/node0245.html exec.library/Vacate Includes_and_Autodocs_3._guide/node0246.html exec.library/Wait Includes_and_Autodocs_3._guide/node0247.html exec.library/WaitIO Includes_and_Autodocs_3._guide/node0248.html exec.library/WaitPort Includes_and_Autodocs_3._guide/node0249.html SAD/--Overview-- Includes_and_Autodocs_3._guide/node024A.html SAD/ALLOCATE_MEMORY Includes_and_Autodocs_3._guide/node024B.html SAD/CALL_ADDRESS Includes_and_Autodocs_3._guide/node024C.html SAD/FREE_MEMORY Includes_and_Autodocs_3._guide/node024D.html SAD/GET_CONTEXT_FRAME Includes_and_Autodocs_3._guide/node024E.html SAD/NOP Includes_and_Autodocs_3._guide/node024F.html SAD/READ_ARRAY Includes_and_Autodocs_3._guide/node0250.html SAD/READ_BYTE Includes_and_Autodocs_3._guide/node0251.html SAD/READ_LONG Includes_and_Autodocs_3._guide/node0252.html SAD/READ_WORD Includes_and_Autodocs_3._guide/node0253.html SAD/RESET Includes_and_Autodocs_3._guide/node0254.html SAD/RETURN_TO_SYSTEM Includes_and_Autodocs_3._guide/node0255.html SAD/TURN_OFF_SINGLE Includes_and_Autodocs_3._guide/node0256.html SAD/TURN_ON_SINGLE Includes_and_Autodocs_3._guide/node0257.html SAD/WRITE_ARRAY Includes_and_Autodocs_3._guide/node0258.html SAD/WRITE_BYTE Includes_and_Autodocs_3._guide/node0259.html SAD/WRITE_LONG Includes_and_Autodocs_3._guide/node025A.html SAD/WRITE_WORD Includes_and_Autodocs_3._guide/node025B.html expansion.doc Includes_and_Autodocs_3._guide/node025C.html expansion.library/AddBootNode Includes_and_Autodocs_3._guide/node025D.html expansion.library/AddConfigDev Includes_and_Autodocs_3._guide/node025E.html expansion.library/AddDosNode Includes_and_Autodocs_3._guide/node025F.html expansion.library/AllocConfigDev Includes_and_Autodocs_3._guide/node0260.html expansion.library/AllocExpansionMem Includes_and_Autodocs_3._guide/node0261.html expansion.library/ConfigBoard Includes_and_Autodocs_3._guide/node0262.html expansion.library/FindConfigDev Includes_and_Autodocs_3._guide/node0263.html expansion.library/FreeConfigDev Includes_and_Autodocs_3._guide/node0264.html expansion.library/FreeExpansionMem Includes_and_Autodocs_3._guide/node0265.html expansion.library/GetCurrentBinding Includes_and_Autodocs_3._guide/node0266.html expansion.library/MakeDosNode Includes_and_Autodocs_3._guide/node0267.html expansion.library/ObtainConfigBinding Includes_and_Autodocs_3._guide/node0268.html expansion.library/ReadExpansionByte Includes_and_Autodocs_3._guide/node0269.html expansion.library/ReadExpansionRom Includes_and_Autodocs_3._guide/node026A.html expansion.library/ReleaseConfigBinding Includes_and_Autodocs_3._guide/node026B.html expansion.library/RemConfigDev Includes_and_Autodocs_3._guide/node026C.html expansion.library/SetCurrentBinding Includes_and_Autodocs_3._guide/node026D.html expansion.library/WriteExpansionByte Includes_and_Autodocs_3._guide/node026E.html filesysres.doc Includes_and_Autodocs_3._guide/node026F.html FileSystem.resource/--background-- Includes_and_Autodocs_3._guide/node0270.html fuelgauge_gc.doc Includes_and_Autodocs_3._guide/node0271.html fuelgauge_gc/--datasheet-- Includes_and_Autodocs_3._guide/node0272.html fuelgauge_gc/FUELGAUGE_GetClass Includes_and_Autodocs_3._guide/node0273.html gadtools.doc Includes_and_Autodocs_3._guide/node0274.html gadtools.library/CreateContext Includes_and_Autodocs_3._guide/node0275.html gadtools.library/CreateGadgetA Includes_and_Autodocs_3._guide/node0276.html gadtools.library/CreateMenusA Includes_and_Autodocs_3._guide/node0277.html gadtools.library/DrawBevelBoxA Includes_and_Autodocs_3._guide/node0278.html gadtools.library/FreeGadgets Includes_and_Autodocs_3._guide/node0279.html gadtools.library/FreeMenus Includes_and_Autodocs_3._guide/node027A.html gadtools.library/FreeVisualInfo Includes_and_Autodocs_3._guide/node027B.html gadtools.library/GetVisualInfoA Includes_and_Autodocs_3._guide/node027C.html gadtools.library/GT_BeginRefresh Includes_and_Autodocs_3._guide/node027D.html gadtools.library/GT_EndRefresh Includes_and_Autodocs_3._guide/node027E.html gadtools.library/GT_FilterIMsg Includes_and_Autodocs_3._guide/node027F.html gadtools.library/GT_GetGadgetAttrsA Includes_and_Autodocs_3._guide/node0280.html gadtools.library/GT_GetIMsg Includes_and_Autodocs_3._guide/node0281.html gadtools.library/GT_PostFilterIMsg Includes_and_Autodocs_3._guide/node0282.html gadtools.library/GT_RefreshWindow Includes_and_Autodocs_3._guide/node0283.html gadtools.library/GT_ReplyIMsg Includes_and_Autodocs_3._guide/node0284.html gadtools.library/GT_SetGadgetAttrsA Includes_and_Autodocs_3._guide/node0285.html gadtools.library/LayoutMenuItemsA Includes_and_Autodocs_3._guide/node0286.html gadtools.library/LayoutMenusA Includes_and_Autodocs_3._guide/node0287.html gameport.doc Includes_and_Autodocs_3._guide/node0288.html gameport.device/GPD_ASKCTYPE Includes_and_Autodocs_3._guide/node0289.html gameport.device/GPD_ASKTRIGGER Includes_and_Autodocs_3._guide/node028A.html gameport.device/GPD_READEVENT Includes_and_Autodocs_3._guide/node028B.html gameport.device/GPD_SETCTYPE Includes_and_Autodocs_3._guide/node028C.html gameport.device/GPD_SETTRIGGER Includes_and_Autodocs_3._guide/node028D.html getfile_gc.doc Includes_and_Autodocs_3._guide/node028E.html getfile.gadget/--datasheet-- Includes_and_Autodocs_3._guide/node028F.html getfile.gadget/GETFILE_GetClass Includes_and_Autodocs_3._guide/node0290.html getfont_gc.doc Includes_and_Autodocs_3._guide/node0291.html getfont.gadget/--datasheet-- Includes_and_Autodocs_3._guide/node0292.html getfont.gadget/GETFONT_GetClass Includes_and_Autodocs_3._guide/node0293.html getscreenmode_gc.doc Includes_and_Autodocs_3._guide/node0294.html getscreenmode.gadget/--datasheet-- Includes_and_Autodocs_3._guide/node0295.html getscreenmode.gadget/GETSCREENMODE_GetClass Includes_and_Autodocs_3._guide/node0296.html glyph_ic.doc Includes_and_Autodocs_3._guide/node0297.html glyph_ic/--datasheet-- Includes_and_Autodocs_3._guide/node0298.html glyph_ic/GLYPH_GetClass Includes_and_Autodocs_3._guide/node0299.html gradientslider_gc.doc Includes_and_Autodocs_3._guide/node029A.html gradientslider.gadget/gradientslider.gadgetlider.gadget/gradientslider.gadget Includes_and_Autodocs_3._guide/node029B.html graphics.doc Includes_and_Autodocs_3._guide/node029C.html graphics.library/AddAnimOb Includes_and_Autodocs_3._guide/node029D.html graphics.library/AddBob Includes_and_Autodocs_3._guide/node029E.html graphics.library/AddFont Includes_and_Autodocs_3._guide/node029F.html graphics.library/AddVSprite Includes_and_Autodocs_3._guide/node02A0.html graphics.library/AllocBitMap Includes_and_Autodocs_3._guide/node02A1.html graphics.library/AllocDBufInfo Includes_and_Autodocs_3._guide/node02A2.html graphics.library/AllocRaster Includes_and_Autodocs_3._guide/node02A3.html graphics.library/AllocSpriteDataA Includes_and_Autodocs_3._guide/node02A4.html graphics.library/AndRectRegion Includes_and_Autodocs_3._guide/node02A5.html graphics.library/AndRegionRegion Includes_and_Autodocs_3._guide/node02A6.html graphics.library/Animate Includes_and_Autodocs_3._guide/node02A7.html graphics.library/AreaCircle Includes_and_Autodocs_3._guide/node02A8.html graphics.library/AreaDraw Includes_and_Autodocs_3._guide/node02A9.html graphics.library/AreaEllipse Includes_and_Autodocs_3._guide/node02AA.html graphics.library/AreaEnd Includes_and_Autodocs_3._guide/node02AB.html graphics.library/AreaMove Includes_and_Autodocs_3._guide/node02AC.html graphics.library/AskFont Includes_and_Autodocs_3._guide/node02AD.html graphics.library/AskSoftStyle Includes_and_Autodocs_3._guide/node02AE.html graphics.library/AttachPalExtra Includes_and_Autodocs_3._guide/node02AF.html graphics.library/AttemptLockLayerRom Includes_and_Autodocs_3._guide/node02B0.html graphics.library/BestModeIDA Includes_and_Autodocs_3._guide/node02B1.html graphics.library/BitMapScale Includes_and_Autodocs_3._guide/node02B2.html graphics.library/BltBitMap Includes_and_Autodocs_3._guide/node02B3.html graphics.library/BltBitMapRastPort Includes_and_Autodocs_3._guide/node02B4.html graphics.library/BltClear Includes_and_Autodocs_3._guide/node02B5.html graphics.library/BltMaskBitMapRastPort Includes_and_Autodocs_3._guide/node02B6.html graphics.library/BltPattern Includes_and_Autodocs_3._guide/node02B7.html graphics.library/BltTemplate Includes_and_Autodocs_3._guide/node02B8.html graphics.library/CalcIVG Includes_and_Autodocs_3._guide/node02B9.html graphics.library/CBump Includes_and_Autodocs_3._guide/node02BA.html graphics.library/CEND Includes_and_Autodocs_3._guide/node02BB.html graphics.library/ChangeExtSpriteA Includes_and_Autodocs_3._guide/node02BC.html graphics.library/ChangeSprite Includes_and_Autodocs_3._guide/node02BD.html graphics.library/ChangeVPBitMap Includes_and_Autodocs_3._guide/node02BE.html graphics.library/CINIT Includes_and_Autodocs_3._guide/node02BF.html graphics.library/ClearEOL Includes_and_Autodocs_3._guide/node02C0.html graphics.library/ClearRectRegion Includes_and_Autodocs_3._guide/node02C1.html graphics.library/ClearRegion Includes_and_Autodocs_3._guide/node02C2.html graphics.library/ClearScreen Includes_and_Autodocs_3._guide/node02C3.html graphics.library/ClipBlit Includes_and_Autodocs_3._guide/node02C4.html graphics.library/CloseFont Includes_and_Autodocs_3._guide/node02C5.html graphics.library/CloseMonitor Includes_and_Autodocs_3._guide/node02C6.html graphics.library/CMOVE Includes_and_Autodocs_3._guide/node02C7.html graphics.library/CoerceMode Includes_and_Autodocs_3._guide/node02C8.html graphics.library/CopySBitMap Includes_and_Autodocs_3._guide/node02C9.html graphics.library/CWAIT Includes_and_Autodocs_3._guide/node02CA.html graphics.library/DisownBlitter Includes_and_Autodocs_3._guide/node02CB.html graphics.library/DisposeRegion Includes_and_Autodocs_3._guide/node02CC.html graphics.library/DoCollision Includes_and_Autodocs_3._guide/node02CD.html graphics.library/Draw Includes_and_Autodocs_3._guide/node02CE.html graphics.library/DrawEllipse Includes_and_Autodocs_3._guide/node02CF.html graphics.library/DrawGList Includes_and_Autodocs_3._guide/node02D0.html graphics.library/EraseRect Includes_and_Autodocs_3._guide/node02D1.html graphics.library/ExtendFont Includes_and_Autodocs_3._guide/node02D2.html graphics.library/FindColor Includes_and_Autodocs_3._guide/node02D3.html graphics.library/FindDisplayInfo Includes_and_Autodocs_3._guide/node02D4.html graphics.library/Flood Includes_and_Autodocs_3._guide/node02D5.html graphics.library/FontExtent Includes_and_Autodocs_3._guide/node02D6.html graphics.library/FreeBitMap Includes_and_Autodocs_3._guide/node02D7.html graphics.library/FreeColorMap Includes_and_Autodocs_3._guide/node02D8.html graphics.library/FreeCopList Includes_and_Autodocs_3._guide/node02D9.html graphics.library/FreeCprList Includes_and_Autodocs_3._guide/node02DA.html graphics.library/FreeDBufInfo Includes_and_Autodocs_3._guide/node02DB.html graphics.library/FreeGBuffers Includes_and_Autodocs_3._guide/node02DC.html graphics.library/FreeRaster Includes_and_Autodocs_3._guide/node02DD.html graphics.library/FreeSprite Includes_and_Autodocs_3._guide/node02DE.html graphics.library/FreeSpriteData Includes_and_Autodocs_3._guide/node02DF.html graphics.library/FreeVPortCopLists Includes_and_Autodocs_3._guide/node02E0.html graphics.library/GetAPen Includes_and_Autodocs_3._guide/node02E1.html graphics.library/GetBitMapAttr Includes_and_Autodocs_3._guide/node02E2.html graphics.library/GetBPen Includes_and_Autodocs_3._guide/node02E3.html graphics.library/GetColorMap Includes_and_Autodocs_3._guide/node02E4.html graphics.library/GetDisplayInfoData Includes_and_Autodocs_3._guide/node02E5.html graphics.library/GetDrMd Includes_and_Autodocs_3._guide/node02E6.html graphics.library/GetExtSpriteA Includes_and_Autodocs_3._guide/node02E7.html graphics.library/GetGBuffers Includes_and_Autodocs_3._guide/node02E8.html graphics.library/GetOPen Includes_and_Autodocs_3._guide/node02E9.html graphics.library/GetRGB32 Includes_and_Autodocs_3._guide/node02EA.html graphics.library/GetRGB4 Includes_and_Autodocs_3._guide/node02EB.html graphics.library/GetRPAttrA Includes_and_Autodocs_3._guide/node02EC.html graphics.library/GetSprite Includes_and_Autodocs_3._guide/node02ED.html graphics.library/GetVPModeID Includes_and_Autodocs_3._guide/node02EE.html graphics.library/GfxAssociate Includes_and_Autodocs_3._guide/node02EF.html graphics.library/GfxFree Includes_and_Autodocs_3._guide/node02F0.html graphics.library/GfxLookUP Includes_and_Autodocs_3._guide/node02F1.html graphics.library/GfxNew Includes_and_Autodocs_3._guide/node02F2.html graphics.library/InitArea Includes_and_Autodocs_3._guide/node02F3.html graphics.library/InitBitMap Includes_and_Autodocs_3._guide/node02F4.html graphics.library/InitGels Includes_and_Autodocs_3._guide/node02F5.html graphics.library/InitGMasks Includes_and_Autodocs_3._guide/node02F6.html graphics.library/InitMasks Includes_and_Autodocs_3._guide/node02F7.html graphics.library/InitRastPort Includes_and_Autodocs_3._guide/node02F8.html graphics.library/InitTmpRas Includes_and_Autodocs_3._guide/node02F9.html graphics.library/InitView Includes_and_Autodocs_3._guide/node02FA.html graphics.library/InitVPort Includes_and_Autodocs_3._guide/node02FB.html graphics.library/LoadRGB32 Includes_and_Autodocs_3._guide/node02FC.html graphics.library/LoadRGB4 Includes_and_Autodocs_3._guide/node02FD.html graphics.library/LoadView Includes_and_Autodocs_3._guide/node02FE.html graphics.library/LockLayerRom Includes_and_Autodocs_3._guide/node02FF.html graphics.library/MakeVPort Includes_and_Autodocs_3._guide/node0300.html graphics.library/ModeNotAvailable Includes_and_Autodocs_3._guide/node0301.html graphics.library/Move Includes_and_Autodocs_3._guide/node0302.html graphics.library/MoveSprite Includes_and_Autodocs_3._guide/node0303.html graphics.library/MrgCop Includes_and_Autodocs_3._guide/node0304.html graphics.library/NewRegion Includes_and_Autodocs_3._guide/node0305.html graphics.library/NextDisplayInfo Includes_and_Autodocs_3._guide/node0306.html graphics.library/ObtainBestPenA Includes_and_Autodocs_3._guide/node0307.html graphics.library/ObtainPen Includes_and_Autodocs_3._guide/node0308.html graphics.library/OpenFont Includes_and_Autodocs_3._guide/node0309.html graphics.library/OpenMonitor Includes_and_Autodocs_3._guide/node030A.html graphics.library/OrRectRegion Includes_and_Autodocs_3._guide/node030B.html graphics.library/OrRegionRegion Includes_and_Autodocs_3._guide/node030C.html graphics.library/OwnBlitter Includes_and_Autodocs_3._guide/node030D.html graphics.library/PolyDraw Includes_and_Autodocs_3._guide/node030E.html graphics.library/QBlit Includes_and_Autodocs_3._guide/node030F.html graphics.library/QBSBlit Includes_and_Autodocs_3._guide/node0310.html graphics.library/ReadPixel Includes_and_Autodocs_3._guide/node0311.html graphics.library/ReadPixelArray8 Includes_and_Autodocs_3._guide/node0312.html graphics.library/ReadPixelLine8 Includes_and_Autodocs_3._guide/node0313.html graphics.library/RectFill Includes_and_Autodocs_3._guide/node0314.html graphics.library/ReleasePen Includes_and_Autodocs_3._guide/node0315.html graphics.library/RemBob Includes_and_Autodocs_3._guide/node0316.html graphics.library/RemFont Includes_and_Autodocs_3._guide/node0317.html graphics.library/RemIBob Includes_and_Autodocs_3._guide/node0318.html graphics.library/RemVSprite Includes_and_Autodocs_3._guide/node0319.html graphics.library/ScalerDiv Includes_and_Autodocs_3._guide/node031A.html graphics.library/ScrollRaster Includes_and_Autodocs_3._guide/node031B.html graphics.library/ScrollRasterBF Includes_and_Autodocs_3._guide/node031C.html graphics.library/ScrollVPort Includes_and_Autodocs_3._guide/node031D.html graphics.library/SetABPenDrMd Includes_and_Autodocs_3._guide/node031E.html graphics.library/SetAPen Includes_and_Autodocs_3._guide/node031F.html graphics.library/SetBPen Includes_and_Autodocs_3._guide/node0320.html graphics.library/SetChipRev Includes_and_Autodocs_3._guide/node0321.html graphics.library/SetCollision Includes_and_Autodocs_3._guide/node0322.html graphics.library/SetDrMd Includes_and_Autodocs_3._guide/node0323.html graphics.library/SetFont Includes_and_Autodocs_3._guide/node0324.html graphics.library/SetMaxPen Includes_and_Autodocs_3._guide/node0325.html graphics.library/SetOPen Includes_and_Autodocs_3._guide/node0326.html graphics.library/SetOutlinePen Includes_and_Autodocs_3._guide/node0327.html graphics.library/SetRast Includes_and_Autodocs_3._guide/node0328.html graphics.library/SetRGB32 Includes_and_Autodocs_3._guide/node0329.html graphics.library/SetRGB32CM Includes_and_Autodocs_3._guide/node032A.html graphics.library/SetRGB4 Includes_and_Autodocs_3._guide/node032B.html graphics.library/SetRGB4CM Includes_and_Autodocs_3._guide/node032C.html graphics.library/SetRPAttrA Includes_and_Autodocs_3._guide/node032D.html graphics.library/SetSoftStyle Includes_and_Autodocs_3._guide/node032E.html graphics.library/SetWriteMask Includes_and_Autodocs_3._guide/node032F.html graphics.library/SortGList Includes_and_Autodocs_3._guide/node0330.html graphics.library/StripFont Includes_and_Autodocs_3._guide/node0331.html graphics.library/SyncSBitMap Includes_and_Autodocs_3._guide/node0332.html graphics.library/Text Includes_and_Autodocs_3._guide/node0333.html graphics.library/TextExtent Includes_and_Autodocs_3._guide/node0334.html graphics.library/TextFit Includes_and_Autodocs_3._guide/node0335.html graphics.library/TextLength Includes_and_Autodocs_3._guide/node0336.html graphics.library/UnlockLayerRom Includes_and_Autodocs_3._guide/node0337.html graphics.library/VBeamPos Includes_and_Autodocs_3._guide/node0338.html graphics.library/VideoControl Includes_and_Autodocs_3._guide/node0339.html graphics.library/WaitBlit Includes_and_Autodocs_3._guide/node033A.html graphics.library/WaitBOVP Includes_and_Autodocs_3._guide/node033B.html graphics.library/WaitTOF Includes_and_Autodocs_3._guide/node033C.html graphics.library/WriteChunkyPixels Includes_and_Autodocs_3._guide/node033D.html graphics.library/WritePixel Includes_and_Autodocs_3._guide/node033E.html graphics.library/WritePixelArray8 Includes_and_Autodocs_3._guide/node033F.html graphics.library/WritePixelLine8 Includes_and_Autodocs_3._guide/node0340.html graphics.library/XorRectRegion Includes_and_Autodocs_3._guide/node0341.html graphics.library/XorRegionRegion Includes_and_Autodocs_3._guide/node0342.html icon.doc Includes_and_Autodocs_3._guide/node0343.html icon.library/AddFreeList Includes_and_Autodocs_3._guide/node0344.html icon.library/BumpRevision Includes_and_Autodocs_3._guide/node0345.html icon.library/ChangeToSelectedIconColor Includes_and_Autodocs_3._guide/node0346.html icon.library/DeleteDiskObject Includes_and_Autodocs_3._guide/node0347.html icon.library/DrawIconStateA Includes_and_Autodocs_3._guide/node0348.html icon.library/DupDiskObjectA Includes_and_Autodocs_3._guide/node0349.html icon.library/FindToolType Includes_and_Autodocs_3._guide/node034A.html icon.library/FreeDiskObject Includes_and_Autodocs_3._guide/node034B.html icon.library/FreeFreeList Includes_and_Autodocs_3._guide/node034C.html icon.library/GetDefDiskObject Includes_and_Autodocs_3._guide/node034D.html icon.library/GetDiskObject Includes_and_Autodocs_3._guide/node034E.html icon.library/GetDiskObjectNew Includes_and_Autodocs_3._guide/node034F.html icon.library/GetIconRectangleA Includes_and_Autodocs_3._guide/node0350.html icon.library/GetIconTagList Includes_and_Autodocs_3._guide/node0351.html icon.library/IconControlA Includes_and_Autodocs_3._guide/node0352.html icon.library/LayoutIconA Includes_and_Autodocs_3._guide/node0353.html icon.library/MatchToolValue Includes_and_Autodocs_3._guide/node0354.html icon.library/NewDiskObject Includes_and_Autodocs_3._guide/node0355.html icon.library/PutDefDiskObject Includes_and_Autodocs_3._guide/node0356.html icon.library/PutDiskObject Includes_and_Autodocs_3._guide/node0357.html icon.library/PutIconTagList Includes_and_Autodocs_3._guide/node0358.html iffparse.doc Includes_and_Autodocs_3._guide/node0359.html iffparse.library/AllocIFF Includes_and_Autodocs_3._guide/node035A.html iffparse.library/AllocLocalItem Includes_and_Autodocs_3._guide/node035B.html iffparse.library/CloseClipboard Includes_and_Autodocs_3._guide/node035C.html iffparse.library/CloseIFF Includes_and_Autodocs_3._guide/node035D.html iffparse.library/CollectionChunk Includes_and_Autodocs_3._guide/node035E.html iffparse.library/CollectionChunks Includes_and_Autodocs_3._guide/node035F.html iffparse.library/CurrentChunk Includes_and_Autodocs_3._guide/node0360.html iffparse.library/EntryHandler Includes_and_Autodocs_3._guide/node0361.html iffparse.library/ExitHandler Includes_and_Autodocs_3._guide/node0362.html iffparse.library/FindCollection Includes_and_Autodocs_3._guide/node0363.html iffparse.library/FindLocalItem Includes_and_Autodocs_3._guide/node0364.html iffparse.library/FindProp Includes_and_Autodocs_3._guide/node0365.html iffparse.library/FindPropContext Includes_and_Autodocs_3._guide/node0366.html iffparse.library/FreeIFF Includes_and_Autodocs_3._guide/node0367.html iffparse.library/FreeLocalItem Includes_and_Autodocs_3._guide/node0368.html iffparse.library/GoodID Includes_and_Autodocs_3._guide/node0369.html iffparse.library/GoodType Includes_and_Autodocs_3._guide/node036A.html iffparse.library/IDtoStr Includes_and_Autodocs_3._guide/node036B.html iffparse.library/InitIFF Includes_and_Autodocs_3._guide/node036C.html iffparse.library/InitIFFasClip Includes_and_Autodocs_3._guide/node036D.html iffparse.library/InitIFFasDOS Includes_and_Autodocs_3._guide/node036E.html iffparse.library/LocalItemData Includes_and_Autodocs_3._guide/node036F.html iffparse.library/OpenClipboard Includes_and_Autodocs_3._guide/node0370.html iffparse.library/OpenIFF Includes_and_Autodocs_3._guide/node0371.html iffparse.library/ParentChunk Includes_and_Autodocs_3._guide/node0372.html iffparse.library/ParseIFF Includes_and_Autodocs_3._guide/node0373.html iffparse.library/PopChunk Includes_and_Autodocs_3._guide/node0374.html iffparse.library/PropChunk Includes_and_Autodocs_3._guide/node0375.html iffparse.library/PropChunks Includes_and_Autodocs_3._guide/node0376.html iffparse.library/PushChunk Includes_and_Autodocs_3._guide/node0377.html iffparse.library/ReadChunkBytes Includes_and_Autodocs_3._guide/node0378.html iffparse.library/ReadChunkRecords Includes_and_Autodocs_3._guide/node0379.html iffparse.library/SetLocalItemPurge Includes_and_Autodocs_3._guide/node037A.html iffparse.library/StopChunk Includes_and_Autodocs_3._guide/node037B.html iffparse.library/StopChunks Includes_and_Autodocs_3._guide/node037C.html iffparse.library/StopOnExit Includes_and_Autodocs_3._guide/node037D.html iffparse.library/StoreItemInContext Includes_and_Autodocs_3._guide/node037E.html iffparse.library/StoreLocalItem Includes_and_Autodocs_3._guide/node037F.html iffparse.library/WriteChunkBytes Includes_and_Autodocs_3._guide/node0380.html iffparse.library/WriteChunkRecords Includes_and_Autodocs_3._guide/node0381.html input.doc Includes_and_Autodocs_3._guide/node0382.html input.device/IND_ADDHANDLER Includes_and_Autodocs_3._guide/node0383.html input.device/IND_REMHANDLER Includes_and_Autodocs_3._guide/node0384.html input.device/IND_SETMPORT Includes_and_Autodocs_3._guide/node0385.html input.device/IND_SETMTRIG Includes_and_Autodocs_3._guide/node0386.html input.device/IND_SETMTYPE Includes_and_Autodocs_3._guide/node0387.html input.device/IND_SETPERIOD Includes_and_Autodocs_3._guide/node0388.html input.device/IND_SETTHRESH Includes_and_Autodocs_3._guide/node0389.html input.device/IND_WRITEEVENT Includes_and_Autodocs_3._guide/node038A.html input.device/PeekQualifier Includes_and_Autodocs_3._guide/node038B.html integer_gc.doc Includes_and_Autodocs_3._guide/node038C.html integer_gc/--datasheet-- Includes_and_Autodocs_3._guide/node038D.html integer_gc/INTEGER_GetClass Includes_and_Autodocs_3._guide/node038E.html intuition.doc Includes_and_Autodocs_3._guide/node038F.html intuition.library/ActivateGadget Includes_and_Autodocs_3._guide/node0390.html intuition.library/ActivateWindow Includes_and_Autodocs_3._guide/node0391.html intuition.library/AddClass Includes_and_Autodocs_3._guide/node0392.html intuition.library/AddGadget Includes_and_Autodocs_3._guide/node0393.html intuition.library/AddGList Includes_and_Autodocs_3._guide/node0394.html intuition.library/AllocRemember Includes_and_Autodocs_3._guide/node0395.html intuition.library/AllocScreenBuffer Includes_and_Autodocs_3._guide/node0396.html intuition.library/AutoRequest Includes_and_Autodocs_3._guide/node0397.html intuition.library/BeginRefresh Includes_and_Autodocs_3._guide/node0398.html intuition.library/BuildEasyRequestArgs Includes_and_Autodocs_3._guide/node0399.html intuition.library/BuildSysRequest Includes_and_Autodocs_3._guide/node039A.html intuition.library/ChangeScreenBuffer Includes_and_Autodocs_3._guide/node039B.html intuition.library/ChangeWindowBox Includes_and_Autodocs_3._guide/node039C.html intuition.library/ClearDMRequest Includes_and_Autodocs_3._guide/node039D.html intuition.library/ClearMenuStrip Includes_and_Autodocs_3._guide/node039E.html intuition.library/ClearPointer Includes_and_Autodocs_3._guide/node039F.html intuition.library/CloseScreen Includes_and_Autodocs_3._guide/node03A0.html intuition.library/CloseWindow Includes_and_Autodocs_3._guide/node03A1.html intuition.library/CloseWorkBench Includes_and_Autodocs_3._guide/node03A2.html intuition.library/CurrentTime Includes_and_Autodocs_3._guide/node03A3.html intuition.library/DisplayAlert Includes_and_Autodocs_3._guide/node03A4.html intuition.library/DisplayBeep Includes_and_Autodocs_3._guide/node03A5.html intuition.library/DisposeObject Includes_and_Autodocs_3._guide/node03A6.html intuition.library/DoGadgetMethodA Includes_and_Autodocs_3._guide/node03A7.html intuition.library/DoubleClick Includes_and_Autodocs_3._guide/node03A8.html intuition.library/DrawBorder Includes_and_Autodocs_3._guide/node03A9.html intuition.library/DrawImage Includes_and_Autodocs_3._guide/node03AA.html intuition.library/DrawImageState Includes_and_Autodocs_3._guide/node03AB.html intuition.library/EasyRequestArgs Includes_and_Autodocs_3._guide/node03AC.html intuition.library/EndRefresh Includes_and_Autodocs_3._guide/node03AD.html intuition.library/EndRequest Includes_and_Autodocs_3._guide/node03AE.html intuition.library/EraseImage Includes_and_Autodocs_3._guide/node03AF.html intuition.library/FreeClass Includes_and_Autodocs_3._guide/node03B0.html intuition.library/FreeRemember Includes_and_Autodocs_3._guide/node03B1.html intuition.library/FreeScreenBuffer Includes_and_Autodocs_3._guide/node03B2.html intuition.library/FreeScreenDrawInfo Includes_and_Autodocs_3._guide/node03B3.html intuition.library/FreeSysRequest Includes_and_Autodocs_3._guide/node03B4.html intuition.library/GadgetMouse Includes_and_Autodocs_3._guide/node03B5.html intuition.library/GetAttr Includes_and_Autodocs_3._guide/node03B6.html intuition.library/GetDefaultPubScreen Includes_and_Autodocs_3._guide/node03B7.html intuition.library/GetDefPrefs Includes_and_Autodocs_3._guide/node03B8.html intuition.library/GetPrefs Includes_and_Autodocs_3._guide/node03B9.html intuition.library/GetScreenData Includes_and_Autodocs_3._guide/node03BA.html intuition.library/GetScreenDrawInfo Includes_and_Autodocs_3._guide/node03BB.html intuition.library/HelpControl Includes_and_Autodocs_3._guide/node03BC.html intuition.library/InitRequester Includes_and_Autodocs_3._guide/node03BD.html intuition.library/IntuiTextLength Includes_and_Autodocs_3._guide/node03BE.html intuition.library/ItemAddress Includes_and_Autodocs_3._guide/node03BF.html intuition.library/LendMenus Includes_and_Autodocs_3._guide/node03C0.html intuition.library/LockIBase Includes_and_Autodocs_3._guide/node03C1.html intuition.library/LockPubScreen Includes_and_Autodocs_3._guide/node03C2.html intuition.library/LockPubScreenList Includes_and_Autodocs_3._guide/node03C3.html intuition.library/MakeClass Includes_and_Autodocs_3._guide/node03C4.html intuition.library/MakeScreen Includes_and_Autodocs_3._guide/node03C5.html intuition.library/ModifyIDCMP Includes_and_Autodocs_3._guide/node03C6.html intuition.library/ModifyProp Includes_and_Autodocs_3._guide/node03C7.html intuition.library/MoveScreen Includes_and_Autodocs_3._guide/node03C8.html intuition.library/MoveWindow Includes_and_Autodocs_3._guide/node03C9.html intuition.library/MoveWindowInFrontOf Includes_and_Autodocs_3._guide/node03CA.html intuition.library/NewModifyProp Includes_and_Autodocs_3._guide/node03CB.html intuition.library/NewObject Includes_and_Autodocs_3._guide/node03CC.html intuition.library/NextObject Includes_and_Autodocs_3._guide/node03CD.html intuition.library/NextPubScreen Includes_and_Autodocs_3._guide/node03CE.html intuition.library/ObtainGIRPort Includes_and_Autodocs_3._guide/node03CF.html intuition.library/OffGadget Includes_and_Autodocs_3._guide/node03D0.html intuition.library/OffMenu Includes_and_Autodocs_3._guide/node03D1.html intuition.library/OnGadget Includes_and_Autodocs_3._guide/node03D2.html intuition.library/OnMenu Includes_and_Autodocs_3._guide/node03D3.html intuition.library/OpenScreen Includes_and_Autodocs_3._guide/node03D4.html intuition.library/OpenScreenTagList Includes_and_Autodocs_3._guide/node03D5.html intuition.library/OpenWindow Includes_and_Autodocs_3._guide/node03D6.html intuition.library/OpenWindowTagList Includes_and_Autodocs_3._guide/node03D7.html intuition.library/OpenWorkBench Includes_and_Autodocs_3._guide/node03D8.html intuition.library/PointInImage Includes_and_Autodocs_3._guide/node03D9.html intuition.library/PrintIText Includes_and_Autodocs_3._guide/node03DA.html intuition.library/PubScreenStatus Includes_and_Autodocs_3._guide/node03DB.html intuition.library/QueryOverscan Includes_and_Autodocs_3._guide/node03DC.html intuition.library/RefreshGadgets Includes_and_Autodocs_3._guide/node03DD.html intuition.library/RefreshGList Includes_and_Autodocs_3._guide/node03DE.html intuition.library/RefreshWindowFrame Includes_and_Autodocs_3._guide/node03DF.html intuition.library/ReleaseGIRPort Includes_and_Autodocs_3._guide/node03E0.html intuition.library/RemakeDisplay Includes_and_Autodocs_3._guide/node03E1.html intuition.library/RemoveClass Includes_and_Autodocs_3._guide/node03E2.html intuition.library/RemoveGadget Includes_and_Autodocs_3._guide/node03E3.html intuition.library/RemoveGList Includes_and_Autodocs_3._guide/node03E4.html intuition.library/ReportMouse Includes_and_Autodocs_3._guide/node03E5.html intuition.library/Request Includes_and_Autodocs_3._guide/node03E6.html intuition.library/ResetMenuStrip Includes_and_Autodocs_3._guide/node03E7.html intuition.library/RethinkDisplay Includes_and_Autodocs_3._guide/node03E8.html intuition.library/ScreenDepth Includes_and_Autodocs_3._guide/node03E9.html intuition.library/ScreenPosition Includes_and_Autodocs_3._guide/node03EA.html intuition.library/ScreenToBack Includes_and_Autodocs_3._guide/node03EB.html intuition.library/ScreenToFront Includes_and_Autodocs_3._guide/node03EC.html intuition.library/ScrollWindowRaster Includes_and_Autodocs_3._guide/node03ED.html intuition.library/SetAttrsA Includes_and_Autodocs_3._guide/node03EE.html intuition.library/SetDefaultPubScreen Includes_and_Autodocs_3._guide/node03EF.html intuition.library/SetDMRequest Includes_and_Autodocs_3._guide/node03F0.html intuition.library/SetEditHook Includes_and_Autodocs_3._guide/node03F1.html intuition.library/SetGadgetAttrsA Includes_and_Autodocs_3._guide/node03F2.html intuition.library/SetMenuStrip Includes_and_Autodocs_3._guide/node03F3.html intuition.library/SetMouseQueue Includes_and_Autodocs_3._guide/node03F4.html intuition.library/SetPointer Includes_and_Autodocs_3._guide/node03F5.html intuition.library/SetPrefs Includes_and_Autodocs_3._guide/node03F6.html intuition.library/SetPubScreenModes Includes_and_Autodocs_3._guide/node03F7.html intuition.library/SetWindowPointerA Includes_and_Autodocs_3._guide/node03F8.html intuition.library/SetWindowTitles Includes_and_Autodocs_3._guide/node03F9.html intuition.library/ShowTitle Includes_and_Autodocs_3._guide/node03FA.html intuition.library/SizeWindow Includes_and_Autodocs_3._guide/node03FB.html intuition.library/SysReqHandler Includes_and_Autodocs_3._guide/node03FC.html intuition.library/TimedDisplayAlert Includes_and_Autodocs_3._guide/node03FD.html intuition.library/UnlockIBase Includes_and_Autodocs_3._guide/node03FE.html intuition.library/UnlockPubScreen Includes_and_Autodocs_3._guide/node03FF.html intuition.library/UnlockPubScreenList Includes_and_Autodocs_3._guide/node0400.html intuition.library/ViewAddress Includes_and_Autodocs_3._guide/node0401.html intuition.library/ViewPortAddress Includes_and_Autodocs_3._guide/node0402.html intuition.library/WBenchToBack Includes_and_Autodocs_3._guide/node0403.html intuition.library/WBenchToFront Includes_and_Autodocs_3._guide/node0404.html intuition.library/WindowLimits Includes_and_Autodocs_3._guide/node0405.html intuition.library/WindowToBack Includes_and_Autodocs_3._guide/node0406.html intuition.library/WindowToFront Includes_and_Autodocs_3._guide/node0407.html intuition.library/ZipWindow Includes_and_Autodocs_3._guide/node0408.html keyboard.doc Includes_and_Autodocs_3._guide/node0409.html keyboard.device/CMD_CLEAR Includes_and_Autodocs_3._guide/node040A.html keyboard.device/KBD_ADDRESETHANDLER Includes_and_Autodocs_3._guide/node040B.html keyboard.device/KBD_READEVENT Includes_and_Autodocs_3._guide/node040C.html keyboard.device/KBD_READMATRIX Includes_and_Autodocs_3._guide/node040D.html keyboard.device/KBD_REMRESETHANDLER Includes_and_Autodocs_3._guide/node040E.html keyboard.device/KBD_RESETHANDLERDONE Includes_and_Autodocs_3._guide/node040F.html keymap.doc Includes_and_Autodocs_3._guide/node0410.html keymap.library/AskKeyMapDefault Includes_and_Autodocs_3._guide/node0411.html keymap.library/MapANSI Includes_and_Autodocs_3._guide/node0412.html keymap.library/MapRawKey Includes_and_Autodocs_3._guide/node0413.html keymap.library/SetKeyMapDefault Includes_and_Autodocs_3._guide/node0414.html label_ic.doc Includes_and_Autodocs_3._guide/node0415.html label_ic/--datasheet-- Includes_and_Autodocs_3._guide/node0416.html label_ic/LABEL_GetClass Includes_and_Autodocs_3._guide/node0417.html layers.doc Includes_and_Autodocs_3._guide/node0418.html layers.library/BeginUpdate Includes_and_Autodocs_3._guide/node0419.html layers.library/BehindLayer Includes_and_Autodocs_3._guide/node041A.html layers.library/CreateBehindHookLayer Includes_and_Autodocs_3._guide/node041B.html layers.library/CreateBehindLayer Includes_and_Autodocs_3._guide/node041C.html layers.library/CreateUpfrontHookLayer Includes_and_Autodocs_3._guide/node041D.html layers.library/CreateUpfrontLayer Includes_and_Autodocs_3._guide/node041E.html layers.library/DeleteLayer Includes_and_Autodocs_3._guide/node041F.html layers.library/DisposeLayerInfo Includes_and_Autodocs_3._guide/node0420.html layers.library/DoHookClipRects Includes_and_Autodocs_3._guide/node0421.html layers.library/EndUpdate Includes_and_Autodocs_3._guide/node0422.html layers.library/FattenLayerInfo Includes_and_Autodocs_3._guide/node0423.html layers.library/InitLayers Includes_and_Autodocs_3._guide/node0424.html layers.library/InstallClipRegion Includes_and_Autodocs_3._guide/node0425.html layers.library/InstallLayerHook Includes_and_Autodocs_3._guide/node0426.html layers.library/InstallLayerInfoHook Includes_and_Autodocs_3._guide/node0427.html layers.library/LockLayer Includes_and_Autodocs_3._guide/node0428.html layers.library/LockLayerInfo Includes_and_Autodocs_3._guide/node0429.html layers.library/LockLayers Includes_and_Autodocs_3._guide/node042A.html layers.library/MoveLayer Includes_and_Autodocs_3._guide/node042B.html layers.library/MoveLayerInFrontOf Includes_and_Autodocs_3._guide/node042C.html layers.library/MoveSizeLayer Includes_and_Autodocs_3._guide/node042D.html layers.library/NewLayerInfo Includes_and_Autodocs_3._guide/node042E.html layers.library/ScrollLayer Includes_and_Autodocs_3._guide/node042F.html layers.library/SizeLayer Includes_and_Autodocs_3._guide/node0430.html layers.library/SwapBitsRastPortClipRectayers.library/SwapBitsRastPortClipRect Includes_and_Autodocs_3._guide/node0431.html layers.library/ThinLayerInfo Includes_and_Autodocs_3._guide/node0432.html layers.library/UnlockLayer Includes_and_Autodocs_3._guide/node0433.html layers.library/UnlockLayerInfo Includes_and_Autodocs_3._guide/node0434.html layers.library/UnlockLayers Includes_and_Autodocs_3._guide/node0435.html layers.library/UpfrontLayer Includes_and_Autodocs_3._guide/node0436.html layers.library/WhichLayer Includes_and_Autodocs_3._guide/node0437.html layout_gc.doc Includes_and_Autodocs_3._guide/node0438.html layout_gc/--datasheet-- Includes_and_Autodocs_3._guide/node0439.html layout_gc/ActivateLayoutGadget Includes_and_Autodocs_3._guide/node043A.html layout_gc/FlushLayoutDomainCache Includes_and_Autodocs_3._guide/node043B.html layout_gc/LAYOUT_GetClass Includes_and_Autodocs_3._guide/node043C.html layout_gc/LayoutLimits Includes_and_Autodocs_3._guide/node043D.html layout_gc/RethinkLayout Includes_and_Autodocs_3._guide/node043E.html listbrowser_gc.doc Includes_and_Autodocs_3._guide/node043F.html listbrowser_gc/--datasheet-- Includes_and_Autodocs_3._guide/node0440.html listbrowser_gc/LISTBROWSER_GetClass Includes_and_Autodocs_3._guide/node0441.html listbrowser_gc/LBM_ADDNODE Includes_and_Autodocs_3._guide/node0442.html listbrowser_gc/LBM_EDITNODE Includes_and_Autodocs_3._guide/node0443.html listbrowser_gc/LBM_REMNODE Includes_and_Autodocs_3._guide/node0444.html listbrowser_gc/AllocListBrowserNodeA Includes_and_Autodocs_3._guide/node0445.html listbrowser_gc/FreeListBrowserList Includes_and_Autodocs_3._guide/node0446.html listbrowser_gc/FreeListBrowserNode Includes_and_Autodocs_3._guide/node0447.html listbrowser_gc/GetListBrowserNodeAttrsA Includes_and_Autodocs_3._guide/node0448.html listbrowser_gc/ListBrowserSelectAll Includes_and_Autodocs_3._guide/node0449.html listbrowser_gc/HideAllListBrowserChildren Includes_and_Autodocs_3._guide/node044A.html listbrowser_gc/HideListBrowserNodeChildren Includes_and_Autodocs_3._guide/node044B.html listbrowser_gc/SetListBrowserNodeAttrsA Includes_and_Autodocs_3._guide/node044C.html listbrowser_gc/ShowAllListBrowserChildren Includes_and_Autodocs_3._guide/node044D.html listbrowser_gc/ShowListBrowserNodeChildren Includes_and_Autodocs_3._guide/node044E.html locale.doc Includes_and_Autodocs_3._guide/node044F.html locale.library/--environment_vars-- Includes_and_Autodocs_3._guide/node0450.html locale.library/--rexxhost-- Includes_and_Autodocs_3._guide/node0451.html locale.library/--structures-- Includes_and_Autodocs_3._guide/node0452.html locale.library/CloseCatalog Includes_and_Autodocs_3._guide/node0453.html locale.library/CloseLocale Includes_and_Autodocs_3._guide/node0454.html locale.library/ConvToLower Includes_and_Autodocs_3._guide/node0455.html locale.library/ConvToUpper Includes_and_Autodocs_3._guide/node0456.html locale.library/FormatDate Includes_and_Autodocs_3._guide/node0457.html locale.library/FormatString Includes_and_Autodocs_3._guide/node0458.html locale.library/GetCatalogStr Includes_and_Autodocs_3._guide/node0459.html locale.library/GetLocaleStr Includes_and_Autodocs_3._guide/node045A.html locale.library/IsXXXX Includes_and_Autodocs_3._guide/node045B.html locale.library/OpenCatalog Includes_and_Autodocs_3._guide/node045C.html locale.library/OpenLocale Includes_and_Autodocs_3._guide/node045D.html locale.library/ParseDate Includes_and_Autodocs_3._guide/node045E.html locale.library/StrConvert Includes_and_Autodocs_3._guide/node045F.html locale.library/StrnCmp Includes_and_Autodocs_3._guide/node0460.html lowlevel.doc Includes_and_Autodocs_3._guide/node0461.html lowlevel.library/AddKBInt Includes_and_Autodocs_3._guide/node0462.html lowlevel.library/AddTimerInt Includes_and_Autodocs_3._guide/node0463.html lowlevel.library/AddVBlankInt Includes_and_Autodocs_3._guide/node0464.html lowlevel.library/ElapsedTime Includes_and_Autodocs_3._guide/node0465.html lowlevel.library/GetKey Includes_and_Autodocs_3._guide/node0466.html lowlevel.library/GetLanguageSelection Includes_and_Autodocs_3._guide/node0467.html lowlevel.library/QueryKeys Includes_and_Autodocs_3._guide/node0468.html lowlevel.library/ReadJoyPort Includes_and_Autodocs_3._guide/node0469.html lowlevel.library/RemKBInt Includes_and_Autodocs_3._guide/node046A.html lowlevel.library/RemTimerInt Includes_and_Autodocs_3._guide/node046B.html lowlevel.library/RemVBlankInt Includes_and_Autodocs_3._guide/node046C.html lowlevel.library/SetJoyPortAttrsA Includes_and_Autodocs_3._guide/node046D.html lowlevel.library/StartTimerInt Includes_and_Autodocs_3._guide/node046E.html lowlevel.library/StopTimerInt Includes_and_Autodocs_3._guide/node046F.html lowlevel.library/SystemControlA Includes_and_Autodocs_3._guide/node0470.html mathffp.doc Includes_and_Autodocs_3._guide/node0471.html mathffp.library/SPAbs Includes_and_Autodocs_3._guide/node0472.html mathffp.library/SPAdd Includes_and_Autodocs_3._guide/node0473.html mathffp.library/SPCeil Includes_and_Autodocs_3._guide/node0474.html mathffp.library/SPCmp Includes_and_Autodocs_3._guide/node0475.html mathffp.library/SPDiv Includes_and_Autodocs_3._guide/node0476.html mathffp.library/SPFix Includes_and_Autodocs_3._guide/node0477.html mathffp.library/SPFloor Includes_and_Autodocs_3._guide/node0478.html mathffp.library/SPFlt Includes_and_Autodocs_3._guide/node0479.html mathffp.library/SPMul Includes_and_Autodocs_3._guide/node047A.html mathffp.library/SPNeg Includes_and_Autodocs_3._guide/node047B.html mathffp.library/SPSub Includes_and_Autodocs_3._guide/node047C.html mathffp.library/SPTst Includes_and_Autodocs_3._guide/node047D.html mathieeedoubbas.doc Includes_and_Autodocs_3._guide/node047E.html mathieeedoubbas.library/IEEEDPAbs Includes_and_Autodocs_3._guide/node047F.html mathieeedoubbas.library/IEEEDPAdd Includes_and_Autodocs_3._guide/node0480.html mathieeedoubbas.library/IEEEDPCeil Includes_and_Autodocs_3._guide/node0481.html mathieeedoubbas.library/IEEEDPCmp Includes_and_Autodocs_3._guide/node0482.html mathieeedoubbas.library/IEEEDPDiv Includes_and_Autodocs_3._guide/node0483.html mathieeedoubbas.library/IEEEDPFix Includes_and_Autodocs_3._guide/node0484.html mathieeedoubbas.library/IEEEDPFloor Includes_and_Autodocs_3._guide/node0485.html mathieeedoubbas.library/IEEEDPFlt Includes_and_Autodocs_3._guide/node0486.html mathieeedoubbas.library/IEEEDPMul Includes_and_Autodocs_3._guide/node0487.html mathieeedoubbas.library/IEEEDPNeg Includes_and_Autodocs_3._guide/node0488.html mathieeedoubbas.library/IEEEDPSub Includes_and_Autodocs_3._guide/node0489.html mathieeedoubbas.library/IEEEDPTst Includes_and_Autodocs_3._guide/node048A.html mathieeedoubtrans.doc Includes_and_Autodocs_3._guide/node048B.html mathieeedoubtrans.library/IEEEDPAcos Includes_and_Autodocs_3._guide/node048C.html mathieeedoubtrans.library/IEEEDPAsin Includes_and_Autodocs_3._guide/node048D.html mathieeedoubtrans.library/IEEEDPAtan Includes_and_Autodocs_3._guide/node048E.html mathieeedoubtrans.library/IEEEDPCos Includes_and_Autodocs_3._guide/node048F.html mathieeedoubtrans.library/IEEEDPCosh Includes_and_Autodocs_3._guide/node0490.html mathieeedoubtrans.library/IEEEDPExp Includes_and_Autodocs_3._guide/node0491.html mathieeedoubtrans.library/IEEEDPFieee Includes_and_Autodocs_3._guide/node0492.html mathieeedoubtrans.library/IEEEDPLog Includes_and_Autodocs_3._guide/node0493.html mathieeedoubtrans.library/IEEEDPLog10 Includes_and_Autodocs_3._guide/node0494.html mathieeedoubtrans.library/IEEEDPPow Includes_and_Autodocs_3._guide/node0495.html mathieeedoubtrans.library/IEEEDPSin Includes_and_Autodocs_3._guide/node0496.html mathieeedoubtrans.library/IEEEDPSincos Includes_and_Autodocs_3._guide/node0497.html mathieeedoubtrans.library/IEEEDPSinh Includes_and_Autodocs_3._guide/node0498.html mathieeedoubtrans.library/IEEEDPSqrt Includes_and_Autodocs_3._guide/node0499.html mathieeedoubtrans.library/IEEEDPTan Includes_and_Autodocs_3._guide/node049A.html mathieeedoubtrans.library/IEEEDPTanh Includes_and_Autodocs_3._guide/node049B.html mathieeedoubtrans.library/IEEEDPTieee Includes_and_Autodocs_3._guide/node049C.html mathieeesingbas.doc Includes_and_Autodocs_3._guide/node049D.html mathieeesingbas.library/IEEESPAbs Includes_and_Autodocs_3._guide/node049E.html mathieeesingbas.library/IEEESPAdd Includes_and_Autodocs_3._guide/node049F.html mathieeesingbas.library/IEEESPCeil Includes_and_Autodocs_3._guide/node04A0.html mathieeesingbas.library/IEEESPCmp Includes_and_Autodocs_3._guide/node04A1.html mathieeesingbas.library/IEEESPDiv Includes_and_Autodocs_3._guide/node04A2.html mathieeesingbas.library/IEEESPFix Includes_and_Autodocs_3._guide/node04A3.html mathieeesingbas.library/IEEESPFloor Includes_and_Autodocs_3._guide/node04A4.html mathieeesingbas.library/IEEESPFlt Includes_and_Autodocs_3._guide/node04A5.html mathieeesingbas.library/IEEESPMul Includes_and_Autodocs_3._guide/node04A6.html mathieeesingbas.library/IEEESPNeg Includes_and_Autodocs_3._guide/node04A7.html mathieeesingbas.library/IEEESPSub Includes_and_Autodocs_3._guide/node04A8.html mathieeesingbas.library/IEEESPTst Includes_and_Autodocs_3._guide/node04A9.html mathieeesingtrans.doc Includes_and_Autodocs_3._guide/node04AA.html mathieeesingtrans.library/IEEESPAcos Includes_and_Autodocs_3._guide/node04AB.html mathieeesingtrans.library/IEEESPAsin Includes_and_Autodocs_3._guide/node04AC.html mathieeesingtrans.library/IEEESPAtan Includes_and_Autodocs_3._guide/node04AD.html mathieeesingtrans.library/IEEESPCos Includes_and_Autodocs_3._guide/node04AE.html mathieeesingtrans.library/IEEESPCosh Includes_and_Autodocs_3._guide/node04AF.html mathieeesingtrans.library/IEEESPExp Includes_and_Autodocs_3._guide/node04B0.html mathieeesingtrans.library/IEEESPFieee Includes_and_Autodocs_3._guide/node04B1.html mathieeesingtrans.library/IEEESPLog Includes_and_Autodocs_3._guide/node04B2.html mathieeesingtrans.library/IEEESPLog10 Includes_and_Autodocs_3._guide/node04B3.html mathieeesingtrans.library/IEEESPPow Includes_and_Autodocs_3._guide/node04B4.html mathieeesingtrans.library/IEEESPSin Includes_and_Autodocs_3._guide/node04B5.html mathieeesingtrans.library/IEEESPSincos Includes_and_Autodocs_3._guide/node04B6.html mathieeesingtrans.library/IEEESPSinh Includes_and_Autodocs_3._guide/node04B7.html mathieeesingtrans.library/IEEESPSqrt Includes_and_Autodocs_3._guide/node04B8.html mathieeesingtrans.library/IEEESPTan Includes_and_Autodocs_3._guide/node04B9.html mathieeesingtrans.library/IEEESPTanh Includes_and_Autodocs_3._guide/node04BA.html mathieeesingtrans.library/IEEESPTieee Includes_and_Autodocs_3._guide/node04BB.html mathtrans.doc Includes_and_Autodocs_3._guide/node04BC.html mathtrans.library/SPAcos Includes_and_Autodocs_3._guide/node04BD.html mathtrans.library/SPAsin Includes_and_Autodocs_3._guide/node04BE.html mathtrans.library/SPAtan Includes_and_Autodocs_3._guide/node04BF.html mathtrans.library/SPCos Includes_and_Autodocs_3._guide/node04C0.html mathtrans.library/SPCosh Includes_and_Autodocs_3._guide/node04C1.html mathtrans.library/SPExp Includes_and_Autodocs_3._guide/node04C2.html mathtrans.library/SPFieee Includes_and_Autodocs_3._guide/node04C3.html mathtrans.library/SPLog Includes_and_Autodocs_3._guide/node04C4.html mathtrans.library/SPLog10 Includes_and_Autodocs_3._guide/node04C5.html mathtrans.library/SPPow Includes_and_Autodocs_3._guide/node04C6.html mathtrans.library/SPSin Includes_and_Autodocs_3._guide/node04C7.html mathtrans.library/SPSincos Includes_and_Autodocs_3._guide/node04C8.html mathtrans.library/SPSinh Includes_and_Autodocs_3._guide/node04C9.html mathtrans.library/SPSqrt Includes_and_Autodocs_3._guide/node04CA.html mathtrans.library/SPTan Includes_and_Autodocs_3._guide/node04CB.html mathtrans.library/SPTanh Includes_and_Autodocs_3._guide/node04CC.html mathtrans.library/SPTieee Includes_and_Autodocs_3._guide/node04CD.html misc.doc Includes_and_Autodocs_3._guide/node04CE.html misc.resource/AllocMiscResource Includes_and_Autodocs_3._guide/node04CF.html misc.resource/FreeMiscResource Includes_and_Autodocs_3._guide/node04D0.html narrator.doc Includes_and_Autodocs_3._guide/node04D1.html narrator.device/AbortIO Includes_and_Autodocs_3._guide/node04D2.html narrator.device/CloseDevice Includes_and_Autodocs_3._guide/node04D3.html narrator.device/CMD_FLUSH Includes_and_Autodocs_3._guide/node04D4.html narrator.device/CMD_READ Includes_and_Autodocs_3._guide/node04D5.html narrator.device/CMD_RESET Includes_and_Autodocs_3._guide/node04D6.html narrator.device/CMD_START Includes_and_Autodocs_3._guide/node04D7.html narrator.device/CMD_STOP Includes_and_Autodocs_3._guide/node04D8.html narrator.device/CMD_WRITE Includes_and_Autodocs_3._guide/node04D9.html narrator.device/OpenDevice Includes_and_Autodocs_3._guide/node04DA.html nonvolatile.doc Includes_and_Autodocs_3._guide/node04DB.html nonvolatile.library/--background-- Includes_and_Autodocs_3._guide/node04DC.html nonvolatile.library/DeleteNV Includes_and_Autodocs_3._guide/node04DD.html nonvolatile.library/FreeNVData Includes_and_Autodocs_3._guide/node04DE.html nonvolatile.library/GetCopyNV Includes_and_Autodocs_3._guide/node04DF.html nonvolatile.library/GetNVInfo Includes_and_Autodocs_3._guide/node04E0.html nonvolatile.library/GetNVList Includes_and_Autodocs_3._guide/node04E1.html nonvolatile.library/SetNVProtection Includes_and_Autodocs_3._guide/node04E2.html nonvolatile.library/StoreNV Includes_and_Autodocs_3._guide/node04E3.html page_gc.doc Includes_and_Autodocs_3._guide/node04E4.html page_gc/--datasheet-- Includes_and_Autodocs_3._guide/node04E5.html page_gc/PAGE_GetClass Includes_and_Autodocs_3._guide/node04E6.html page_gc/RefreshPageGadget Includes_and_Autodocs_3._guide/node04E7.html page_gc/SetPageGadgetAttrsA Includes_and_Autodocs_3._guide/node04E8.html palette_gc.doc Includes_and_Autodocs_3._guide/node04E9.html palette_gc/--datasheet-- Includes_and_Autodocs_3._guide/node04EA.html palette_gc/--styleguide-- Includes_and_Autodocs_3._guide/node04EB.html palette_gc/PALETTE_GetClass Includes_and_Autodocs_3._guide/node04EC.html parallel.doc Includes_and_Autodocs_3._guide/node04ED.html parallel.device/CMD_CLEAR Includes_and_Autodocs_3._guide/node04EE.html parallel.device/CMD_FLUSH Includes_and_Autodocs_3._guide/node04EF.html parallel.device/CMD_READ Includes_and_Autodocs_3._guide/node04F0.html parallel.device/CMD_RESET Includes_and_Autodocs_3._guide/node04F1.html parallel.device/CMD_START Includes_and_Autodocs_3._guide/node04F2.html parallel.device/CMD_STOP Includes_and_Autodocs_3._guide/node04F3.html parallel.device/CMD_WRITE Includes_and_Autodocs_3._guide/node04F4.html parallel.device/OpenDevice Includes_and_Autodocs_3._guide/node04F5.html parallel.device/PDCMD_QUERY Includes_and_Autodocs_3._guide/node04F6.html parallel.device/PDCMD_SETPARAMS Includes_and_Autodocs_3._guide/node04F7.html penmap_ic.doc Includes_and_Autodocs_3._guide/node04F8.html penmap_ic/--datasheet-- Includes_and_Autodocs_3._guide/node04F9.html penmap_ic/PENMAP_GetClass Includes_and_Autodocs_3._guide/node04FA.html picture_dtc.doc Includes_and_Autodocs_3._guide/node04FB.html picture.datatype/picture.datatype Includes_and_Autodocs_3._guide/node04FC.html port-handler.doc Includes_and_Autodocs_3._guide/node04FD.html port-handler/port_handler Includes_and_Autodocs_3._guide/node04FE.html potgo.doc Includes_and_Autodocs_3._guide/node04FF.html potgo.resource/AllocPotBits Includes_and_Autodocs_3._guide/node0500.html potgo.resource/FreePotBits Includes_and_Autodocs_3._guide/node0501.html potgo.resource/WritePotgo Includes_and_Autodocs_3._guide/node0502.html printer.doc Includes_and_Autodocs_3._guide/node0503.html printer.device/--background-- Includes_and_Autodocs_3._guide/node0504.html printer.device/CallErrHook Includes_and_Autodocs_3._guide/node0505.html printer.device/CMD_FLUSH Includes_and_Autodocs_3._guide/node0506.html printer.device/CMD_INVALID Includes_and_Autodocs_3._guide/node0507.html printer.device/CMD_RESET Includes_and_Autodocs_3._guide/node0508.html printer.device/CMD_START Includes_and_Autodocs_3._guide/node0509.html printer.device/CMD_STOP Includes_and_Autodocs_3._guide/node050A.html printer.device/CMD_WRITE Includes_and_Autodocs_3._guide/node050B.html printer.device/PBothReady Includes_and_Autodocs_3._guide/node050C.html printer.device/PRD_DUMPRPORT Includes_and_Autodocs_3._guide/node050D.html printer.device/PRD_DUMPRPORTTAGS Includes_and_Autodocs_3._guide/node050E.html printer.device/PRD_EDITPREFS Includes_and_Autodocs_3._guide/node050F.html printer.device/PRD_PRTCOMMAND Includes_and_Autodocs_3._guide/node0510.html printer.device/PRD_QUERY Includes_and_Autodocs_3._guide/node0511.html printer.device/PRD_RAWWRITE Includes_and_Autodocs_3._guide/node0512.html printer.device/PRD_READPREFS Includes_and_Autodocs_3._guide/node0513.html printer.device/PRD_SETERRHOOK Includes_and_Autodocs_3._guide/node0514.html printer.device/PRD_WRITEPREFS Includes_and_Autodocs_3._guide/node0515.html printer.device/PQuery Includes_and_Autodocs_3._guide/node0516.html printer.device/PRead Includes_and_Autodocs_3._guide/node0517.html printer.device/PWrite Includes_and_Autodocs_3._guide/node0518.html queue-handler.doc Includes_and_Autodocs_3._guide/node0519.html queue-handler/queue_handler Includes_and_Autodocs_3._guide/node051A.html radiobutton_gc.doc Includes_and_Autodocs_3._guide/node051B.html radiobutton_gc/--datasheet-- Includes_and_Autodocs_3._guide/node051C.html radiobutton_gc/RADIOBUTTON_GetClass Includes_and_Autodocs_3._guide/node051D.html radiobutton_gc/AllocRadioButtonNodeA Includes_and_Autodocs_3._guide/node051E.html radiobutton_gc/FreeRadioButtonNode Includes_and_Autodocs_3._guide/node051F.html radiobutton_gc/GetRadioButtonNodeAttrsA Includes_and_Autodocs_3._guide/node0520.html radiobutton_gc/SetRadioButtonNodeAttrsA Includes_and_Autodocs_3._guide/node0521.html reaction_lib.doc Includes_and_Autodocs_3._guide/node0522.html reaction.lib/--datasheet-- Includes_and_Autodocs_3._guide/node0523.html reaction.lib/BrowserNodesA Includes_and_Autodocs_3._guide/node0524.html reaction.lib/ChooserLabelsA Includes_and_Autodocs_3._guide/node0525.html reaction.lib/ClickTabsA Includes_and_Autodocs_3._guide/node0526.html reaction.lib/FreeBrowserNodes Includes_and_Autodocs_3._guide/node0527.html reaction.lib/FreeChooserLabels Includes_and_Autodocs_3._guide/node0528.html reaction.lib/FreeClickTabs Includes_and_Autodocs_3._guide/node0529.html reaction.lib/FreeRadioButtons Includes_and_Autodocs_3._guide/node052A.html reaction.lib/GetAttrs Includes_and_Autodocs_3._guide/node052B.html reaction.lib/GetCode Includes_and_Autodocs_3._guide/node052C.html reaction.lib/LBAddNodeA Includes_and_Autodocs_3._guide/node052D.html reaction.lib/LBEditNodeA Includes_and_Autodocs_3._guide/node052E.html reaction.lib/LBRemNode Includes_and_Autodocs_3._guide/node052F.html reaction.lib/LibDoGadgetMethodA Includes_and_Autodocs_3._guide/node0530.html reaction.lib/OpenLayoutWindowTagList Includes_and_Autodocs_3._guide/node0531.html reaction.lib/RadioButtonsA Includes_and_Autodocs_3._guide/node0532.html realtime.doc Includes_and_Autodocs_3._guide/node0533.html realtime.library/CreatePlayer Includes_and_Autodocs_3._guide/node0534.html realtime.library/DeletePlayer Includes_and_Autodocs_3._guide/node0535.html realtime.library/ExternalSync Includes_and_Autodocs_3._guide/node0536.html realtime.library/FindConductor Includes_and_Autodocs_3._guide/node0537.html realtime.library/GetPlayerAttrsA Includes_and_Autodocs_3._guide/node0538.html realtime.library/LockRealTime Includes_and_Autodocs_3._guide/node0539.html realtime.library/NextConductor Includes_and_Autodocs_3._guide/node053A.html realtime.library/SetConductorState Includes_and_Autodocs_3._guide/node053B.html realtime.library/SetPlayerAttrs Includes_and_Autodocs_3._guide/node053C.html realtime.library/UnlockRealTime Includes_and_Autodocs_3._guide/node053D.html resource.doc Includes_and_Autodocs_3._guide/node053E.html resource.library/--background-- Includes_and_Autodocs_3._guide/node053F.html resource.library/RL_CloseResource Includes_and_Autodocs_3._guide/node0540.html resource.library/RL_DisposeGroup Includes_and_Autodocs_3._guide/node0541.html resource.library/RL_DisposeObject Includes_and_Autodocs_3._guide/node0542.html resource.library/RL_GetObjectArray Includes_and_Autodocs_3._guide/node0543.html resource.library/RL_NewGroupA Includes_and_Autodocs_3._guide/node0544.html resource.library/RL_NewObjectA Includes_and_Autodocs_3._guide/node0545.html resource.library/RL_OpenResource Includes_and_Autodocs_3._guide/node0546.html resource.library/RL_SetResourceScreen Includes_and_Autodocs_3._guide/node0547.html rexxsyslib.doc Includes_and_Autodocs_3._guide/node0548.html rexxsyslib.library/ClearRexxMsg Includes_and_Autodocs_3._guide/node0549.html rexxsyslib.library/CreateArgstring Includes_and_Autodocs_3._guide/node054A.html rexxsyslib.library/CreateRexxMsg Includes_and_Autodocs_3._guide/node054B.html rexxsyslib.library/DeleteArgstring Includes_and_Autodocs_3._guide/node054C.html rexxsyslib.library/DeleteRexxMsg Includes_and_Autodocs_3._guide/node054D.html rexxsyslib.library/FillRexxMsg Includes_and_Autodocs_3._guide/node054E.html rexxsyslib.library/IsRexxMsg Includes_and_Autodocs_3._guide/node054F.html rexxsyslib.library/LengthArgstring Includes_and_Autodocs_3._guide/node0550.html rexxsyslib.library/LockRexxBase Includes_and_Autodocs_3._guide/node0551.html rexxsyslib.library/UnlockRexxBase Includes_and_Autodocs_3._guide/node0552.html scroller_gc.doc Includes_and_Autodocs_3._guide/node0553.html scroller_gc/--datasheet-- Includes_and_Autodocs_3._guide/node0554.html scroller_gc/SCROLLER_GetClass Includes_and_Autodocs_3._guide/node0555.html serial.doc Includes_and_Autodocs_3._guide/node0556.html serial.device/AbortIO Includes_and_Autodocs_3._guide/node0557.html serial.device/BeginIO Includes_and_Autodocs_3._guide/node0558.html serial.device/CloseDevice Includes_and_Autodocs_3._guide/node0559.html serial.device/CMD_CLEAR Includes_and_Autodocs_3._guide/node055A.html serial.device/CMD_FLUSH Includes_and_Autodocs_3._guide/node055B.html serial.device/CMD_READ Includes_and_Autodocs_3._guide/node055C.html serial.device/CMD_RESET Includes_and_Autodocs_3._guide/node055D.html serial.device/CMD_START Includes_and_Autodocs_3._guide/node055E.html serial.device/CMD_STOP Includes_and_Autodocs_3._guide/node055F.html serial.device/CMD_WRITE Includes_and_Autodocs_3._guide/node0560.html serial.device/OpenDevice Includes_and_Autodocs_3._guide/node0561.html serial.device/SDCMD_BREAK Includes_and_Autodocs_3._guide/node0562.html serial.device/SDCMD_QUERY Includes_and_Autodocs_3._guide/node0563.html serial.device/SDCMD_SETPARAMS Includes_and_Autodocs_3._guide/node0564.html sound_dtc.doc Includes_and_Autodocs_3._guide/node0565.html sound.datatype/sound.datatype Includes_and_Autodocs_3._guide/node0566.html speedbar_gc.doc Includes_and_Autodocs_3._guide/node0567.html speedbar_gc/--datasheet-- Includes_and_Autodocs_3._guide/node0568.html speedbar_gc/SPEEDBAR_GetClass Includes_and_Autodocs_3._guide/node0569.html speedbar_gc/AllocSpeedButtonNodeA Includes_and_Autodocs_3._guide/node056A.html speedbar_gc/FreeSpeedButtonNode Includes_and_Autodocs_3._guide/node056B.html speedbar_gc/GetSpeedButtonNodeAttrsA Includes_and_Autodocs_3._guide/node056C.html speedbar_gc/SetSpeedButtonNodeAttrsA Includes_and_Autodocs_3._guide/node056D.html string_gc.doc Includes_and_Autodocs_3._guide/node056E.html string_gc/--datasheet-- Includes_and_Autodocs_3._guide/node056F.html string_gc/STRING_GetClass Includes_and_Autodocs_3._guide/node0570.html text_dtc.doc Includes_and_Autodocs_3._guide/node0571.html text.datatype/text.datatype Includes_and_Autodocs_3._guide/node0572.html timer.doc Includes_and_Autodocs_3._guide/node0573.html timer.device/--background-- Includes_and_Autodocs_3._guide/node0574.html timer.device/AbortIO Includes_and_Autodocs_3._guide/node0575.html timer.device/AddTime Includes_and_Autodocs_3._guide/node0576.html timer.device/CmpTime Includes_and_Autodocs_3._guide/node0577.html timer.device/GetSysTime Includes_and_Autodocs_3._guide/node0578.html timer.device/ReadEClock Includes_and_Autodocs_3._guide/node0579.html timer.device/SubTime Includes_and_Autodocs_3._guide/node057A.html timer.device/TR_ADDREQUEST Includes_and_Autodocs_3._guide/node057B.html timer.device/TR_GETSYSTIME Includes_and_Autodocs_3._guide/node057C.html timer.device/TR_SETSYSTIME Includes_and_Autodocs_3._guide/node057D.html trackdisk.doc Includes_and_Autodocs_3._guide/node057E.html trackdisk.device/CMD_CLEAR Includes_and_Autodocs_3._guide/node057F.html trackdisk.device/CMD_READ Includes_and_Autodocs_3._guide/node0580.html trackdisk.device/CMD_UPDATE Includes_and_Autodocs_3._guide/node0581.html trackdisk.device/CMD_WRITE Includes_and_Autodocs_3._guide/node0582.html trackdisk.device/TD_ADDCHANGEINT Includes_and_Autodocs_3._guide/node0583.html trackdisk.device/TD_CHANGENUM Includes_and_Autodocs_3._guide/node0584.html trackdisk.device/TD_CHANGESTATE Includes_and_Autodocs_3._guide/node0585.html trackdisk.device/TD_EJECT Includes_and_Autodocs_3._guide/node0586.html trackdisk.device/TD_FORMAT Includes_and_Autodocs_3._guide/node0587.html trackdisk.device/TD_GETDRIVETYPE Includes_and_Autodocs_3._guide/node0588.html trackdisk.device/TD_GETGEOMETRY Includes_and_Autodocs_3._guide/node0589.html trackdisk.device/TD_GETNUMTRACKS Includes_and_Autodocs_3._guide/node058A.html trackdisk.device/TD_MOTOR Includes_and_Autodocs_3._guide/node058B.html trackdisk.device/TD_PROTSTATUS Includes_and_Autodocs_3._guide/node058C.html trackdisk.device/TD_RAWREAD Includes_and_Autodocs_3._guide/node058D.html trackdisk.device/TD_RAWWRITE Includes_and_Autodocs_3._guide/node058E.html trackdisk.device/TD_REMCHANGEINT Includes_and_Autodocs_3._guide/node058F.html trackdisk.device/TD_SEEK Includes_and_Autodocs_3._guide/node0590.html translator.doc Includes_and_Autodocs_3._guide/node0591.html translator.library/Translate Includes_and_Autodocs_3._guide/node0592.html utility.doc Includes_and_Autodocs_3._guide/node0593.html utility.library/AddNamedObject Includes_and_Autodocs_3._guide/node0594.html utility.library/AllocateTagItems Includes_and_Autodocs_3._guide/node0595.html utility.library/AllocNamedObjectA Includes_and_Autodocs_3._guide/node0596.html utility.library/Amiga2Date Includes_and_Autodocs_3._guide/node0597.html utility.library/ApplyTagChanges Includes_and_Autodocs_3._guide/node0598.html utility.library/AttemptRemNamedObject Includes_and_Autodocs_3._guide/node0599.html utility.library/CallHookPkt Includes_and_Autodocs_3._guide/node059A.html utility.library/CheckDate Includes_and_Autodocs_3._guide/node059B.html utility.library/CloneTagItems Includes_and_Autodocs_3._guide/node059C.html utility.library/Date2Amiga Includes_and_Autodocs_3._guide/node059D.html utility.library/FilterTagChanges Includes_and_Autodocs_3._guide/node059E.html utility.library/FilterTagItems Includes_and_Autodocs_3._guide/node059F.html utility.library/FindNamedObject Includes_and_Autodocs_3._guide/node05A0.html utility.library/FindTagItem Includes_and_Autodocs_3._guide/node05A1.html utility.library/FreeNamedObject Includes_and_Autodocs_3._guide/node05A2.html utility.library/FreeTagItems Includes_and_Autodocs_3._guide/node05A3.html utility.library/GetTagData Includes_and_Autodocs_3._guide/node05A4.html utility.library/GetUniqueID Includes_and_Autodocs_3._guide/node05A5.html utility.library/MapTags Includes_and_Autodocs_3._guide/node05A6.html utility.library/NamedObjectName Includes_and_Autodocs_3._guide/node05A7.html utility.library/NextTagItem Includes_and_Autodocs_3._guide/node05A8.html utility.library/PackBoolTags Includes_and_Autodocs_3._guide/node05A9.html utility.library/PackStructureTags Includes_and_Autodocs_3._guide/node05AA.html utility.library/RefreshTagItemClones Includes_and_Autodocs_3._guide/node05AB.html utility.library/ReleaseNamedObject Includes_and_Autodocs_3._guide/node05AC.html utility.library/RemNamedObject Includes_and_Autodocs_3._guide/node05AD.html utility.library/SDivMod32 Includes_and_Autodocs_3._guide/node05AE.html utility.library/SMult32 Includes_and_Autodocs_3._guide/node05AF.html utility.library/SMult64 Includes_and_Autodocs_3._guide/node05B0.html utility.library/Stricmp Includes_and_Autodocs_3._guide/node05B1.html utility.library/Strnicmp Includes_and_Autodocs_3._guide/node05B2.html utility.library/TagInArray Includes_and_Autodocs_3._guide/node05B3.html utility.library/ToLower Includes_and_Autodocs_3._guide/node05B4.html utility.library/ToUpper Includes_and_Autodocs_3._guide/node05B5.html utility.library/UDivMod32 Includes_and_Autodocs_3._guide/node05B6.html utility.library/UMult32 Includes_and_Autodocs_3._guide/node05B7.html utility.library/UMult64 Includes_and_Autodocs_3._guide/node05B8.html utility.library/UnpackStructureTags Includes_and_Autodocs_3._guide/node05B9.html wb.doc Includes_and_Autodocs_3._guide/node05BA.html workbench.library/AddAppIconA Includes_and_Autodocs_3._guide/node05BB.html workbench.library/AddAppMenuItemA Includes_and_Autodocs_3._guide/node05BC.html workbench.library/AddAppWindowA Includes_and_Autodocs_3._guide/node05BD.html workbench.library/AddAppWindowDropZoneAorkbench.library/AddAppWindowDropZoneA Includes_and_Autodocs_3._guide/node05BE.html workbench.library/ChangeWorkbenchSelectionA.library/ChangeWorkbenchSelectionA Includes_and_Autodocs_3._guide/node05BF.html workbench.library/CloseWorkbenchObjectAorkbench.library/CloseWorkbenchObjectA Includes_and_Autodocs_3._guide/node05C0.html workbench.library/MakeWorkbenchObjectVisibleArary/MakeWorkbenchObjectVisibleA Includes_and_Autodocs_3._guide/node05C1.html workbench.library/OpenWorkbenchObjectA Includes_and_Autodocs_3._guide/node05C2.html workbench.library/RemoveAppIcon Includes_and_Autodocs_3._guide/node05C3.html workbench.library/RemoveAppMenuItem Includes_and_Autodocs_3._guide/node05C4.html workbench.library/RemoveAppWindow Includes_and_Autodocs_3._guide/node05C5.html workbench.library/RemoveAppWindowDropZoneench.library/RemoveAppWindowDropZone Includes_and_Autodocs_3._guide/node05C6.html workbench.library/WBInfo Includes_and_Autodocs_3._guide/node05C7.html workbench.library/WorkbenchControlA Includes_and_Autodocs_3._guide/node05C8.html window_cl.doc Includes_and_Autodocs_3._guide/node05C9.html window_cl/--datasheet-- Includes_and_Autodocs_3._guide/node05CA.html window_cl/WINDOW_GetClass Includes_and_Autodocs_3._guide/node05CB.html window_cl/WM_CLOSE Includes_and_Autodocs_3._guide/node05CC.html window_cl/WM_HANDLEINPUT Includes_and_Autodocs_3._guide/node05CD.html window_cl/WM_ICONIFY Includes_and_Autodocs_3._guide/node05CE.html window_cl/WM_OPEN Includes_and_Autodocs_3._guide/node05CF.html window_cl/WM_RETHINK Includes_and_Autodocs_3._guide/node05D0.html include/dos/dosasl.h Includes_and_Autodocs_3._guide/node05D1.html include/datatypes/animationclass.h Includes_and_Autodocs_3._guide/node05D2.html include/libraries/amigaguide.h Includes_and_Autodocs_3._guide/node05D3.html include/graphics/monitor.h Includes_and_Autodocs_3._guide/node05D4.html include/graphics/gels.h Includes_and_Autodocs_3._guide/node05D5.html include/classes/arexx.h Includes_and_Autodocs_3._guide/node05D6.html include/workbench/workbench.h Includes_and_Autodocs_3._guide/node05D7.html include/graphics/rastport.h Includes_and_Autodocs_3._guide/node05D8.html include/libraries/aml.h Includes_and_Autodocs_3._guide/node05D9.html include/dos/dosextens.h Includes_and_Autodocs_3._guide/node05DA.html include/diskfont/diskfont.h Includes_and_Autodocs_3._guide/node05DB.html include/devices/hardblocks.h Includes_and_Autodocs_3._guide/node05DC.html include/graphics/gfx.h Includes_and_Autodocs_3._guide/node05DD.html include/datatypes/pictureclass.h Includes_and_Autodocs_3._guide/node05DE.html include/graphics/scale.h Includes_and_Autodocs_3._guide/node05DF.html include/hardware/blit.h Includes_and_Autodocs_3._guide/node05E0.html include/intuition/intuition.h Includes_and_Autodocs_3._guide/node05E1.html include/libraries/expansionbase.h Includes_and_Autodocs_3._guide/node05E2.html include/resources/card.h Includes_and_Autodocs_3._guide/node05E3.html include/libraries/locale.h Includes_and_Autodocs_3._guide/node05E4.html include/devices/cd.h Includes_and_Autodocs_3._guide/node05E5.html include/hardware/cia.h Includes_and_Autodocs_3._guide/node05E6.html include/intuition/classes.h Includes_and_Autodocs_3._guide/node05E7.html include/gadgets/texteditor.h Includes_and_Autodocs_3._guide/node05E8.html include/libraries/iffparse.h Includes_and_Autodocs_3._guide/node05E9.html include/devices/clipboard.h Includes_and_Autodocs_3._guide/node05EA.html include/graphics/clip.h Includes_and_Autodocs_3._guide/node05EB.html include/utility/date.h Includes_and_Autodocs_3._guide/node05EC.html include/graphics/text.h Includes_and_Autodocs_3._guide/node05ED.html include/graphics/view.h Includes_and_Autodocs_3._guide/node05EE.html include/gadgets/colorwheel.h Includes_and_Autodocs_3._guide/node05EF.html include/gadgets/listbrowser.h Includes_and_Autodocs_3._guide/node05F0.html include/libraries/realtime.h Includes_and_Autodocs_3._guide/node05F1.html include/libraries/configvars.h Includes_and_Autodocs_3._guide/node05F2.html include/devices/conunit.h Includes_and_Autodocs_3._guide/node05F3.html include/graphics/copper.h Includes_and_Autodocs_3._guide/node05F4.html include/prefs/locale.h Includes_and_Autodocs_3._guide/node05F5.html include/dos/rdargs.h Includes_and_Autodocs_3._guide/node05F6.html include/hardware/custom.h Includes_and_Autodocs_3._guide/node05F7.html include/datatypes/datatypes.h Includes_and_Autodocs_3._guide/node05F8.html include/dos/dos.h Includes_and_Autodocs_3._guide/node05F9.html include/dos/datetime.h Includes_and_Autodocs_3._guide/node05FA.html include/libraries/hdwrench.h Includes_and_Autodocs_3._guide/node05FB.html include/exec/devices.h Includes_and_Autodocs_3._guide/node05FC.html include/devices/prtbase.h Includes_and_Autodocs_3._guide/node05FD.html include/dos/filehandler.h Includes_and_Autodocs_3._guide/node05FE.html include/libraries/configregs.h Includes_and_Autodocs_3._guide/node05FF.html include/graphics/displayinfo.h Includes_and_Autodocs_3._guide/node0600.html include/resources/disk.h Includes_and_Autodocs_3._guide/node0601.html include/libraries/asl.h Includes_and_Autodocs_3._guide/node0602.html include/intuition/screens.h Includes_and_Autodocs_3._guide/node0603.html include/images/drawlist.h Includes_and_Autodocs_3._guide/node0604.html include/devices/trackdisk.h Includes_and_Autodocs_3._guide/node0605.html include/devices/printer.h Includes_and_Autodocs_3._guide/node0606.html include/datatypes/datatypesclass.h Includes_and_Autodocs_3._guide/node0607.html include/devices/timer.h Includes_and_Autodocs_3._guide/node0608.html include/dos/exall.h Includes_and_Autodocs_3._guide/node0609.html include/exec/execbase.h Includes_and_Autodocs_3._guide/node060A.html include/graphics/gfxnodes.h Includes_and_Autodocs_3._guide/node060B.html include/graphics/sprite.h Includes_and_Autodocs_3._guide/node060C.html include/resources/filesysres.h Includes_and_Autodocs_3._guide/node060D.html include/prefs/font.h Includes_and_Autodocs_3._guide/node060E.html include/intuition/cghooks.h Includes_and_Autodocs_3._guide/node060F.html include/devices/gameport.h Includes_and_Autodocs_3._guide/node0610.html include/gadgets/getfile.h Includes_and_Autodocs_3._guide/node0611.html include/gadgets/getfont.h Includes_and_Autodocs_3._guide/node0612.html include/graphics/gfxbase.h Includes_and_Autodocs_3._guide/node0613.html include/diskfont/glyph.h Includes_and_Autodocs_3._guide/node0614.html include/reaction/reaction_class.h Includes_and_Autodocs_3._guide/node0615.html include/intuition/gadgetclass.h Includes_and_Autodocs_3._guide/node0616.html include/gadgets/getscreenmode.h Includes_and_Autodocs_3._guide/node0617.html include/utility/hooks.h Includes_and_Autodocs_3._guide/node0618.html include/workbench/icon.h Includes_and_Autodocs_3._guide/node0619.html include/prefs/icontrol.h Includes_and_Autodocs_3._guide/node061A.html include/devices/inputevent.h Includes_and_Autodocs_3._guide/node061B.html include/intuition/imageclass.h Includes_and_Autodocs_3._guide/node061C.html include/prefs/input.h Includes_and_Autodocs_3._guide/node061D.html include/exec/interrupts.h Includes_and_Autodocs_3._guide/node061E.html include/intuition/intuitionbase.h Includes_and_Autodocs_3._guide/node061F.html include/devices/audio.h Includes_and_Autodocs_3._guide/node0620.html include/rexx/rexxio.h Includes_and_Autodocs_3._guide/node0621.html include/exec/io.h Includes_and_Autodocs_3._guide/node0622.html include/graphics/graphint.h Includes_and_Autodocs_3._guide/node0623.html include/devices/keymap.h Includes_and_Autodocs_3._guide/node0624.html include/libraries/lowlevel.h Includes_and_Autodocs_3._guide/node0625.html include/graphics/layers.h Includes_and_Autodocs_3._guide/node0626.html include/exec/libraries.h Includes_and_Autodocs_3._guide/node0627.html include/datatypes/textclass.h Includes_and_Autodocs_3._guide/node0628.html include/exec/lists.h Includes_and_Autodocs_3._guide/node0629.html include/dos/var.h Includes_and_Autodocs_3._guide/node062A.html include/libraries/gadtools.h Includes_and_Autodocs_3._guide/node062B.html include/libraries/mathlibrary.h Includes_and_Autodocs_3._guide/node062C.html include/resources/mathresource.h Includes_and_Autodocs_3._guide/node062D.html include/exec/memory.h Includes_and_Autodocs_3._guide/node062E.html include/exec/ports.h Includes_and_Autodocs_3._guide/node062F.html include/exec/nodes.h Includes_and_Autodocs_3._guide/node0630.html include/devices/narrator.h Includes_and_Autodocs_3._guide/node0631.html include/utility/name.h Includes_and_Autodocs_3._guide/node0632.html include/libraries/commodities.h Includes_and_Autodocs_3._guide/node0633.html include/rexx/storage.h Includes_and_Autodocs_3._guide/node0634.html include/dos/notify.h Includes_and_Autodocs_3._guide/node0635.html include/libraries/nonvolatile.h Includes_and_Autodocs_3._guide/node0636.html include/intuition/classusr.h Includes_and_Autodocs_3._guide/node0637.html include/classes/requester.h Includes_and_Autodocs_3._guide/node0638.html include/prefs/overscan.h Includes_and_Autodocs_3._guide/node0639.html include/prefs/palette.h Includes_and_Autodocs_3._guide/node063A.html include/prefs/pointer.h Includes_and_Autodocs_3._guide/node063B.html include/intuition/preferences.h Includes_and_Autodocs_3._guide/node063C.html include/prefs/prefhdr.h Includes_and_Autodocs_3._guide/node063D.html include/prefs/printertxt.h Includes_and_Autodocs_3._guide/node063E.html include/prefs/printergfx.h Includes_and_Autodocs_3._guide/node063F.html include/prefs/printerps.h Includes_and_Autodocs_3._guide/node0640.html include/prefs/reaction.h Includes_and_Autodocs_3._guide/node0641.html include/dos/record.h Includes_and_Autodocs_3._guide/node0642.html include/graphics/regions.h Includes_and_Autodocs_3._guide/node0643.html include/exec/resident.h Includes_and_Autodocs_3._guide/node0644.html include/rexx/rxslib.h Includes_and_Autodocs_3._guide/node0645.html include/prefs/screenmode.h Includes_and_Autodocs_3._guide/node0646.html include/devices/scsidisk.h Includes_and_Autodocs_3._guide/node0647.html include/exec/semaphores.h Includes_and_Autodocs_3._guide/node0648.html include/prefs/serial.h Includes_and_Autodocs_3._guide/node0649.html include/intuition/sghooks.h Includes_and_Autodocs_3._guide/node064A.html include/prefs/sound.h Includes_and_Autodocs_3._guide/node064B.html include/exec/tasks.h Includes_and_Autodocs_3._guide/node064C.html include/utility/tagitem.h Includes_and_Autodocs_3._guide/node064D.html include/reaction/reaction_prefs.h Includes_and_Autodocs_3._guide/node064E.html include/utility/utility.h Includes_and_Autodocs_3._guide/node064F.html include/datatypes/soundclass.h Includes_and_Autodocs_3._guide/node0650.html include/workbench/startup.h Includes_and_Autodocs_3._guide/node0651.html include/prefs/wbpattern.h Includes_and_Autodocs_3._guide/node0652.html include/classes/window.h Includes_and_Autodocs_3._guide/node0653.html include/prefs/workbench.h Includes_and_Autodocs_3._guide/node0654.html include/exec/types.h Includes_and_Autodocs_3._guide/node0655.html include/diskfont/diskfonttag.h Includes_and_Autodocs_3._guide/node0656.html include/diskfont/oterrors.h Includes_and_Autodocs_3._guide/node0657.html include/devices/console.h Includes_and_Autodocs_3._guide/node0658.html include/dos/dostags.h Includes_and_Autodocs_3._guide/node0659.html include/libraries/dos.h Includes_and_Autodocs_3._guide/node065A.html include/dos/stdio.h Includes_and_Autodocs_3._guide/node065B.html include/exec/alerts.h Includes_and_Autodocs_3._guide/node065C.html include/hardware/intbits.h Includes_and_Autodocs_3._guide/node065D.html include/libraries/dosextens.h Includes_and_Autodocs_3._guide/node065E.html include/libraries/filehandler.h Includes_and_Autodocs_3._guide/node065F.html include/gadgets/fuelgauge.h Includes_and_Autodocs_3._guide/node0660.html include/graphics/gfxmacros.h Includes_and_Autodocs_3._guide/node0661.html include/graphics/modeid.h Includes_and_Autodocs_3._guide/node0662.html include/graphics/coerce.h Includes_and_Autodocs_3._guide/node0663.html include/graphics/rpattr.h Includes_and_Autodocs_3._guide/node0664.html include/graphics/videocontrol.h Includes_and_Autodocs_3._guide/node0665.html include/devices/prtgfx.h Includes_and_Autodocs_3._guide/node0666.html include/libraries/resource.h Includes_and_Autodocs_3._guide/node0667.html include/gadgets/scroller.h Includes_and_Autodocs_3._guide/node0668.html include/devices/serial.h Includes_and_Autodocs_3._guide/node0669.html include/gadgets/speedbar.h Includes_and_Autodocs_3._guide/node066A.html include/utility/pack.h Libraries_Manual_guide/node0000.html Amiga® RKM Libraries: Contents Libraries_Manual_guide/node0001.html Please note... Libraries_Manual_guide/node0002.html Amiga® RKM Libraries: User Interface Libraries Libraries_Manual_guide/node0003.html Amiga® RKM Libraries: Exec Library Libraries_Manual_guide/node0004.html Amiga® RKM Libraries: Graphics Libraries Libraries_Manual_guide/node0005.html Amiga® RKM Libraries: Additional Libraries Libraries_Manual_guide/node0006.html Amiga® RKM Libraries: Appendices Libraries_Manual_guide/node0007.html Amiga® RKM Libraries: Preface Libraries_Manual_guide/node0008.html Amiga® RKM Libraries: 1 Introduction to Amiga System Libraries Libraries_Manual_guide/node0009.html 1 Introduction to Libraries / Programming in the Amiga Environment Libraries_Manual_guide/node000A.html 1 / Programming in the Amiga Environment / Multitasking Libraries_Manual_guide/node000B.html 1 / / Multitasking / What the System Does For You Libraries_Manual_guide/node000C.html 1 / / Multitasking / What the System Doesn't Do For You Libraries_Manual_guide/node000D.html 1 / Programming in the Amiga Environment / Libraries of Functions Libraries_Manual_guide/node000E.html 1 / / Libraries of Functions / Opening a Library in C Libraries_Manual_guide/node000F.html 1 / / Libraries of Functions / Opening a Library in Assembler Libraries_Manual_guide/node0010.html 1 / / Libraries of Functions / Another Kind of Function Library Libraries_Manual_guide/node0011.html 1 / / Libraries of Functions / Libraries, Devices and Resources Libraries_Manual_guide/node0012.html 1 / Programming in the Amiga Environment / Dynamic Memory Architecture Libraries_Manual_guide/node0013.html 1 / / Dynamic Memory Architecture / Exec: The System Executive Libraries_Manual_guide/node0014.html 1 / Programming in the Amiga Environment / Operating System Versions Libraries_Manual_guide/node0015.html 1 / / Operating System Versions / About Release 2 Libraries_Manual_guide/node0016.html 1 / Programming in the Amiga Environment / The Custom Chips Libraries_Manual_guide/node0017.html 1 / / The Custom Chips / Custom Chip Revisions Libraries_Manual_guide/node0018.html 1 / / The Custom Chips / Two Kinds of Memory Libraries_Manual_guide/node0019.html 1 Introduction to Amiga System Libraries / About the Examples Libraries_Manual_guide/node001A.html 1 Introduction to Libraries / General Amiga Development Guidelines Libraries_Manual_guide/node001B.html 1 / General Development Guidelines / 68010/020/030/040 Compatibility Libraries_Manual_guide/node001C.html 1 / General Development Guidelines / Hardware Programming Guidelines Libraries_Manual_guide/node001D.html 1 / General Guidelines / Additional Assembler Development Guidelines Libraries_Manual_guide/node001E.html 1 Introduction to Amiga System Libraries / 1.3 Compatibility Issues Libraries_Manual_guide/node001F.html 1 / 1.3 Compatibility Issues / Design Decisions Libraries_Manual_guide/node0020.html 1 / / Design Decisions / Transparent Release 2 Extensions Libraries_Manual_guide/node0021.html 1 / / Design Decisions / Conditional Code Libraries_Manual_guide/node0022.html 1 / / Design Decisions / ASL Requesters Libraries_Manual_guide/node0023.html 1 / / Design / DOS System(), CreateNewProc(), and CON: Enhancements Libraries_Manual_guide/node0024.html 1 / / Design Decisions / The Display Database Libraries_Manual_guide/node0025.html 1 / / Design Decisions / ARexx Libraries_Manual_guide/node0026.html 1 / 1.3 Compatibility Issues / Compatible Libraries Libraries_Manual_guide/node0027.html 1 / / Compatible Libraries / IFFParse Library Libraries_Manual_guide/node0028.html 1 / / Compatible Libraries / Single Precision IEEE Math Libraries Libraries_Manual_guide/node0029.html 1 / / Compatible Libraries / Third Party Compatible Libraries Libraries_Manual_guide/node002A.html 1 / Introduction / Commodore Applications and Technical Support (CATS) Libraries_Manual_guide/node002B.html 1 Introduction to Amiga System Libraries / Error Reports Libraries_Manual_guide/node002C.html Amiga® RKM Libraries: Index Libraries_Manual_guide/node002D.html Misc Index Libraries_Manual_guide/node002E.html 680x0 Index Libraries_Manual_guide/node002F.html A Index Libraries_Manual_guide/node0030.html Active Window Index Libraries_Manual_guide/node0031.html Alert Index Libraries_Manual_guide/node0032.html Amiga Index Libraries_Manual_guide/node0033.html Animation Index Libraries_Manual_guide/node0034.html ASL Index Libraries_Manual_guide/node0035.html attributes Index Libraries_Manual_guide/node0036.html B Index Libraries_Manual_guide/node0037.html Backdrop Index Libraries_Manual_guide/node0038.html BitMap Index Libraries_Manual_guide/node0039.html BitMap Structure Index Libraries_Manual_guide/node003A.html BitPlane Index Libraries_Manual_guide/node003B.html Blitter Index Libraries_Manual_guide/node003C.html Boopsi Index Libraries_Manual_guide/node003D.html Border Index Libraries_Manual_guide/node003E.html Border structure Index Libraries_Manual_guide/node003F.html Borderless Index Libraries_Manual_guide/node0040.html C Index Libraries_Manual_guide/node0041.html Caveats Index Libraries_Manual_guide/node0042.html Checkmark Index Libraries_Manual_guide/node0043.html Chip Memory Index Libraries_Manual_guide/node0044.html Clipping Index Libraries_Manual_guide/node0045.html Clipping Rectangles Index Libraries_Manual_guide/node0046.html Color Index Libraries_Manual_guide/node0047.html Commodities Index Libraries_Manual_guide/node0048.html Compatibility Index Libraries_Manual_guide/node0049.html Copper Index Libraries_Manual_guide/node004A.html Copper list Index Libraries_Manual_guide/node004B.html D Index Libraries_Manual_guide/node004C.html Dates Index Libraries_Manual_guide/node004D.html Deadlock Index Libraries_Manual_guide/node004E.html Depth Gadget Index Libraries_Manual_guide/node004F.html Device Index Libraries_Manual_guide/node0050.html DrawInfo structure Index Libraries_Manual_guide/node0051.html Drawing Index Libraries_Manual_guide/node0052.html DrawMode Index Libraries_Manual_guide/node0053.html Dual playfield Index Libraries_Manual_guide/node0054.html E Index Libraries_Manual_guide/node0055.html EasyStruct structure Index Libraries_Manual_guide/node0056.html Error Index Libraries_Manual_guide/node0057.html Examples Index Libraries_Manual_guide/node0058.html Exceptions Index Libraries_Manual_guide/node0059.html Exec Index Libraries_Manual_guide/node005A.html Expansion Index Libraries_Manual_guide/node005B.html F Index Libraries_Manual_guide/node005C.html FgPen Index Libraries_Manual_guide/node005D.html Flags Index Libraries_Manual_guide/node005E.html Font Index Libraries_Manual_guide/node005F.html G Index Libraries_Manual_guide/node0060.html Gadget Index Libraries_Manual_guide/node0061.html Gadget structure Index Libraries_Manual_guide/node0062.html GadTools Index Libraries_Manual_guide/node0063.html GimmeZeroZero Index Libraries_Manual_guide/node0064.html Graphics Index Libraries_Manual_guide/node0065.html H Index Libraries_Manual_guide/node0066.html Hooks Index Libraries_Manual_guide/node0067.html I Index Libraries_Manual_guide/node0068.html IDCMP Index Libraries_Manual_guide/node0069.html IFF Index Libraries_Manual_guide/node006A.html IFFParse Index Libraries_Manual_guide/node006B.html Image structure Index Libraries_Manual_guide/node006C.html International strings Index Libraries_Manual_guide/node006D.html Interrupt Structure Index Libraries_Manual_guide/node006E.html Interrupts Index Libraries_Manual_guide/node006F.html IntuiMessage structure Index Libraries_Manual_guide/node0070.html IntuiText structure Index Libraries_Manual_guide/node0071.html Intuition Index Libraries_Manual_guide/node0072.html J Index Libraries_Manual_guide/node0073.html K Index Libraries_Manual_guide/node0074.html Keyboard Index Libraries_Manual_guide/node0075.html Keymap Index Libraries_Manual_guide/node0076.html L Index Libraries_Manual_guide/node0077.html Layer Structure Index Libraries_Manual_guide/node0078.html Layers Index Libraries_Manual_guide/node0079.html Left Amiga Key Index Libraries_Manual_guide/node007A.html Libraries Index Libraries_Manual_guide/node007B.html Library Index Libraries_Manual_guide/node007C.html Library (Exec) Index Libraries_Manual_guide/node007D.html Lines Index Libraries_Manual_guide/node007E.html Lists Index Libraries_Manual_guide/node007F.html LoadView() Index Libraries_Manual_guide/node0080.html Lock Index Libraries_Manual_guide/node0081.html M Index Libraries_Manual_guide/node0082.html MakeVPort() Index Libraries_Manual_guide/node0083.html Memory Index Libraries_Manual_guide/node0084.html Menu Index Libraries_Manual_guide/node0085.html Menu Number Index Libraries_Manual_guide/node0086.html Menu structure Index Libraries_Manual_guide/node0087.html MenuItem structure Index Libraries_Manual_guide/node0088.html Message Port Index Libraries_Manual_guide/node0089.html Messages Index Libraries_Manual_guide/node008A.html Mouse Index Libraries_Manual_guide/node008B.html MrgCop() Index Libraries_Manual_guide/node008C.html N Index Libraries_Manual_guide/node008D.html NewWindow structure Index Libraries_Manual_guide/node008E.html Nodes Index Libraries_Manual_guide/node008F.html O Index Libraries_Manual_guide/node0090.html OM_SET Index Libraries_Manual_guide/node0091.html Output Index Libraries_Manual_guide/node0092.html Overscan Index Libraries_Manual_guide/node0093.html P Index Libraries_Manual_guide/node0094.html Pens Index Libraries_Manual_guide/node0095.html Pointer Index Libraries_Manual_guide/node0096.html Position Index Libraries_Manual_guide/node0097.html Preferences Index Libraries_Manual_guide/node0098.html Public Screen Index Libraries_Manual_guide/node0099.html PubScreenNode Structure Index Libraries_Manual_guide/node009A.html Q Index Libraries_Manual_guide/node009B.html Qualifier Index Libraries_Manual_guide/node009C.html Queue Limit Index Libraries_Manual_guide/node009D.html R Index Libraries_Manual_guide/node009E.html Raster Index Libraries_Manual_guide/node009F.html Refresh Index Libraries_Manual_guide/node00A0.html Regions Index Libraries_Manual_guide/node00A1.html Requester Index Libraries_Manual_guide/node00A2.html Requester Structure Index Libraries_Manual_guide/node00A3.html Right Mouse Button Index Libraries_Manual_guide/node00A4.html RxOffset Index Libraries_Manual_guide/node00A5.html RyOffset Index Libraries_Manual_guide/node00A6.html S Index Libraries_Manual_guide/node00A7.html Screen Structure Index Libraries_Manual_guide/node00A8.html Screens Index Libraries_Manual_guide/node00A9.html Scrolling Index Libraries_Manual_guide/node00AA.html Signals Index Libraries_Manual_guide/node00AB.html Simple Sprite Index Libraries_Manual_guide/node00AC.html Size Index Libraries_Manual_guide/node00AD.html SprColors pointer Index Libraries_Manual_guide/node00AE.html Sprite Index Libraries_Manual_guide/node00AF.html Stack Index Libraries_Manual_guide/node00B0.html Structures Index Libraries_Manual_guide/node00B1.html SuperBitMap Refresh Index Libraries_Manual_guide/node00B2.html T Index Libraries_Manual_guide/node00B3.html Tag lists Index Libraries_Manual_guide/node00B4.html Tags Index Libraries_Manual_guide/node00B5.html Tasks Index Libraries_Manual_guide/node00B6.html Text Index Libraries_Manual_guide/node00B7.html Title Index Libraries_Manual_guide/node00B8.html Title Bar Index Libraries_Manual_guide/node00B9.html ToolTypes Index Libraries_Manual_guide/node00BA.html TRAP Index Libraries_Manual_guide/node00BB.html U Index Libraries_Manual_guide/node00BC.html Utility Index Libraries_Manual_guide/node00BD.html V Index Libraries_Manual_guide/node00BE.html VideoControl() Index Libraries_Manual_guide/node00BF.html ViewPort Index Libraries_Manual_guide/node00C0.html VSprite Index Libraries_Manual_guide/node00C1.html W,X,Y,Z Index Libraries_Manual_guide/node00C2.html Window Index Libraries_Manual_guide/node00C3.html Window structure Index Libraries_Manual_guide/node00C4.html Workbench Index Libraries_Manual_guide/node00C5.html Zoom Index Libraries_Manual_guide/node00C6.html RKM Libraries: 2 Intuition and the Amiga Graphical User Interface Libraries_Manual_guide/node00C7.html 2 Intuition and the Graphical User Interface / About User Interfaces Libraries_Manual_guide/node00C8.html 2 / User Interfaces / Elements of the Graphical User Interface System Libraries_Manual_guide/node00C9.html 2 / About User Interfaces / Goals of Intuition Libraries_Manual_guide/node00CA.html 2 Intuition and the Graphical Interface / How the User Sees Intuition Libraries_Manual_guide/node00CB.html 2 / How the User Sees Intuition / Workbench and Preferences Libraries_Manual_guide/node00CC.html 2 / How the User Sees Intuition / Intuition's 3D Look Libraries_Manual_guide/node00CD.html 2 Intuition & Graphical Interface / How an Application Sees Intuition Libraries_Manual_guide/node00CE.html 2 / How an Application Sees Intuition / Components of Intuition Libraries_Manual_guide/node00CF.html 2 / How an Application Sees Intuition / Screens and Windows Libraries_Manual_guide/node00D0.html 2 / How an Application Sees Intuition / Gadgets, Menus And Requesters Libraries_Manual_guide/node00D1.html 2 / / Gadgets, Menus And Requesters / Gadgets Libraries_Manual_guide/node00D2.html 2 / / Gadgets, Menus And Requesters / Menus Libraries_Manual_guide/node00D3.html 2 / / Gadgets, Menus And Requesters / Requesters Libraries_Manual_guide/node00D4.html 2 / / Gadgets, Menus And Requesters / The Intuition Input Event Loop Libraries_Manual_guide/node00D5.html 2 Intuition and the Graphical Interface / A Simple Intuition Program Libraries_Manual_guide/node00D6.html 2 / A Simple Intuition Program / Example Intuition Event Loop Libraries_Manual_guide/node00D7.html Amiga® RKM Libraries: 3 Intuition Screens Libraries_Manual_guide/node00D8.html 3 Intuition Screens / Types of Screens Libraries_Manual_guide/node00D9.html 3 / Types of Screens / Multiple Screens Libraries_Manual_guide/node00DA.html 3 / Types of Screens / Public Screens and Custom Screens Libraries_Manual_guide/node00DB.html 3 / Types of Screens / Screen Components Libraries_Manual_guide/node00DC.html 3 Intuition Screens / Screen Data Structures Libraries_Manual_guide/node00DD.html 3 / Screen Data Structures / The Intuition Screen Data Structure Libraries_Manual_guide/node00DE.html 3 / Screen Data Structures / Other Screen Data Structures Libraries_Manual_guide/node00DF.html 3 Intuition Screens / Custom Screen Functions Libraries_Manual_guide/node00E0.html 3 / Custom Screen Functions / Creating A New Custom Screen Libraries_Manual_guide/node00E1.html 3 / / Creating A New Custom Screen / A Custom Screen Example Libraries_Manual_guide/node00E2.html 3 / / / Creating A Custom Screen that Works With Older Systems Libraries_Manual_guide/node00E3.html 3 / / Creating Custom Screen / Return Values from OpenScreenTagList() Libraries_Manual_guide/node00E4.html 3 / / Creating A New Custom Screen / Closing the Screen Libraries_Manual_guide/node00E5.html 3 / Custom Screen Functions / Screen Attributes Libraries_Manual_guide/node00E6.html 3 Intuition Screens / Public Screen Functions Libraries_Manual_guide/node00E7.html 3 / Public Screen Functions / Accessing a Public Screen by Name Libraries_Manual_guide/node00E8.html 3 / Public Screen Functions / The Default Public Screen and Workbench Libraries_Manual_guide/node00E9.html 3 / Public Screen Functions / Taking a New Custom Screen Public Libraries_Manual_guide/node00EA.html 3 / Public Screen Functions / Searching the Public Screen List Libraries_Manual_guide/node00EB.html 3 Intuition Screens / DrawInfo and the 3D Look Libraries_Manual_guide/node00EC.html 3 / DrawInfo and the 3D Look / The Pen Specification in DrawInfo Libraries_Manual_guide/node00ED.html 3 / DrawInfo and the 3D Look / The Font Specification in DrawInfo Libraries_Manual_guide/node00EE.html 3 / DrawInfo and the 3D Look / Cloning a Public Screen (Workbench) Libraries_Manual_guide/node00EF.html 3 Intuition Screens / Overscan and the Display Clip Libraries_Manual_guide/node00F0.html 3 / Overscan and the Display Clip / Preset Overscan Values Libraries_Manual_guide/node00F1.html 3 Intuition Screens / Intuition Screens and the Graphics Library Libraries_Manual_guide/node00F2.html 3 / Intuition Screens and Graphics Library / Changing Screen Colors Libraries_Manual_guide/node00F3.html 3 / Intuition Screens and the Graphics Library / Direct Screen Access Libraries_Manual_guide/node00F4.html 3 / / Screen Functions That Integrate Intuition and Graphics Libraries_Manual_guide/node00F5.html 3 / Screens and Graphics Lib / Limitations of the Graphics Subsystem Libraries_Manual_guide/node00F6.html 3 Intuition Screens / Advanced Screen Programming Libraries_Manual_guide/node00F7.html 3 / Advanced Screen Programming / Double Buffering Libraries_Manual_guide/node00F8.html 3 / Advanced Screen Programming / Dual-Playfield Screen Example Libraries_Manual_guide/node00F9.html 3 Intuition Screens / Other Screen Functions Libraries_Manual_guide/node00FA.html 3 / Other Screen Functions / Screen Depth Arrangement Libraries_Manual_guide/node00FB.html 3 / Other Screen Functions / Screen Movement and Scrolling Libraries_Manual_guide/node00FC.html 3 / Other Screen Functions / Miscellaneous Screen Functions Libraries_Manual_guide/node00FD.html 3 Intuition Screens / Function Reference Libraries_Manual_guide/node00FE.html Amiga® RKM Libraries: 4 Intuition Windows Libraries_Manual_guide/node00FF.html 4 Intuition Windows / About Windows Libraries_Manual_guide/node0100.html 4 / About Windows / Window System Gadgets Libraries_Manual_guide/node0101.html 4 / About Windows / The Active Window Libraries_Manual_guide/node0102.html 4 Intuition Windows / Basic Window Structures and Functions Libraries_Manual_guide/node0103.html 4 / Basic Window Structures and Functions / Opening a Window Libraries_Manual_guide/node0104.html 4 / / Opening A Window / Setting Window Attributes Libraries_Manual_guide/node0105.html 4 / Basic Window Structures and Functions / Closing Windows Libraries_Manual_guide/node0106.html 4 / Basic Window Structures and Functions / Windows and Screens Libraries_Manual_guide/node0107.html 4 / Window Structures and Functions / Graphics and Text in Windows Libraries_Manual_guide/node0108.html 4 / Basic Window Structures and Functions / Window Dimensions Libraries_Manual_guide/node0109.html 4 / / Window Dimensions / A Display Sized Window Example Libraries_Manual_guide/node010A.html 4 / Basic Window Structures and Functions / Window Border Dimensions Libraries_Manual_guide/node010B.html 4 / Window Structures and Functions / Changing Window Size Limits Libraries_Manual_guide/node010C.html 4 Intuition Windows / Communicating with Intuition Libraries_Manual_guide/node010D.html 4 / Communicating with Intuition / The IDCMP Libraries_Manual_guide/node010E.html 4 / Communicating with Intuition / The Console Device Libraries_Manual_guide/node010F.html 4 / Communicating with Intuition / The IDCMP And The Active Window Libraries_Manual_guide/node0110.html 4 / Communicating with Intuition / The IDCMP And Gadgets Libraries_Manual_guide/node0111.html 4 / / The IDCMP And Gadgets / System Gadgets Libraries_Manual_guide/node0112.html 4 / / The IDCMP And Gadgets / Application Gadgets Libraries_Manual_guide/node0113.html 4 Intuition Windows / Window Types Libraries_Manual_guide/node0114.html 4 / Window Types / Backdrop Window Type Libraries_Manual_guide/node0115.html 4 / Window Types / Borderless Window Type Libraries_Manual_guide/node0116.html 4 / Window Types / GimmeZeroZero Window Type Libraries_Manual_guide/node0117.html 4 Intuition Windows / Preserving the Window Display Libraries_Manual_guide/node0118.html 4 / Preserving the Window Display / Damage Regions Libraries_Manual_guide/node0119.html 4 / Preserving the Window Display / Refreshing Intuition Windows Libraries_Manual_guide/node011A.html 4 / / Refreshing Intuition Windows / Simple Refresh Libraries_Manual_guide/node011B.html 4 / / Refreshing Intuition Windows / Smart Refresh Libraries_Manual_guide/node011C.html 4 / / Refreshing Intuition Windows / SuperBitMap Refresh Libraries_Manual_guide/node011D.html 4 / Preserving the Window Display / Intuition Refresh Events Libraries_Manual_guide/node011E.html 4 / Preserving the Window Display / Optimized Window Refreshing Libraries_Manual_guide/node011F.html 4 / Preserving the Window Display / Setting Up A SuperBitMap Window Libraries_Manual_guide/node0120.html 4 / / Setting Up A SuperBitMap Window / Graphics and Layers Functions Libraries_Manual_guide/node0121.html 4 Intuition Windows / The Window Structure Libraries_Manual_guide/node0122.html 4 Intuition Windows / Window Attributes Libraries_Manual_guide/node0123.html 4 / Window Attributes / Extended New Window Libraries_Manual_guide/node0124.html 4 / Window Attributes / Window Attribute Tags Libraries_Manual_guide/node0125.html 4 / Window Attributes / Boolean Window Attribute Tags Libraries_Manual_guide/node0126.html 4 Intuition Windows / Other Window Functions Libraries_Manual_guide/node0127.html 4 / Other Window Functions / Menus and the Active Window Libraries_Manual_guide/node0128.html 4 / Other Window Functions / Requesters in the Window Libraries_Manual_guide/node0129.html 4 / Other Window Functions / Program Control of Window Arrangement Libraries_Manual_guide/node012A.html 4 / Other Window Functions / Changing the Window or Screen Title Libraries_Manual_guide/node012B.html 4 / Other Window Functions / Changing Message Queue Limits Libraries_Manual_guide/node012C.html 4 / Other Window Functions / Changing Pointer Position Reports Libraries_Manual_guide/node012D.html 4 / Other Window Functions / Custom Pointers Libraries_Manual_guide/node012E.html 4 Intuition Windows / Function Reference Libraries_Manual_guide/node012F.html Amiga® RKM Libraries: 5 Intuition Gadgets Libraries_Manual_guide/node0130.html 5 Intuition Gadgets / About Gadgets Libraries_Manual_guide/node0131.html 5 / About Gadgets / System Gadgets Libraries_Manual_guide/node0132.html 5 / About Gadgets / Application Gadgets Libraries_Manual_guide/node0133.html 5 / About Gadgets / Adding and Removing Gadgets Libraries_Manual_guide/node0134.html 5 Intuition Gadgets / Gadget Imagery Libraries_Manual_guide/node0135.html 5 / Gadget Imagery / Hand Drawn Gadgets Libraries_Manual_guide/node0136.html 5 / Gadget Imagery / Line Drawn Gadgets Libraries_Manual_guide/node0137.html 5 / Gadget Imagery / Gadget Text Libraries_Manual_guide/node0138.html 5 / Gadget Imagery / Gadgets Without Imagery Libraries_Manual_guide/node0139.html 5 Intuition Gadgets / Gadget Selection Libraries_Manual_guide/node013A.html 5 Intuition Gadgets / Gadget Size and Position Libraries_Manual_guide/node013B.html 5 / Gadget Size and Position / Select Box Position Libraries_Manual_guide/node013C.html 5 / Gadget Size and Position / Select Box Dimension Libraries_Manual_guide/node013D.html 5 / Gadget Size and Position / Positioning Gadgets in Window Borders Libraries_Manual_guide/node013E.html 5 Intuition Gadgets / Gadget Highlighting Libraries_Manual_guide/node013F.html 5 / Gadget Highlighting / Highlighting by Color Complementing Libraries_Manual_guide/node0140.html 5 / Gadget Highlighting / Highlighting by Drawing a Box Libraries_Manual_guide/node0141.html 5 / Gadget Highlighting / With an Alternate Image or Alternate Border Libraries_Manual_guide/node0142.html 5 Intuition Gadgets / Gadget Refreshing Libraries_Manual_guide/node0143.html 5 / Gadget Refreshing / Gadget Refreshing by Intuition Libraries_Manual_guide/node0144.html 5 / Gadget Refreshing / Gadget Refreshing by the Program Libraries_Manual_guide/node0145.html 5 / / Gadget Refreshing by the Program / Updating a Gadget's Imagery Libraries_Manual_guide/node0146.html 5 / / Gadget Refreshing by the Program / Gadget Refresh Function Libraries_Manual_guide/node0147.html 5 Intuition Gadgets / Gadget Enabling and Disabling Libraries_Manual_guide/node0148.html 5 Intuition Gadgets / Gadget Pointer Movements Libraries_Manual_guide/node0149.html 5 Intuition Gadgets / Gadget Structure Libraries_Manual_guide/node014A.html 5 / Gadget Structure / Gadget Flags Libraries_Manual_guide/node014B.html 5 / Gadget Structure / Gadget Activation Flags Libraries_Manual_guide/node014C.html 5 Intuition Gadgets / Boolean Gadget Type Libraries_Manual_guide/node014D.html 5 / Boolean Gadget Type / Masked Boolean Gadgets Libraries_Manual_guide/node014E.html 5 / Boolean Gadget Type / BoolInfo Structure Libraries_Manual_guide/node014F.html 5 / Boolean Gadget Type / Mutual Exclude Libraries_Manual_guide/node0150.html 5 / / Mutual Exclude / Gadget Type for Mutual Exclusion Libraries_Manual_guide/node0151.html 5 / / Mutual Exclude / Gadget Highlighting for Mutual Exclusion Libraries_Manual_guide/node0152.html 5 / / Mutual Exclude / Handling of Mutually Exclusive Gadgets Libraries_Manual_guide/node0153.html 5 Intuition Gadgets / Proportional Gadget Type Libraries_Manual_guide/node0154.html 5 / Proportional Gadget Type / New 3D Look Proportional Gadgets Libraries_Manual_guide/node0155.html 5 / Proportional Gadget Type / Logical Types of Proportional Gadgets Libraries_Manual_guide/node0156.html 5 / / Logical Types of Proportional Gadgets / Scrollers Libraries_Manual_guide/node0157.html 5 / / Logical Types of Proportional Gadgets / Sliders Libraries_Manual_guide/node0158.html 5 / Proportional Gadget Type / Proportional Gadget Components Libraries_Manual_guide/node0159.html 5 / / Proportional Gadget Components / The Container Libraries_Manual_guide/node015A.html 5 / / Proportional Gadget Components / The Knob Libraries_Manual_guide/node015B.html 5 / / Proportional Gadget Components / The Pot Variables Libraries_Manual_guide/node015C.html 5 / / Proportional Gadget Components / The Body Variables Libraries_Manual_guide/node015D.html 5 / / Proportional Gadget Components / Using the Body and Pot Values Libraries_Manual_guide/node015E.html 5 / / Proportional Gadget Components / Functions for Using a Scroller Libraries_Manual_guide/node015F.html 5 / / Proportional Gadget Components / Functions for Using a Slider Libraries_Manual_guide/node0160.html 5 / Proportional Gadget / Initialization of a Proportional Gadget Libraries_Manual_guide/node0161.html 5 / / Initialization of Proportional Gadget / the PropInfo Structure Libraries_Manual_guide/node0162.html 5 / / Initialization of Proportional Gadget / of the Gadget Structure Libraries_Manual_guide/node0163.html 5 / Proportional Gadget Type / Modifying an Existing Gadget Libraries_Manual_guide/node0164.html 5 Intuition Gadgets / String Gadget Type Libraries_Manual_guide/node0165.html 5 / String Gadget Type / Integer Gadget Type Libraries_Manual_guide/node0166.html 5 / String Gadget Type / String Gadget IDCMP Messages Libraries_Manual_guide/node0167.html 5 / String Gadget Type / Program Control of String Gadgets Libraries_Manual_guide/node0168.html 5 / String Gadget Type / Tabbing Between String Gadgets Libraries_Manual_guide/node0169.html 5 / String Gadget Type / Gadget Structure For String Gadgets Libraries_Manual_guide/node016A.html 5 / / Gadget Structure For String Gadgets / Imagery and Highlighting Libraries_Manual_guide/node016B.html 5 / String Gadget Type / StringInfo Structure Libraries_Manual_guide/node016C.html 5 / / Stringinfo Structure / Gadget Key Mapping Libraries_Manual_guide/node016D.html 5 / String Gadget Type / Extended String Gadgets Libraries_Manual_guide/node016E.html 5 / String Gadget Type / Custom String Editing Libraries_Manual_guide/node016F.html 5 / / Custom String Editing / SGWork Structure Libraries_Manual_guide/node0170.html 5 / / Custom String Editing / EditOp Definitions Libraries_Manual_guide/node0171.html 5 / / Custom String Editing / Actions Definitions Libraries_Manual_guide/node0172.html 5 / / Custom String Editing / The SGH_KEY Command Libraries_Manual_guide/node0173.html 5 / / Custom String Editing / Actions with SGH_KEY Libraries_Manual_guide/node0174.html 5 / / Custom String Editing / The SGH_CLICK Command Libraries_Manual_guide/node0175.html 5 / / Custom String Editing / Actions with SGH_CLICK Libraries_Manual_guide/node0176.html 5 / String Gadget Type / Custom Gadgets Libraries_Manual_guide/node0177.html 5 Intuition Gadgets / Function Reference Libraries_Manual_guide/node0178.html Amiga® RKM Libraries: 6 Intuition Menus Libraries_Manual_guide/node0179.html 6 Intuition Menus / About Menus Libraries_Manual_guide/node017A.html 6 / About Menus / Types of Menu Choices Libraries_Manual_guide/node017B.html 6 / About Menus / The Menu System Libraries_Manual_guide/node017C.html 6 / / The Menu System / Selecting Menu Items Libraries_Manual_guide/node017D.html 6 / / The Menu System / Menu Item Imagery Libraries_Manual_guide/node017E.html 6 / About Menus / Menu Limitations Libraries_Manual_guide/node017F.html 6 / / Menu Limitations / Alternatives to Menus Libraries_Manual_guide/node0180.html 6 Intuition Menus / Setting Up Menus Libraries_Manual_guide/node0181.html 6 / Setting Up Menus / Submitting and Removing Menu Strips Libraries_Manual_guide/node0182.html 6 / Setting Up Menus / Simple Menu Example Libraries_Manual_guide/node0183.html 6 / Setting Up Menus / Disabling Menu Operations Libraries_Manual_guide/node0184.html 6 / Setting Up Menus / Changing Menu Strips Libraries_Manual_guide/node0185.html 6 / Setting Up Menus / Sharing Menu Strips Libraries_Manual_guide/node0186.html 6 / Setting Up Menus / Menu Selection Messages Libraries_Manual_guide/node0187.html 6 / / Menu Selection Messages / Multi-Selection of Menu Items Libraries_Manual_guide/node0188.html 6 / Setting Up Menus / Menu Numbers Libraries_Manual_guide/node0189.html 6 / / Menu Numbers / How Menu Numbers Really Work Libraries_Manual_guide/node018A.html 6 / Setting Up Menus / Help Key Processing in Menus Libraries_Manual_guide/node018B.html 6 / Setting Up Menus / Menu Layout Libraries_Manual_guide/node018C.html 6 / Setting Up Menus / About Menu Item Boxes Libraries_Manual_guide/node018D.html 6 / Setting Up Menus / Attribute Items and the Checkmark Libraries_Manual_guide/node018E.html 6 / Setting Up Menus / Toggle Selection Libraries_Manual_guide/node018F.html 6 / Setting Up Menus / Mutual Exclusion Libraries_Manual_guide/node0190.html 6 / Setting Up Menus / Managing the State of Checkmarks Libraries_Manual_guide/node0191.html 6 / Setting Up Menus / Command Key Sequences Libraries_Manual_guide/node0192.html 6 / Setting Up Menus / Enabling and Disabling Menus and Menu Items Libraries_Manual_guide/node0193.html 6 / Setting Up Menus / Intercepting Normal Menu Operations Libraries_Manual_guide/node0194.html 6 / / Intercepting Menu Operations / A Warning on the MENUSTATE Flag Libraries_Manual_guide/node0195.html 6 / / Intercepting Normal Menu Operations / Menu Verify Libraries_Manual_guide/node0196.html 6 / / Intercepting Menu Operations / Shortcuts and IDCMP_MENUVERIFY Libraries_Manual_guide/node0197.html 6 / / Intercepting Menu Operations / IDCMP_MENUVERIFY and Deadlock Libraries_Manual_guide/node0198.html 6 Intuition Menus / Menu Data Structures Libraries_Manual_guide/node0199.html 6 / Menu Data Structures / Menu Structure Libraries_Manual_guide/node019A.html 6 / Menu Data Structures / MenuItem Structure Libraries_Manual_guide/node019B.html 6 / Menu Data Structures / MenuItem Flags Libraries_Manual_guide/node019C.html 6 Intuition Menus / A Menu Example Libraries_Manual_guide/node019D.html 6 Intuition Menus / Other Menu Macros Libraries_Manual_guide/node019E.html 6 Intuition Menus / Function Reference Libraries_Manual_guide/node019F.html Amiga® RKM Libraries: 7 Intuition Requesters and Alerts Libraries_Manual_guide/node01A0.html 7 Intuition Requesters and Alerts / Types Of Requesters Libraries_Manual_guide/node01A1.html 7 Intuition Requesters and Alerts / True Requesters Libraries_Manual_guide/node01A2.html 7 / True Requesters / Creating Application Requesters Libraries_Manual_guide/node01A3.html 7 / True Requesters / Requester I/O Libraries_Manual_guide/node01A4.html 7 / True Requesters / Rendering Requesters Libraries_Manual_guide/node01A5.html 7 / True Requesters / Requester Refresh Type Libraries_Manual_guide/node01A6.html 7 / True Requesters / Requester Display Position Libraries_Manual_guide/node01A7.html 7 / True Requesters / Gadgets in Requesters Libraries_Manual_guide/node01A8.html 7 / True Requesters / Using a Requester to Block Window Input Libraries_Manual_guide/node01A9.html 7 / True Requesters / Double Menu Requesters Libraries_Manual_guide/node01AA.html 7 / True Requesters / IDCMP Requester Features Libraries_Manual_guide/node01AB.html 7 Intuition Requesters and Alerts / Requester Structure Libraries_Manual_guide/node01AC.html 7 Intuition Requesters and Alerts / Easy Requesters Libraries_Manual_guide/node01AD.html 7 / Easy Requesters / The EasyStruct Structure Libraries_Manual_guide/node01AE.html 7 / Easy Requesters / Low Level Access to Easy Requesters Libraries_Manual_guide/node01AF.html 7 Intuition Requesters and Alerts / System Requesters Libraries_Manual_guide/node01B0.html 7 / System Requesters / Redirecting System Requesters Libraries_Manual_guide/node01B1.html 7 Intuition Requesters and Alerts / Alerts Libraries_Manual_guide/node01B2.html 7 / Alerts / Types of Alerts Libraries_Manual_guide/node01B3.html 7 / Alerts / Creating Alerts Libraries_Manual_guide/node01B4.html 7 Intuition Requesters and Alerts / Function Reference Libraries_Manual_guide/node01B5.html Amiga® RKM Libraries: 8 Intuition Images, Line Drawing and Text Libraries_Manual_guide/node01B6.html 8 Intuition Images, Line Drawing and Text / Intuition Graphic Objects Libraries_Manual_guide/node01B7.html 8 / Graphic Objects / Displaying Images, Borders and IntuiText Libraries_Manual_guide/node01B8.html 8 / Intuition Graphic Objects / Positioning Graphic Objects Libraries_Manual_guide/node01B9.html 8 Intuition Images, Line Drawing and Text / Creating Images Libraries_Manual_guide/node01BA.html 8 / Creating Images / Image Structure Libraries_Manual_guide/node01BB.html 8 / Creating Images / Directly Drawing the Image Libraries_Manual_guide/node01BC.html 8 / Creating Images / Image Data Libraries_Manual_guide/node01BD.html 8 / / Image Data / Defining Image Data Libraries_Manual_guide/node01BE.html 8 / Creating Images / Picking Bitplanes for Image Display Libraries_Manual_guide/node01BF.html 8 / Creating Images / Image Example Libraries_Manual_guide/node01C0.html 8 Intuition Images, Line Drawing and Text / Creating Borders Libraries_Manual_guide/node01C1.html 8 / Creating Borders / Border Structure Definition Libraries_Manual_guide/node01C2.html 8 / Creating Borders / Directly Drawing the Borders Libraries_Manual_guide/node01C3.html 8 / Creating Borders / Border Colors and Drawing Modes Libraries_Manual_guide/node01C4.html 8 / Creating Borders / Border Coordinates Libraries_Manual_guide/node01C5.html 8 / Creating Borders / Linking Borders Libraries_Manual_guide/node01C6.html 8 Intuition Images, Line Drawing and Text / Creating Text Libraries_Manual_guide/node01C7.html 8 / Creating Text / IntuiText Structure Libraries_Manual_guide/node01C8.html 8 / Creating Text / Directly Drawing the IntuiText Libraries_Manual_guide/node01C9.html 8 / Creating Text / Determining Text Length Libraries_Manual_guide/node01CA.html 8 / Creating Text / Text Colors and Drawing Modes Libraries_Manual_guide/node01CB.html 8 / Creating Text / Fonts Libraries_Manual_guide/node01CC.html 8 / Creating Text / Linking Text Strings Libraries_Manual_guide/node01CD.html 8 Intuition Images, Line Drawing and Text / Function Reference Libraries_Manual_guide/node01CE.html Amiga® RKM Libraries: 9 Intuition Input and Output Methods Libraries_Manual_guide/node01CF.html 9 Intuition Input and Output Methods / Overview of System I/O Libraries_Manual_guide/node01D0.html 9 Intuition Input and Output Methods / Intuition Input Libraries_Manual_guide/node01D1.html 9 / Intuition Input / Intuition as an Input Handler Libraries_Manual_guide/node01D2.html 9 / Intuition Input / Receiving Input Events from Intuition Libraries_Manual_guide/node01D3.html 9 / Intuition Input / IDCMP Events and the Input Focus Libraries_Manual_guide/node01D4.html 9 Intuition Input and Output Methods / Intuition Output Libraries_Manual_guide/node01D5.html 9 Intuition Input and Output Methods / Console Device I/O Libraries_Manual_guide/node01D6.html 9 Intuition Input and Output Methods / Using the IDCMP Libraries_Manual_guide/node01D7.html 9 / Using the IDCMP / Standard IntuiMessage Event Loop Libraries_Manual_guide/node01D8.html 9 / Using the IDCMP / Setting Up A Custom User Port Libraries_Manual_guide/node01D9.html 9 / Using the IDCMP / IntuiMessages Libraries_Manual_guide/node01DA.html 9 Intuition Input and Output Methods / IDCMP Flags Libraries_Manual_guide/node01DB.html 9 / IDCMP Flags / Event Message Classes and Flags Libraries_Manual_guide/node01DC.html 9 / / Event Message Classes and Flags / Mouse Flags Libraries_Manual_guide/node01DD.html 9 / / Event Message Classes and Flags / Gadget Flags Libraries_Manual_guide/node01DE.html 9 / / Event Message Classes and Flags / Menu Flags Libraries_Manual_guide/node01DF.html 9 / / Event Message Classes and Flags / Requester Flags Libraries_Manual_guide/node01E0.html 9 / / Event Message Classes and Flags / Window Flags Libraries_Manual_guide/node01E1.html 9 / / Event Message Classes and Flags / Other Flags Libraries_Manual_guide/node01E2.html 9 / IDCMP Flags / Verification Functions Libraries_Manual_guide/node01E3.html 9 Intuition Input and Output Methods / Function Reference Libraries_Manual_guide/node01E4.html Amiga® RKM Libraries: 10 Intuition Mouse and Keyboard Libraries_Manual_guide/node01E5.html 10 Intuition Mouse and Keyboard / The Mouse Libraries_Manual_guide/node01E6.html 10 / The Mouse / Intuition's Use of Mouse Events Libraries_Manual_guide/node01E7.html 10 / / Intuition's Use of Mouse Events / Select Button Libraries_Manual_guide/node01E8.html 10 / / Intuition's Use of Mouse Events / Menu Button Libraries_Manual_guide/node01E9.html 10 / The Mouse / Mouse Messages Libraries_Manual_guide/node01EA.html 10 / The Mouse / Mouse Usage Example Libraries_Manual_guide/node01EB.html 10 Intuition Mouse and Keyboard / The Pointer Libraries_Manual_guide/node01EC.html 10 / The Pointer / Pointer Position Libraries_Manual_guide/node01ED.html 10 / The Pointer / Custom Pointer Libraries_Manual_guide/node01EE.html 10 / / Custom Pointer / The Sprite Data Structure Libraries_Manual_guide/node01EF.html 10 Intuition Mouse and Keyboard / The Keyboard Libraries_Manual_guide/node01F0.html 10 / The Keyboard / Keyboard Control of the Pointer Libraries_Manual_guide/node01F1.html 10 / The Keyboard / Intuition Keyboard Shortcuts Libraries_Manual_guide/node01F2.html 10 / The Keyboard / Menu Shortcuts Libraries_Manual_guide/node01F3.html 10 / The Keyboard / Amiga Qualifiers Libraries_Manual_guide/node01F4.html 10 Intuition Mouse and Keyboard / Function Reference Libraries_Manual_guide/node01F5.html Amiga® RKM Libraries: 11 Intuition Special Functions Libraries_Manual_guide/node01F6.html 11 Intuition Special Functions / Locking IntuitionBase Libraries_Manual_guide/node01F7.html 11 Special Functions / Easy Memory Allocation and Deallocation Libraries_Manual_guide/node01F8.html 11 / Easy Memory Allocation and Deallocation / Helps You Remember Libraries_Manual_guide/node01F9.html 11 / Easy Memory Allocation and Deallocation / How to Remember Libraries_Manual_guide/node01FA.html 11 / Easy Memory Allocation and Deallocation / The Remember Structure Libraries_Manual_guide/node01FB.html 11 Intuition Special Functions / Current Time Values Libraries_Manual_guide/node01FC.html 11 Special Functions / Using Sprites in Intuition Windows and Screens Libraries_Manual_guide/node01FD.html 11 Intuition Special Functions / Intuition and Preferences Libraries_Manual_guide/node01FE.html 11 Intuition Special Functions / Function Reference Libraries_Manual_guide/node01FF.html Amiga® RKM Libraries: 12 Boopsi--Object Oriented Intuition Libraries_Manual_guide/node0200.html 12 Boopsi--Object Oriented Intuition / OOP Overview Libraries_Manual_guide/node0201.html 12 / OOP Overview / Using Boopsi Libraries_Manual_guide/node0202.html 12 / / Using Boopsi / Boopsi and Tags Libraries_Manual_guide/node0203.html 12 / / Using Boopsi / Creating an Object Libraries_Manual_guide/node0204.html 12 / / Using Boopsi / Disposing of an Object Libraries_Manual_guide/node0205.html 12 / / Using Boopsi / Setting an Existing Object's Attributes Libraries_Manual_guide/node0206.html 12 / / Using Boopsi / Getting an Object's Attributes Libraries_Manual_guide/node0207.html 12 / / Using Boopsi / What About the Boopsi Messages and Methods? Libraries_Manual_guide/node0208.html 12 / OOPOverview / The Public Classes Libraries_Manual_guide/node0209.html 12 / / The Public Classes / The Imageclass Subclasses Libraries_Manual_guide/node020A.html 12 / / The Public Classes / The Gadgetclass Subclasses Libraries_Manual_guide/node020B.html 12 / OOP Overview / Making Gadget Objects Talk to Each Other Libraries_Manual_guide/node020C.html 12 / OOP Overview / Making Gadgets Talk to an Application Libraries_Manual_guide/node020D.html 12 / OOP Overview / The Interconnection Classes Libraries_Manual_guide/node020E.html 12 Boopsi--Object Oriented Intuition / Creating a Boopsi Class Libraries_Manual_guide/node020F.html 12 / Creating a Boopsi Class / Building On Existing Public Classes Libraries_Manual_guide/node0210.html 12 / / Building On Existing Public Classes / Building Rkmmodelclass Libraries_Manual_guide/node0211.html 12 / Creating a Boopsi Class / Writing the Dispatcher Libraries_Manual_guide/node0212.html 12 / / Writing The Dispatcher / OM_NEW Libraries_Manual_guide/node0213.html 12 / / Writing The Dispatcher / OM_SET/OM_UPDATE Libraries_Manual_guide/node0214.html 12 / / Writing The Dispatcher / OM_GET Libraries_Manual_guide/node0215.html 12 / / Writing The Dispatcher / Making the New Class Libraries_Manual_guide/node0216.html 12 / / Writing The Dispatcher / RKMModel.c Libraries_Manual_guide/node0217.html 12 / Boopsi Class / White Boxes - The Transparent Base Classes Libraries_Manual_guide/node0218.html 12 Boopsi--Object Oriented Intuition / Boopsi Gadgets Libraries_Manual_guide/node0219.html 12 / Boopsi Gadgets / The Boopsi Gadget Methods Libraries_Manual_guide/node021A.html 12 / / The Boopsi Gadget Methods / GM_RENDER Libraries_Manual_guide/node021B.html 12 / / The Boopsi Gadget Methods / GM_HITTEST Libraries_Manual_guide/node021C.html 12 / / The Boopsi Gadget Methods / GM_GOACTIVE/GM_HANDLEINPUT Libraries_Manual_guide/node021D.html 12 / / The Boopsi Gadget Methods / GM_GOINACTIVE Libraries_Manual_guide/node021E.html 12 / Boopsi Gadgets / The Active Gadget Libraries_Manual_guide/node021F.html 12 / / The Active Gadget / RKMButtonclass.c Libraries_Manual_guide/node0220.html 12 Boopsi--Object Oriented Intuition / Function Reference Libraries_Manual_guide/node0221.html Amiga® RKM Libraries: 13 Preferences Libraries_Manual_guide/node0222.html 13 Preferences / Preferences in 1.3 and Older Versions of the OS Libraries_Manual_guide/node0223.html 13 / Preferences in 1.3 and Older Versions / Reading 1.3 Preferences Libraries_Manual_guide/node0224.html 13 / Preferences 1.3 & Older Versions / Preferences Structure in 1.3 Libraries_Manual_guide/node0225.html 13 / Preferences in 1.3 and Older Versions / Setting 1.3 Preferences Libraries_Manual_guide/node0226.html 13 / Preferences in 1.3 and Older Versions / Alternatives to SetPrefs Libraries_Manual_guide/node0227.html 13 Preferences / Preferences in Release 2 Libraries_Manual_guide/node0228.html 13 / Preferences in Release 2 / Preferences Editors and Storage Libraries_Manual_guide/node0229.html 13 / Preferences in Release 2 / The ENV: Directory and Notification Libraries_Manual_guide/node022A.html 13 / Preferences in Release 2 / Preference File Format in Release 2 Libraries_Manual_guide/node022B.html 13 / / Preference File Format in Release 2 / The Header Chunk Libraries_Manual_guide/node022C.html 13 / / Preference File Format in Release 2 / The Data Chunk Libraries_Manual_guide/node022D.html 13 / Preferences in Release 2 / FONT Libraries_Manual_guide/node022E.html 13 / Preferences in Release 2 / ICTL Libraries_Manual_guide/node022F.html 13 / Preferences in Release 2 / INPT Libraries_Manual_guide/node0230.html 13 / Preferences in Release 2 / OSCN Libraries_Manual_guide/node0231.html 13 / Preferences in Release 2 / PGFX Libraries_Manual_guide/node0232.html 13 / Preferences in Release 2 / PTXT Libraries_Manual_guide/node0233.html 13 / Preferences in Release 2 / SCRM Libraries_Manual_guide/node0234.html 13 / Preferences in Release 2 / SERL Libraries_Manual_guide/node0235.html 13 / Preferences in Release 2 / Other File Formats in Release 2 Libraries_Manual_guide/node0236.html 13 Preferences / Function Reference Libraries_Manual_guide/node0237.html Amiga® RKM Libraries: 14 Workbench and Icon Library Libraries_Manual_guide/node0238.html 14 Workbench and Icon Library / The Info File Libraries_Manual_guide/node0239.html 14 Workbench and Icon Library / Workbench Environment Libraries_Manual_guide/node023A.html 14 / Workbench Environment / Argument Passing In Workbench Libraries_Manual_guide/node023B.html 14 / / Argument Passing In Workbench / One Argument Libraries_Manual_guide/node023C.html 14 / / Argument Passing In Workbench / Two Arguments Libraries_Manual_guide/node023D.html 14 / / Argument Passing In Workbench / Multiple Arguments Libraries_Manual_guide/node023E.html 14 / Workbench Environment / WBStartup Message Libraries_Manual_guide/node023F.html 14 Workbench and Icon Library / The Icon Library Libraries_Manual_guide/node0240.html 14 / The Icon Library / Icon Library Data Structures Libraries_Manual_guide/node0241.html 14 / / Icon Library Data Structures / The DiskObject Structure Libraries_Manual_guide/node0242.html 14 / / Icon Library Data Structures / The Gadget Structure Libraries_Manual_guide/node0243.html 14 / The Icon Library / Icon Library Functions Libraries_Manual_guide/node0244.html 14 / The Icon Library / The Tool Types Array Libraries_Manual_guide/node0245.html 14 Workbench and Icon Library / The Workbench Library Libraries_Manual_guide/node0246.html 14 / The Workbench Library / Workbench Library Functions Libraries_Manual_guide/node0247.html 14 Workbench and Icon Library / Workbench and the Startup Code Module Libraries_Manual_guide/node0248.html 14 / Workbench and the Startup Code Module / Workbench Startup Libraries_Manual_guide/node0249.html 14 / Workbench and the Startup Code Module / Shell Startup Libraries_Manual_guide/node024A.html 14 Workbench and Icon Library / Function Reference Libraries_Manual_guide/node024B.html Amiga® RKM Libraries: 15 GadTools Library Libraries_Manual_guide/node024C.html 15 GadTools Library / Elements of GadTools Libraries_Manual_guide/node024D.html 15 / Elements of GadTools / GadTools Tags Libraries_Manual_guide/node024E.html 15 GadTools Library / GadTools Menus Libraries_Manual_guide/node024F.html 15 / GadTools Menus / The NewMenu Structure Libraries_Manual_guide/node0250.html 15 / GadTools Menus / Functions for GadTools Menus Libraries_Manual_guide/node0251.html 15 / / Functions for GadTools Menus / Creating Menus Libraries_Manual_guide/node0252.html 15 / / Functions for GadTools Menus / Layout of the Menus Libraries_Manual_guide/node0253.html 15 / / Functions for GadTools Menus / Layout for Individual Menus Libraries_Manual_guide/node0254.html 15 / / Functions for GadTools Menus / Freeing Menus Libraries_Manual_guide/node0255.html 15 / GadTools Menus / GadTools Menus and IntuiMessages Libraries_Manual_guide/node0256.html 15 / GadTools Menus / Restrictions on GadTools Menus Libraries_Manual_guide/node0257.html 15 / GadTools Menus / Language-Sensitive Menus Libraries_Manual_guide/node0258.html 15 GadTools Library / GadTools Gadgets Libraries_Manual_guide/node0259.html 15 / GadTools Gadgets / The NewGadget Structure Libraries_Manual_guide/node025A.html 15 / GadTools Gadgets / Creating Gadgets Libraries_Manual_guide/node025B.html 15 / GadTools Gadgets / Handling Gadget Messages Libraries_Manual_guide/node025C.html 15 / GadTools Gadgets / IDCMP Flags Libraries_Manual_guide/node025D.html 15 / GadTools Gadgets / Freeing Gadgets Libraries_Manual_guide/node025E.html 15 / GadTools Gadgets / Modifying Gadgets Libraries_Manual_guide/node025F.html 15 / GadTools Gadgets / The Kinds of GadTools Gadgets Libraries_Manual_guide/node0260.html 15 / / The Kinds of GadTools Gadgets / Button Gadgets Libraries_Manual_guide/node0261.html 15 / / Kinds of GadTools Gadgets / Text-Entry and Number-Entry Gadgets Libraries_Manual_guide/node0262.html 15 / / The Kinds of GadTools Gadgets / Checkbox Gadgets Libraries_Manual_guide/node0263.html 15 / / The Kinds of GadTools Gadgets / Mutually-Exclusive Gadgets Libraries_Manual_guide/node0264.html 15 / / The Kinds of GadTools Gadgets / Cycle Gadgets Libraries_Manual_guide/node0265.html 15 / / The Kinds of GadTools Gadgets / Slider Gadgets Libraries_Manual_guide/node0266.html 15 / / The Kinds of GadTools Gadgets / Scroller Gadgets Libraries_Manual_guide/node0267.html 15 / / The Kinds of GadTools Gadgets / Listview Gadgets Libraries_Manual_guide/node0268.html 15 / / The Kinds of GadTools Gadgets / Palette Gadgets Libraries_Manual_guide/node0269.html 15 / / Kinds of GadTools / Text-Display and Numeric-Display Gadgets Libraries_Manual_guide/node026A.html 15 / / The Kinds of GadTools Gadgets / Generic Gadgets Libraries_Manual_guide/node026B.html 15 / GadTools / Functions for Setting Up GadTools Menus and Gadgets Libraries_Manual_guide/node026C.html 15 / / / GetVisualInfo() and FreeVisualInfo() Libraries_Manual_guide/node026D.html 15 / / Setting Up GadTools Menus and Gadgets / CreateContext() Libraries_Manual_guide/node026E.html 15 / GadTools Gadgets / Creating Gadget Lists Libraries_Manual_guide/node026F.html 15 / GadTools Gadgets / Gadget Refresh Functions Libraries_Manual_guide/node0270.html 15 / GadTools Gadgets / Other GadTools Functions Libraries_Manual_guide/node0271.html 15 / / Other Functions / GT_FilterIMsg() and GT_PostFilterIMsg() Libraries_Manual_guide/node0272.html 15 / / Other GadTools Functions / DrawBevelBox() Libraries_Manual_guide/node0273.html 15 / GadTools Gadgets / Gadget Keyboard Equivalents Libraries_Manual_guide/node0274.html 15 / / Keyboard Equivalents / Denoting a Gadget's Keyboard Equivalent Libraries_Manual_guide/node0275.html 15 / / / Implementing a Gadget's Keyboard Equivalent Behavior Libraries_Manual_guide/node0276.html 15 / GadTools Gadgets / Restrictions on GadTools Gadgets Libraries_Manual_guide/node0277.html 15 / GadTools Gadgets / Documented Side-Effects Libraries_Manual_guide/node0278.html 15 GadTools Library / Function Reference Libraries_Manual_guide/node0279.html Amiga® RKM Libraries: 16 ASL Library Libraries_Manual_guide/node027A.html 16 ASL Library / About Requesters Libraries_Manual_guide/node027B.html 16 ASL Library / Creating a File Requester Libraries_Manual_guide/node027C.html 16 / Creating a File Requester / Specifying Options with TagItems Libraries_Manual_guide/node027D.html 16 / / File Pattern Matching and Multiple Selects Libraries_Manual_guide/node027E.html 16 / Creating a File Requester / ASL Requesters and Custom Screens Libraries_Manual_guide/node027F.html 16 / Creating a File Requester / The Save Requester Libraries_Manual_guide/node0280.html 16 / Creating a File Requester / The Directory Requester Libraries_Manual_guide/node0281.html 16 ASL Library / Creating a Font Requester Libraries_Manual_guide/node0282.html 16 / Creating a Font Requester / Specifying Options with TagItems Libraries_Manual_guide/node0283.html 16 ASL Library / Calling Custom Functions from a Requester Libraries_Manual_guide/node0284.html 16 / Calling Functions / Parameters Passed to Custom Hook Functions Libraries_Manual_guide/node0285.html 16 ASL Library / Function Reference Libraries_Manual_guide/node0286.html Amiga® RKM Libraries: 17 Introduction to Exec Libraries_Manual_guide/node0287.html 17 Introduction to Exec / Multitasking Libraries_Manual_guide/node0288.html 17 Introduction to Exec / Dynamic Memory Allocation Libraries_Manual_guide/node0289.html 17 Introduction to Exec / Signals Libraries_Manual_guide/node028A.html 17 / Signals / Looking for Break Keys Libraries_Manual_guide/node028B.html 17 / Signals / Processing Signals Without Wait()ing Libraries_Manual_guide/node028C.html 17 Introduction to Exec / Interprocess Communications Libraries_Manual_guide/node028D.html 17 / / Waiting on Message Ports and Signals at the Same Time Libraries_Manual_guide/node028E.html 17 Introduction to Exec / Libraries and Devices Libraries_Manual_guide/node028F.html 17 / Libraries and Devices / Library Vector Offsets (LVOs) Libraries_Manual_guide/node0290.html 17 / Libraries and Devices / Calling a Library Function Libraries_Manual_guide/node0291.html Amiga® RKM Libraries: 18 Exec Libraries Libraries_Manual_guide/node0292.html 18 Exec Libraries / What is a Library? Libraries_Manual_guide/node0293.html 18 / What is a Library? / Using a Library to Reference Data Libraries_Manual_guide/node0294.html 18 / What is a Library? / Relationship of Libraries to Devices Libraries_Manual_guide/node0295.html 18 / What is a Library? / Minimum Subset of Library Vectors Libraries_Manual_guide/node0296.html 18 / What is a Library? / Changing the Contents of a Library Libraries_Manual_guide/node0297.html 18 Exec Libraries / Adding a Library Libraries_Manual_guide/node0298.html 18 / Adding a Library / Resident (Romtag) Structure Libraries_Manual_guide/node0299.html Amiga® RKM Libraries: 19 Exec Device I/O Libraries_Manual_guide/node029A.html 19 Exec Device I/O / What is a Device? Libraries_Manual_guide/node029B.html 19 Exec Device I/O / Accessing a Device Libraries_Manual_guide/node029C.html 19 / Accessing a Device / Creating a Message Port Libraries_Manual_guide/node029D.html 19 / Accessing a Device / Creating an I/O Request Libraries_Manual_guide/node029E.html 19 / Accessing a Device / Opening a Device Libraries_Manual_guide/node029F.html 19 Exec Device I/O / Using a Device Libraries_Manual_guide/node02A0.html 19 / Using A Device / Synchronous Vs. Asynchronous Requests Libraries_Manual_guide/node02A1.html 19 / Using A Device / I/O Request Completion Libraries_Manual_guide/node02A2.html 19 / / I/O Request Completion / Closing the Device Libraries_Manual_guide/node02A3.html 19 / / I/O Request Completion / Ending Device Access Libraries_Manual_guide/node02A4.html 19 Exec Device I/O / Devices With Functions Libraries_Manual_guide/node02A5.html 19 Exec Device I/O / Function Reference Libraries_Manual_guide/node02A6.html Amiga® RKM Libraries: 20 Exec Memory Allocation Libraries_Manual_guide/node02A7.html 20 Exec Memory Allocation / Memory Functions Libraries_Manual_guide/node02A8.html 20 / Memory Functions / Memory Attributes Libraries_Manual_guide/node02A9.html 20 / Memory Functions / Allocating System Memory Libraries_Manual_guide/node02AA.html 20 / Memory Functions / Freeing System Memory Libraries_Manual_guide/node02AB.html 20 / Memory Functions / Memory Information Functions Libraries_Manual_guide/node02AC.html 20 / / Memory Information Functions / Memory Requirements Libraries_Manual_guide/node02AD.html 20 / / Memory Info Functions / Calling Memory Information Functions Libraries_Manual_guide/node02AE.html 20 / Memory Functions / Using Memory Copy Functions Libraries_Manual_guide/node02AF.html 20 / / Using Memory Copy Functions / Copying System Memory Libraries_Manual_guide/node02B0.html 20 / / Summary of System Controlled Memory Handling Routines Libraries_Manual_guide/node02B1.html 20 Exec Memory Allocation / Allocating Multiple Memory Blocks Libraries_Manual_guide/node02B2.html 20 / Allocating Multiple Memory Blocks / Sample Code Libraries_Manual_guide/node02B3.html 20 / Allocating Multiple Memory Blocks / Result Libraries_Manual_guide/node02B4.html 20 / Allocating Multiple Memory / Multiple Memory Blocks and Tasks Libraries_Manual_guide/node02B5.html 20 / Allocating Multiple Memory / Summary of Allocation Routines Libraries_Manual_guide/node02B6.html 20 Exec Memory Allocation / Other Memory Functions Libraries_Manual_guide/node02B7.html 20 / Other Memory Functions / Allocating Memory at an Absolute Address Libraries_Manual_guide/node02B8.html 20 / Other Memory Functions / Adding Memory to the System Pool Libraries_Manual_guide/node02B9.html 20 Exec Memory Allocation / Function Reference Libraries_Manual_guide/node02BA.html Amiga® RKM Libraries: 21 Exec Tasks Libraries_Manual_guide/node02BB.html 21 Exec Tasks / Task Structure Libraries_Manual_guide/node02BC.html 21 Exec Tasks / Task Creation Libraries_Manual_guide/node02BD.html 21 / Task Creation / Task Creation With Amiga.lib Libraries_Manual_guide/node02BE.html 21 / Task Creation / Task Stack Libraries_Manual_guide/node02BF.html 21 / Task Creation / Task Priority Libraries_Manual_guide/node02C0.html 21 Exec Tasks / Task Termination Libraries_Manual_guide/node02C1.html 21 Exec Tasks / Task Exclusion Libraries_Manual_guide/node02C2.html 21 / Task Exclusion / Forbidding Task Switching Libraries_Manual_guide/node02C3.html 21 / Task Exclusion / Disabling Tasks Libraries_Manual_guide/node02C4.html 21 / Task Exclusion / Task Semaphores Libraries_Manual_guide/node02C5.html 21 Exec Tasks / Task Exceptions Libraries_Manual_guide/node02C6.html 21 Exec Tasks / Task Traps Libraries_Manual_guide/node02C7.html 21 / Task Traps / Trap Handlers Libraries_Manual_guide/node02C8.html 21 / Task Traps / Trap Instructions Libraries_Manual_guide/node02C9.html 21 Exec Tasks / Processor and Cache Control Libraries_Manual_guide/node02CA.html 21 / Processor and Cache Control / Supervisor Mode Libraries_Manual_guide/node02CB.html 21 / Processor and Cache Control / Status Register Libraries_Manual_guide/node02CC.html 21 / Processor and Cache Control / Condition Code Register Libraries_Manual_guide/node02CD.html 21 / Processor and Cache Control / Cache Functions Libraries_Manual_guide/node02CE.html 21 / Processor and Cache Control / DMA Cache Functions Libraries_Manual_guide/node02CF.html 21 / Processor and Cache Control / The 68040 and CPU Caches Libraries_Manual_guide/node02D0.html 21 Exec Tasks / Function Reference Libraries_Manual_guide/node02D1.html Amiga® RKM Libraries: 22 Exec Signals Libraries_Manual_guide/node02D2.html 22 Exec Signals / The Signal System Libraries_Manual_guide/node02D3.html 22 / The Signal System / Signal Allocation Libraries_Manual_guide/node02D4.html 22 / The Signal System / Waiting for a Signal Libraries_Manual_guide/node02D5.html 22 / The Signal System / Generating a Signal Libraries_Manual_guide/node02D6.html 22 Exec Signals / Function Reference Libraries_Manual_guide/node02D7.html Amiga® RKM Libraries: 23 Exec Lists and Queues Libraries_Manual_guide/node02D8.html 23 Exec Lists and Queues / List Structure Libraries_Manual_guide/node02D9.html 23 / List Structure / Node Structure Definition Libraries_Manual_guide/node02DA.html 23 / List Structure / Node Initialization Libraries_Manual_guide/node02DB.html 23 / List Structure / List Header Structure Definition Libraries_Manual_guide/node02DC.html 23 / List Structure / Header Initialization Libraries_Manual_guide/node02DD.html 23 Exec Lists and Queues / List Functions Libraries_Manual_guide/node02DE.html 23 / List Functions / Insertion and Removal Libraries_Manual_guide/node02DF.html 23 / List Functions / Special Case Insertion Libraries_Manual_guide/node02E0.html 23 / List Functions / Special Case Removal Libraries_Manual_guide/node02E1.html 23 / List Functions / MinList/MinNode Operations Libraries_Manual_guide/node02E2.html 23 / List Functions / Prioritized Insertion Libraries_Manual_guide/node02E3.html 23 / List Functions / Searching by Name Libraries_Manual_guide/node02E4.html 23 / List Functions / More on the Use of Named Lists Libraries_Manual_guide/node02E5.html 23 / List Functions / List Macros for Assembly Language Programmers Libraries_Manual_guide/node02E6.html 23 / List Functions / Empty Lists Libraries_Manual_guide/node02E7.html 23 / List Functions / Scanning a List Libraries_Manual_guide/node02E8.html 23 / List Functions / Important Note About Shared Lists Libraries_Manual_guide/node02E9.html 23 Exec Lists and Queues / Function Reference Libraries_Manual_guide/node02EA.html Amiga® RKM Libraries: 24 Exec Messages and Ports Libraries_Manual_guide/node02EB.html 24 Exec Messages and Ports / Message Ports Libraries_Manual_guide/node02EC.html 24 / Message Ports / Creating a Message Port Libraries_Manual_guide/node02ED.html 24 / Message Ports / Deleting a Message Port Libraries_Manual_guide/node02EE.html 24 / Message Ports / How To Rendezvous at a Message Port Libraries_Manual_guide/node02EF.html 24 Exec Messages and Ports / Messages Libraries_Manual_guide/node02F0.html 24 / Messages / Putting a Message Libraries_Manual_guide/node02F1.html 24 / Messages / Waiting For a Message Libraries_Manual_guide/node02F2.html 24 / Messages / Getting a Message Libraries_Manual_guide/node02F3.html 24 / Messages / Replying Libraries_Manual_guide/node02F4.html 24 Exec Messages and Ports / Function Reference Libraries_Manual_guide/node02F5.html Amiga® RKM Libraries: 25 Exec Semaphores Libraries_Manual_guide/node02F6.html 25 Exec Semaphores / Semaphore Functions Libraries_Manual_guide/node02F7.html 25 / Semaphore Functions / The Signal Semaphore Libraries_Manual_guide/node02F8.html 25 / / The Signal Semaphore / Creating a SignalSemaphore Structure Libraries_Manual_guide/node02F9.html 25 / / / Making a SignalSemaphore Available to the Public Libraries_Manual_guide/node02FA.html 25 / / The Signal Semaphore / Obtaining a SignalSemaphore Exclusively Libraries_Manual_guide/node02FB.html 25 / / The Signal Semaphore / Obtaining a Shared SignalSemaphore Libraries_Manual_guide/node02FC.html 25 / / The Signal Semaphore / Checking a SignalSemaphore Libraries_Manual_guide/node02FD.html 25 / / The Signal Semaphore / Releasing a SignalSemaphore Libraries_Manual_guide/node02FE.html 25 / / The Signal Semaphore / Removing a SignalSemaphore Structure Libraries_Manual_guide/node02FF.html 25 / Semaphore Functions / Multiple Semaphores Libraries_Manual_guide/node0300.html 25 Exec Semaphores / Function Reference Libraries_Manual_guide/node0301.html Amiga® RKM Libraries: 26 Exec Interrupts Libraries_Manual_guide/node0302.html 26 Exec Interrupts / Introduction Libraries_Manual_guide/node0303.html 26 / Introduction / Sequence of Events During an Interrupt Libraries_Manual_guide/node0304.html 26 / Introduction / Interrupt Priorities Libraries_Manual_guide/node0305.html 26 / Introduction / Nonmaskable Interrupt Libraries_Manual_guide/node0306.html 26 Exec Interrupts / Servicing Interrupts Libraries_Manual_guide/node0307.html 26 / Servicing Interrupts / Interrupt Data Structure Libraries_Manual_guide/node0308.html 26 / Servicing Interrupts / Environment Libraries_Manual_guide/node0309.html 26 / Servicing Interrupts / Interrupt Handlers Libraries_Manual_guide/node030A.html 26 / / Interrupt Handlers / Interrupt Handler Register Usage Libraries_Manual_guide/node030B.html 26 / Servicing Interrupts / Interrupt Servers Libraries_Manual_guide/node030C.html 26 / / Interrupt Servers / Interrupt Server Register Usage Libraries_Manual_guide/node030D.html 26 Exec Interrupts / Software Interrupts Libraries_Manual_guide/node030E.html 26 Exec Interrupts / Disabling Interrupts Libraries_Manual_guide/node030F.html 26 Exec Interrupts / Function Reference Libraries_Manual_guide/node0310.html Amiga® RKM Libraries: 27 Graphics Primitives Libraries_Manual_guide/node0311.html 27 Graphics Primitives / Introduction Libraries_Manual_guide/node0312.html 27 / Introduction / Components of a Display Libraries_Manual_guide/node0313.html 27 / Introduction / Introduction To Raster Displays Libraries_Manual_guide/node0314.html 27 / / / Effect of Display Overscan on the Viewing Area Libraries_Manual_guide/node0315.html 27 / / / Color Information for the Video Lines Libraries_Manual_guide/node0316.html 27 / Introduction / Interlaced and Non-Interlaced Modes Libraries_Manual_guide/node0317.html 27 / Introduction / Low, High and Super-High Resolution Modes Libraries_Manual_guide/node0318.html 27 / / Resolution Modes / Display Modes, Colors, and Requirements Libraries_Manual_guide/node0319.html 27 / Introduction / About ECS Libraries_Manual_guide/node031A.html 27 / / About ECS / SuperHires (35 nanosecond) Pixel Resolutions Libraries_Manual_guide/node031B.html 27 / / About ECS / Productivity Mode Libraries_Manual_guide/node031C.html 27 / / About ECS / Selectable PAL/NTSC Libraries_Manual_guide/node031D.html 27 / / About ECS / Determining Chip Versions Libraries_Manual_guide/node031E.html 27 / Introduction / Forming an Image Libraries_Manual_guide/node031F.html 27 / Introduction / Role of the Copper (Coprocessor) Libraries_Manual_guide/node0320.html 27 Graphics Primitives / Display Routines and Structures Libraries_Manual_guide/node0321.html 27 / Display Routines and Structures / Limitations on Use of Viewports Libraries_Manual_guide/node0322.html 27 / Display Routines and Structures / Characteristics of a Viewport Libraries_Manual_guide/node0323.html 27 / Display Routines and Structures / Viewport Size Specifications Libraries_Manual_guide/node0324.html 27 / / Viewport Size Specifications / ViewPort Height Libraries_Manual_guide/node0325.html 27 / / Viewport Size Specifications / ViewPort Width Libraries_Manual_guide/node0326.html 27 / Display Routines and Structures / Viewport Color Selection Libraries_Manual_guide/node0327.html 27 / Display Routines and Structures / Viewport Display Modes Libraries_Manual_guide/node0328.html 27 / / Viewport Display Modes / Single- vs. Dual-playfield Mode Libraries_Manual_guide/node0329.html 27 / / Viewport Display Modes / Low- vs. High-resolution Mode Libraries_Manual_guide/node032A.html 27 / / Viewport Display Modes / Interlaced vs. Non-interlaced Mode Libraries_Manual_guide/node032B.html 27 / Display Routines and Structures / Viewport Display Memory Libraries_Manual_guide/node032C.html 27 / Display Routines and Structures / Forming a Basic Display Libraries_Manual_guide/node032D.html 27 / / Forming a Basic Display / Preparing the View Structure Libraries_Manual_guide/node032E.html 27 / / Forming a Basic Display / Preparing the BitMap Structure Libraries_Manual_guide/node032F.html 27 / / Forming a Basic Display / Preparing the RasInfo Structure Libraries_Manual_guide/node0330.html 27 / / Forming a Basic Display / Preparing the ViewPort Structure Libraries_Manual_guide/node0331.html 27 / / Forming a Basic Display / Preparing the ColorMap Structure Libraries_Manual_guide/node0332.html 27 / / Forming a Basic Display / Creating the Display Instructions Libraries_Manual_guide/node0333.html 27 / Display Routines and Structures / Loading and Displaying the View Libraries_Manual_guide/node0334.html 27 / / Loading and Displaying the View / Exiting Gracefully Libraries_Manual_guide/node0335.html 27 / Routines and Structures / Monitors, Modes and Display Database Libraries_Manual_guide/node0336.html 27 / / Monitors, Modes and the Display Database / New Monitors Libraries_Manual_guide/node0337.html 27 / / Monitors, Modes and the Display Database / New Modes Libraries_Manual_guide/node0338.html 27 / / / Mode Specification, Screen Interface Libraries_Manual_guide/node0339.html 27 / / / Mode Specification, ViewPort Interface Libraries_Manual_guide/node033A.html 27 / / Monitors, Modes and the Display Database / Coexisting Modes Libraries_Manual_guide/node033B.html 27 / / Monitors, Modes and the Display Database / ModeID Identifiers Libraries_Manual_guide/node033C.html 27 / / / The Display Database and the DisplayInfo Record Libraries_Manual_guide/node033D.html 27 / / Monitors, Modes and Display Database / Accessing DisplayInfo Libraries_Manual_guide/node033E.html 27 / / Monitors, Modes and the Display Database / Mode Availability Libraries_Manual_guide/node033F.html 27 / / Monitors, Modes and Display Database / Accessing MonitorSpec Libraries_Manual_guide/node0340.html 27 / / Monitors, Modes and the Display Database / Mode Properties Libraries_Manual_guide/node0341.html 27 / / Monitors, Modes and the Display Database / Nominal Values Libraries_Manual_guide/node0342.html 27 / / Monitors, Modes and the Display Database / Preference Items Libraries_Manual_guide/node0343.html 27 / / / Run-Time Name Binding of Mode Information Libraries_Manual_guide/node0344.html 27 Graphics Primitives / Advanced Topics Libraries_Manual_guide/node0345.html 27 / Advanced Topics / Creating a Dual-Playfield Display Libraries_Manual_guide/node0346.html 27 / Advanced Topics / Creating a Double-Buffered Display Libraries_Manual_guide/node0347.html 27 / Advanced Topics / Extra-Half-Brite Mode Libraries_Manual_guide/node0348.html 27 / Advanced Topics / Hold-And-Modify Mode Libraries_Manual_guide/node0349.html 27 Graphics Primitives / Drawing Routines Libraries_Manual_guide/node034A.html 27 / Drawing Routines / The RastPort Structure Libraries_Manual_guide/node034B.html 27 / / The RastPort Structure / Initializing a BitMap Structure Libraries_Manual_guide/node034C.html 27 / / The RastPort Structure / Initializing a RastPort Structure Libraries_Manual_guide/node034D.html 27 / / The RastPort Structure / RastPort Area-fill Information Libraries_Manual_guide/node034E.html 27 / / The RastPort Structure / RastPort Graphics Element Pointer Libraries_Manual_guide/node034F.html 27 / / The RastPort Structure / RastPort Write Mask Libraries_Manual_guide/node0350.html 27 / / The RastPort Structure / RastPort Drawing Pens Libraries_Manual_guide/node0351.html 27 / / The RastPort Structure / RastPort Drawing Modes Libraries_Manual_guide/node0352.html 27 / / RastPort Structure / RastPort Line and Area Drawing Patterns Libraries_Manual_guide/node0353.html 27 / / The RastPort Structure / RastPort Pen Position and Size Libraries_Manual_guide/node0354.html 27 / / The RastPort Structure / Text Attributes Libraries_Manual_guide/node0355.html 27 / Drawing Routines / Using the Graphics Drawing Routines Libraries_Manual_guide/node0356.html 27 / / Using the Graphics Drawing Routines / Drawing Individual Pixels Libraries_Manual_guide/node0357.html 27 / / Using the Graphics Drawing Routines / Reading Individual Pixels Libraries_Manual_guide/node0358.html 27 / / Using Graphics Drawing Routines / Drawing Ellipses and Circles Libraries_Manual_guide/node0359.html 27 / / Using the Graphics Drawing Routines / Drawing Lines Libraries_Manual_guide/node035A.html 27 / / Using the Graphics Drawing Routines / Drawing Patterned Lines Libraries_Manual_guide/node035B.html 27 / / / Drawing Multiple Lines with a Single Command Libraries_Manual_guide/node035C.html 27 / / Using the Graphics Drawing Routines / Area-fill Operations Libraries_Manual_guide/node035D.html 27 / / Using Drawing Routines / Ellipse and Circle-fill Operations Libraries_Manual_guide/node035E.html 27 / / Using the Graphics Drawing Routines / Flood-fill Operations Libraries_Manual_guide/node035F.html 27 / / Using the Graphics Drawing Routines / Rectangle-fill Operations Libraries_Manual_guide/node0360.html 27 / Drawing Routines / Performing Data Move Operations Libraries_Manual_guide/node0361.html 27 / / Performing Data Move Operations / Clearing a Memory Area Libraries_Manual_guide/node0362.html 27 / / Data Move Operations / Setting a Whole Raster to a Color Libraries_Manual_guide/node0363.html 27 / / Data Move Operations / Scrolling a Sub-rectangle of a Raster Libraries_Manual_guide/node0364.html 27 / / Performing Data Move Operations / Drawing through a Stencil Libraries_Manual_guide/node0365.html 27 / / Data Move Operations / Extracting from a Bit-packed Array Libraries_Manual_guide/node0366.html 27 / / Performing Data Move Operations / Copying Rectangular Areas Libraries_Manual_guide/node0367.html 27 / / Performing Data Move Operations / Scaling Rectangular Areas Libraries_Manual_guide/node0368.html 27 / / Performing Data Move Operations / When to Wait for the Blitter Libraries_Manual_guide/node0369.html 27 / / Performing Data Move Operations / Accessing Blitter Directly Libraries_Manual_guide/node036A.html 27 Graphics Primitives / User Copper Lists Libraries_Manual_guide/node036B.html 27 / User Copper Lists / Copper List Macros Libraries_Manual_guide/node036C.html 27 Graphics Primitives / ECS and Genlocking Features Libraries_Manual_guide/node036D.html 27 / ECS and Genlocking Features / Genlock Control Libraries_Manual_guide/node036E.html 27 Graphics Primitives / Function Reference Libraries_Manual_guide/node036F.html Amiga® RKM Libraries: 28 Graphics Sprites, Bobs and Animation Libraries_Manual_guide/node0370.html 28 Graphics Sprites, Bobs and Animation / About the GELs System Libraries_Manual_guide/node0371.html 28 / About the GELs System / Types of GELs Libraries_Manual_guide/node0372.html 28 / / Types Of GELs / Simple Sprites Libraries_Manual_guide/node0373.html 28 / / Types Of GELs / VSprites Libraries_Manual_guide/node0374.html 28 / / Types Of GELs / Bobs and AnimComps Libraries_Manual_guide/node0375.html 28 / / Types Of GELs / AnimObs Libraries_Manual_guide/node0376.html 28 / / Types Of GELs / VSprites vs. Bobs Libraries_Manual_guide/node0377.html 28 / About the GELs System / The GELs System Libraries_Manual_guide/node0378.html 28 / / The GELs System / Initializing the GEL System Libraries_Manual_guide/node0379.html 28 Sprites, Bobs and Animation / Using Simple (Hardware) Sprites Libraries_Manual_guide/node037A.html 28 / Using Simple (Hardware) Sprites / Simple Sprite Functions Libraries_Manual_guide/node037B.html 28 / / Simple Sprite Functions / Accessing A Hardware Sprite Libraries_Manual_guide/node037C.html 28 / / Sprite Functions / Changing The Appearance Of A Simple Sprite Libraries_Manual_guide/node037D.html 28 / / Simple Sprite Functions / Moving A Simple Sprite Libraries_Manual_guide/node037E.html 28 / / Simple Sprite Functions / Relinquishing A Simple Sprite Libraries_Manual_guide/node037F.html 28 / / Simple Sprite Functions / Controlling Sprite DMA Libraries_Manual_guide/node0380.html 28 Graphics Sprites, Bobs and Animation / Using Virtual Sprites Libraries_Manual_guide/node0381.html 28 / Using Virtual Sprites / Specification of VSprite Structure Libraries_Manual_guide/node0382.html 28 / Using Virtual Sprites / Reserved VSprite Members Libraries_Manual_guide/node0383.html 28 / Using Virtual Sprites / Using VSprite Flags Libraries_Manual_guide/node0384.html 28 / Using Virtual Sprites / VSprite Position Libraries_Manual_guide/node0385.html 28 / Using Virtual Sprites / VSprite Image Size Libraries_Manual_guide/node0386.html 28 / Using Virtual Sprites / VSprites and Collision Detection Libraries_Manual_guide/node0387.html 28 / Using Virtual Sprites / VSprite Image Data Libraries_Manual_guide/node0388.html 28 / Using Virtual Sprites / Specifying the Colors of a VSprite Libraries_Manual_guide/node0389.html 28 / Using Virtual Sprites / Adding and Removing VSprites Libraries_Manual_guide/node038A.html 28 / Using Virtual Sprites / Changing VSprites Libraries_Manual_guide/node038B.html 28 / Using Virtual Sprites / Getting the VSprite List In Order Libraries_Manual_guide/node038C.html 28 / Using Virtual Sprites / Displaying the VSprites Libraries_Manual_guide/node038D.html 28 / / Displaying the VSprites / Drawing the Graphics Elements Libraries_Manual_guide/node038E.html 28 / / Displaying the VSprites / Merging VSprite Instructions Libraries_Manual_guide/node038F.html 28 / / Displaying the VSprites / Loading the New View Libraries_Manual_guide/node0390.html 28 / / Displaying the VSprites / Synchronizing with the Display Libraries_Manual_guide/node0391.html 28 Graphics: Sprites, Bobs and Animation / VSprite Advanced Topics Libraries_Manual_guide/node0392.html 28 / VSprite Advanced Topics / Reserving Hardware Sprites Libraries_Manual_guide/node0393.html 28 / VSprite Advanced Topics / How VSprites Are Assigned Libraries_Manual_guide/node0394.html 28 / Advanced Topics / How VSprite and Playfield Colors Interact Libraries_Manual_guide/node0395.html 28 Graphics Sprites, Bobs and Animation / Using Bobs Libraries_Manual_guide/node0396.html 28 / Using Bobs / The VSprite Structure and Bobs Libraries_Manual_guide/node0397.html 28 / Using Bobs / VSprite Flags and Bobs Libraries_Manual_guide/node0398.html 28 / Using Bobs / The Bob Structure Libraries_Manual_guide/node0399.html 28 / / The Bob Structure / Linking Bob and VSprite Structures Libraries_Manual_guide/node039A.html 28 / Using Bobs / Using Bob Flags Libraries_Manual_guide/node039B.html 28 / Using Bobs / Specifying the Size of a Bob Libraries_Manual_guide/node039C.html 28 / Using Bobs / Specifying the Shape of a Bob Libraries_Manual_guide/node039D.html 28 / Using Bobs / Specifying the Colors of a Bob Libraries_Manual_guide/node039E.html 28 / Using Bobs / Other Items Influencing Bob Colors Libraries_Manual_guide/node039F.html 28 / / Other Items Influencing Bob Colors / ImageShadow Libraries_Manual_guide/node03A0.html 28 / / Other Items Influencing Bob Colors / PlanePick Libraries_Manual_guide/node03A1.html 28 / / Other Items Influencing Bob Colors / PlaneOnOff Libraries_Manual_guide/node03A2.html 28 / Using Bobs / Bob Priorities Libraries_Manual_guide/node03A3.html 28 / / Bob Priorities / Letting the System Decide Priorities Libraries_Manual_guide/node03A4.html 28 / / Bob Priorities / Specifying the Drawing Order Libraries_Manual_guide/node03A5.html 28 / Using Bobs / Adding a Bob Libraries_Manual_guide/node03A6.html 28 / Using Bobs / Removing a Bob Libraries_Manual_guide/node03A7.html 28 / Using Bobs / Sorting and Displaying Bobs Libraries_Manual_guide/node03A8.html 28 / Using Bobs / Changing Bobs Libraries_Manual_guide/node03A9.html 28 / Using Bobs / Double-Buffering Libraries_Manual_guide/node03AA.html 28 / / Double-Buffering / DBufPacket and Double-Buffering Libraries_Manual_guide/node03AB.html 28 / / Collisions and GEL Structure Extensions Libraries_Manual_guide/node03AC.html 28 / Collisions and GEL Structure Extensions / Detecting Gel Collisions Libraries_Manual_guide/node03AD.html 28 / / Detecting Gel Collisions / Preparing for Collision Detection Libraries_Manual_guide/node03AE.html 28 / / Detecting Collisions / Building a Table of Collision Routines Libraries_Manual_guide/node03AF.html 28 / / Detecting Gel Collisions / VSprite Collision Mask Libraries_Manual_guide/node03B0.html 28 / / Detecting Gel Collisions / VSprite BorderLine Libraries_Manual_guide/node03B1.html 28 / / Detecting Gel Collisions / VSprite HitMask and MeMask Libraries_Manual_guide/node03B2.html 28 / / Detecting Gel Collisions / Using HitMask and MeMask Libraries_Manual_guide/node03B3.html 28 / / Setting Up For Boundary Collisions Libraries_Manual_guide/node03B4.html 28 / / / Parameters To Your Boundary Collision Routine Libraries_Manual_guide/node03B5.html 28 / / / Parameters To Your Inter-GEL Collision Routines Libraries_Manual_guide/node03B6.html 28 / / Set Up For Boundary Collisions / Handling Multiple Collisions Libraries_Manual_guide/node03B7.html 28 / / Adding User Extensions To Gel Data Structures Libraries_Manual_guide/node03B8.html 28 Graphics Sprites, Bobs and Animation / Animation with GELs Libraries_Manual_guide/node03B9.html 28 / Animation with GELs / Animation Data Structures Libraries_Manual_guide/node03BA.html 28 / Animation with GELs / Animation Types Libraries_Manual_guide/node03BB.html 28 / / Animation Types / Simple Motion Control Libraries_Manual_guide/node03BC.html 28 / / Animation Types / Sequenced Drawing Libraries_Manual_guide/node03BD.html 28 / / Animation Types / Ring Motion Control Libraries_Manual_guide/node03BE.html 28 / Animation with GELs / Specifying Animation Components Libraries_Manual_guide/node03BF.html 28 / / Specifying Animation Components / Sequencing AnimComps Libraries_Manual_guide/node03C0.html 28 / / Specifying Animation Components / Position of an AnimComp Libraries_Manual_guide/node03C1.html 28 / / Animation Components / Specifying Time for Each Image Libraries_Manual_guide/node03C2.html 28 / / Animation Components / Linking Multiple AnimComp Sequences Libraries_Manual_guide/node03C3.html 28 / / Specifying Animation Components / Component Ordering Libraries_Manual_guide/node03C4.html 28 / Animation with GELs / Specifying the Animation Object Libraries_Manual_guide/node03C5.html 28 / / / Linking the AnimComp Sequences to the AnimOb Libraries_Manual_guide/node03C6.html 28 / / Specifying the Animation Object / Position of an AnimOb Libraries_Manual_guide/node03C7.html 28 / / Specifying Animation Object / Setting Up Simple Motion Control Libraries_Manual_guide/node03C8.html 28 / / Specifying Animation Object / Setting Up Ring Motion Control Libraries_Manual_guide/node03C9.html 28 / / / Using Sequenced Drawing and Motion Control Libraries_Manual_guide/node03CA.html 28 / Animation with GELs / The AnimKey Libraries_Manual_guide/node03CB.html 28 / Animation with GELs / Adding Animation Objects Libraries_Manual_guide/node03CC.html 28 / Animation with GELs / Moving the Objects Libraries_Manual_guide/node03CD.html 28 / Animation with GELs / Your Own Animation Routine Calls Libraries_Manual_guide/node03CE.html 28 / Animation with GELs / Standard Gel Rules Still Apply Libraries_Manual_guide/node03CF.html 28 / Animation with GELs / Animations Special Numbering System Libraries_Manual_guide/node03D0.html 28 / Animation with GELs / Animtools.h and Animtools.c Libraries_Manual_guide/node03D1.html 28 Graphics Sprites, Bobs and Animation / Function Reference Libraries_Manual_guide/node03D2.html Amiga® RKM Libraries: 29 Graphics Library and Text Libraries_Manual_guide/node03D3.html 29 Graphics Library and Text / About Amiga Fonts Libraries_Manual_guide/node03D4.html 29 / About Amiga Fonts / System Fonts In Release 2 Libraries_Manual_guide/node03D5.html 29 Graphics Library and Text / The Text Function Libraries_Manual_guide/node03D6.html 29 / The Text Function / Choosing the Font Libraries_Manual_guide/node03D7.html 29 / The Text Function / Setting the Text Drawing Attributes Libraries_Manual_guide/node03D8.html 29 / The Text Function / Rendering the Text Libraries_Manual_guide/node03D9.html 29 / The Text Function / Setting the Font Style Libraries_Manual_guide/node03DA.html 29 Graphics Library and Text / Does the Text Fit? Libraries_Manual_guide/node03DB.html 29 Graphics Library and Text / Font Scaling and Aspect Ratio Libraries_Manual_guide/node03DC.html 29 Graphics Library and Text / Some Things to Look Out For Libraries_Manual_guide/node03DD.html 29 Graphics Library and Text / What Fonts Are Available? Libraries_Manual_guide/node03DE.html 29 Graphics Library and Text / How an Amiga Font Structured in Memory? Libraries_Manual_guide/node03DF.html 29 Graphics Library and Text / But What About Color Fonts? Libraries_Manual_guide/node03E0.html 29 Graphics Library and Text / Composition of a Bitmap Font on Disk Libraries_Manual_guide/node03E1.html 29 Graphics Library and Text / Function Reference Libraries_Manual_guide/node03E2.html Amiga® RKM Libraries: 30 Layers Library Libraries_Manual_guide/node03E3.html 30 Layers Library / Layers Libraries_Manual_guide/node03E4.html 30 / Layers / The Layer Structure Libraries_Manual_guide/node03E5.html 30 / Layers / The Layer's RastPort Libraries_Manual_guide/node03E6.html 30 / Layers / Types of Layers Libraries_Manual_guide/node03E7.html 30 / / Types of Layers / Simple Refresh Layer Libraries_Manual_guide/node03E8.html 30 / / Types of Layers / Smart Refresh Layer Libraries_Manual_guide/node03E9.html 30 / / Types of Layers / Super Bitmap Layer Libraries_Manual_guide/node03EA.html 30 / / Types of Layers / Backdrop Layer Libraries_Manual_guide/node03EB.html 30 / Layers / Opening the Layers Library Libraries_Manual_guide/node03EC.html 30 / Layers / Working With Existing Layers Libraries_Manual_guide/node03ED.html 30 / / Working With Existing Layers / Intertask Operations Libraries_Manual_guide/node03EE.html 30 / / Working With Existing Layers / Determining Layer Position Libraries_Manual_guide/node03EF.html 30 / Layers / Creating and Using New Layers Libraries_Manual_guide/node03F0.html 30 / / Creating and Using New Layers / Creating a Viewing Workspace Libraries_Manual_guide/node03F1.html 30 / / Creating and Using New Layers / Creating the Layers Libraries_Manual_guide/node03F2.html 30 / / / Allocating and Deallocating Layer_Info Libraries_Manual_guide/node03F3.html 30 / / Creating and Using Layers / Allocating and Deallocating Layers Libraries_Manual_guide/node03F4.html 30 / / Creating and Using New Layers / Moving and Sizing Layers Libraries_Manual_guide/node03F5.html 30 / / Creating and Using New Layers / Changing a Viewpoint Libraries_Manual_guide/node03F6.html 30 / / Creating and Using New Layers / Reordering Layers Libraries_Manual_guide/node03F7.html 30 / / Creating and Using New Layers / Sub-Layer Rectangle Operations Libraries_Manual_guide/node03F8.html 30 Layers Library / Regions Libraries_Manual_guide/node03F9.html 30 / Regions / Creating and Deleting Regions Libraries_Manual_guide/node03FA.html 30 / Regions / Installing Regions Libraries_Manual_guide/node03FB.html 30 / Regions / Changing a Region Libraries_Manual_guide/node03FC.html 30 / / Changing a Region / Rectangles and Regions Libraries_Manual_guide/node03FD.html 30 / / Changing a Region / Regions and Regions Libraries_Manual_guide/node03FE.html 30 Layers Library / Function Reference Libraries_Manual_guide/node03FF.html Amiga® RKM Libraries: 31 Commodities Exchange Library Libraries_Manual_guide/node0400.html 31 Commodities Exchange Library / Custom Input Handlers Libraries_Manual_guide/node0401.html 31 Commodities Exchange Library / CxObjects Libraries_Manual_guide/node0402.html 31 Commodities Exchange Library / Installing A Broker Object Libraries_Manual_guide/node0403.html 31 Commodities Exchange Library / CxMessages Libraries_Manual_guide/node0404.html 31 / CxMessages / Controller Commands Libraries_Manual_guide/node0405.html 31 / CxMessages / Shutting Down the Commodity Libraries_Manual_guide/node0406.html 31 Commodities Exchange Library / Commodity Tool Types Libraries_Manual_guide/node0407.html 31 Commodities Exchange / Filter Objects and Input Description Strings Libraries_Manual_guide/node0408.html 31 Commodities Exchange Library / Connecting CxObjects Libraries_Manual_guide/node0409.html 31 Commodities Exchange Library / Sender CxObjects Libraries_Manual_guide/node040A.html 31 Commodities Exchange Library / Translate CxObjects Libraries_Manual_guide/node040B.html 31 Commodities Exchange Library / CxObject Errors Libraries_Manual_guide/node040C.html 31 Commodities Exchange Library / Uniqueness Libraries_Manual_guide/node040D.html 31 Commodities Exchange Library / Signal CxObjects Libraries_Manual_guide/node040E.html 31 Commodities Exchange Library / Custom CxObjects Libraries_Manual_guide/node040F.html 31 Commodities Exchange Library / Debug CxObjects Libraries_Manual_guide/node0410.html 31 Commodities Exchange Library / The IX Structure Libraries_Manual_guide/node0411.html 31 Commodities Exchange Library / Controlling CxMessages Libraries_Manual_guide/node0412.html 31 Commodities Exchange Library / New Input Events Libraries_Manual_guide/node0413.html 31 Commodities Exchange Library / Function Reference Libraries_Manual_guide/node0414.html Amiga® RKM Libraries: 32 Expansion Library Libraries_Manual_guide/node0415.html 32 Expansion Library / AUTOCONFIG(TM) Libraries_Manual_guide/node0416.html 32 Expansion Library / The Expansion Sequence Libraries_Manual_guide/node0417.html 32 / The Expansion Sequence / Simple Expansion Library Example Libraries_Manual_guide/node0418.html 32 Expansion Library / Expansion Board Drivers Libraries_Manual_guide/node0419.html 32 / Expansion Board Drivers / Disk Based Drivers Libraries_Manual_guide/node041A.html 32 / Expansion Board Drivers / Expansion Drivers and DOS Libraries_Manual_guide/node041B.html 32 / Expansion Board Drivers / ROM Based and Autoboot Drivers Libraries_Manual_guide/node041C.html 32 / / ROM Based and Autoboot Drivers / Events At DIAG Time Libraries_Manual_guide/node041D.html 32 / / ROM Based and Autoboot Drivers / Events At ROMTAG INIT Time Libraries_Manual_guide/node041E.html 32 / / ROM Based and Autoboot Drivers / Events At BOOT Time Libraries_Manual_guide/node041F.html 32 / Expansion Board Drivers / RigidDiskBlock and Alternate Filesystems Libraries_Manual_guide/node0420.html 32 / / RigidDiskBlock and Alternate Filesystems / RigidDiskBlock Libraries_Manual_guide/node0421.html 32 / / RigidDiskBlock and Alternate Filesystems / BadBlockBlock Libraries_Manual_guide/node0422.html 32 / / RigidDiskBlock and Alternate Filesystems / PartitionBlock Libraries_Manual_guide/node0423.html 32 / / RigidDiskBlock and Alternate Filesystems / FileSysHeaderBlock Libraries_Manual_guide/node0424.html 32 / / RigidDiskBlock and Alternate Filesystems / LoadSegBlock Libraries_Manual_guide/node0425.html 32 / / RigidDiskBlock and Alternate Filesystems / filesysres.h and .i Libraries_Manual_guide/node0426.html 32 Expansion Library / Function Reference Libraries_Manual_guide/node0427.html Amiga® RKM Libraries: 33 IFFParse Library Libraries_Manual_guide/node0428.html 33 IFFParse Library / The Structure of IFF Files Libraries_Manual_guide/node0429.html 33 / The Structure of IFF Files / Chunks: The Building Blocks of IFF Libraries_Manual_guide/node042A.html 33 / The Structure of IFF Files / Composite Data Types Libraries_Manual_guide/node042B.html 33 IFFParse Library / Parsing an IFF File Libraries_Manual_guide/node042C.html 33 / / Basic Functions and Structures of IFFParse Library Libraries_Manual_guide/node042D.html 33 IFFParse Library / Stream Management Libraries_Manual_guide/node042E.html 33 / Stream Management / Initialization Libraries_Manual_guide/node042F.html 33 / Stream Management / Termination Libraries_Manual_guide/node0430.html 33 / Stream Management / Custom Streams Libraries_Manual_guide/node0431.html 33 IFFParse Library / Parsing Libraries_Manual_guide/node0432.html 33 / Parsing / Controlling Parsing Libraries_Manual_guide/node0433.html 33 / / Controlling Parsing / StopChunk() Libraries_Manual_guide/node0434.html 33 / / Controlling Parsing / PropChunk()/FindProp() Libraries_Manual_guide/node0435.html 33 / Parsing / Putting It Together Libraries_Manual_guide/node0436.html 33 / Parsing / Other Chunk Management Functions Libraries_Manual_guide/node0437.html 33 / / Management Functions / CollectionChunk() and FindCollection() Libraries_Manual_guide/node0438.html 33 / / Other Chunk Management Functions / StopOnExit() Libraries_Manual_guide/node0439.html 33 / / Other Chunk Management Functions / EntryHandler() Libraries_Manual_guide/node043A.html 33 / / Other Chunk Management Functions / ExitHandler() Libraries_Manual_guide/node043B.html 33 / Parsing / Reading Chunk Data Libraries_Manual_guide/node043C.html 33 / Parsing / Other Parsing Modes Libraries_Manual_guide/node043D.html 33 / / Other Parsing Modes / IFFPARSE_RAWSTEP Libraries_Manual_guide/node043E.html 33 / / Other Parsing Modes / IFFPARSE_STEP Libraries_Manual_guide/node043F.html 33 IFFParse Library / Writing IFF Files Libraries_Manual_guide/node0440.html 33 / Writing IFF Files / Creating Chunks In a File Libraries_Manual_guide/node0441.html 33 / / Creating Chunks In a File / PushChunk() Libraries_Manual_guide/node0442.html 33 / / Creating Chunks In a File / PopChunk() Libraries_Manual_guide/node0443.html 33 / Writing IFF Files / Writing Chunk Data Libraries_Manual_guide/node0444.html 33 / Writing IFF Files / A Note On Seekability Libraries_Manual_guide/node0445.html 33 IFFParse Library / Context Functions Libraries_Manual_guide/node0446.html 33 / Context Functions / Context Nodes Libraries_Manual_guide/node0447.html 33 / / Context Nodes / CurrentChunk() Libraries_Manual_guide/node0448.html 33 / / Context Nodes / ParentChunk() Libraries_Manual_guide/node0449.html 33 / Context Functions / The Default Context Libraries_Manual_guide/node044A.html 33 / Context Functions / Context-Specific Data: LocalContextItems Libraries_Manual_guide/node044B.html 33 / / Context-Specific Data: LocalContextItems / AllocLocalItem() Libraries_Manual_guide/node044C.html 33 / / Context-Specific Data: LocalContextItems / LocalItemData() Libraries_Manual_guide/node044D.html 33 / Context Functions / Storing LCIs Libraries_Manual_guide/node044E.html 33 / / Storing LCIs / StoreLocalItem() Libraries_Manual_guide/node044F.html 33 / / Storing LCIs / StoreItemInContext() Libraries_Manual_guide/node0450.html 33 / / Storing LCIs / FindLocalItem() Libraries_Manual_guide/node0451.html 33 / Context Functions / Some Interesting Internal Details Libraries_Manual_guide/node0452.html 33 IFFParse Library / Error Handling Libraries_Manual_guide/node0453.html 33 IFFParse Library / Advanced Topics Libraries_Manual_guide/node0454.html 33 / Advanced Topics / Custom Stream Handlers Libraries_Manual_guide/node0455.html 33 / / Custom Stream Handlers / Installing a Custom Stream Handler Libraries_Manual_guide/node0456.html 33 / / Custom Stream Handlers / Inside a Custom Stream Handler Libraries_Manual_guide/node0457.html 33 / Advanced Topics / Custom Chunk Handlers Libraries_Manual_guide/node0458.html 33 / / Custom Chunk Handlers / Installing a Custom Chunk Handler Libraries_Manual_guide/node0459.html 33 / / Custom Chunk Handlers / Inside a Custom Chunk Handler Libraries_Manual_guide/node045A.html 33 / / Custom Chunk Handlers / The Object Parameter Libraries_Manual_guide/node045B.html 33 / Advanced Topics / Finding The PROP Context Libraries_Manual_guide/node045C.html 33 / Advanced Topics / Freeing LCIs Libraries_Manual_guide/node045D.html 33 IFFParse Library / IFF FORM Specifications Libraries_Manual_guide/node045E.html 33 / IFF FORM Specifications / FORM ILBM Libraries_Manual_guide/node045F.html 33 / / FORM ILBM / ILBM.BMHD BitMapHeader Chunk Libraries_Manual_guide/node0460.html 33 / / FORM ILBM / Sample Hex Dump of an ILBM Libraries_Manual_guide/node0461.html 33 / / FORM ILBM / Interpreting ILBMs Libraries_Manual_guide/node0462.html 33 / / FORM ILBM / ILBM BODY Compression Libraries_Manual_guide/node0463.html 33 / / FORM ILBM / Interpreting the Scan Line Data Libraries_Manual_guide/node0464.html 33 / / FORM ILBM / Other ILBM Notes Libraries_Manual_guide/node0465.html 33 / IFF FORM Specifications / FORM FTXT Libraries_Manual_guide/node0466.html 33 IFFParse Library / IFFParse Examples Libraries_Manual_guide/node0467.html 33 IFFParse Library / Function Reference Libraries_Manual_guide/node0468.html Amiga® RKM Libraries: 34 Keymap Library Libraries_Manual_guide/node0469.html 34 Keymap Library / Keymap Functions Libraries_Manual_guide/node046A.html 34 / Keymap Functions / Asking For the Default Keymap Libraries_Manual_guide/node046B.html 34 / Keymap Functions / Setting the Default Keymap Libraries_Manual_guide/node046C.html 34 / Keymap Functions / Accessing the Keymap For the Current Console Libraries_Manual_guide/node046D.html 34 / Keymap Functions / Mapping Key Codes To ANSI Strings Libraries_Manual_guide/node046E.html 34 / Keymap Functions / Mapping ANSI Strings To Key Codes Libraries_Manual_guide/node046F.html 34 / Keymap Functions / Details Of the Keymap Structure Libraries_Manual_guide/node0470.html 34 / / Details Of the Keymap Structure / LoKeyMap and HighKeyMap Libraries_Manual_guide/node0471.html 34 / / Details Of Keymap Structure / LoKeyMapTypes and HiKeyMapTypes Libraries_Manual_guide/node0472.html 34 / / Details Of the Keymap Structure / More About Qualifiers Libraries_Manual_guide/node0473.html 34 / / Details Of the Keymap Structure / String Output Keys Libraries_Manual_guide/node0474.html 34 / / Details Of the Keymap Structure / Capsable Bit Tables Libraries_Manual_guide/node0475.html 34 / / Details Of the Keymap Structure / Repeatable Bit Tables Libraries_Manual_guide/node0476.html 34 / Keymap Functions / Key Map Standards Libraries_Manual_guide/node0477.html 34 / Keymap Functions / Dead-Class Keys Libraries_Manual_guide/node0478.html 34 / Keymap Functions / Double-Dead Keys Libraries_Manual_guide/node0479.html 34 Keymap Library / Keyboard Layout Libraries_Manual_guide/node047A.html 34 Keymap Library / Function Reference Libraries_Manual_guide/node047B.html Amiga® RKM Libraries: 35 Math Libraries Libraries_Manual_guide/node047C.html 35 Math Libraries / Math Libraries and Functions Libraries_Manual_guide/node047D.html 35 Math Libraries / FFP Floating Point Data Format Libraries_Manual_guide/node047E.html 35 Math Libraries / FFP Basic Mathematics Library Libraries_Manual_guide/node047F.html 35 / FFP Basic Mathematics Library / FFP Basic Functions Libraries_Manual_guide/node0480.html 35 Math Libraries / FFP Transcendental Mathematics Library Libraries_Manual_guide/node0481.html 35 / Transcendental Mathematics Library / FFP Transcendental Functions Libraries_Manual_guide/node0482.html 35 Math Libraries / FFP Mathematics Conversion Library Libraries_Manual_guide/node0483.html 35 / FFP Mathematics Conversion Library / Math Support Functions Libraries_Manual_guide/node0484.html 35 Math Libraries / IEEE Single-Precision Data Format Libraries_Manual_guide/node0485.html 35 Math Libraries / IEEE Single-Precision Basic Math Library Libraries_Manual_guide/node0486.html 35 / SP Basic Math Library / SP IEEE Basic Functions (V36 or Greater) Libraries_Manual_guide/node0487.html 35 Math Libraries / IEEE Single-Precision Transcendental Math Library Libraries_Manual_guide/node0488.html 35 / / SP IEEE Transcendental Functions (V36 Or Greater) Libraries_Manual_guide/node0489.html 35 Math Libraries / IEEE Double-Precision Data Format Libraries_Manual_guide/node048A.html 35 Math Libraries / IEEE Double-Precision Basic Math Library Libraries_Manual_guide/node048B.html 35 /IEEE Double-Precision Basic Math Library / DP IEEE Basic Functions Libraries_Manual_guide/node048C.html 35 Math Libraries / IEEE Double-Precision Transcendental Math Library Libraries_Manual_guide/node048D.html 35 / / DP IEEE Transcendental Functions Libraries_Manual_guide/node048E.html 35 Math Libraries / Function Reference Libraries_Manual_guide/node048F.html 35 Math Libraries / Compile and Link Commands for SAS C 5.10 Libraries_Manual_guide/node0490.html Amiga® RKM Libraries: 36 Translator Library Libraries_Manual_guide/node0491.html 36 Translator Library / Opening the Translator Library Libraries_Manual_guide/node0492.html 36 Translator Library / Using the Translate Function Libraries_Manual_guide/node0493.html 36 Translator Library / Closing the Translator Library Libraries_Manual_guide/node0494.html 36 Translator Library / Additional Notes About Translate Libraries_Manual_guide/node0495.html Amiga® RKM Libraries: 37 Utility Library Libraries_Manual_guide/node0496.html 37 Utility Library / Tags Libraries_Manual_guide/node0497.html 37 / Tags / Tag Functions and Structures Libraries_Manual_guide/node0498.html 37 / Tags / Simple Tag Usage Libraries_Manual_guide/node0499.html 37 / Tags / Advanced Tag Usage Libraries_Manual_guide/node049A.html 37 / / Advanced Tag Usage / Creating a New Tag List Libraries_Manual_guide/node049B.html 37 / / Advanced Tag Usage / Copying an Existing Tag List Libraries_Manual_guide/node049C.html 37 / / Advanced Tag Usage / Filtering an Existing Tag List Libraries_Manual_guide/node049D.html 37 / / Advanced Tag Usage / Locating an Attribute Libraries_Manual_guide/node049E.html 37 / / Advanced Tag Usage / Sequential Access of Tag Lists Libraries_Manual_guide/node049F.html 37 / / Advanced Tag Usage / Random Access of Tag Lists Libraries_Manual_guide/node04A0.html 37 / / Advanced Tag Usage / Obtaining Boolean Values Libraries_Manual_guide/node04A1.html 37 / / Advanced Tag Usage / Mapping Tag Attributes Libraries_Manual_guide/node04A2.html 37 Utility Library / Callback Hooks Libraries_Manual_guide/node04A3.html 37 / Callback Hooks / Callback Hook Structure and Function Libraries_Manual_guide/node04A4.html 37 / / Hook Structure And Function / Simple Callback Hook Usage Libraries_Manual_guide/node04A5.html 37 Utility Library / 32-bit Integer Math Functions Libraries_Manual_guide/node04A6.html 37 Utility Library / International String Functions Libraries_Manual_guide/node04A7.html 37 Utility Library / Date Functions Libraries_Manual_guide/node04A8.html 37 Utility Library / Function Reference Libraries_Manual_guide/node04A9.html 37 / Function Reference / Tag Function Reference Libraries_Manual_guide/node04AA.html 37 / Function Reference / Callback Hook Function Reference Libraries_Manual_guide/node04AB.html 37 / Function Reference / 32-Bit Integer Math Function Reference Libraries_Manual_guide/node04AC.html 37 / Function Reference / International String Function Reference Libraries_Manual_guide/node04AD.html 37 / Function Reference / Date Function Reference Libraries_Manual_guide/node04AE.html Amiga® RKM Libraries: A Linker Libraries Libraries_Manual_guide/node04AF.html A Appendix A: Linker Libraries / Amiga.lib Libraries_Manual_guide/node04B0.html A / Amiga.lib / Exec Support Libraries_Manual_guide/node04B1.html A / Amiga.lib / Clib Libraries_Manual_guide/node04B2.html A / Amiga.lib / Math Libraries_Manual_guide/node04B3.html A / Amiga.lib / Graphics Libraries_Manual_guide/node04B4.html A / Amiga.lib / ARexx Libraries_Manual_guide/node04B5.html A / Amiga.lib / Timer Libraries_Manual_guide/node04B6.html A / Amiga.lib / Commodities Libraries_Manual_guide/node04B7.html A / Amiga.lib / Intuition Libraries_Manual_guide/node04B8.html A Appendix A: Linker Libraries / Debug.lib Libraries_Manual_guide/node04B9.html Amiga® RKM Libraries: B Boopsi Class Reference Libraries_Manual_guide/node04BA.html B Boopsi Class Reference / Introduction Libraries_Manual_guide/node04BB.html B Boopsi Class Reference / rootclass Libraries_Manual_guide/node04BC.html B / rootclass / New Methods: OM_NEW Libraries_Manual_guide/node04BD.html B / rootclass / New Methods: OM_DISPOSE Libraries_Manual_guide/node04BE.html B / rootclass / New Methods: OM_ADDTAIL Libraries_Manual_guide/node04BF.html B / rootclass / New Methods: OM_REMOVE Libraries_Manual_guide/node04C0.html B / rootclass / New Methods: OM_ADDMEMBER Libraries_Manual_guide/node04C1.html B / rootclass / New Methods: OM_REMMEMBER Libraries_Manual_guide/node04C2.html B / rootclass / New Methods: OM_GET Libraries_Manual_guide/node04C3.html B / rootclass / New Methods: OM_SET Libraries_Manual_guide/node04C4.html B / rootclass / New Methods: OM_UPDATE Libraries_Manual_guide/node04C5.html B / rootclass / New Methods: OM_NOTIFY Libraries_Manual_guide/node04C6.html B Boopsi Class Reference / icclass Libraries_Manual_guide/node04C7.html B / icclass / Changed Methods: OM_SET Libraries_Manual_guide/node04C8.html B / icclass / Changed Methods: OM_UPDATE/OM_NOTIFY Libraries_Manual_guide/node04C9.html B / icclass / Attributes: ICA_TARGET (IS) Libraries_Manual_guide/node04CA.html B / icclass / Attributes: ICA_MAP (IS) Libraries_Manual_guide/node04CB.html B / icclass / Attributes: ICSPECIAL_CODE () Libraries_Manual_guide/node04CC.html B Boopsi Class Reference / modelclass Libraries_Manual_guide/node04CD.html B / modelclass / Changed Methods: OM_ADDMEMBER Libraries_Manual_guide/node04CE.html B / modelclass / Changed Methods: OM_REMMEMBER Libraries_Manual_guide/node04CF.html B / modelclass / Changed Methods: OM_DISPOSE Libraries_Manual_guide/node04D0.html B / modelclass / Changed Methods: OM_NOTIFY/OM_UPDATE Libraries_Manual_guide/node04D1.html B Boopsi Class Reference / imageclass Libraries_Manual_guide/node04D2.html B / imageclass / New Methods: IM_DRAW Libraries_Manual_guide/node04D3.html B / imageclass / New Methods: IM_HITTEST Libraries_Manual_guide/node04D4.html B / imageclass / New Methods: IM_ERASE Libraries_Manual_guide/node04D5.html B / imageclass / New Methods: IM_DRAWFRAME Libraries_Manual_guide/node04D6.html B / imageclass / New Methods: IM_HITFRAME Libraries_Manual_guide/node04D7.html B / imageclass / New Methods: IM_ERASEFRAME Libraries_Manual_guide/node04D8.html B / imageclass / New Methods: IM_FRAMEBOX Libraries_Manual_guide/node04D9.html B / imageclass / Changed Methods: OM_NEW Libraries_Manual_guide/node04DA.html B / imageclass / Changed Methods: OM_SET Libraries_Manual_guide/node04DB.html B / imageclass / Attributes:IA_Left, IA_Top, IA_Width, IA_Height (ISG) Libraries_Manual_guide/node04DC.html B / imageclass / Attributes: IA_FGPen, IA_BGPen (ISG) Libraries_Manual_guide/node04DD.html B / imageclass / Attributes: IA_Data (ISG) Libraries_Manual_guide/node04DE.html B / imageclass / Attributes: IA_Pens () Libraries_Manual_guide/node04DF.html B Boopsi Class Reference / frameiclass Libraries_Manual_guide/node04E0.html B / frameiclass / Changed Methods: IM_DRAW Libraries_Manual_guide/node04E1.html B / frameiclass / IDS_NORMAL, IDS_INACTIVENORMAL, IDS_DISABLED Libraries_Manual_guide/node04E2.html B / frameiclass / Changed Methods: IDS_SELECTED, IDS_INACTIVESELECTED Libraries_Manual_guide/node04E3.html B / frameiclass / Changed Methods: IM_DRAWFRAME Libraries_Manual_guide/node04E4.html B / frameiclass / Changed Methods: IM_FRAMEBOX Libraries_Manual_guide/node04E5.html B / frameiclass / Attributes: IA_Recessed (IS) Libraries_Manual_guide/node04E6.html B / frameiclass / Attributes: IA_EdgesOnly (IS) Libraries_Manual_guide/node04E7.html B Boopsi Class Reference / sysiclass Libraries_Manual_guide/node04E8.html B / sysiclass / Attributes: SYSIA_DrawInfo (I) Libraries_Manual_guide/node04E9.html B / sysiclass / Attributes: SYSIA_Which (I) Libraries_Manual_guide/node04EA.html B / sysiclass / Attributes: SYSIA_Size (I) Libraries_Manual_guide/node04EB.html B Boopsi Class Reference / fillrectclass Libraries_Manual_guide/node04EC.html B / fillrectclass / Changed Methods: IM_DRAW Libraries_Manual_guide/node04ED.html B / fillrectclass / Changed Methods: IM_DRAWFRAME Libraries_Manual_guide/node04EE.html B / fillrectclass / Attributes: IA_APattern, IA_APatSize (IS) Libraries_Manual_guide/node04EF.html B / fillrectclass / Attributes: IA_Mode (IS) Libraries_Manual_guide/node04F0.html B Boopsi Class Reference / itexticlass Libraries_Manual_guide/node04F1.html B / itexticlass / New Methods: IM_DRAW/IM_DRAWFRAME Libraries_Manual_guide/node04F2.html B Boopsi Class Reference / gadgetclass Libraries_Manual_guide/node04F3.html B / gadgetclass / New Methods: GM_HITTEST Libraries_Manual_guide/node04F4.html B / gadgetclass / New Methods: GM_RENDER Libraries_Manual_guide/node04F5.html B / gadgetclass / New Methods: GM_GOACTIVE Libraries_Manual_guide/node04F6.html B / gadgetclass / New Methods: GM_HANDLEINPUT Libraries_Manual_guide/node04F7.html B / gadgetclass / New Methods: GM_GOINACTIVE Libraries_Manual_guide/node04F8.html B / gadgetclass / Changed Methods: OM_NEW Libraries_Manual_guide/node04F9.html B / gadgetclass / Changed Methods: OM_NOTIFY Libraries_Manual_guide/node04FA.html B / gadgetclass / Attributes: GA_Previous (I) Libraries_Manual_guide/node04FB.html B / gadgetclass / Attributes: ICA_TARGET (IS) Libraries_Manual_guide/node04FC.html B / gadgetclass / Attributes: ICA_MAP (IS) Libraries_Manual_guide/node04FD.html B / gadgetclass / Attributes:GA_Left, GA_Top, GA_Width, GA_Height (IS) Libraries_Manual_guide/node04FE.html B / / GA_RelRight, GA_RelBottom, GA_RelWidth, GA_RelHeight (IS) Libraries_Manual_guide/node04FF.html B / gadgetclass / Attributes:GA_IntuiText, GA_Text, GA_LabelImage (IS) Libraries_Manual_guide/node0500.html B / gadgetclass / Attributes: GA_Image (IS) Libraries_Manual_guide/node0501.html B / gadgetclass / Attributes: GA_Border - GA_SpecialInfo (IS) Libraries_Manual_guide/node0502.html B / gadgetclass / Attributes: GA_GZZGadget, GA_SysGadget (IS) Libraries_Manual_guide/node0503.html B / gadgetclass / Attributes: GA_Disabled, GA_Selected (IS) Libraries_Manual_guide/node0504.html B / gadgetclass / Attributes: GA_EndGadget - GA_TabCycle (IS) Libraries_Manual_guide/node0505.html B / gadgetclass / Attributes: GA_Highlight (IS) Libraries_Manual_guide/node0506.html B / gadgetclass / Attributes: GA_SysGType (IS) Libraries_Manual_guide/node0507.html B Boopsi Class Reference / propgclass Libraries_Manual_guide/node0508.html B / propgclass / Changed Methods: GM_HANDLEINPUT Libraries_Manual_guide/node0509.html B / propgclass / Attributes: GA_Image (I) Libraries_Manual_guide/node050A.html B / propgclass / Attributes: GA_Border (I) Libraries_Manual_guide/node050B.html B / propgclass / Attributes: GA_Highlight (I) Libraries_Manual_guide/node050C.html B / propgclass / Attributes: PGA_Freedom (IG) Libraries_Manual_guide/node050D.html B / propgclass / Attributes: PGA_NewLook (I) Libraries_Manual_guide/node050E.html B / propgclass / Attributes: PGA_Borderless (I) Libraries_Manual_guide/node050F.html B / propgclass / PGA_Top (ISGNU), PGA_Visible, PGA_Total (ISU) Libraries_Manual_guide/node0510.html B Boopsi Class Reference / strgclass Libraries_Manual_guide/node0511.html B / strgclass / Changed Methods: OM_NEW Libraries_Manual_guide/node0512.html B / strgclass / Attributes: STRINGA_LongVal (ISGNU) Libraries_Manual_guide/node0513.html B / strgclass / Attributes: STRINGA_TextVal (ISGNU) Libraries_Manual_guide/node0514.html B / strgclass / Attributes: STRINGA_MaxChars - STRINGA_WorkBuffer (I) Libraries_Manual_guide/node0515.html B / strgclass / Attributes: STRINGA_BufferPos, STRINGA_DispPos (ISU) Libraries_Manual_guide/node0516.html B / strgclass / Attributes: STRINGA_AltKeyMap (IS) Libraries_Manual_guide/node0517.html B / strgclass / Attributes: STRINGA_Font (IS) Libraries_Manual_guide/node0518.html B / strgclass / Attributes: STRINGA_Pens (IS) Libraries_Manual_guide/node0519.html B / strgclass / Attributes: STRINGA_ActivePens (IS) Libraries_Manual_guide/node051A.html B / strgclass / Attributes: STRINGA_EditHook (I) Libraries_Manual_guide/node051B.html B / strgclass / Attributes: STRINGA_EditModes (IS) Libraries_Manual_guide/node051C.html B / strgclass / STRINGA_ReplaceMode - STRINGA_NoFilterMode (IS) Libraries_Manual_guide/node051D.html B / strgclass / Attributes: STRINGA_Justification (IS) Libraries_Manual_guide/node051E.html B / strgclass / Attributes: STRINGA_ExitHelp (IS) Libraries_Manual_guide/node051F.html B Boopsi Class Reference / buttongclass Libraries_Manual_guide/node0520.html B / buttongclass / Changed Methods: GM_HITTEST Libraries_Manual_guide/node0521.html B / buttongclass / Changed Methods: GM_HANDLEINPUT Libraries_Manual_guide/node0522.html B / buttongclass / Changed Methods: GM_RENDER Libraries_Manual_guide/node0523.html B / buttongclass / Attributes: GA_Image (IS) Libraries_Manual_guide/node0524.html B Boopsi Class Reference / frbuttonclass Libraries_Manual_guide/node0525.html B / frbuttonclass / Changed Methods: OM_NEW Libraries_Manual_guide/node0526.html B / frbuttonclass / Changed Methods: GM_HITTEST Libraries_Manual_guide/node0527.html B / frbuttonclass / Changed Methods: GM_RENDER Libraries_Manual_guide/node0528.html B / frbuttonclass / Attributes: GA_Width, GA_Height (S) Libraries_Manual_guide/node0529.html B / frbuttonclass / Attributes: GA_DrawInfo (I) Libraries_Manual_guide/node052A.html B / frbuttonclass / Attributes:GA_Text,GA_IntuiText,GA_LabelImage (IS) Libraries_Manual_guide/node052B.html B Boopsi Class Reference / groupgclass Libraries_Manual_guide/node052C.html B / groupgclass / Changed Methods: OM_SET Libraries_Manual_guide/node052D.html B / groupgclass / Changed Methods: OM_ADDMEMBER Libraries_Manual_guide/node052E.html B / groupgclass / Changed Methods: OM_REMMEMBER Libraries_Manual_guide/node052F.html B / groupgclass / Changed Methods: OM_DISPOSE Libraries_Manual_guide/node0530.html B / groupgclass / Changed Methods: GM_HITTEST Libraries_Manual_guide/node0531.html B / groupgclass / Changed Methods: GM_RENDER Libraries_Manual_guide/node0532.html B / groupgclass / Changed: GM_GOACTIVE/GM_GOINACTIVE/GM_HANDLEINPUT Libraries_Manual_guide/node0533.html B / groupgclass / Attributes: GA_Left, GA_Top (IS) Libraries_Manual_guide/node0534.html Amiga® RKM Libraries: C Sample Library Source Code Libraries_Manual_guide/node0535.html Amiga® RKM Libraries: D Troubleshooting Guide Libraries_Manual_guide/node0536.html D Troubleshooting Guide / Errors Libraries_Manual_guide/node0537.html D / Errors / Audio--Corrupted Samples Libraries_Manual_guide/node0538.html D / Errors / Character Input/Output Problems Libraries_Manual_guide/node0539.html D / Errors / CLI Error Message Problems Libraries_Manual_guide/node053A.html D / Errors / CLI Won't Close on RUN Libraries_Manual_guide/node053B.html D / Errors / Crashes and Memory Corruption Libraries_Manual_guide/node053C.html D / Errors / Crashes--After Exit Libraries_Manual_guide/node053D.html D / Errors / Crashes--Only on 68000 and 68010 Libraries_Manual_guide/node053E.html D / Errors / Crashes--Only on 68040 Libraries_Manual_guide/node053F.html D / Errors / Crashes--Subtasks, Interrupts Libraries_Manual_guide/node0540.html D / Errors / Crashes--Window Related Libraries_Manual_guide/node0541.html D / Errors / Crashes--Workbench Only Libraries_Manual_guide/node0542.html D / Errors / Device-related Problems Libraries_Manual_guide/node0543.html D / Errors / Disk Icon Won't Go Away Libraries_Manual_guide/node0544.html D / Errors / DOS-related Problems Libraries_Manual_guide/node0545.html D / Errors / Fails only on 68020/30 Libraries_Manual_guide/node0546.html D / Errors / Fails only on 68000 Libraries_Manual_guide/node0547.html D / Errors / Fails only on Older ROMs or Older WB Libraries_Manual_guide/node0548.html D / Errors / Fails only on Newer ROMs or Newer WB Libraries_Manual_guide/node0549.html D / Errors / Fails only on Chip-RAM-Only Machines Libraries_Manual_guide/node054A.html D / Errors / Fails only on machines with Fast RAM Libraries_Manual_guide/node054B.html D / Errors / Fails only with Enhanced Chips Libraries_Manual_guide/node054C.html D / Errors / Fireworks Libraries_Manual_guide/node054D.html D / Errors / Graphics--Corrupted Images Libraries_Manual_guide/node054E.html D / Errors / Hang--One Program Only Libraries_Manual_guide/node054F.html D / Errors / Hang--Whole System Libraries_Manual_guide/node0550.html D / Errors / Memory Loss Libraries_Manual_guide/node0551.html D / Errors / Memory Loss--CLI Only Libraries_Manual_guide/node0552.html D / Errors / Memory Loss--Ctrl-C Exit Only Libraries_Manual_guide/node0553.html D / Errors / Memory Loss--During Execution Libraries_Manual_guide/node0554.html D / Errors / Memory Loss--Workbench Only Libraries_Manual_guide/node0555.html D / Errors / Menu Problems Libraries_Manual_guide/node0556.html D / Errors / Out-of-Sync Response to Input Libraries_Manual_guide/node0557.html D / Errors / Performance Loss in Other Processes Libraries_Manual_guide/node0558.html D / Errors / Performance Loss--On A3000 Libraries_Manual_guide/node0559.html D / Errors / Trackdisk Data not Transferred Libraries_Manual_guide/node055A.html D / Errors / Windows--Borders Flicker after Resize Libraries_Manual_guide/node055B.html D / Errors / Windows--Visual Problems Libraries_Manual_guide/node055C.html D Troubleshooting Guide / General Debugging Techniques Libraries_Manual_guide/node055D.html D Troubleshooting Guide / A Final Word About Testing Libraries_Manual_guide/node055E.html Amiga® RKM Libraries: E Release 2 Compatibility Libraries_Manual_guide/node055F.html E Release 2 Compatibility / General Compatibility Problem Areas Libraries_Manual_guide/node0560.html E Compatibility / Release 2 Changes That Can Affect Compatibility Libraries_Manual_guide/node0561.html E / Release 2 Changes That Can Affect Compatibility / Exec Libraries_Manual_guide/node0562.html E / Release 2 Changes That Can Affect Compatibility / Expansion Libraries_Manual_guide/node0563.html E / Release 2 Changes That Can Affect Compatibility / Strap Libraries_Manual_guide/node0564.html E / Release 2 Changes That Can Affect Compatibility / DOS Libraries_Manual_guide/node0565.html E / Release 2 Changes That Can Affect Compatibility / Audio Device Libraries_Manual_guide/node0566.html E / Release 2 Changes That Can Affect Compatibility / Gameport Device Libraries_Manual_guide/node0567.html E / Release 2 Changes That Can Affect Compatibility / Serial Device Libraries_Manual_guide/node0568.html E / Release 2 Changes That Can Affect Compatibility / Timer Device Libraries_Manual_guide/node0569.html E / Release 2 Changes That Can Affect Compatibility / Trackdisk Device Libraries_Manual_guide/node056A.html E / Release 2 Changes That Can Affect Compatibility / CIA Timers Libraries_Manual_guide/node056B.html E /Release 2 Changes That Affect Compatibility / Other Hardware Issues Libraries_Manual_guide/node056C.html E / Release 2 Changes That Can Affect Compatibility / Intuition Libraries_Manual_guide/node056D.html E / Release 2 Changes That Can Affect Compatibility / Preferences Libraries_Manual_guide/node056E.html E / Release 2 Changes That Can Affect Compatibility / Workbench Libraries_Manual_guide/node056F.html E / Release 2 Changes That Can Affect Compatibility / Layers Libraries_Manual_guide/node0570.html E / Release 2 Changes That Can Affect Compatibility / Graphics Libraries_Manual_guide/node0571.html E / Release 2 Changes That Can Affect Compatibility / Fonts Libraries_Manual_guide/node0572.html E / Release 2 Changes That Can Affect Compatibility / CLI/Shell Libraries_Manual_guide/node0573.html E Release 2 Compatibility / Additional Information Libraries_Manual_guide/node0574.html E / Additional Information / Task Switching Libraries_Manual_guide/node0575.html E / Additional Information / Intuition Gadgets and Window Borders Libraries_Manual_guide/node0576.html E / Additional Information / Workbench And Startup Libraries_Manual_guide/node0577.html Amiga® RKM Libraries: F Sample Startup Code Libraries_Manual_guide/node0578.html lib_examples/easy.c Libraries_Manual_guide/node0579.html lib_examples/easy.asm Libraries_Manual_guide/node057A.html lib_examples/uptime.c Libraries_Manual_guide/node057B.html Lib_examples/bob.c Libraries_Manual_guide/node057C.html Lib_examples/filehook.c Libraries_Manual_guide/node057D.html Lib_examples/filepat.c Libraries_Manual_guide/node057E.html Lib_examples/fontreq.c Libraries_Manual_guide/node057F.html Lib_examples/filereq.c Libraries_Manual_guide/node0580.html Lib_examples/RKMButClass.c Libraries_Manual_guide/node0581.html Lib_examples/RKMModel.c Libraries_Manual_guide/node0582.html Lib_examples/Talk2boopsi.c Libraries_Manual_guide/node0583.html Lib_examples/CloseWindowSafely.c Libraries_Manual_guide/node0584.html Lib_examples/PopShell.c Libraries_Manual_guide/node0585.html Lib_examples/divert.c Libraries_Manual_guide/node0586.html Lib_examples/broker.c Libraries_Manual_guide/node0587.html Lib_examples/HotKey.c Libraries_Manual_guide/node0588.html Lib_examples/a2d.c Libraries_Manual_guide/node0589.html Lib_examples/prefnotify.c Libraries_Manual_guide/node058A.html Lib_examples/eventloop.c Libraries_Manual_guide/node058B.html Lib_examples/buildlist.c Libraries_Manual_guide/node058C.html Lib_examples/sample.library.asm Libraries_Manual_guide/node058D.html Lib_examples/semaphore.c Libraries_Manual_guide/node058E.html Lib_examples/signals.c Libraries_Manual_guide/node058F.html Lib_examples/simpletask.c Libraries_Manual_guide/node0590.html Lib_examples/tasklist.c Libraries_Manual_guide/node0591.html Lib_examples/trap_c.c Libraries_Manual_guide/node0592.html Lib_examples/DeviceUse.c Libraries_Manual_guide/node0593.html Lib_examples/findboards.c Libraries_Manual_guide/node0594.html Lib_examples/Diag.asm Libraries_Manual_guide/node0595.html Lib_examples/simplegad.c Libraries_Manual_guide/node0596.html Lib_examples/strhooks.c Libraries_Manual_guide/node0597.html Lib_examples/updatestrgad.c Libraries_Manual_guide/node0598.html Lib_examples/gadtoolsgadgets.c Libraries_Manual_guide/node0599.html Lib_examples/simplegtgadget.c Libraries_Manual_guide/node059A.html Lib_examples/gadtoolsmenu.c Libraries_Manual_guide/node059B.html Lib_examples/WBClone.c Libraries_Manual_guide/node059C.html Lib_examples/animtools.c Libraries_Manual_guide/node059D.html Lib_examples/RGBBoxes.c Libraries_Manual_guide/node059E.html Lib_examples/UserCopperExample.c Libraries_Manual_guide/node059F.html Lib_examples/ClipFTXT.c Libraries_Manual_guide/node05A0.html Lib_examples/Sift.c Libraries_Manual_guide/node05A1.html Lib_examples/blockinput.c Libraries_Manual_guide/node05A2.html Lib_examples/compleximage.c Libraries_Manual_guide/node05A3.html Lib_examples/custompointer.c Libraries_Manual_guide/node05A4.html Lib_examples/displayalert.c Libraries_Manual_guide/node05A5.html Lib_examples/easyintuition.c Libraries_Manual_guide/node05A6.html Lib_examples/easyintuition37.c Libraries_Manual_guide/node05A7.html Lib_examples/easyrequest.c Libraries_Manual_guide/node05A8.html Lib_examples/intuitext.c Libraries_Manual_guide/node05A9.html Lib_examples/mousetest.c Libraries_Manual_guide/node05AA.html Lib_examples/remembertest.c Libraries_Manual_guide/node05AB.html Lib_examples/shadowborder.c Libraries_Manual_guide/node05AC.html Lib_examples/simpleimage.c Libraries_Manual_guide/node05AD.html Lib_examples/maprawkey.c Libraries_Manual_guide/node05AE.html Lib_examples/mapansi.c Libraries_Manual_guide/node05AF.html Lib_examples/menulayout.c Libraries_Manual_guide/node05B0.html Lib_examples/simplemenu.c Libraries_Manual_guide/node05B1.html Lib_examples/showprefs.c Libraries_Manual_guide/node05B2.html Lib_examples/clonescreen.c Libraries_Manual_guide/node05B3.html Lib_examples/doublebuffer.c Libraries_Manual_guide/node05B4.html Lib_examples/dualplayfield.c Libraries_Manual_guide/node05B5.html Lib_examples/pubscreenbeep.c Libraries_Manual_guide/node05B6.html Lib_examples/publicscreen.c Libraries_Manual_guide/node05B7.html Lib_examples/AvailFonts.c Libraries_Manual_guide/node05B8.html Lib_examples/MeasureText.c Libraries_Manual_guide/node05B9.html Lib_examples/cliptext.c Libraries_Manual_guide/node05BA.html Lib_examples/suits8.asm Libraries_Manual_guide/node05BB.html Lib_examples/pseudotext.c Libraries_Manual_guide/node05BC.html Lib_examples/openwindowtags.c Libraries_Manual_guide/node05BD.html Lib_examples/lines.c Libraries_Manual_guide/node05BE.html Lib_examples/winpubscreen.c Libraries_Manual_guide/node05BF.html Lib_examples/visiblewindow.c Libraries_Manual_guide/node05C0.html Lib_examples/appicon.c Libraries_Manual_guide/node05C1.html Lib_examples/appmenuitem.c Libraries_Manual_guide/node05C2.html Lib_examples/appwindow.c Libraries_Manual_guide/node05C3.html Lib_examples/iconexample.c Libraries_Manual_guide/node05C4.html Lib_examples/prargs.c Libraries_Manual_guide/node05C5.html Lib_examples/hooks1.c Libraries_Manual_guide/node05C6.html Lib_examples/clipping.c Libraries_Manual_guide/node05C7.html Lib_examples/istr.c Libraries_Manual_guide/node05C8.html Lib_examples/Layers.c Libraries_Manual_guide/node05C9.html Lib_examples/tag1.c Libraries_Manual_guide/node05CA.html Lib_pics/2-1.pic Libraries_Manual_guide/node05CB.html Lib_pics/2-2.pic Libraries_Manual_guide/node05CC.html Lib_pics/2-3.pic Libraries_Manual_guide/node05CD.html Lib_pics/2-4.pic Libraries_Manual_guide/node05CE.html Lib_pics/2-5.pic Libraries_Manual_guide/node05CF.html lib_pics/3-1.pic Libraries_Manual_guide/node05D0.html lib_examples/newlookscreen.c Libraries_Manual_guide/node05D1.html lib_examples/screen34to37.c Libraries_Manual_guide/node05D2.html devices/modules/screen.c Libraries_Manual_guide/node05D3.html lib_pics/4-1.pic Libraries_Manual_guide/node05D4.html lib_pics/5-1.pic Libraries_Manual_guide/node05D5.html lib_pics/6-1.pic Libraries_Manual_guide/node05D6.html lib_pics/6-2.pic Libraries_Manual_guide/node05D7.html lib_pics/6-3.pic Libraries_Manual_guide/node05D8.html lib_pics/6-4.pic Libraries_Manual_guide/node05D9.html lib_pics/7-1.pic Libraries_Manual_guide/node05DA.html lib_pics/7-2.pic Libraries_Manual_guide/node05DB.html lib_pics/9-1.pic Libraries_Manual_guide/node05DC.html lib_pics/9-2.pic Libraries_Manual_guide/node05DD.html lib_pics/12-2.pic Libraries_Manual_guide/node05DE.html lib_pics/12-4.pic Libraries_Manual_guide/node05DF.html lib_pics/12-5.pic Libraries_Manual_guide/node05E0.html Includes/prefs/printergfx.h Libraries_Manual_guide/node05E1.html Lib_pics/14-1.pic Libraries_Manual_guide/node05E2.html lib_pics/15-1.pic Libraries_Manual_guide/node05E3.html lib_pics/16-1.pic Libraries_Manual_guide/node05E4.html lib_pics/16-2.pic Libraries_Manual_guide/node05E5.html lib_examples/allocentry.c Libraries_Manual_guide/node05E6.html lib_examples/allocate.c Libraries_Manual_guide/node05E7.html lib_examples/port2.c Libraries_Manual_guide/node05E8.html lib_examples/port1.c Libraries_Manual_guide/node05E9.html lib_examples/rbf.c Libraries_Manual_guide/node05EA.html lib_examples/rbfhandler.asm Libraries_Manual_guide/node05EB.html lib_examples/vertb.c Libraries_Manual_guide/node05EC.html lib_examples/vertbserver.asm Libraries_Manual_guide/node05ED.html lib_examples/timersoftint.c Libraries_Manual_guide/node05EE.html lib_pics/27-1.pic Libraries_Manual_guide/node05EF.html lib_pics/27-12.pic Libraries_Manual_guide/node05F0.html lib_pics/27-13.pic Libraries_Manual_guide/node05F1.html lib_pics/27-16.pic Libraries_Manual_guide/node05F2.html lib_examples/vsprite.c Libraries_Manual_guide/node05F3.html lib_examples/ssprite.c Libraries_Manual_guide/node05F4.html lib_pics/28-4.pic Libraries_Manual_guide/node05F5.html lib_pics/28-5.pic Libraries_Manual_guide/node05F6.html lib_pics/28-7.pic Libraries_Manual_guide/node05F7.html lib_examples/animtools.h Libraries_Manual_guide/node05F8.html lib_pics/29-1.pic Libraries_Manual_guide/node05F9.html Includes/diskfont/diskfont.h Libraries_Manual_guide/node05FA.html lib_pics/31-1.pic Libraries_Manual_guide/node05FB.html lib_pics/31-2.pic Libraries_Manual_guide/node05FC.html lib_pics/31-3.pic Libraries_Manual_guide/node05FD.html lib_examples/mathtrans.c Libraries_Manual_guide/node05FE.html lib_examples/mathffp.c Libraries_Manual_guide/node05FF.html lib_examples/mathieeesingbas.c Libraries_Manual_guide/node0600.html lib_examples/mathieeesingtrans.c Libraries_Manual_guide/node0601.html lib_examples/mathieeedoubbas.c Libraries_Manual_guide/node0602.html lib_examples/mathieeedoubtrans.c Libraries_Manual_guide/node0603.html lib_examples/makefile Libraries_Manual_guide/node0604.html lib_examples/asmsupp.i Libraries_Manual_guide/node0605.html lib_examples/sample_rev.i Libraries_Manual_guide/node0606.html lib_examples/sample_protos.h Libraries_Manual_guide/node0607.html lib_examples/sample_pragmas.h Libraries_Manual_guide/node0608.html lib_examples/samplebase.i Libraries_Manual_guide/node0609.html lib_examples/samplebase.h Libraries_Manual_guide/node060A.html lib_examples/sample_lvos.asm Libraries_Manual_guide/node060B.html lib_examples/sample_stubs.asm Libraries_Manual_guide/node060C.html lib_examples/clibtest.c Libraries_Manual_guide/node060D.html lib_examples/alibtest.asm Libraries_Manual_guide/node060E.html lib_startup/lmkfile Libraries_Manual_guide/node060F.html lib_startup/startup.asm Libraries_Manual_guide/node0610.html lib_startup/allstartup.i Libraries_Manual_guide/node0611.html lib_startup/Astartup.i Libraries_Manual_guide/node0612.html lib_startup/AWstartup.i Libraries_Manual_guide/node0613.html lib_startup/Qstartup.i Libraries_Manual_guide/node0614.html lib_startup/Rstartup.i Libraries_Manual_guide/node0615.html lib_startup/RWstartup.i Libraries_Manual_guide/node0616.html lib_startup/RXstartup.i
Devices_Manual_guide/node0025.html.txt:1:2 / Audio And System I/O Functions / AbortIO() ]" border=0> This function can be used to cancel requests for ADCMD_ALLOCATE , ADCMD_LOCK , CMD_WRITE , or ADCMD_WAITCYCLE . When used with the audio device, AbortIO() always succeeds. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node0299.html.txt:1:SAMP.doc / Converting Midi Sample Dump to SAMP ]" border=0> SEMANTICS: When MIDI literature talks about a sample, usually it means a collection of many sample points that make up what we call "a wave". Therefore, a Midi Sample Dump sends all the sample data that makes up ONE wave. A SAMP file is designed to hold up to 255 of these waves (midi dumps). The Midi Sample Dump specifies playback rate only in terms of a sample PERIOD in nanoseconds. SAMP also expresses playback in terms of samples per second (frequency). The Amiga needs to see its period rounded to the nearest microsecond. If you take the sample period field of a Midi sample Dump (the 8th, 9th, and 10th bytes of the Dump Header LSB first) which we will call MidiSamplePer, and the Rate of a SAMP file, here is the relationship: Rate = (1/MidiSamplePer) x 10E9 Also the number of samples (wave's length) in a Midi Sample Dump (the 11th, 12th, and 13th bytes of the Dump header) is expressed in WORDS. SAMP's WaveSize is expressed in the number of BYTES. (For the incredibly stupid), the relationship is: WaveSize = MidiSampleLength x 2 A Midi sample dump's LoopStart point and LoopEnd point are also in WORDS as versus the SAMP equivalents expressed in BYTES. A Midi sample dump's sample number can be 0 to 65535. A SAMP file can hold up to 255 waves, and their numbers in the playmap must be 1 to 255. (A single, Midi Sample Dump only sends info on one wave.) When recieving a Midi Sample Dump, just store the sample number (5th and 6th bytes of the Dump Header LSB first) in SAMP's MidiSampNum field. Then forget about this number until you need to send the wave back to the Midi instrument from whence it came. A Midi Dump's loop type can be forward, or forward/backward. Amiga hardware supports forward only. You should store the Midi Dump's LoopType byte here, but ignore it otherwise until/unless Amiga hardware supports "reading audio data" in various ways. If so, then the looptype is as follows: forward = 0, backward/forward = 1 A Midi Dump's sample format byte is the same as SAMP's. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node01C5.html.txt:1:A Quick Introduction to IFF / What is IFF? ]" border=0> IFF, the "Interchange File Format" standard, encourages multimedia interchange between different programs and different computers. It supports long-lived, extensible data. It's great for composite files like a page layout file that includes photos, an animation file that includes music, and a library of sound effects. IFF is a 2-level standard. The first layer is the "wrapper" or "envelope" structure for all IFF files. Technically, it's the syntax. The second layer defines particular IFF file types such as ILBM (standard raster pictures), ANIM (animation), SMUS (simple musical score), and 8SVX (8-bit sampled audio voice). IFF is also a design idea: programs should use interchange formats for their everyday storage. This way, users rarely need converters and import/export commands to change software releases, application programs, or hardware. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node0003.html.txt:1:Amiga® RKM Devices: 1 Introduction to Amiga System Devices ]" border=0> The Amiga system devices are software engines that provide access to the Amiga hardware. Through these devices, a programmer can operate a modem, spin a disk drive motor, time an event, speak to a user and blast a trumpet sound in beautiful, living stereo. Yet, for all that variety, the programmer uses each device in the same basic manner. Amiga System Devices Audio Controls the use of the audio hardware Clipboard Manages the cutting and pasting of common data blocks Console Provides the text-oriented user interface. Gameport Controls the two mouse/joystick ports. Input Processes input from the gameport and keyboard devices. Keyboard Controls the keyboard. Narrator Produces the Amiga synthesized speech. Parallel Controls the parallel port. Printer Converts a standard set of printer control codes to printer specific codes. SCSI Controls the Small Computer Standard Interface hardware. Serial Controls the serial port. Timer Provides timing functions to measure time intervals and send interrupts. Trackdisk Controls the Amiga floppy disk drives. What is a Device? I/O Request Completion Accessing a Device Ending Device Access Using a Device Devices With Functions Synchronous vs. Asynchronous Requests Example Device Programs [Back to Amiga Developer Docs ]
Devices_Manual_guide/node0029.html.txt:1:2 Audio Device / Allocation and Arbitration Commands ]" border=0> These commands allow the audio channels to be shared among different tasks and programs. None of these commands can be called from interrupt code. ADCMD_ALLOCATE ADCMD_FREE ADCMD_SETPREC ADCMD_LOCK [Back to Amiga Developer Docs ]
Devices_Manual_guide/node0116.html.txt:1:8 / Device Interface / The Amiga Speech System ]" border=0> The speech system on the Amiga is divided into two subsystems: * The translator library, consisting of a single function: Translate() , which converts an English string into its phonetic representation, and * The narrator device, which uses the phonetic representation (generated either manually or by the translator library) as input to generate human-like speech and play it out via the audio device. The two subsystems can be used either together or individually. Generally, hand coding phonetic text will produce better quality speech than using the translator library, but this requires the programmer to "hard code" the phonetic text in the program or otherwise restrict the input to phonetic text only. If the program must handle arbitrary English input, the translator library should be used. Below is an example of how you would use the translator library to translate a string for the narrator device. #define BUFLEN 500 APTR EnglStr; /* pointer to sample input string */ LONG EnglLen; /* input length */ UBYTE PhonBuffer[BUFLEN]; /* place to put the translation */ LONG rtnCode; /* return code from function */ struct narrator_rb *VoiceIO; /* speaking I/O request block */ struct mouth_rb *MouthIO; /* mouth movement I/O request block */ EnglStr = "This is Amiga speaking."; /* a test string */ EnglLen = strlen(EnglStr); rtnCode = Translate(EnglStr, EnglLen, (APTR)&PhonBuffer[0], BUFLEN); voice_io->message.io_Command = CMD_WRITE; voice_io->message.io_Offset = 0; voice_io->message.io_Data = PhonBuffer; voice_io->message.io_Length = strlen(PhonBuffer); DoIO((struct IORequest *)VoiceIO) This chapter discusses only the narrator device; refer to the "Translator Library" chapter of the Amiga ROM Kernel Reference Manual: Libraries for more information on the translator library. While the narrator device on the Amiga supports all of the major device commands (see the Narrator Device Commands and Functions section), two of these commands do most of the work in the device. They are: * CMD_WRITE - This command is used to send a phonetic string to the device to be spoken. The narrator_rb I/O request block also contains several parameters which can be set to control various aspects of the speech, such as pitch, speaking rate, male/female voice, and so on. Some of the options are rather arcane. See the Writing to the Narrator Device section for a complete list of options and their descriptions. * CMD_READ - The narrator device can be told to generate various synchronization events which the user can query. These events are: mouth shape changes, word sync, and/or syllable sync. The events can be generated singly or in any combination, as requested by the user. Word and syllable synchronization events are new to system 2.0 and later (V37 and later of the narrator device). See the Reading from the Narrator Device section for more details. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node029A.html.txt:1:SAMP.doc / Interpreting the Playmode ]" border=0> PlayMode specifies how the bytes in the PlayMap are to be interpreted. Remember that a PlayMap byte of 0 means "No Wave to Play". #define INDEPENDANT 0 #define MULTI 1 #define STEREO 2 #define PAN 3 PlayMode types: INDEPENDANT(0)-The wave #s for a midi note are to be output on Amiga audio channels 0, 1, 2, and 3 respectively. If the NumOfChans is 1, the second PlayMap byte should be a defined wave number as well (even if it is deliberately set to the same value as the first byte). This insures that all 4 PlayModes will have some effect on a given SAMP file. Also, an application should allow the user to change the PlayMode at will. The PlayMode stored in the SAMP file is only a default or initial set-up condition. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node0298.html.txt:1:SAMP.doc / Additional User Data Section ]" border=0> There is a provision for storing user data for each wave. This is where an application can store Amiga hardware info, or other, application specific info. The waveHeader's USERtype tells what kind of data is stored. The current types are: #define SPECIFIC 0 #define VOLMOD 1 #define PERMOD 2 #define LOOPING 3 SPECIFIC (0) - application specific data. It should be stored in a format that some application can immediately recognize. (i.e. a "format within" the SAMP format) If the USERtype is SPECIFIC, and an application doesn't find some sort of header that it can re- cognize, it should conclude that this data was put there by "someone else", and ignore the data. VOLMOD (1) - This data is for volume modulation of an Amiga channel as described by the ADKCON register. This data will be sent to the modulator channel of the channel set to play the wave. PERMOD (2) - This data is for period modulation of an Amiga channel as described by the ADKCON register. This data will be sent to the modulator channel of the channel set to play the wave. LOOPING (3) - This contains more looping points for the sample. There are some samplers that allow more than just one loop (Casio products primarily). Additional looping info can be stored in this format: UWORD numOfLoops; /* number of loop points to follow */ ULONG StartLoop1, /* BYTE offset from the beginning of the sample to the start of loop1 */ EndLoop1, /* BYTE offset from the beginning of the sample to the end of loop1 */ StartLoop2, /* ...etc */ [Back to Amiga Developer Docs ]
Devices_Manual_guide/node0218.html.txt:1:AIFF.doc / AIFF / File Structure ]" border=0> The "EA IFF 85 Standard for Interchange Format Files" defines an overall structure for storing data in files. Audio IFF conforms to those portions of "EA IFF 85" that are germane to Audio IFF. For a more complete discussion of "EA IFF 85", please refer to the document "EAIFF 85, Standard for Interchange Format Files." An "EA IFF 85" file is made up of a number of chunks of data. Chunks are the building blocks of "EA IFF 85" files. A chunk consists of some header information followed by data: +--------------------+ | ckID |\ +--------------------+ } header info | ckSize |/ +--------------------+ | | | | | data | | | | | +--------------------+ Figure 2: IFF Chunk structure A chunk can be represented using our C-like language in the following manner: typedef struct { ID ckID; /* chunk ID */ long ckSize; /* chunk Size */ char ckData[]; /* data */ } Chunk; The ckID describes the format of the data portion of a chunk. A program can determine how to interpret the chunk data by examining ckID. The ckSize is the size of the data portion of the chunk, in bytes. It does not include the 8 bytes used by ckID and ckSize. The ckData contains the data stored in the chunk. The format of this data is determined by ckID. If the data is an odd number of bytes in length, a zero pad byte must be added at the end. The pad byte is not included in ckSize. Note that an array with no size specification (e.g., char ckData[];) indicates a variable-sized array in our C-like language. This differs from standard C. An Audio IFF file is a collection of a number of different types of chunks. There is a Common Chunk which contains important parameters describing the sampled sound, such as its length and sample rate. There is a Sound Data Chunk which contains the actual audio samples. There are several other optional chunks which define markers, list instrument parameters, store application-specific information, etc. All of these chunks are described in detail in later sections of this document. The chunks in an Audio IFF file are grouped together in a container chunk. "EA IFF 85" Standard for Interchange Format Files defines a number of container chunks, but the one used by Audio IFF is called a FORM. A FORM has the following format: typedef struct { ID ckID; long ckSize; ID formType; char chunks[]; } The ckID is always 'FORM'. This indicates that this is a FORM chunk. The ckSize contains the size of data portion of the 'FORM' chunk. Note that the data portion has been broken into two parts, formType and chunks[]. The formType field describes what's in the 'FORM' chunk. For Audio IFF files, formType is always 'AIFF'. This indicates that the chunks within the FORM pertain to sampled sound. A FORM chunk of formType 'AIFF' is called a FORM AIFF. The chunks field are the chunks contained within the FORM. These chunks are called local chunks. A FORM AIFF along with its local chunks make up an Audio IFF file. Here is an example of a simple Audio IFF file. It consists of a file containing single FORM AIFF which contains two local chunks, a Common Chunk and a Sound Data Chunk. __________________________ | FORM AIFF Chunk | | ckID = 'FORM' | | formType = 'AIFF' | | __________________ | | | Common Chunk | | | | ckID = 'COMM' | | | |__________________| | | __________________ | | | Sound Data Chunk | | | | ckID = 'SSND' | | | |__________________| | |__________________________| Figure 3: Simple Audio IFF File There are no restrictions on the ordering of local chunks within a FORM AIFF. A more detailed example of an Audio IFF file can be found in Appendix A. Please refer to this example as often as necessary while reading the remainder of this document. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node0021.html.txt:1:2 / Device Interface / Scope Of Audio Commands ]" border=0> Most audio commands can operate on multiple channels. The exceptions are ADCMD_WAITCYCLE , CMD_WRITE and CMD_READ , which can only operate on one channel at a time. You specify the channel(s) that you want to use by setting the appropriate bits in the ioa_Request.io_Unit field of the IOAudio block. If you send a command for a channel that you do not own, your command will be ignored. For more details, see the section on " Allocation and Arbitration " below. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node02F3.html.txt:1:Devices/apps/Play8SVX/Play8SVX.c ]" border=0> /** Play8SVX.c ************************************************************** * * Read and play sound sample from an IFF file. 21Jan85 * * By Steve Hayes, Electronic Arts. * This software is in the public domain. * * Modified 05/91 for use with iffparse & to play notes - CAS_CBM * requires linkage with several IFF modules - see Makefile ****************************************************************************/ #include "iffp/8svxapp.h" #include #include #include #ifdef LATTICE int CXBRK(void) { return(0); } /* Disable Lattice CTRL/C handling */ int chkabort(void) { return(0); } /* really */ #endif /* prototypes for our functions */ void cleanup(void); void bye(UBYTE *s,int error); void DUnpack(BYTE source[], LONG n, BYTE dest[]); BYTE D1Unpack(BYTE source[], LONG n, BYTE dest[], BYTE x); LONG LoadSample(struct EightSVXInfo *esvx, UBYTE *filename); void UnloadSample(struct EightSVXInfo *esvx); LONG LoadSBody(struct EightSVXInfo *esvx); void UnloadSBody(struct EightSVXInfo *esvx); LONG ShowSample(struct EightSVXInfo *esvx); LONG OpenAudio(void); void CloseAudio(void); LONG PlaySample(struct EightSVXInfo *esvx, LONG octave, LONG note, UWORD volume, ULONG delay); struct IOAudio *playbigsample(struct IOAudio *aio0, struct IOAudio *aio1, BYTE *samptr, LONG ssize, ULONG period, UWORD volume); #define MINARGS 2 char *vers = "\0$VER: Play8SVX 37.5"; char *Copyright = "Play8SVX v37.5 (Freely Redistributable)"; char *usage = "Usage: Play8SVX 8SVXname"; /* globals */ struct Library *IFFParseBase = NULL; struct Library *GfxBase = NULL; BOOL FromWb; /* 8SVX Property chunks to be grabbed */ LONG esvxprops[] = { ID_8SVX, ID_VHDR, ID_8SVX, ID_NAME, ID_8SVX, ID_ATAK, ID_8SVX, ID_RLSE, ID_8SVX, ID_AUTH, ID_8SVX, ID_Copyright, TAG_DONE }; /* 8SVX Collection chunks (more than one in file) to be gathered */ LONG esvxcollects[] = { ID_8SVX, ID_ANNO, TAG_DONE }; /* 8SVX Chunk to stop on */ LONG esvxstops[] = { ID_8SVX, ID_BODY, TAG_DONE }; UBYTE nomem[] = "Not enough memory\n"; UBYTE noiffh[] = "Can't alloc iff\n"; /* For our allocated EightSVXInfo */ struct EightSVXInfo *esvx = NULL; /* * MAIN */ void main(int argc, char **argv) { UBYTE *esvxname=NULL; ULONG oct; LONG error=0L; FromWb = argc ? FALSE : TRUE; if((argc ParseInfo.propchks = esvxprops; esvx->ParseInfo.collectchks = esvxcollects; esvx->ParseInfo.stopchks = esvxstops; /* * Alloc the IFF handle for the frame */ if(!(esvx->ParseInfo.iff = AllocIFF())) bye(noiffh,RETURN_FAIL); if(!(error = LoadSample(esvx, esvxname))) { ShowSample(esvx); if(!(error = OpenAudio())) { /* If we think this is a sound effect, play it as such (note=-1) */ if((esvx->Vhdr.ctOctave==1)&&(esvx->Vhdr.samplesPerSec) &&(esvx->Vhdr.oneShotHiSamples)&&(!esvx->Vhdr.repeatHiSamples)) { PlaySample(esvx,0,-1,64,0); } /* Else play it like an instrument */ else { for(oct=0; oct Vhdr.ctOctave; oct++) { PlaySample(esvx,oct,0,64,50); PlaySample(esvx,oct,4,64,50); PlaySample(esvx,oct,7,64,50); } } CloseAudio(); } else printf("error opening audio device\n"); } else printf("%s\n",IFFerr(error)); cleanup(); exit(RETURN_OK); } void bye(UBYTE *s,int error) { if((*s)&&(!FromWb)) printf("%s\n",s); cleanup(); exit(error); } void cleanup() { if(esvx) { DD(bug("About to UnloadSample\n")); UnloadSample(esvx); DD(bug("About to FreeIFF\n")); if(esvx->ParseInfo.iff) FreeIFF(esvx->ParseInfo.iff); DD(bug("About to free EightSVXInfo\n")); FreeMem(esvx,sizeof(struct EightSVXInfo)); } if(IFFParseBase) CloseLibrary(IFFParseBase); } /** ShowSample() ********************************************** * * Show sample information after calling LoadSample() * *************************************************************************/ LONG ShowSample(struct EightSVXInfo *esvx) { LONG error = 0L; BYTE *buf; Voice8Header *vhdr; if(!esvx) return(CLIENT_ERROR); if(!(buf = esvx->sample)) return(CLIENT_ERROR); /* LoadSample copied VHDR and NAME (if any) to our esvx frame */ vhdr = &esvx->Vhdr; if(esvx->name[0]) printf("\nNAME: %s",esvx->name); printf("\n\nVHDR Info:"); printf("\noneShotHiSamples=%ld", vhdr->oneShotHiSamples); printf("\nrepeatHiSamples=%ld", vhdr->repeatHiSamples); printf("\nsamplesPerHiCycle=%ld", vhdr->samplesPerHiCycle); printf("\nsamplesPerSec=%ld", vhdr->samplesPerSec); printf("\nctOctave=%ld", vhdr->ctOctave); printf("\nsCompression=%ld", vhdr->sCompression); printf("\nvolume=0x%lx", vhdr->volume); printf("\nData = %3ld %3ld %3ld %3ld %3ld %3ld %3ld %3ld", buf[0],buf[1],buf[2],buf[3],buf[4],buf[5],buf[6],buf[7]); printf("\n %3ld %3ld %3ld %3ld %3ld %3ld %3ld %3ld ...\n", buf[8+0],buf[8+1],buf[8+2],buf[8+3],buf[8+4],buf[8+5], buf[8+6],buf[8+ 7]); return(error); } /* OpenAudio * * Opens audio device for one audio channel, 2 IO requests * Returns 0 for success * * Based on code by Dan Baker */ UBYTE whichannel[] = { 1,2,4,8 }; /* periods for scale starting at 65.40Hz (C) with 128 samples per cycle * or 130.81Hz (C) with 64 samples per cycle * or 261.63Hz (C) with 32 samples per cycle * or 523.25Hz (C) with 16 samples per cycle * or 1046.50Hz (C) with 8 samples per cycle * or 2093.00Hz (C) with 4 samples per cycle */ UWORD per_ntsc[12]= { 428, 404, 380, 360, 340, 320, 302, 286, 270, 254, 240, 226 }; /* periods adjusted for system clock frequency */ UWORD per[12]; /* Note - these values 3579545 NTSC, 3546895 PAL */ #define NTSC_CLOCK 3579545L #define PAL_CLOCK 3546895L #define AIOCNT 4 struct IOAudio *aio[AIOCNT] = {NULL}; /* Ptrs to IO blocks for commands */ struct MsgPort *port; /* Pointer to a port so the device can reply */ BOOL devopened; ULONG clock = NTSC_CLOCK; /* Will check for PAL and change if necessary */ LONG OpenAudio() { extern struct ExecBase *SysBase; LONG error=0L; ULONG period; int k; if(devopened) return(-1); /*-------------------------------------------------------------------------*/ /* Ask the system if we are PAL or NTSC and set clock constant accordingly */ /*-------------------------------------------------------------------------*/ if(GfxBase=OpenLibrary("graphics.library",0L)) { if(((struct GfxBase *)GfxBase)->DisplayFlags & PAL) clock = PAL_CLOCK; else clock = NTSC_CLOCK; CloseLibrary((struct Library *) GfxBase); } printf("OpenAudio: For period calculations, clock=%ld\n", clock); /* calculate period values for one octave based on system clock */ for(k=0; k > 1)) / NTSC_CLOCK; per[k] = period; D(bug("per[%ld]=%ld ",k,per[k])); } D(bug("\n")); /*-------------------------------------------------------------------*/ /* Create a reply port so the audio device can reply to our commands */ /*-------------------------------------------------------------------*/ if(!(port=CreatePort(0,0))) { error = 1; goto bailout; } /*--------------------------------------------------------------------------*/ /* Create audio I/O blocks so we can send commands to the audio device */ /*--------------------------------------------------------------------------*/ for(k=0; k ioa_Request.io_Command = ADCMD_ALLOCATE; aio[0]->ioa_Request.io_Flags = ADIOF_NOWAIT; aio[0]->ioa_AllocKey = 0; aio[0]->ioa_Data = whichannel; aio[0]->ioa_Length = sizeof(whichannel); /*-----------------------------------------------*/ /* Open the audio device and allocate a channel */ /*-----------------------------------------------*/ if(!(OpenDevice("audio.device",0L, (struct IORequest *) aio[0] ,0L))) devopened = TRUE; else { error = 5; goto bailout; } /* Clone the flags, channel allocation, etc. into other IOAudio requests */ for(k=1; k 11) note=0; if( note == -1 ) period = clock / esvx->Vhdr.samplesPerSec; else period = per[note]; /* table set up by OpenAudio */ if(octave > esvx->Vhdr.ctOctave) octave = 0; if(volume > 64) volume = 64; oneshot = esvx->osamps[octave]; osize = esvx->osizes[octave]; repeat = esvx->rsamps[octave]; rsize = esvx->rsizes[octave]; D(bug("oneshot $%lx size %ld, repeat $%lx size %ld\n", oneshot, osize, repeat, rsize)); /*------------------------------------------------------------*/ /* Set up audio I/O blocks to play a sample using CMD_WRITE. */ /* Set up one request for the oneshot and one for repeat */ /* (all ready for simple case, but we may not need both) */ /* The io_Flags are set to ADIOF_PERVOL so we can set the */ /* period (speed) and volume with the our sample; */ /* ioa_Data points to the sample; ioa_Length gives the length */ /* ioa_Cycles tells how many times to repeat the sample */ /* If you want to play the sample at a given sampling rate, */ /* set ioa_Period = clock/(given sampling rate) */ /*------------------------------------------------------------*/ aio[0]->ioa_Request.io_Command =CMD_WRITE; aio[0]->ioa_Request.io_Flags =ADIOF_PERVOL; aio[0]->ioa_Data =oneshot; aio[0]->ioa_Length =osize; aio[0]->ioa_Period =period; aio[0]->ioa_Volume =volume; aio[0]->ioa_Cycles =1; aio[2]->ioa_Request.io_Command =CMD_WRITE; aio[2]->ioa_Request.io_Flags =ADIOF_PERVOL; aio[2]->ioa_Data =repeat; aio[2]->ioa_Length =rsize; aio[2]->ioa_Period =period; aio[2]->ioa_Volume =volume; aio[2]->ioa_Cycles =0; /* repeat until stopped */ /*---------------------------------------------------*/ /* Send the command to start a sound using BeginIO() */ /* Go to sleep and wait for the sound to finish with */ /* WaitIO() to wait and get the get the ReplyMsg */ /*---------------------------------------------------*/ printf("Starting tone O len %ld for %0ld cyc, R len %ld for %0ld cyc, per=%ld...", osize, aio[0]->ioa_Cycles, rsize, aio[1]->ioa_Cycles, period); if(osize) { /* Simple case for oneshot sample 128K */ else { *aio[1] = *aio[0]; aout0 = playbigsample(aio[0],aio[1],oneshot,osize,period,volume); } } if(rsize) { /* Simple case for oneshot sample 128K */ else { *aio[3] = *aio[2]; aout1 = playbigsample(aio[2],aio[3],repeat,rsize,period,volume); } } if(delay) Delay(delay); /* crude timing for notes */ /* Wait for any requests we still have out */ if(aout0) WaitIO(aout0); if(aout1) { if(note >= 0) AbortIO(aout1); /* if a note, stop it now */ WaitIO(aout1); } printf("Done\n"); } /** playbigsample() ******************************************************** * * called by playsample to deal with samples > 128K * * wants pointers to two ready-to-use IOAudio iorequest blocks * * returns pointer to the IOAudio request that is still out * or NULL if none (error) *************************************************************************/ struct IOAudio *playbigsample(struct IOAudio *aio0, struct IOAudio* aio1, BYTE *samptr, LONG ssize, ULONG period, UWORD volume) { struct IOAudio *aio[2]; LONG size; int req=0, reqn=1; /* current and next IOAudio request indexes */ if((!aio0)||(!aio1)||(ssize ioa_Request.io_Command =CMD_WRITE; aio[req]->ioa_Request.io_Flags =ADIOF_PERVOL; aio[req]->ioa_Data =samptr; aio[req]->ioa_Length =MAXSAMPLE; aio[req]->ioa_Period =period; aio[req]->ioa_Volume =volume; aio[req]->ioa_Cycles =1; BeginIO((struct IORequest*)aio[req]); for(samptr=samptr + MAXSAMPLE, size = ssize - MAXSAMPLE; size > 0; samptr += MAXSAMPLE) { /* queue the next piece of sample */ reqn = req ^ 1; /* alternate IO blocks 0 and 1 */ aio[reqn]->ioa_Request.io_Command =CMD_WRITE; aio[reqn]->ioa_Request.io_Flags =ADIOF_PERVOL; aio[reqn]->ioa_Data =samptr; aio[reqn]->ioa_Length = (size > MAXSAMPLE) ? MAXSAMPLE : size; aio[reqn]->ioa_Period =period; aio[reqn]->ioa_Volume =volume; aio[reqn]->ioa_Cycles =1; BeginIO((struct IORequest*)aio[reqn]); /* Wait for previous request to finish */ WaitIO(aio[req]); /* decrement size */ size = (size > MAXSAMPLE) ? size-MAXSAMPLE : 0; req = reqn; /* switch between aio[0] and aio[1] */ } return(aio[reqn]); } /** LoadSample() ********************************************************** * * Read 8SVX, given an initialized EightSVXInfo with not-in-use IFFHandle, * and filename. Leaves the IFFHandle open so you can FindProp() * additional chunks or copychunks(). You must UnloadSample() * when done. UnloadSample will closeifile if the file is still * open. * * Fills in esvx->Vhdr and Name, and allocates/loads esvx->sample, * setting esvx->samplebytes to size for deallocation. * * Returns 0 for success of an IFFERR (libraries/iffparse.h) *************************************************************************/ LONG LoadSample(struct EightSVXInfo *esvx, UBYTE *filename) { struct IFFHandle *iff; struct StoredProperty *sp; Voice8Header *vhdr; BYTE *oneshot, *repeat; ULONG osize, rsize, spcyc; int oct; LONG error = 0L; D(bug("LoadSample:\n")); if(!esvx) return(CLIENT_ERROR); if(!(iff=esvx->ParseInfo.iff)) return(CLIENT_ERROR); if(!(error = openifile((struct ParseInfo *)esvx, filename, IFFF_READ))) { printf("Reading '%s'...\n",filename); error = parseifile((struct ParseInfo *)esvx, ID_FORM, ID_8SVX, esvx->ParseInfo.propchks, esvx->ParseInfo.collectchks, esvx->ParseInfo.stopchks); D(bug("LoadSample: after parseifile - error = %ld\n",error)); if((!error)||(error == IFFERR_EOC)||(error == IFFERR_EOF)) { if(contextis(iff,ID_8SVX,ID_FORM)) { D(bug("LoadSample: context is 8SVX\n")); if(!(sp = FindProp(iff,ID_8SVX,ID_VHDR))) { message("No 8SVX.VHDR!"); error = IFFERR_SYNTAX; } else { D(bug("LoadSample: Have VHDR\n")); /* copy Voice8Header into frame */ vhdr = (Voice8Header *)(sp->sp_Data); *(&esvx->Vhdr) = *vhdr; /* copy name if any */ esvx->name[0]='\0'; if(sp = FindProp(iff,ID_8SVX,ID_NAME)) { strncpy(esvx->name,sp->sp_Data,sp->sp_Size); esvx->name[MIN(sp->sp_Size,79)] = '\0'; } error = LoadSBody(esvx); D(bug("LoadSample: After LoadSBody - error = %ld\n",error)); if(!error) { osize = esvx->Vhdr.oneShotHiSamples; rsize = esvx->Vhdr.repeatHiSamples; spcyc = esvx->Vhdr.samplesPerHiCycle; if(!spcyc) spcyc = esvx->Vhdr.repeatHiSamples; if(!spcyc) spcyc = 8; oneshot = esvx->sample; for(oct = esvx->Vhdr.ctOctave-1; oct >= 0; oct--, oneshot+=(osize+rsize), osize osizes[oct] = osize; if(osize) esvx->osamps[oct] = oneshot; else esvx->osamps[oct] = 0; esvx->rsizes[oct] = rsize; if(rsize) esvx->rsamps[oct] = repeat; else esvx->rsamps[oct] = 0; esvx->spcycs[oct] = spcyc; D(bug("oneshot $%lx size %ld, repeat $%lx size %ld\n", oneshot, osize, repeat, rsize)); } } } } else { message("Not an 8SVX\n"); error = NOFILE; } } } if(error) { closeifile((struct ParseInfo *)esvx); UnloadSample(esvx); } return(error); } /** UnloadSample() ******************************************************* * * Frees and closes everything opened/alloc'd by LoadSample() * *************************************************************************/ void UnloadSample(struct EightSVXInfo *esvx) { if(esvx) { UnloadSBody(esvx); closeifile((struct ParseInfo *)esvx); } } /** LoadSBody() *********************************************************** * * Read a 8SVX Sample BODY into RAM. * *************************************************************************/ LONG LoadSBody(struct EightSVXInfo *esvx) { struct IFFHandle *iff; LONG sbytes, rlen, error = 0L; ULONG memtype; Voice8Header *vhdr = &esvx->Vhdr; BYTE *t; D(bug("LoadSBody:\n")); if(!(iff=esvx->ParseInfo.iff)) return(CLIENT_ERROR); if(!esvx) return(CLIENT_ERROR); if(!(currentchunkis(iff,ID_8SVX,ID_BODY))) { message("LoadSBody: not at BODY!"); return(IFFERR_READ); } sbytes = ChunkMoreBytes(CurrentChunk(iff)); /* if we have to decompress, let's just load it into public mem */ memtype = vhdr->sCompression ? MEMF_PUBLIC : MEMF_CHIP; D(bug("LoadSBody: samplebytes=%ld, compression=%ld\n", sbytes,vhdr->sCompression)); if(!(esvx->sample = (BYTE *)AllocMem(sbytes, memtype))) { error = CLIENT_ERROR; } else { D(bug("LoadSBody: have load buffer\n")); esvx->samplebytes = sbytes; if(rlen=ReadChunkBytes(iff,esvx->sample,sbytes) != sbytes) error = IFFERR_READ; if(error) { D(bug("LoadSBody: ReadChunkBytes error = %ld, read %ld bytes\n", error)); UnloadSample(esvx); } else if (vhdr->sCompression) /* Decompress, if needed. */ { if(t = (BYTE *)AllocMem(sbytes sample, sbytes, t); FreeMem(esvx->sample, sbytes); esvx->sample = t; esvx->samplebytes = sbytes smaple * *************************************************************************/ void UnloadSBody(struct EightSVXInfo *esvx) { if(esvx) { if(esvx->sample) { DD(bug("About to free SBody\n")); FreeMem(esvx->sample,esvx->samplebytes); esvx->sample = NULL; } esvx->samplebytes = NULL; } } /* DUnpack.c --- Fibonacci Delta decompression by Steve Hayes */ /* Fibonacci delta encoding for sound data */ BYTE codeToDelta[16] = {-34,-21,-13,-8,-5,-3,-2,-1,0,1,2,3,5,8,13,21}; /* Unpack Fibonacci-delta encoded data from n byte source * buffer into 2*n byte dest buffer, given initial data * value x. It returns the lats data value x so you can * call it several times to incrementally decompress the data. */ BYTE D1Unpack(BYTE source[], LONG n, BYTE dest[], BYTE x) { BYTE d; LONG i, lim; lim = n > 1]; /* get a pair of nibbles */ if (i & 1) /* select low or high nibble */ d &= 0xf; /* mask to get the low nibble */ else d >>= 4; /* shift to get the high nibble */ x += codeToDelta[d]; /* add in the decoded delta */ dest[i] = x; /* store a 1 byte sample */ } return(x); } /* Unpack Fibonacci-delta encoded data from n byte * source buffer into 2*(n-2) byte dest buffer. * Source buffer has a pad byte, an 8-bit initial * value, followed by n-2 bytes comprising 2*(n-2) * 4-bit encoded samples. */ void DUnpack(source, n, dest) BYTE source[], dest[]; LONG n; { D1Unpack(source+2, n-2, dest, source[1]); } [Back to Amiga Developer Docs ]
Devices_Manual_guide/node0162.html.txt:1:Devices/Dev_examples/Audio_8SVX.c ]" border=0> /* * Audio_8SVX.c * * 8SVX example - double buffers >128K samples * * Compile with SAS C 5.10 lc -b1 -cfistq -v -y -L * * Run from CLI only */ #include #include #include #include #include #include #include #include #include #include #include #include #include #include #ifdef LATTICE int CXBRK(void) { return(0); } /* Disable SAS CTRL/C handling */ int chkabort(void) { return(0); } /* really */ #endif #define VHDR MakeID('V','H','D','R') #define BODY MakeID('B','O','D','Y') #define MY8S MakeID('8','S','V','X') void kill8svx(char *); void kill8(void); /*--------------------*/ /* These globals are needed */ /* G L O B A L S */ /* by the clean up routines */ /*--------------------*/ struct IOAudio *AIOptr1, /* Pointers to Audio IOBs */ *AIOptr2, *Aptr; struct Message *msg; /* Msg, port and device for */ struct MsgPort *port, /* driving audio */ *port1,*port2; ULONG device; UBYTE *sbase,*fbase; /* For sample memory allocation */ ULONG fsize,ssize; /* and freeing */ struct FileHandle *v8handle; UBYTE chan1[] = { 1 };/* Audio channel allocation arrays */ UBYTE chan2[] = { 2 }; UBYTE chan3[] = { 4 }; UBYTE chan4[] = { 8 }; UBYTE *chans[] = {chan1,chan2,chan3,chan4}; BYTE oldpri,c; /* Stuff for bumping priority */ struct Task *mt=0L; struct GfxBase *GfxBase = NULL; /*-----------*/ /* M A I N */ /*-----------*/ void main(int argc,char **argv) { /*-------------*/ /* L O C A L S */ /*-------------*/ char *fname; /* File name and data pointer*/ UBYTE *p8data; /* for file read. */ ULONG clock; /* Clock constant */ ULONG length[2]; /* Sample lengths */ BYTE iobuffer[8], /* Buffer for 8SVX header */ *psample[2]; /* Sample pointers */ Chunk *p8Chunk; /* Pointers for 8SVX parsing */ Voice8Header *pVoice8Header; ULONG y,rd8count,speed; /* Counters, sampling speed */ ULONG wakebit; /* A wakeup mask */ /*-------------*/ /* C O D E */ /*-------------*/ /*------------------------------*/ /* Check Arguments, Initialize */ /*------------------------------*/ fbase=0L; sbase=0L; AIOptr1=0L; AIOptr2=0L; port=0L; port1=0L; port2=0L; v8handle=0L; device=1L; if (argc DisplayFlags & PAL) clock=3546895L; /* PAL clock */ else clock=3579545L; /* NTSC clock */ if (GfxBase) CloseLibrary( (struct Library *) GfxBase); /*---------------*/ /* Open the File */ /*---------------*/ v8handle= (struct FileHandle *) Open(fname,MODE_OLDFILE); if (v8handle==0) { kill8svx("Can't open 8SVX file.\n"); exit(1L); } /*-------------------------------------------*/ /* Read the 1st 8 Bytes of the File for Size */ /*-------------------------------------------*/ rd8count=Read((BPTR)v8handle,iobuffer,8L); if (rd8count==-1) { kill8svx ("Read error.\n"); exit(1L); } if (rd8count ckID != FORM ) { kill8svx("Not an IFF FORM.\n"); exit(1L); } /*--------------------------------------------*/ /* Allocate Memory for File and Read it in. */ /*--------------------------------------------*/ fbase= (UBYTE *)AllocMem(fsize=p8Chunk->ckSize , MEMF_PUBLIC|MEMF_CLEAR); if (fbase==0) { kill8svx("No memory for read.\n"); exit(1L); } p8data=fbase; rd8count=Read((BPTR)v8handle,p8data,p8Chunk->ckSize); if (rd8count==-1) { kill8svx ("Read error.\n"); exit(1L); } if (rd8count ckSize) { kill8svx ("Malformed IFF, too short.\n"); exit(1L); } /*-------------------*/ /* Evaluate IFF Type */ /*-------------------*/ if (MakeID( *p8data, *(p8data+1) , *(p8data+2) , *(p8data+3) ) != MY8S ) { kill8svx("Not an IFF 8SVX file.\n"); exit(1L); } /*----------------------*/ /* Evaluate 8SVX Chunks */ /*----------------------*/ p8data=p8data+4; while( p8data ckID) { case VHDR: /*------------------------------------------------*/ /* Get a pointer to the 8SVX header for later use */ /*------------------------------------------------*/ pVoice8Header=(Voice8Header *)(p8data+8L); break; case BODY: /*-------------------------------------------------*/ /* Create pointers to 1-shot and continuous parts */ /* for the top octave and get length. Store them. */ /*-------------------------------------------------*/ psample[0] = (BYTE *)(p8data + 8L); psample[1] = psample[0] + pVoice8Header->oneShotHiSamples; length[0] = (ULONG)pVoice8Header->oneShotHiSamples; length[1] = (ULONG)pVoice8Header->repeatHiSamples; break; default: break; } /* end switch */ p8data = p8data + 8L + p8Chunk->ckSize; if (p8Chunk->ckSize&1L == 1) p8data++; } /* Play either the one-shot or continuous, not both */ if (length[0]==0) y=1; else y=0; /*---------------------------------------*/ /* Allocate chip memory for samples and */ /* copy from read buffer to chip memory. */ /*---------------------------------------*/ if (length[y] samplesPerSec; /*-------------------*/ /* Bump our priority */ /*-------------------*/ mt=FindTask(NULL); oldpri=SetTaskPri(mt,21); /*--------------------------------*/ /* Allocate two audio I/O blocks */ /*--------------------------------*/ AIOptr1=(struct IOAudio *) AllocMem( sizeof(struct IOAudio),MEMF_PUBLIC|MEMF_CLEAR); if (AIOptr1==0) { kill8svx("No IO memory\n"); exit(1L); } AIOptr2=(struct IOAudio *) AllocMem( sizeof(struct IOAudio),MEMF_PUBLIC|MEMF_CLEAR); if (AIOptr2==0) { kill8svx("No IO memory\n"); exit(1L); } /*----------------------*/ /* Make two reply ports */ /*----------------------*/ port1=CreatePort(0,0); if (port1==0) { kill8svx("No port\n"); exit(1L); } port2=CreatePort(0,0); if (port2==0) { kill8svx("No port\n"); exit(1L); } c=0; while(device!=0 && c ioa_Request.io_Message.mn_ReplyPort = port1; AIOptr1->ioa_Request.io_Message.mn_Node.ln_Pri = 127; /* No stealing! */ AIOptr1->ioa_AllocKey = 0; AIOptr1->ioa_Data = chans[c]; AIOptr1->ioa_Length = 1; device=OpenDevice(AUDIONAME,0L,(struct IORequest *)AIOptr1,0L); c++; } if (device!=0) { kill8svx("No channel\n"); exit(1L); } /*-------------------------------------------*/ /* Set Up Audio IO Blocks for Sample Playing */ /*-------------------------------------------*/ AIOptr1->ioa_Request.io_Command =CMD_WRITE; AIOptr1->ioa_Request.io_Flags =ADIOF_PERVOL; /*--------*/ /* Volume */ /*--------*/ AIOptr1->ioa_Volume=60; /*---------------*/ /* Period/Cycles */ /*---------------*/ AIOptr1->ioa_Period =(UWORD)speed; AIOptr1->ioa_Cycles =1; *AIOptr2 = *AIOptr1; /* Make sure we have the same allocation keys, */ /* same channels selected and same flags */ /* (but different ports...) */ AIOptr1->ioa_Request.io_Message.mn_ReplyPort = port1; AIOptr2->ioa_Request.io_Message.mn_ReplyPort = port2; /*--------*/ /* Data */ /*--------*/ AIOptr1->ioa_Data =(UBYTE *)sbase; AIOptr2->ioa_Data =(UBYTE *)sbase + 51200; /*-----------------*/ /* Run the sample */ /*-----------------*/ if (length[y] ioa_Length=length[y]; /* No double buffering needed */ BeginIO((struct IORequest *)AIOptr1); /* Begin the sample, wait for */ wakebit=0L; /* it to finish, then quit. */ wakebit=Wait(1 mp_SigBit); while((msg=GetMsg(port1))==0){}; } else { length[y]-=102400; /* It's a real long sample so */ AIOptr1->ioa_Length=51200L; /* double buffering is needed */ AIOptr2->ioa_Length=51200L; BeginIO((struct IORequest *)AIOptr1); /* Start up the first 2 blocks */ BeginIO((struct IORequest *)AIOptr2); Aptr=AIOptr1; port=port1; /* Set the switch... */ while(length[y]>0) { /* Wait() for one IO to finish */ wakebit=Wait(1 mp_SigBit); /* reuse the IO block & queue */ while((msg=GetMsg(port))==0){}; /* it up again while the 2nd IO*/ /* block plays.Switch & repeat */ /* Set length of next IO block */ if (length[y] ioa_Length=length[y]; else Aptr->ioa_Length=51200L; /* Copy sample fragment from read buffer to chip memory */ CopyMem(psample[y],Aptr->ioa_Data,Aptr->ioa_Length); /* Adjust size and pointer of read buffer*/ length[y]-=Aptr->ioa_Length; psample[y]+=51200; BeginIO((struct IORequest *)Aptr); if (Aptr==AIOptr1) { Aptr=AIOptr2; /* This logic handles switching */ port=port2; /* between the 2 IO blocks and */ } /* the 2 ports we are using. */ else { Aptr=AIOptr1; port=port1; } } /*-------------------------------------------------*/ /* OK we are at the end of the sample so just wait */ /* for the last two parts of the sample to finish */ /*-------------------------------------------------*/ wakebit=Wait(1 mp_SigBit); while((msg=GetMsg(port))==0){}; if (Aptr==AIOptr1) { Aptr=AIOptr2; /* This logic handles switching */ port=port2; /* between the 2 IO blocks and */ } /* the 2 ports we are using. */ else { Aptr=AIOptr1; port=port1; } wakebit=Wait(1 mp_SigBit); while((msg=GetMsg(port))==0){}; } kill8(); exit(0L); } /*----------------*/ /* Abort the Read */ /*----------------*/ void kill8svx(kill8svxstring) char *kill8svxstring; { puts(kill8svxstring); kill8(); } /*-------------------------*/ /* Return system resources */ /*-------------------------*/ void kill8() { if (device ==0) CloseDevice((struct IORequest *)AIOptr1); if (port1 !=0) DeletePort(port1); if (port2 !=0) DeletePort(port2); if (AIOptr1!=0) FreeMem( AIOptr1,sizeof(struct IOAudio) ); if (AIOptr2!=0) FreeMem( AIOptr2,sizeof(struct IOAudio) ); if (mt!=0) SetTaskPri(mt,oldpri); if (sbase !=0) FreeMem (sbase, ssize); if (fbase !=0) FreeMem(fbase,fsize); if (v8handle!=0) Close((BPTR)v8handle); } [Back to Amiga Developer Docs ]
Devices_Manual_guide/node0295.html.txt:1:SAMP.doc / The Waveheader Explained ]" border=0> The WaveSize is, as stated, the number of BYTES in the wave's sample table. If your sample data consisted of the following 8 bit samples: BYTE 100,-90,80,-60,30,35,40,-30,-35,-40,00,12,12,10 then WaveSize = 14. (PAD THE DATA OUT TO AN EVEN NUMBER OF BYTES!) The MidiSampNum is ONLY used to hold the sample number received from a MIDI Sample Dump. It has no bearing on where the wave should be placed in a SAMP file. Also, the wave numbers in the PlayMap are between 1 to 255, with 1 being the number of the first wave in the file. Remember that a wave number of 0 is reserved to mean "no wave to play back". Likewise, the LoopType is only used to hold info from a MIDI sample dump. The InsType is explained at the end of this document. Often it will be set to 0. The RootNote is the Midi Note number that will play the wave back at it's original, recorded pitch. For example, consider the following excerpt of a PlayMap: PlayMap {2,0,0,4 /* Midi Note #0 channel assignment */ 4,100,1,0 /* Midi Note #1 " " */ 1,4,0,0 /* Midi Note #2 " " */ 60,2,1,1...} /* Midi Note #3 " " */ Notice that Midi Notes 0, 1, and 2 are all set to play wave number 4 (on Amiga channels 3, 0, and 1 respectively). If we set wave 4's RootNote = 1, then receiving Midi Note number 1 would play back wave 4 (on Amiga channel 0) at it's original pitch. If we receive a Midi Note number 0, then wave 4 would be played back on channel 3) a half step lower than it's original pitch. If we receive Midi Note number 2, then wave 4 would be played (on channel 1) a half step higher than it's original pitch. If we receive Midi Note number 3, then wave 4 would not be played at all because it isn't specified in the PlayMap bytes for Midi Note number 3. The Rate is the number of samples per second of the original pitch. For example, if Rate = 20000, then to play the wave at it's original pitch, the sampling period would be: (1/20000)/.279365 = .000178977 #define AUDIO_HARDWARE_FUDGE .279365 where .279365 is the Amiga Fudge Factor (a hardware limitation). Since the Amiga needs to see the period in terms of microseconds, move the decimal place to the right 6 places and our sampling period = 179 (rounded to an integer). In order to play the wave at higher or lower pitches, one would need to "transpose" this period value. By specifying a higher period value, the Amiga will play back the samples slower, and a lower pitch will be achieved. By specifying a lower period value, the amiga will play back the sample faster, and a higher pitch will be achieved. By specifying this exact period, the wave will be played back exactly "as it was recorded (sampled)". ("This period is JUST RIGHT!", exclaimed GoldiLocks.) Later, a method of transposing pitch will be shown using a "look up" table of periods. This should prove to be the fastest way to transpose pitch, though there is nothing in the SAMP format that compels you to do it this way. The LoopStart is a BYTE offset from the beginning of the wave to where the looping portion of the wave begins. For example, if SampleData points to the start of the wave, then SampleData + LoopStart is the start address of the looping portion. In 8SVX, the looping portion was referred to as repeatHiSamples. The data from the start of the wave up to the start of the looping portion is the oneShot portion of the wave. LoopEnd is a BYTE offset from the beginning of the wave to where the looping portion ends. This might be the very end of the wave in memory, or perhaps there might be still more data after this point. You can choose to ignore this "trailing" data and play back the two other portions of the wave just like an 8SVX file (except that there are no other interpolated octaves of this wave). VelTable contains 16 BYTE offsets from the beginning of the wave. Each successive value should be greater (or equal to) the preceding value. If VelStart = POSITIVE (64), then for each 8 increments in Midi Velocity above 0, you move UP in the table, add this offset to the wave's beginning address (start of oneShot), and start playback at that address. Here is a table relating received midi note-on velocity vs. start playback address for POSITIVE VelStart. SamplePtr points to the beginning of the sample. If midi velocity = 0, then don't play a sample, this is a note off If midi velocity = 1 to 7, then start play at SamplePtr + VelTable[0] If midi velocity = 8 to 15, then start at SamplePtr + VelTable[1] If midi velocity = 16 to 23, then start at SamplePtr + VelTable[2] If midi velocity = 24 to 31, then start at SamplePtr + VelTable[3] If midi velocity = 32 to 39, then start at SamplePtr + VelTable[4] If midi velocity = 40 to 47, then start at SamplePtr + VelTable[5] If midi velocity = 48 to 55, then start at SamplePtr + VelTable[6] If midi velocity = 56 to 63, then start at SamplePtr + VelTable[7] If midi velocity = 64 to 71, then start at SamplePtr + VelTable[8] If midi velocity = 72 to 79, then start at SamplePtr + VelTable[9] If midi velocity = 80 to 87, then start at SamplePtr + VelTable[10] If midi velocity = 88 to 95, then start at SamplePtr + VelTable[11] If midi velocity = 96 to 103, then start at SamplePtr + VelTable[12] If midi velocity = 104 to 111, then start at SamplePtr + VelTable[13] If midi velocity = 112 to 119, then start at SamplePtr + VelTable[14] If midi velocity = 120 to 127, then start at SamplePtr + VelTable[15] We don't want to specify a scale factor and use integer division to find the sample start. This would not only be slow, but also, it could never be certain that the resulting sample would be a zero crossing if the start point is calcu- lated "on the fly". The reason for having a table is so that the offsets can be be initially set on zero crossings via an editor. This way, no audio "clicks" is guaranteed. This table should provide enough resolution. If VelStart = NEGATIVE (128), then for each 8 increments in midi velocity, you start from the END of VelTable, and work backwards. Here is a table for NEGATIVE velocity start. If midi velocity = 0, then don't play a sample, this is a note off If midi velocity = 1 to 7, then start play at SamplePtr + VelTable[15] If midi velocity = 8 to 15, then start at SamplePtr + VelTable[14] If midi velocity = 16 to 23, then start at SamplePtr + VelTable[13] If midi velocity = 24 to 31, then start at SamplePtr + VelTable[12] If midi velocity = 32 to 39, then start at SamplePtr + VelTable[11] If midi velocity = 40 to 47, then start at SamplePtr + VelTable[10] If midi velocity = 48 to 55, then start at SamplePtr + VelTable[9] If midi velocity = 56 to 63, then start at SamplePtr + VelTable[8] If midi velocity = 64 to 71, then start at SamplePtr + VelTable[7] If midi velocity = 72 to 81, then start at SamplePtr + VelTable[6] If midi velocity = 80 to 87, then start at SamplePtr + VelTable[5] If midi velocity = 88 to 95, then start at SamplePtr + VelTable[4] If midi velocity = 96 to 103, then start at SamplePtr + VelTable[3] If midi velocity = 104 to 111, then start at SamplePtr + VelTable[2] If midi velocity = 112 to 119, then start at SamplePtr + VelTable[1] If midi velocity = 120 to 127, then start at SamplePtr + VelTable[0] In essence, increasing midi velocity starts playback "farther into" the wave for POSITIVE VelStart. Increasing midi velocity "brings the start point back" toward the beginning of the wave for NEGATIVE VelStart. If VelStart is set to NONE (0), then the wave's playback start should not be affected by the table of offsets. What is the use of this feature? As an example, when a snare drum is hit with a soft volume, its initial attack is less pronounced than when it is struck hard. You might record a snare being hit hard. By setting VelStart to a NEGATIVE value and setting up the offsets in the Table, a lower midi velocity will "skip" the beginning samples and thereby tend to soften the initial attack. In this way, one wave yields a true representation of its instrument throughout its volume range. Furthermore, stringed and plucked instruments (violins, guitars, pianos, etc) exhibit different attacks at different volumes. VelStart makes these kinds of waves more realistic via a software implementation. Also, an application program can allow the user to enable/ disable this feature. See the section "Making the Velocity Table" for info on how to best choose the 16 table values. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node0028.html.txt:1:2 Audio Device / Audio Allocation and Arbitration ]" border=0> The first command you send to the audio device should always be ADCMD_ALLOCATE . You can do this when you open the device, or at a later time. You specify the channels you want in the ioa_Data field of the IOAudio block. If the allocation succeeds, the audio device will return the channels that you now own in the lower four bits of the ioa_Request.io_Unit field of your IOAudio block. For instance, if the io_Unit field equals 5 (binary 0101) then you own channels 2 and 0. If the io_Unit field equals 15 (binary 1111) then you own all the channels. When you send the ADCMD_ALLOCATE command, the audio device will also return a unique allocation key in the ioa_AllocKey of the IOAudio block. You must use this allocation key for all subsequent commands that you send to the audio device. The audio device uses this unique key to identify which task issued the command. If you do not use the correct allocation key assigned to you by the audio device when you send a command, your command will be ignored. When you request a channel with ADCMD_ALLOCATE , you specify a precedence number from -128 to 127 in the ioa_Request.io_Message.mn_Node.ln_Pri field of the IOAudio block. If a channel you want is being used and you have specified a higher precedence than the current user, ADCMD_ALLOCATE will "steal" the channel from the other user. Later on, if your precedence is lower than that of another user who is performing an allocation, the channel may be stolen from you. If you set the precedence to 127 when you open the device or raise the precedence to 127 with the ADCMD_SETPREC command, no other tasks can steal a channel from you. When you have finished with a channel, you must relinquish it with the ADCMD_FREE command to make it available for other users. The following table shows suggested precedence values. SUGGESTED PRECEDENCES FOR CHANNEL ALLOCATION Predecence Type of Sound ---------- ------------- 127 Unstoppable. Sounds first allocated at lower precedence, then set to this to the highest level. 90 - 100 Emergencies. Alert, urgent situation that requires immediate action. 80 - 90 Annunciators. Attention, bell (CTRL-G). 75 Speech. Synthesized or recorded speech (narrator.device). 50 - 70 Sonic cues. Sounds thatprovide information that is not provided by graphics. Only the beginning of each sound (enough to recognize it) should be at this level;the rest should be set to sound effects level. -50 - 50 Music program. Musical notes in music-oriented program. The higher levels should be used for the attack portions of each note. -70 - -50 Sound effects. Sounds used in conjunction with graphics. More important sounds should use higher levels. -100 - -80 Background. Theme music and restartable background sounds. -128 Silence. Lowest level (freeing the channel completely is preferred). If you attempt to perform a command on a channel that has been stolen from you by a higher priority task, an AUDIO_NOALLOCATION error is returned and the bit in the ioa_Request.io_Unit field corresponding to the stolen channel is cleared so you know which channel was stolen. If you want to be warned before a channel is stolen so that you have a chance to stop your sound gracefully, then you should use the ADCMD_LOCK command after you open the device. This command is also useful for programs which write directly to the audio hardware. For more on ADCMD_LOCK , see the section below. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node021E.html.txt:1:AIFF.doc / AIFF / Block-Aligning Sound Data ]" border=0> There may be some applications that, to ensure real time recording and playback of audio, wish to align sampled sound data with fixed-size blocks. This alignment can be accomplished with the offset and blockSize parameters of the Sound Data Chunk, as shown in Figure 7. ____________ __________________________________ ____________ |\\ unused \\| sample frames |\\ unused \\| |____________|__________________________________|____________| | blockSize | | | | | | | | | |_______________|_______________|_______________|_______________| block N-1 block N block N+1 block N+2 Figure 7: Block-Aligned Sound Data In Figure 7, the first sample frame starts at the beginning of block N. This is accomplished by skipping the first offset bytes of the soundData. Note too, that the soundData bytes can extend beyond valid sample frames, allowing the soundData bytes to end on a block boundary as well. The blockSize specifies the size in bytes of the block to which you would align the sound data. A blockSize of zero indicates that the sound data does not need to be block-aligned. Applications that don't care about block alignment should set the blockSize and offset to zero when creating Audio IFF files. Applications that write block-aligned sound data should set blockSize to the appropriate block size. Applications that modify an existing Audio IFF file should try to preserve alignment of the sound data, although this is not required. If an application does not preserve alignment, it should set the blockSize and offset to zero. If an application needs to realign sound data to a different sized block, it should update blockSize and offset accordingly. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node021B.html.txt:1:AIFF / Local Chunk Types / The Common Chunk ]" border=0> The Common Chunk describes fundamental parameters of the sampled sound. #define CommonID 'COMM' /* ckID for Common Chunk */ typedef struct { ID ckID; long ckSize; short numChannels; unsigned long numSampleFrames; short sampleSize; extended sampleRate; } CommonChunk; The ckID is always 'COMM'. The ckSize is the size of the data portion of the chunk, in bytes. It does not include the 8 bytes used by ckID and ckSize. For the Common Chunk, ckSize is always 18. The numChannels field contains the number of audio channels for the sound. A value of 1 means monophonic sound, 2 means stereo, and 4 means four channel sound, etc. Any number of audio channels may be represented. For multichannel sounds, single sample points from each channel are interleaved. A set of interleaved sample points is called a sample frame. The actual sound samples are stored in another chunk, the Sound Data Chunk, which will be described shortly. Single sample points from each channel are interleaved such that each sample frame is a sample point from the same moment in time for each channel available. The numSampleFrames field contains the number of sample frames. This is not necessarily the same as the number of bytes nor the number of samplepoints in the Sound Data Chunk. The total number of sample points in the file is numSampleFrames times numChannels. The sampleSize is the number of bits in each sample point. It can be any number from 1 to 32. The format of a sample point will be described in the next section. The sampleRate field is the sample rate at which the sound is to be played back in sample frames per second. One, and only one, Common Chunk is required in every FORM AIFF. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node001D.html.txt:1:2 Audio Device / Audio Device Commands and Functions ]" border=0> Command Operation ------- --------- ADCMD_ALLOCATE Allocate one or more of the four audio channels. ADCMD_FINISH Abort the current write request on one or more of the channels. Can be done immediately or at the end of the current cycle. ADCMD_FREE Free one or more audio channels. ADCMD_LOCK Lock one or more audio channels. ADCMD_PERVOL Change the period and volume for writes in progress. Can be done immediately or at the end of the cycle. ADCMD_SETPREC Set the allocation precedence of one or more channels. ADCMD_WAITCYCLE Wait for the current write cycle to complete on a single channel. Returns at the end of the cycle or immediately if no cycle is active on the channel. CMD_FLUSH Purge all write cycles and waitcycles (in-progress and queued) for one or more channels. CMD_READ Return a pointer to the I/O block currently writing on a single channel. CMD_RESET Reset one or more channels their initialized state. All active and queued requests will be aborted. CMD_START Resume writes to one or more channels that were stopped. CMD_STOP Stop any write cycle in progress on one or more channels. CMD_WRITE Start a write cycle on a single channel. Exec Functions as Used in This Chapter -------------------------------------- AbortIO() Abort a command to the audio device. If in progress, it is stopped immediately, otherwise it is removed from the queue. BeginIO() Initiate a command and return immediately (asynchronous request). CheckIO() Determine the current state of an I/O request. CloseDevice() Relinquish use of the audio device. OpenDevice() Obtain use of the audio device. Wait() Wait for a signal from the audio device. WaitPort() Wait for the audio message port to receive a message. Exec Support Functions as Used in This Chapter ---------------------------------------------- AllocMem() Allocate a block of memory. CreatePort() Create a signal message port for reply messages from the audio device. Exec will signal a task when a message arrives at the reply port. DeletePort() Delete the message port created by CreatePort(). FreeMem() Free a block of previously allocated memory. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node02B0.html.txt:1:Background / Instrument Registers ]" border=0> Instrument reference. In SSSP , each note event points to a "timbre object" which supplies the "instrument" (the sound driver data) for that note. FORM SMUS stores these pointers as a "current instrument setting" for each track. It's just a run encoded version of the same information. SSSP reference uses a symbol table to hold all the pointers to "timbre object". SMUS uses INS1 chunks for the same purpose. They name the score's instruments. The actual instrument data to use depends on the playback environment, but we want the score to be independent of environment. Different playback environments have different audio output hardware and different sound driver software. And there are channel allocation issues like how many output channels there are, which ones are polyphonic, and which I/O ports they're connected to. If you use MIDI to control the instruments, you get into issues of what kind of device is listening to each MIDI channel and what each of its presets sounds like. If you use computer-based instruments, you need driver- specific data like waveform tables and oscillator parameters. We just want some orchestration. If the score wants a "piano", we let the playback program find a "piano". Instrument reference by name. A reference from a SMUS score to actual instrument data is normally by name. The score simply names the instrument, for instance "tubular bells". It's up to the player program to find suitable instrument data for its output devices. (More on locating instruments below.) Instrument reference by MIDI channel and preset. A SMUS score can also ask for a specific MIDI channel number and preset number. MIDI programs may honor these specific requests. But these channel allocations can become obsolete or the score may be played without MIDI hardware. In such cases, the player program should fall back to instrument reference by name. Instrument reference via instrument register. Each reference from a SMUS track to an instrument is via an "instrument register". Each track selects an instrument register which in turn points to the specific instrument data. Each score has an array of instrument registers . Each track has a "current instrument setting", which is simply an index number into this array. This is like setting a raster image's pixel to a specific color number (a reference to a color value through a "color register") or setting a text character to a specific font number (a reference to a font through a "font register"). This is diagramed below: +------------+--------+--------+------------+--------+-----------+ Track 1 | Set Inst 2 | Note | Note | Set Inst 1 | Note | Note... | .---+------------+--------+--------+------------+--------+-----------+ / ______________________________________/ / / / / \ \ +------------------+ +--------------------------------+ \ `----->| "piano" |-----> | (internal piano data) | \ +------------------+ +--------------------------------+ `------->| "guitar" |-----> | (internal guitar data) | Instrument +------------------+ +--------------------------------+ Registers | "Spanish guitar" |-----> | (internal Spanish guitar data) | +------------------+ +--------------------------------+ .----->| "bass drum" |-----> | (internal bass drum data) | / +------------------+ +--------------------------------+ / \ \ `-+------------+--------+--------+--------+--------+-----------+ Track 2 | Set Inst 4 | Note | Note | Note | Note | Note... | +------------+--------+--------+--------+--------+-----------+ Locating instrument data by name. "INS1" chunks in a SMUS score name the instruments to use for that score. The player program uses these names to locate instrument data. To locate instrument data, the player performs these steps: For each instrument register, check for a suitable instrument with the right name? {"Suitable" means usable with an available output device and driver.} {Use case independent name comparisons.} 1.Initialize the instrument register to point to a built-in default instrument. {Every player program must have default instruments. Simple programs stop here. For fancier programs, the default instruments are a backstop in case the search fails.} 2.Check any instrument FORM s embedded in the FORM SMUS . (This is an "instrument cache".) 3.Else check the default instruments. 4.Else search the local "instrument library". (The library might simply be a disk directory.) 5.If all else fails, display the desired instrument name and ask the user to pick an available one. This algorithm can be implemented to varying degrees of fanciness. It's OK to stop searching after step 1, 2, 3, or 4. If exact instrument name matches fail, it's OK to try approximate matches. E.g., search for any kind of "guitar" if you can't find a "Spanish guitar". In any case, a player only has to search for instruments while loading a score. When the embedded instruments are suitable, they save the program from asking the user to insert the "right" disk in a drive and searching that disk for the "right" instrument. But it's just a cache. In practice, we rarely move scores between environments so the cache often works. When the score is moved, embedded instruments must be discarded (a cache miss) and other instrument data used. Be careful to distinguish an instrument's name from its filename--the contents name vs. container name. A musical instrument FORM should contain a NAME chunk that says what instrument it really is. Its filename, on the other hand, is a handle used to locate the FORM. Filenames are affected by external factors like drives, directories, and filename character and length limits. Instrument names are not. Issue: Consider instrument naming conventions for consistency. Consider a naming convention that aids approximate matches. E.g., we could accept "guitar, bass1" if we didn't find "guitar, bass". Failing that, we could accept "guitar" or any name starting with "guitar". Set instrument events. If the player implements the set-instrument score event, each track can change instrument numbers while playing. That is, it can switch between the loaded instruments. Initial instrument settings. Each time a score is played, every track's running state information must be initialized. Specifically, each track's instrument number should be initialized to its track number. Track 1 to instrument 1, etc. It's as if each track began with a set-instrument event. In this way, programs that don't implement the set-instrument event still assign an instrument to each track. The INS1 chunks imply these initial instrument settings. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node001C.html.txt:1:2 / About Amiga Audio / Definitions ]" border=0> Terms used in the following discussions may be unfamiliar. Some of the more important ones are defined below. Amplitude The height of a waveform, which corresponds to the amount of voltage or current in the electronic circuit. Amplitude modulation A means of producing special audio effects by using one channel to alter the amplitude of another. Channel One "unit" of the audio device. Cycle One repetition of a waveform. Frequency The number of times per second a cycle repeats. Frequency modulation A means of producing special audio effects by using one channel to affect the period of the waveform produced by another channel. Period The time elapsed between the output of successive sound samples, in units of system clock ticks. Precedence Priority of the user of a sound channel. Sample Unit of audio data, one of the fixed-interval points on the waveform. Waveform Graph that shows a model of how the amplitude of a sound varies over time-usually over one cycle. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node0037.html.txt:1:2 / Hardware Control Commands / CMD_RESET ]" border=0> CMD_RESET restores all the audio hardware registers. It clears the attach bits, restores the audio interrupt vectors if the programmer has changed them, and performs the CMD_FLUSH command to cancel all requests to the channels. CMD_RESET also unstops channels that have had a CMD_STOP performed on them. CMD_RESET does not unlock channels that have been locked by ADCMD_LOCK . [Back to Amiga Developer Docs ]
Devices_Manual_guide/node003D.html.txt:1:2 Audio Device / Additional Information on the Audio Device ]" border=0> Additional programming information on the audio device can be found in the include files and the Autodocs for the audio device. Both are contained in the Amiga ROM Kernel Reference Manual: Includes and Autodocs. Information can also be found in the Amiga Hardware Reference Manual . Audio Device Information ------------------------------- INCLUDES devices/ audio.h devices/ audio.i AUTODOCS audio.doc [Back to Amiga Developer Docs ]
Devices_Manual_guide/node0134.html.txt:1:D,E Index ]" border=0> Demo_Dump.c, 190 Device Specific Commands, devices/audio.h, 16 devices/clipboard.h, 37 , 40 devices/gameport.h, 92 devices/hardblocks.h, 256 devices/inputevent.h, 105 , 106 devices/narrator.h, 134 devices/parallel.h, 161 devices/printer.h, 175 devices/prtbase.h, 181 , 196 devices/scsidisk.h, 251 devices/serial.h, 267 devices/timer.h, 287 devices/trackdisk.h, 305 Digital-To-Analog, 13 Disk Resource, 335 - add'l info, 337 - allocation, 336 - functions, 335 DISKINSERTED message, 314 DISKREMOVED message, 314 DoIO(), , DoSpecial(), 199 - parameters, 199 E-Clock, 287 - E-Clock time, 298 - ECLOCK Timer Unit, 288 - EClockVal, 298 Ejecting a disk, 311 End-of-Clip, 41 End-of-File, 41 EpsonX Driver --> ETD_CLEAR Command, 310 ETD_FORMAT Command, 311 ETD_MOTOR Command, 310 ETD_RAWREAD Command, 315 ETD_RAWWRITE Command, 316 ETD_READ Command, 307 ETD_SEEK Command, 314 ETD_UPDATE Command, 310 ETD_WRITE Command, 308 Exec Commands, , exec/errors.h, exec/interrupts.h, 106 exec/io.h, Exec error codes, 187 [Back to Amiga Developer Docs ]
Devices_Manual_guide/node028E.html.txt:1:A / IFF Third Party Public Form and Chunk Specification / SAMP.doc ]" border=0> Sampled sound format IFF FORM "SAMP" Sampled Sound Date: Dec 3,1989 From: Jim Fiore and Jeff Glatt, dissidents The form "SAMP" is a file format used to store sampled sound data in some ways like the current standard, "8SVX". Unlike "8SVX", this new format is not restricted to 8 bit sample data. There can be more than one waveform per octave, and the lengths of different waveforms do not have to be factors of 2. In fact, the lengths (waveform size) and playback mapping (which musical notes each waveform will "play") are independently determined for each wave- form. Furthermore, this format takes into account the MIDI sample dump stan- dard (the defacto standard for musical sample storage), while also incorpo- rating the ability to store Amiga specific info (for example, the sample data that might be sent to an audio channel which is modulating another channel). Although this form can be used to store "sound effects" (typically oneShot sounds played at a set pitch), it is primarily intended to correct the many deficiencies of the "8SVX" form in regards to musical sampling. Because the emphasis is on musical sampling, this format relies on the MIDI (Musical Instrument Digital Interface) method of describing "sound events" as does virtually all currently manufactured, musical samplers. In addition, it at- tempts to incorporate features found on many professional music samplers, in anticipation that future Amiga models will implement 16 bit sampling, and thus be able to achieve this level of performance. Because this format is more complex than "8SVX", programming examples to demonstrate the use of this format have been included in both C and assembly. Also, a library of func- tions to read and write SAMP files is available, with example applications. SEMANTICS: When MIDI literature talks about a sample, usually it means a collection of many sample points that make up what we call a "wave". Similarities and Differences from the 8SVX Form The SAMP Header The MHDR Chunk The NAME Chunk The BODY Chunk Structure of an Individual Sample Point The Waveheader Explained MIDI Velocity vs. Amiga Channel Volume An EGpoint (Envelope Generator) Additional User Data Section Converting Midi Sample Dump to SAMP Interpreting the Playmode Making A Transpose Table Making the Velocity Table The Instrument Type The Order of the Chunks Filename Conventions Why Does Anyone Need Such a Complicated File? [Back to Amiga Developer Docs ]
Devices_Manual_guide/node0023.html.txt:1:2 / Audio And System I/O Functions / BeginIO() ]" border=0> All the commands that you can give to the audio device should be sent by calling the BeginIO() function. This differs from other Amiga devices which generally use SendIO() or DoIO() . You should not use SendIO() or DoIO() with the audio device because these functions clear some special flags used by the audio device; this might cause audio to work incorrectly under certain circumstances. To be safe, you should always use BeginIO() with the audio device. [Back to Amiga Developer Docs ]
Devices_Manual_guide/node0293.html.txt:1:SAMP.doc / The BODY Chunk ]" border=0> The "BODY" chunk is CONSIDERABLY different than the "8SVX" form. Like all chunks it has an ID. #define ID_BODY MakeID('B','O','D','Y') Every wave has an 80 byte waveHeader, followed by its data. The waveHeader structure is as follows: typedef struct { ULONG WaveSize; /* total # of BYTES in the wave (MUST be even) */ UWORD MidiSampNum; /* ONLY USED for Midi Dumps */ UBYTE LoopType, /* ONLY USED for Midi Dumps */ InsType; /* Used for searching for a certain instrument */ ULONG Period, /* in nanoseconds at original pitch */ Rate, /* # of samples per second at original pitch */ LoopStart, /* an offset in BYTES (from the beginning of the of the wave) where the looping portion of the wave begins. Set to WaveSize if no loop. */ LoopEnd; /* an offset in BYTES (from the beginning of the of the wave) where the looping portion of the wave ends. Set to WaveSize if no loop. */ UBYTE RootNote, /* the Midi Note # that plays back orig. pitch */ VelStart; /* 0 = NO velocity effect, 128 = negative direction, 64 = positive direction (it must be one of these 3) */ UWORD VelTable[16]; /* contains 16 successive offset values in BYTES from the beginning of the wave */ /* The ATAK and RLSE segments contain an EGPoint[] piece-wise linear envelope just like 8SVX. The structure of an EGPoint[] is the same as 8SVX. See that document for details. */ ULONG ATAKsize, /* # of BYTES in subsequent ATAK envelope. If 0, then no ATAK data for this wave. */ RLSEsize, /* # of BYTES in subsequent RLSE envelope If 0, then no RLSE envelope follows */ /* The FATK and FRLS segments contain an EGPoint[] piece-wise linear envelope for filtering purposes. This is included in the hope that future Amiga audio will incorporate a VCF (Voltage Controlled Filter). Until then, if you are doing any non-realtime digital filtering, you could store info here. */ sizeOfFATK, /* # of BYTES in FATK segment */ sizeOfFRLS, /* # of BYTES in FRLS segment */ USERsize; /* # of BYTES in the following data segment (not including USERtype). If zero, then no user data */ UWORD USERtype; /* See explanation below. If USERsize = 0, then ignore this. */ /* End of the waveHeader. */ /* The data for any ATAK, RLSE, FATK, FRLS, USER, and the actual wave data for wave #1 follows in this order: Now list each EGPoint[] (if any) for the VCA's (Voltage Controlled Amp) attack portion. Now list each EGPoint[] for the VCA's (Voltage Controlled Amp) release portion. List EGPoints[] (if any) for FATK. List EGPoints[] if any for FRLS */ /* Now include the user data here if there is any.Just pad it out to an even number of bytes and have USERsize reflect that. Finally,here is the actual sample data for the wave. The size (in BYTES) of this data is WaveSize. It MUST be padded out to an even number of bytes. */ } WaveFormInfo; /* END OF WAVE #1 */ /* The waveHeader and data for the next wave would now follow. It is the same form as the first wave */ In assembly, the BODY chunk looks like this: CNOP 0,2 BodyHEADER dc.b 'BODY' sizeOfBody dc.l [total bytes in the BODY chunk not counting 8 byte header] ; Now for the first wave WaveSize dc.l ;[total # of BYTES in this wave (MUST be even)] MidiSampNum dc.w ;[from Midi Sample Dump] ; ONLY USED for Midi Dumps LoopType dc.b ;[0 or 1] ; ONLY USED for Midi Dumps InsType dc.b 0 Period dc.l ;[period in nanoseconds at original pitch] Rate dc.l ;[# of samples per second at original pitch] LoopStart dc.l ;[an offset in BYTES (from the beginning of the ; of the wave) to where the looping ; portion of the wave begins.] LoopEnd dc.l ;[an offset in BYTES (from the beginning of the ; of the wave) to where the looping ; portion of the wave ends] RootNote dc.b ;[the Midi Note # that plays back original pitch] VelStart dc.b ;[0, 64, or 128] VelTable dc.w ;[first velocity offset] dc.w ;[second velocity offset]...etc ds.w 14 ;...for a TOTAL of 16 velocity offsets ATAKsize dc.l ;# of BYTES in subsequent ATAK envelope. ;If 0, then no ATAK data for this wave. RLSEsize dc.l ;# of BYTES in subsequent RLSE envelope ;If 0, then no RLSE data FATKsize dc.l ;# of BYTES in FATK segment FRLSsize dc.l ;# of BYTES in FRLS segment USERsize dc.l ;# of BYTES in the following User data ;segment (not including USERtype). ;If zero, then no user data USERtype dc.w ; See explanation below. If USERsize ; = 0, then ignore this. ;Now include the EGpoints[] (data) for the ATAK if any ;Now the EGpoints for the RLSE ;Now the EGpoints for the FATK ;Now the EGpoints for the FLSR ;Now include the user data here if there is any. Just pad ;it out to an even number of bytes. ;After the userdata (if any) is the actual sample data for ;the wave. The size (in BYTES) of this segment is WaveSize. ;It MUST be padded out to an even number of bytes. ; END OF WAVE #1 [Back to Amiga Developer Docs ]
