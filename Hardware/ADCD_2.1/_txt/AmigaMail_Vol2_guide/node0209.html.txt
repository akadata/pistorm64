SOURCE: AmigaMail_Vol2_guide/node0209.html
TITLE: XI-25/AppMap_demo.c

XI-25/AppMap_demo.c ]" border=0> ;/* appmap_demo.c - Execute me to compile me with SAS/C 6.56 sc data=far nominc strmer streq nostkchk saveds ign=73 appmap_demo.c slink FROM LIB:c.o,appmap_demo.o,appkeymap.o TO appmap_demo LIB LIB:SC.lib,LIB:Amiga.lib quit */ /* Appmap_demo uses the routines in appkeymap.o to clone the current */ /* task's console keymap. Appmap_demo then modifies the keymap clone */ /* by redefining some of the keypad keys. It installs a string key, */ /* a "normal" key, and a NO OP key, which are acceptable replacements */ /* for keypad keys on a console-based application. */ /* */ /* This example also installs a dead/deadable key pair and a double */ /* dead/deadable key pair. These are provided only as a means for */ /* understanding how dead-class keys work. Do not use them as part */ /* of anything for public consumption. */ #include #include #include #include #include #include #include #include #include #include #ifdef __SASC void __regargs __chkabort(void); void __regargs __chkabort(void){} #endif #include "appkeymap.h" #define MYKEYCOUNT 7 far UBYTE deadmap[] = /* The data for the dead key (the introducer) */ { 0, '4', /* maps to '4' when keypad 4 is pressed alone */ DPF_DEAD, 1 /* maps to a dead key when shift is down */ }; far UBYTE deadablemap[] = { 0, '5', /* maps to '5' when keypad 5 is pressed alone */ DPF_MOD, 4, /* maps to a deadable key when shift is down */ '5', 0xC2, '5', '5', '5' /* Entry 1 in this table maps to 0xC2, the */ }; /* others map to '5'. */ far UBYTE doubledeadmap[] = { 0, '6', /* maps to '6' when keypad 6 is pressed alone */ DPF_DEAD, 1 | (2 lib_Version io_Command = CD_ASKKEYMAP; /* Obtain a copy of the */ conio->io_Data = (APTR) & defkeymap; /* shell console's KeyMap. */ conio->io_Length = sizeof (struct KeyMap); DoIO (conio); appkeymap = CreateAppKeyMap (&defkeymap); if (appkeymap == NULL) closeout ("Can't create keymap", RETURN_FAIL); /* If we get here, all went OK. We now have appkeymap and defkeymap, and */ /* conio IOStdRequest is init'd to talk to our shell's console device unit */ AlterAppKeyMap (appkeymap, mykeys, MYKEYCOUNT); conio->io_Command = CD_SETKEYMAP; /* Set the keymap for the console */ conio->io_Data = (APTR) appkeymap; /* to be the modified clone. */ conio->io_Length = sizeof (struct KeyMap); DoIO (conio); printf ("Appkeymap installed for this console.\n"); printf ("Changes for our keymap were specified in an array in appmap_demo.c\n\n"); printf ("Numeric pad 1 is now a repeatable and capsable string key. It\n"); printf (" also prints a different string for all qualifier combos.\n"); printf ("Numeric pad 2 is different chars if normal, shifted, alted, shift-alted.\n"); printf ("Numeric pad 3 is disabled.\n"); printf ("Shift-Numeric pad 4 is a dead-key. Shift-Numeric pad 5 is a deadable key.\n"); printf (" When you hit Shift-Numeric pad 4 then Shift-Numeric pad 5, this\n"); printf (" example prints '\302'\n"); printf ("Shift-Numeric pad 6 is a double dead-key. Shift-Numeric pad 7 is a deadable\n"); printf (" key. When you hit Shift-Numeric pad 6 once then Shift-Numeric pad 7,\n"); printf (" this example prints '\245'. When you hit Shift-Numeric pad 6 twice then\n"); printf (" Shift-Numeric pad 7, this example prints '\251'.\n"); printf ("\nHit return to exit when done\n"); getchar (); printf ("Setting this console back to default keymap\n"); conio->io_Command = CD_SETKEYMAP; /* Restore the shell's original keymap */ conio->io_Data = (APTR) & defkeymap; conio->io_Length = sizeof (struct KeyMap); DoIO (conio); closeall (); exit (rc); } struct IOStdReq * makeio (void) { struct MsgPort *conport; struct IOStdReq *ior = NULL; struct InfoData *id; struct Process *proc; proc = (struct Process *) FindTask (NULL); conport = (struct MsgPort *) proc->pr_ConsoleTask; if (!conport) return (NULL); if (id = (struct InfoData *) AllocMem (sizeof (struct InfoData), MEMF_PUBLIC | MEMF_CLEAR)) { if (DoPkt (conport, ACTION_DISK_INFO, ((ULONG) id) >> 2, 0L, 0L, 0L, 0L)) { if (replyport = CreateMsgPort ()) { if (ior = CreateIORequest (replyport, sizeof (struct IOStdReq))) { ior->io_Device = ((struct IOStdReq *) id->id_InUse)->io_Device; ior->io_Unit = ((struct IOStdReq *) id->id_InUse)->io_Unit; } } } FreeMem (id, sizeof (struct InfoData)); } return (ior); } void freeio (struct IOStdReq *ior) { if (ior) { if (ior->io_Message.mn_ReplyPort) DeleteMsgPort (ior->io_Message.mn_ReplyPort); DeleteIORequest (ior); } } void closeall () { if (conio) freeio (conio); if (appkeymap) DeleteAppKeyMap (appkeymap); } void closeout (UBYTE * errstring, LONG rc) { if (*errstring) printf ("%s\n", errstring); closeall (); exit (rc); } [Back to Amiga Developer Docs ]
