SOURCE: Includes_and_Autodocs_3._guide/node02A1.html
TITLE: graphics.library/AllocDBufInfo

graphics.library/AllocDBufInfo ]" border=0> NAME AllocDBufInfo -- Allocate structure for multi-buffered animation (V39) SYNOPSIS AllocDBufInfo(vp) a0 struct DBufInfo * AllocDBufInfo(struct ViewPort *) FUNCTION Allocates a structure which is used by the ChangeVPBitMap() routine. INPUTS vp = A pointer to a ViewPort structure. BUGS NOTES Returns 0 if there is no memory available or if the display mode of the viewport does not support double-buffering. The only fields of the DBufInfo structure which can be used by application programs are the dbi_SafeMessage, dbi_DispMessage, dbi_UserData1 and dbi_UserData2 fields. dbi_SafeMessage and dbi_DispMessage are standard exec message structures which may be used for synchronizing your animation with the screen update. dbi_SafeMessage is a message which is replied to when it is safe to write to the old BitMap (the one which was installed when you called ChangeVPBitMap). dbi_DispMessage is replied to when it is safe to call ChangeVPBitMap again and be certain that the new frame has been seen at least once. The dbi_UserData1 and dbi_UserData2 fields, which are stored after each message, are for your application to stuff any data into that it may need to examine when looking at the reply coming into the ReplyPort for either of the embedded Message structures. DBufInfo structures MUST be allocated with this function. The size of the structure will grow in future releases. The following fragment shows proper double buffering synchronization: int SafeToChange=TRUE, SafeToWrite=TRUE, CurBuffer=1; struct MsgPort *ports[2]; /* reply ports for DispMessage and SafeMessage */ struct BitMap *BmPtrs[2]; struct DBufInfo *myDBI; ... allocate bitmap pointers, DBufInfo , set up viewports, etc. myDBI->dbi_SafeMessage.mn_ReplyPort=ports[0]; myDBI->dbi_DispMessage.mn_ReplyPort=ports[1]; while (! done) { if (! SafeToWrite) while(! GetMsg(ports[0])) Wait(1l mp_SigBit)); SafeToWrite=TRUE; ... render to bitmap # CurBuffer. if (! SafeToChange) while(! GetMsg(ports[1])) Wait(1l mp_SigBit)); SafeToChange=TRUE; WaitBlit(); /* be sure rendering has finished */ ChangeVPBitMap(vp,BmPtrs[CurBuffer],myDBI); SafeToChange=FALSE; SafeToWrite=FALSE; CurBuffer ^=1; /* toggle current buffer */ } if (! SafeToChange) /* cleanup pending messages */ while(! GetMsg(ports[1])) Wait(1l mp_SigBit)); if (! SafeToWrite) /* cleanup */ while(! GetMsg(ports[0])) Wait(1l mp_SigBit)); SEE ALSO FreeDBufInfo() ChangeVPBitMap() [Back to Amiga Developer Docs ]
