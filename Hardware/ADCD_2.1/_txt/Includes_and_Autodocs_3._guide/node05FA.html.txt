SOURCE: Includes_and_Autodocs_3._guide/node05FA.html
TITLE: include/libraries/hdwrench.h

include/libraries/hdwrench.h ]" border=0> #ifndef LIBRARIES_HDWRENCH_H #define LIBRARIES_HDWRENCH_H /* ** $VER: hdwrench.h 44.3 (29.7.1999) ** Includes Release 44.1 ** ** Disk Prep Support Library API includes ** ** (C) Copyright 1999 Joanne B. Dow, Wizardess Designs, ** for license to Amiga, Inc. ** ** All Rights Reserved */ /*****************************************************************************/ #ifndef EXEC_LIBRARIES_H #include #endif #ifndef DEVICES_HARDBLOCKS_H #include #endif /*****************************************************************************/ struct HDWLibrary { struct Library ml_Lib; ULONG ml_SegList; ULONG ml_Flags; APTR ml_ExecBase; /* pointer to exec base */ long *ml_relocs; /* pointer to relocs. */ struct HDWLibrary *ml_origbase; /* pointer to original library base */ long ml_numjmps; }; #define HDWBaseName "hdwrench.library" /* === General Constant Defines === */ /* Artificial unassigned value for the RDB structures. */ #define UNASSIGNED (ULONG) -131L /* End block number link within RDB structures */ #define RDBEND (ULONG) -1L #define DEFAULT_RDBBLOCKSHI 63 /* === Structure & Typedefs === */ typedef struct { USHORT ready [ 16 ]; /* Tests ready and first block read */ USHORT there [ 16 ]; /* Tests as "there" but fails other tests */ } ValidIDstruct; /* Actual disk read write return structure: */ struct rw_return /* Should fit within a ULONG */ { USHORT success; /* Error code */ USHORT failed_word; /* 0 on reads. */ USHORT block_written; /* 0 on reads. */ }; enum rw_success_val /* Return values for rw_return.success field. */ { success = 0, /* 0 */ success_on_retry_write, /* 1 */ success_on_retry_read, /* 2 */ failed_on_write, /* 3 */ failed_on_reread, /* 4 */ illegal_command, /* 5 */ io_command_failure, /* 6 */ scsi_command_failure, /* 7 */ out_of_memory, /* 8 */ no_more_disk_blocks, /* 9 */ rdsk_not_located, /* 10 */ io_device_not_open, /* 11 */ invalid_blocksize_found, /* 12 */ no_callback_hook, /* 13 */ user_aborted, /* 14 */ operation_not_permitted /* 15 */ }; /* Internal bootblock structure. Create dummy structures to pass to read * and write functions as necessary. Be sure that bb_BlockNum is filled in * and that the actual size of the data area pointed to by the union is * sufficiently large to contain one disk block. */ typedef struct bootblock { struct MinNode bb_Node; LONG allocsize; LONG bb_BlockNum; WORD bb_Changed; LONG unit; /* Unit number for THIS set of RDBs. */ char DeviceName [32]; /* Device name */ struct rw_return bb_RWErrors; BOOL wflag; /* Written out flag. */ BYTE spares[4-sizeof(BOOL)];/* Fill out short word */ union { struct RigidDiskBlock bd_RDB; struct PartitionBlock bd_PB; struct FileSysHeaderBlock bd_FHB; struct LoadSegBlock bd_LSB; struct BadBlockBlock bd_BB; UBYTE bd_Bytes[512]; /* NB: This is the MINIMUM size we */ UWORD bd_Words[256]; /* can have here. It MAY be extended */ ULONG bd_Longs[128]; /* if actual block size is larger. */ } bb_Data; } BootBlock; /* ==== Error report values for other functions ==== */ #define E_NOERROR 0 #define E_ILLEGAL_SLASH 200 #define E_EOF_IN_COMMENT 201 #define E_ILLEGAL_STAR 202 #define E_TOKEN_TO_LONG 203 #define E_MEMORY_PANIC 204 #define E_PREMATURE_EOF 205 #define E_MISSING_EQUALS 206 #define E_ILLEGAL_T_F 207 #define E_ILLEGAL_TOKEN 208 #define E_DUPLICATE_DISK 209 #define E_NOT_LEGAL_NAME 210 #define E_EXCEEDED_SIZE_LIM 211 #define E_FILE_WRITE_ERROR 212 #define E_TOOMANY_FS 213 #define E_FSAVE_CONFUSION 214 #define E_FS_CANNOT_OPEN 215 #define E_LOST_IN_RDB_SPACE 216 #define E_FS_WRITE_ERROR 217 #define E_MULTIPLE_RDSKS 218 #define E_RDSK_NOT_1ST 219 #define E_NO_RDBS_LOADED 220 #define E_RDBS_ALREADY_IN 221 /* RDBs already loaded. */ #define E_FAILED_FILEOPEN 222 #define E_FILE_READ_FAILED 223 #define E_FILE_NOT_RDBS 224 #define E_NO_BLOCKSIZE_SPEC 225 #define E_FILE_WRITE_FAILED 226 #define E_MEMORYP_NULL 227 /* prospective "memp" is null */ #define E_ILLEGAL_BLOCKSIZE 228 #define E_INSUFFICIENT_MEM 229 #define E_RENUMBER_FAILED 230 #define E_BLOCKS_EXCEEDED 231 /* Too many RDB blocks */ #define E_INCOMPLETE_FSDESC 232 #define E_FS_NOT_FOUND 233 #define E_LIST_SCREWEDUP 234 #define E_NO_SUCH_DIR 235 #define E_EXALL_ERROR 236 #define E_UNIT_DIFFERS 237 #define T_RENUMBER_LEFT 300 #define W_DUPLICATE_FS 100 #define W_FS_NO_WRITE 101 /* Definitions for type field in FileSave */ #define DRIVEINIT 0 #define FILESYSTEM 1 struct DefaultsArray { ULONG TotalBlocks; UWORD BytesPerBlock; UWORD BlocksPerSurface; UWORD Surfaces; UWORD Cylinders; /* note: MaxCyl = Cylinders - 1; */ UWORD UnusedBlocks; }; /* Defaults Array filling error bit array */ #define DA_NOERRORS 0 #define DA_NO_CAPACITY_REPORT 1 #define DA_NO_OPTIMIZE 2 #define DA_BAD_MODESENSE_4 4 #define DA_BAD_MODESENSE_3 8 #define DA_FAILED 256 #define DA_NO_DRIVE_OPEN DA_FAILED #define DA_RIDICULOUS_VALUES ( DA_FAILED [Back to Amiga Developer Docs ]
