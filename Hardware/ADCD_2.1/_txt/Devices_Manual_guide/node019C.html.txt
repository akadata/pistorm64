SOURCE: Devices_Manual_guide/node019C.html
TITLE: Devices/Dev_examples/Track_Copy.c

Devices/Dev_examples/Track_Copy.c ]" border=0> /* * Track_Copy.c * * This program does a track by track copy from one drive to another * * Compile with SAS C 5.10 LC -cfist -ms -v -L * * This program will only run from the CLI. If started from * the workbench, it will just exit... * * Usage: trackcopy dfx dfy */ #include #include #include #include */ #include #include #include #include #include #ifdef LATTICE int CXBRK(void) { return(0); } /* Disable SAS CTRL/C handling */ int chkabort(void) { return(0); } /* really */ #endif #define TRACK_SIZE ((LONG)(NUMSECS * TD_SECTOR)) /* * Turn the BUSY flag off/on for the drive * If onflag is TRUE, the disk will be marked as busy... * * This is to stop the validator from executing while * we are playing with the disks. */ VOID disk_busy(UBYTE *drive,LONG onflag) { struct StandardPacket *pk; struct Process *tsk; tsk=(struct Process *)FindTask(NULL); if (pk=AllocMem(sizeof(struct StandardPacket),MEMF_PUBLIC|MEMF_CLEAR)) { pk->sp_Msg.mn_Node.ln_Name=(UBYTE *)&(pk->sp_Pkt); pk->sp_Pkt.dp_Link=&(pk->sp_Msg); pk->sp_Pkt.dp_Port=&(tsk->pr_MsgPort); pk->sp_Pkt.dp_Type=ACTION_INHIBIT; pk->sp_Pkt.dp_Arg1=(onflag ? -1L : 0L); PutMsg(DeviceProc(drive),(struct Message *)pk); WaitPort(&(tsk->pr_MsgPort)); GetMsg(&(tsk->pr_MsgPort)); FreeMem(pk,(long)sizeof(*pk)); } } /* * This turns the motor off */ VOID Motor_Off(struct IOExtTD *disk) { disk->iotd_Req.io_Length=0; disk->iotd_Req.io_Command=TD_MOTOR; DoIO((struct IORequest *)disk); } /* * This turns the motor on */ VOID Motor_On(struct IOExtTD *disk) { disk->iotd_Req.io_Length=1; disk->iotd_Req.io_Command=TD_MOTOR; DoIO((struct IORequest *)disk); } /* * This reads a track, reporting any errors... */ SHORT Read_Track(struct IOExtTD *disk,UBYTE *buffer,SHORT track) { SHORT All_OK=TRUE; disk->iotd_Req.io_Length=TRACK_SIZE; disk->iotd_Req.io_Data=(APTR)buffer; disk->iotd_Req.io_Command=CMD_READ; disk->iotd_Req.io_Offset=(ULONG)(TRACK_SIZE * track); DoIO((struct IORequest *)disk); if (disk->iotd_Req.io_Error) { All_OK=FALSE; printf("Error %u when reading track %d",disk->iotd_Req.io_Error,track); } return(All_OK); } /* * This writes a track, reporting any errors... */ SHORT Write_Track(struct IOExtTD *disk,UBYTE *buffer,SHORT track) { SHORT All_OK=TRUE; disk->iotd_Req.io_Length=TRACK_SIZE; disk->iotd_Req.io_Data=(APTR)buffer; disk->iotd_Req.io_Command=TD_FORMAT; disk->iotd_Req.io_Offset=(ULONG)(TRACK_SIZE * track); DoIO((struct IORequest *)disk); if (disk->iotd_Req.io_Error) { All_OK=FALSE; printf("Error %d when writing track %d",disk->iotd_Req.io_Error,track); } return(All_OK); } /* * This function finds the number of TRACKS on the device. * NOTE That this is TRACKS and not cylinders. On a Two-Head * drive (such as the standard 3.5" drives) the number of tracks * is 160, 80 cylinders, 2-heads. */ SHORT FindNumTracks(struct IOExtTD *disk) { disk->iotd_Req.io_Command=TD_GETNUMTRACKS; DoIO((struct IORequest *)disk); return((SHORT)disk->iotd_Req.io_Actual); } /* * This routine allocates the memory for one track and does * the copy loop. */ VOID Do_Copy(struct IOExtTD *diskreq0,struct IOExtTD *diskreq1) { UBYTE *buffer; SHORT track; SHORT All_OK; SHORT NumTracks; if (buffer=AllocMem(TRACK_SIZE,MEMF_CHIP|MEMF_PUBLIC)) { printf(" Starting Motors\r"); Motor_On(diskreq0); Motor_On(diskreq1); All_OK=TRUE; NumTracks=FindNumTracks(diskreq0); for (track=0;(track = '0' && argv[j][2] [Back to Amiga Developer Docs ]
