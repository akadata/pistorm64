Devices/Dev_examples/SCSI_Direct.c ]" border=0> /* * SCSI_Direct.c * * The following program demonstrates the use of the HD_SCSICmd to send a * MODE SENSE to a unit on the requested device (default scsi.device). This * code can be easily modified to send other commands to the drive. * * Compile with SAS C 5.10 lc -b1 -cfistq -v -y -L * * Run from CLI only */ #include #include #include #include #include #include #include #include #include #ifdef LATTICE int CXBRK(void) { return(0); } /* Disable SAS CTRL/C handling */ int chkabort(void) { return(0); } /* really */ #endif #define BUFSIZE 256 UBYTE *buffer; /* a data buffer used for mode sense data */ struct IOStdReq SCSIReq; /* a standard IORequest structure */ struct SCSICmd Cmd; /* where the actual SCSI command goes */ UBYTE Sense[20]; /* buffer for request sense data */ struct MsgPort Port; /* our ReplyPort */ void ShowSenseData(void); static UBYTE TestReady[] = { 0,0,0,0,0,0 }; /* not used but here for */ static UBYTE StartUnit[] = { 0x1b,0,0,0,1,0 }; /* illustration of other */ static UBYTE StopUnit[] = { 0x1b,0,0,0,0,0 }; /* commands. */ static UBYTE ModeSense[]={ 0x1a,0,0xff,0,254,0 }; /* the command being sent */ void main(int argc, char **argv) { int unit,tval,i; char *dname = "scsi.device"; UBYTE *tbuf; if ((argc 3)) { printf("Usage: %s unit [xxxx.device]\n",argv[0]); exit(100); } unit = atoi( argv[1] ); if (argc == 3) dname = argv[2]; buffer = (UBYTE *) AllocMem(BUFSIZE, MEMF_PUBLIC|MEMF_CLEAR); if (!buffer) { printf("Couldn't get memory\n"); exit(100); } Port.mp_Node.ln_Pri = 0; /* setup the ReplyPort */ Port.mp_SigBit = AllocSignal(-1); Port.mp_SigTask = (struct Task *)FindTask(0); NewList( &(Port.mp_MsgList) ); SCSIReq.io_Message.mn_ReplyPort = &Port; if (OpenDevice( dname, unit, &SCSIReq, 0)) { printf("Couldn't open unit %ld on %s\n",unit,dname); FreeMem( buffer,BUFSIZE ); exit(100); } SCSIReq.io_Length = sizeof(struct SCSICmd); SCSIReq.io_Data = (APTR)&Cmd; SCSIReq.io_Command = HD_SCSICMD; /* the command we are sending */ Cmd.scsi_Data = (UWORD *)buffer; /* where we put mode sense data */ Cmd.scsi_Length = 254; /* how much we will accept */ Cmd.scsi_CmdLength = 6; /* length of the command */ Cmd.scsi_Flags = SCSIF_AUTOSENSE|SCSIF_READ; /* do automatic REQUEST_SENSE */ /* set expected data direction */ Cmd.scsi_SenseData =(UBYTE *)Sense; /* where sense data will go */ Cmd.scsi_SenseLength = 18; /* how much we will accept */ Cmd.scsi_SenseActual = 0; /* how much has been received */ Cmd.scsi_Command=(UBYTE *)ModeSense;/* issuing a MODE_SENSE command */ DoIO( &SCSIReq ); /* send it to the device driver */ if (Cmd.scsi_Status) ShowSenseData(); /* if bad status then show it */ else { printf("\nBlock descriptor header\n"); printf("=======================\n"); printf("Mode Sense data length = %d\n",(short)buffer[0]); printf("Block descriptor length = %d\n",(short)buffer[3]); tbuf = &buffer[4]; printf("Density code = %d\n",(short)tbuf[0]); tval = (tbuf[1] >1)&1); printf("POST ERROR = %d\n",(short)(tbuf[2]>>2)&1); printf("ENABLE EARLY CORRECTION = %d\n",(short)(tbuf[2]>>3)&1); printf("READ CONTINUOUS = %d\n",(short)(tbuf[2]>>4)&1); printf("TRANSFER BLOCK = %d\n",(short)(tbuf[2]>>5)&1); printf("AUTO READ REALLOCATION = %d\n",(short)(tbuf[2]>>6)&1); printf("AUTO WRITE REALLOCATION = %d\n",(short)(tbuf[2]>>7)&1); printf("Retry count = %d\n",(short)tbuf[3]); printf("Correction span = %d\n",(short)tbuf[4]); printf("Head offset count = %d\n",(short)tbuf[5]); printf("Data strobe offset count= %d\n",(short)tbuf[6]); printf("Recovery time limit = %d\n",(short)tbuf[7]); tbuf += tbuf[1]+2; break; case 2: printf("\nDisconnect/Reconnect Control\n"); printf("============================\n"); printf("Page length = %d\n",(short)tbuf[1]); printf("Buffer full ratio = %d\n",(short)tbuf[2]); printf("Buffer empty ratio = %d\n",(short)tbuf[3]); tval = (tbuf[4] [Back to Amiga Developer Docs ]