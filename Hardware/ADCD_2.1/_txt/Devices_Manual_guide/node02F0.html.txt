SOURCE: Devices_Manual_guide/node02F0.html
TITLE: Devices/iffp/ilbm.h

Devices/iffp/ilbm.h ]" border=0> /* * * ilbm.h: Definitions for IFFParse ILBM reader. * * 6/27/91 */ #ifndef IFFP_ILBM_H #define IFFP_ILBM_H #ifndef IFFP_IFF_H #include "iffp/iff.h" #endif #ifndef INTUITION_INTUITION_H #include #endif #ifndef GRAPHICS_VIDEOCONTROL_H #include #endif #ifndef NO_PROTOS #include #include #include #endif /* IFF types we may encounter */ #define ID_ILBM MAKE_ID('I','L','B','M') /* ILBM Chunk ID's we may encounter * (see iffp/iff.h for some other generic chunks) */ #define ID_BMHD MAKE_ID('B','M','H','D') #define ID_CMAP MAKE_ID('C','M','A','P') #define ID_CRNG MAKE_ID('C','R','N','G') #define ID_CCRT MAKE_ID('C','C','R','T') #define ID_GRAB MAKE_ID('G','R','A','B') #define ID_SPRT MAKE_ID('S','P','R','T') #define ID_DEST MAKE_ID('D','E','S','T') #define ID_CAMG MAKE_ID('C','A','M','G') /* Use this constant instead of sizeof(ColorRegister). */ #define sizeofColorRegister 3 typedef WORD Color4; /* Amiga RAM version of a color-register, * with 4 bits each RGB in low 12 bits.*/ /* Maximum number of bitplanes storable in BitMap structure */ #define MAXAMDEPTH 8 #define MAXAMCOLORREG 32 /* Maximum planes we can save */ #define MAXSAVEDEPTH 24 /* convert width to BytesPerRow */ #define BytesPerRow(w) ((w) + 15 >> 4 > 4 > 4) > 4" won't sign extend.*/ } ColorRegister; /* ---------- Point2D --------------------------------------------------*/ /* A Point2D is stored in a GRAB chunk. */ typedef struct { WORD x, y; /* coordinates (pixels) */ } Point2D; /* ---------- DestMerge ------------------------------------------------*/ /* A DestMerge is stored in a DEST chunk. */ typedef struct { UBYTE depth; /* # bitplanes in the original source */ UBYTE pad1; /* UNUSED; for consistency store 0 here */ UWORD planePick; /* how to scatter source bitplanes into destination */ UWORD planeOnOff; /* default bitplane data for planePick */ UWORD planeMask; /* selects which bitplanes to store into */ } DestMerge; /* ---------- SpritePrecedence -----------------------------------------*/ /* A SpritePrecedence is stored in a SPRT chunk. */ typedef UWORD SpritePrecedence; /* ---------- Camg Amiga Viewport Mode ---------------------------------*/ /* A Commodore Amiga ViewPort->Modes is stored in a CAMG chunk. */ /* The chunk's content is declared as a LONG. */ typedef struct { ULONG ViewModes; } CamgChunk; /* ---------- CRange cycling chunk -------------------------------------*/ #define RNG_NORATE 36 /* Dpaint uses this rate to mean non-active */ /* A CRange is store in a CRNG chunk. */ typedef struct { WORD pad1; /* reserved for future use; store 0 here */ WORD rate; /* 60/sec=16384, 30/sec=8192, 1/sec=16384/60=273 */ WORD active; /* bit0 set = active, bit 1 set = reverse */ UBYTE low, high; /* lower and upper color registers selected */ } CRange; /* ---------- Ccrt (Graphicraft) cycling chunk -------------------------*/ /* A Ccrt is stored in a CCRT chunk. */ typedef struct { WORD direction; /* 0=don't cycle, 1=forward, -1=backwards */ UBYTE start; /* range lower */ UBYTE end; /* range upper */ LONG seconds; /* seconds between cycling */ LONG microseconds; /* msecs between cycling */ WORD pad; /* future exp - store 0 here */ } CcrtChunk; /* If you are writing all of your chunks by hand, * you can use these macros for these simple chunks. */ #define putbmhd(iff, bmHdr) \ PutCk(iff, ID_BMHD, sizeof(BitMapHeader), (BYTE *)bmHdr) #define putgrab(iff, point2D) \ PutCk(iff, ID_GRAB, sizeof(Point2D), (BYTE *)point2D) #define putdest(iff, destMerge) \ PutCk(iff, ID_DEST, sizeof(DestMerge), (BYTE *)destMerge) #define putsprt(iff, spritePrec) \ PutCk(iff, ID_SPRT, sizeof(SpritePrecedence), (BYTE *)spritePrec) #define putcamg(iff, camg) \ PutCk(iff, ID_CAMG, sizeof(CamgChunk),(BYTE *)camg) #define putcrng(iff, crng) \ PutCk(iff, ID_CRNG, sizeof(CRange),(BYTE *)crng) #define putccrt(iff, ccrt) \ PutCk(iff, ID_CCRT, sizeof(CcrtChunk),(BYTE *)ccrt) #ifndef NO_PROTOS /* unpacker.c */ BOOL unpackrow(BYTE **pSource, BYTE **pDest, WORD srcBytes0, WORD dstBytes0); /* packer.c */ LONG packrow(BYTE **pSource, BYTE **pDest, LONG rowSize); /* ilbmr.c ILBM reader routines */ LONG loadbody(struct IFFHandle *iff, struct BitMap *bitmap, BitMapHeader *bmhd); LONG loadbody2(struct IFFHandle *iff, struct BitMap *bitmap, BYTE *mask, BitMapHeader *bmhd, BYTE *buffer, ULONG bufsize); LONG loadcmap(struct IFFHandle *, WORD *colortable, USHORT *pNcolors); LONG getcolors(struct ILBMInfo *ilbm); void freecolors(struct ILBMInfo *ilbm); LONG alloccolortable(struct ILBMInfo *ilbm); ULONG getcamg(struct ILBMInfo *ilbm); /* ilbmw.c ILBM writer routines */ long initbmhd(BitMapHeader *bmhd, struct BitMap *bitmap, WORD masking, WORD compression, WORD transparentColor, WORD width, WORD height, WORD pageWidth, WORD pageHeight, ULONG modeid); long putcmap(struct IFFHandle *iff,APTR colortable,UWORD ncolors,UWORD bitspergun); long putbody(struct IFFHandle *iff, struct BitMap *bitmap, BYTE *mask, BitMapHeader *bmHdr, BYTE *buffer, LONG bufsize); /* getdisplay.c (used to load a display) */ LONG showilbm(struct ILBMInfo *ilbm, UBYTE *filename); void unshowilbm(struct ILBMInfo *ilbm); LONG createdisplay(struct ILBMInfo *); void deletedisplay(struct ILBMInfo *); LONG getdisplay(struct ILBMInfo *); void freedisplay(struct ILBMInfo *); /* getbitmap.c (used if just loading brush or bitmap) */ LONG createbrush(struct ILBMInfo *); void deletebrush(struct ILBMInfo *); LONG getbitmap(struct ILBMInfo *); void freebitmap(struct ILBMInfo *); /* screen.c (opens 1.3 or 2.0 screen) */ struct Screen *openidscreen(struct ILBMInfo *,SHORT,SHORT,SHORT,ULONG); struct Window *opendisplay(struct ILBMInfo *,SHORT,SHORT,SHORT,ULONG); ULONG modefallback(ULONG, SHORT, SHORT, SHORT); void clipit(SHORT wide, SHORT high, struct Rectangle *spos, struct Rectangle *dclip, struct Rectangle *txto, struct Rectangle *stdo,struct Rectangle *maxo, struct Rectangle * uclip); void closedisplay(struct ILBMInfo *); void modeErrorMsg(ULONG,ULONG); /* loadilbm.c */ LONG loadbrush(struct ILBMInfo *ilbm, UBYTE *filename); void unloadbrush(struct ILBMInfo *ilbm); LONG queryilbm(struct ILBMInfo *ilbm, UBYTE *filename); LONG loadilbm(struct ILBMInfo *ilbm, UBYTE *filename); void unloadilbm(struct ILBMInfo *ilbm); /* saveilbm.c */ LONG screensave(struct ILBMInfo *ilbm, struct Screen *scr, struct Chunk *chunklist1, struct Chunk *chunklist2, UBYTE *filename); LONG saveilbm(struct ILBMInfo *ilbm, struct BitMap *bitmap, ULONG modeid, WORD width, WORD height, WORD pagewidth, WORD pageheight, APTR colortable, UWORD count, UWORD bitspergun, WORD masking, WORD transparentColor, struct Chunk *chunklist1, struct Chunk *chunklist2, UBYTE *filename); /* screendump.c (print screen or brush) */ int screendump(struct Screen *scr, UWORD srcx, UWORD srcy, UWORD srcw, UWORD srch, LONG destcols, UWORD special); /* bmprintc.c (write C source for ILBM) */ void BMPrintCRep(struct BitMap *bm, FILE *fp, UBYTE *name, UBYTE *fmt); #endif /* NO_PROTOS */ #endif /* IFFP_ILBM_H */ [Back to Amiga Developer Docs ]
