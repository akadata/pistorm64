SOURCE: Hardware_Manual_guide/node0121.html
TITLE: 6 Blitter Hardware / Copying Arbitrary Regions

6 Blitter Hardware / Copying Arbitrary Regions ]" border=0> One of the most common uses of the blitter is to move arbitrary rectangles of data from one bitplane to another, or to different positions within a bitplane. These rectangles are usually on arbitrary bit coordinates, so shifting and masking are necessary. There are further complications. It may take several readings and some experimentation before everything in this section can be understood. A source image that spans only two words may, when copied with certain shifts , span three words. Our 23 pixel wide rectangle above, for instance, when shifted 12 bits, will span three words. Alternatively, an image spanning three words may fit in two for certain shifts . Under all such circumstances, the blit size should be set to the larger of the two values, such that both source and destination will fit within the blit size. Proper masking should be applied to mask out unwanted data. Some general guidelines for copying an arbitrary region are as follows. 1. Use the A DMA channel , disabled, preloaded with all ones and the appropriate mask and shift values , to mask the cookie-cut function. Use the B channel to fetch the source data, the C channel to fetch the destination data, and the D channel to write the destination data. Use the cookie-cut function $CA. 2. If shifting , always use ascending mode if bit shifting to the right, and use descending mode if bit shifting to the left. NOTE: ----- These shifts are the shifts of the bit position of the leftmost edge within a word, rather than absolute shifts , as explained previously. 3. If the source and destination overlap, use ascending mode if the destination has a lower memory address (is higher on the display) and descending mode otherwise. 4. If the source spans more words than the destination, use the same shift value for the A channel as for the source B channel and set the first and last word masks as if they were masking the B source data. 5. If the destination spans more words than the source, use a shift value of zero for the A channel and set the first and last word masks as if they were masking the destination D data. 6. If the source and destination span the same number of words, use the A channel to mask either the source, as in 4, or the destination, as in 5. Warning: -------- Conditions 2 and 3 can be contradictory if, for instance, you are trying to move an image one pixel down and to the right. In this case, we would want to use descending mode so our destination does not overwrite our source before we use the source, but we would want to use ascending mode for the right shift . In some situations, it is possible to get around general guideline 2 above with clever masking . But occasionally just masking the first or last word may not be sufficient; it may be necessary to mask more than 16 bits on one or the other end. In such a case, a mask can be built in memory for a single raster row, and the A DMA channel enabled to explicitly fetch this mask. By setting the A modulo value to the negative of the width of the mask, the mask will be repeatedly fetched for each row. [Back to Amiga Developer Docs ]
