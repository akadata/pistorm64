SOURCE: Libraries_Manual_guide/node0403.html
TITLE: 31 Commodities Exchange Library / CxMessages

31 Commodities Exchange Library / CxMessages ]" border=0> There are actually two types of CxMessages. The first, CXM_IEVENT , corresponds to an input event and travels through the Commodities Exchange network. The other type, CXM_COMMAND , carries a command to a commodity. A CXM_COMMAND normally comes from the controller program and is used to pass user commands on to a commodity. A commodity receives these commands through an Exec message port that the commodity sets up before it calls CxBroker() . The NewBroker 's nb_Port field points to this message port. A commodity can tell the difference between the two types of CxMessages by calling the CxMsgType() function. ULONG CxMsgType( CxMsg *cxm ); UBYTE *CxMsgData( CxMsg *cxm ); LONG CxMsgID ( CxMsg *cxm ); A CxMessage not only has a type, it can also have a data pointer as well as an ID associated with it. The data associated with a CXM_IEVENT CxMessage is an InputEvent structure. By using the CxMsgData() function, a commodity can obtain a pointer to the corresponding InputEvent of a CXM_IEVENT message. Commodities Exchange gives an ID of zero to any CXM_IEVENT CxMessage that it introduces to the Commodities network but certain CxObjects can assign an ID to them. For a CXM_COMMAND CxMessages, the data pointer is generally not used but the ID specifies a command passed to the commodity from the user operating the controller program. The CxMsgID() macro extracts the ID from a CxMessage. A Simple Commodity Example Controller Commands Shutting Down the Commodity [Back to Amiga Developer Docs ]
