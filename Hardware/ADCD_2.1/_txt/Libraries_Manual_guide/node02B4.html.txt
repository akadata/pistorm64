SOURCE: Libraries_Manual_guide/node02B4.html
TITLE: 20 / Allocating Multiple Memory / Multiple Memory Blocks and Tasks

20 / Allocating Multiple Memory / Multiple Memory Blocks and Tasks ]" border=0> If you want to take advantage of Exec's automatic cleanup, use the MemList and AllocEntry() facility to do your dynamic memory allocation. In the Task control block structure, there is a list header named tc_MemEntry . This is the list header that you initialize to include MemList s that your task has created by call(s) to AllocEntry() . Here is a short program segment that handles task memory list header initialization only. It assumes that you have already run AllocEntry() as shown in the simple AllocEntry() example above. struct Task *tc; struct MemList *ml; /* First initialize the task pointer and AllocEntry() the memlist ml */ if(!tc->tc_MemEntry) NewList(tc->tc_MemEntry); /* Initialize the task's memory */ /* list header. Do this once only! */ AddTail(tc->tc_MemEntry, ml); Assuming that you have only used the AllocEntry() method (or AllocMem() and built your own custom MemList ), the system now knows where to find the blocks of memory that your task has dynamically allocated. The RemTask() function automatically frees all memory found on tc_MemEntry . CreateTask() Sets Up A MemList . ------------------------------- The amiga.lib CreateTask() function, and other system task and process creation functions use a MemList in tc_MemEntry so that the Task structure and stack will be automatically deallocated when the Task is removed. [Back to Amiga Developer Docs ]
