SOURCE: Libraries_Manual_guide/node0346.html
TITLE: 27 / Advanced Topics / Creating a Double-Buffered Display

27 / Advanced Topics / Creating a Double-Buffered Display ]" border=0> To produce smooth animation or similar effects, it is occasionally necessary to double-buffer your display. To prevent the user from seeing your graphics rendering while it is in progress, you will want to draw into one memory area while actually displaying a different area. There are two methods of creating and displaying a double-buffered display. The simplest method is to create two complete Views and switch back and forth between them with LoadView() and WaitTOF() . The second method consists of creating two separate display areas and two sets of pointers to those areas for a single View . This is more complicated but takes less memory. * Allocate one ViewPort structure and one View structure. * Allocate two BitMap structures and one RasInfo structure. Initialize each BitMap structure to describe one drawing area and allocate memory for the bitplanes themselves. Initialize the RasInfo structure, setting the RasInfo.BitMap field to the address of one of the two BitMaps you created. * Call MakeVPort() , MrgCop() and LoadView() . When you call MrgCop(), the system uses the information you have provided to create a Copper instruction list for the Copper to execute. The system allocates memory for a long-frame (LOF) Copper list and, if this is an interlaced display, a short-frame (SHF) Copper list as well. The system places a pointer to the long-frame Copper list in View.LOFCprList and a pointer to a short-frame Copper list (if this is an interlaced display) in View.SHFCprList . The Copper instruction stream referenced by these pointers applies to the first BitMap . * Save the values in View.LOFCprList and View.SHFCprlist and reset these fields to zero. Place a pointer to the second BitMap structure in the RasInfo.BitMap field. Next call MakeVPort() and MrgCop() . * When you perform MrgCop() with the Copper instruction list fields of the View set to zero, the system automatically allocates and fills in a new list of instructions for the Copper. Now you have created two sets of instruction streams for the Copper, one that works with data in the first BitMap and the other that works with data in the second BitMap. * You can save pointers to the second list of Copper instructions as well. Then, to perform the double-buffering, alternate between the two Copper lists. The code for the double-buffering loop would be as follows: call WaitTOF() , change the Copper instruction list pointers in the View , call LoadView() to show one of the BitMap s while drawing into the other BitMap, and repeat. Remember that you will have to call FreeCprList() on both sets of Copper lists when you have finished. [Back to Amiga Developer Docs ]
