SOURCE: Libraries_Manual_guide/node047F.html
TITLE: 35 / FFP Basic Mathematics Library / FFP Basic Functions

35 / FFP Basic Mathematics Library / FFP Basic Functions ]" border=0> SPAbs() FLOAT SPAbs( FLOAT parm ); Take absolute value of FFP variable. SPAdd() FLOAT SPAdd( FLOAT leftParm, FLOAT rightParm); Add two FFP variables. SPCeil() FLOAT SPCeil( FLOAT parm ); Computer largest integer less than or equal to variable. SPCmp() LONG SPCmp( FLOAT leftParm, FLOAT rightParm); Compare two FFP variables. SPDiv() FLOAT SPDiv( FLOAT leftParm, FLOAT rightParm); Divide two FFP variables. SPFix() LONG SPFix( FLOAT parm ); Convert FFP variable to integer. SPFloor() FLOAT SPFloor( FLOAT parm ); Compute least integer greater than or equal to variable. SPFlt() FLOAT SPFlt( long integer ); Convert integer variable to FFP. SPMul() FLOAT SPMul( FLOAT leftParm, FLOAT rightParm); Multiply two FFP variables. SPNeg() FLOAT SPNeg( FLOAT parm ); Take two's complement of FFP variable. SPSub() FLOAT SPSub( FLOAT leftParm, FLOAT rightParm); Subtract two FFP variables. SPTst() LONG SPTst( FLOAT parm ); Test an FFP variable against zero. Be sure to include the proper data type definitions shown below. #include #include #include struct Library *MathBase; VOID main() { FLOAT f1, f2, f3; LONG i1; if (MathBase = OpenLibrary("mathffp.library", 0)) { i1 = SPFix(f1); /* Call SPFix entry */ f1 = SPFlt(i1); /* Call SPFlt entry */ if (SPCmp(f1,f2)) {}; /* Call SPCmp entry */ if (!(SPTst(f1))) {}; /* Call SPTst entry */ f1 = SPAbs(f2); /* Call SPAbs entry */ f1 = SPNeg(f2); /* Call SPNeg entry */ f1 = SPAdd(f2, f3); /* Call SPAdd entry */ f1 = SPSub(f2, f3); /* Call SPSub entry */ f1 = SPMul(f2, f3); /* Call SPMul entry */ f1 = SPDiv(f2, f3); /* Call SPDiv entry */ f1 = SPCeil(f2); /* Call SPCeil entry */ f1 = SPFloor(f2); /* Call SPFloor entry */ CloseLibrary(MathBase); } else printf("Can't open mathffp.library\n"); } The assembly language interface to the FFP basic math routines is shown below, including some details about how the system flags are affected by each operation. The access mechanism is: MOVEA.L _MathBase,A6 JSR _LVOSPFix(A6) __________________________________________________________________ | | | FFP Basic Assembly Functions | | | | Function Input Output Condition Codes | |__________________________________________________________________| | | | | | | _LVOSPAbs | D0=FFP arg | D0=FFP absolute | N=0 | | | | value | Z=1 if result | | | | | is zero | | | | | V=0 | | | | | C=undefined | | | | | X=undefined | |-------------|-------------|--------------------|-----------------| | _LVOSPAdd | D1=FFP arg1 | D0=FFP addition | N=1 if result | | | D0=FFP arg2 | of arg1 + arg2 | is negative | | | | | Z=1 if result | | | | | is zero | | | | | V=1 if result | | | | | overflowed | | | | | C=undefined | | | | | Z=undefined | |-------------|-------------|--------------------|-----------------| | _LVOSPCeil | D0=FFP arg | D0=least integer | N=1 if result | | | | >=arg | is negative | | | | | Z=1 if result | | | | | is zero | | | | | V=undefined | | | | | C=undefined | | | | | Z=undefined | |-------------|-------------|--------------------|-----------------| | _LVOSPCmp | D1=FFP arg1 | D0=+1 if arg1>arg2 | N=0 | | | D0=FFP arg2 | D0=-1 if arg1 arg1 | | | | | GE=arg2>=arg1 | | | | | EQ=arg2=arg1 | | | | | NE=arg2<>arg1 | | | | | LT=arg2 0.0 | N=1 if result | | | | D0=-1 if arg 0.0 | | | trashes the | | PL=arg>=0.0 | | | arg in D1. | | MI=arg [Back to Amiga Developer Docs ]
