<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/34.11 FILE="Devices/modules/bmprintc.c" NODE="MAIN" TITLE="Devices/modules/bmprintc.c" -->
<head>
<title>Devices/modules/bmprintc.c</title>
</head>
<body>
<img src="../images/toc_d.gif" alt="[Contents]">
<img src="../images/index_d.gif" alt="[Index]">
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../Devices_Manual_guide/node02FF.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../Devices_Manual_guide/node0301.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
/*--------------------------------------------------------------*/
/*								*/
/*			bmprintc.c				*/
/*								*/
/* print out a C-language representation of data for bitmap	*/
/*								*/
/* By Jerry Morrison and Steve Shaw, Electronic Arts.		*/
/* This software is in the public domain.			*/
/*								*/
/* This version for the Amiga computer.				*/
/* Cleaned up and modified a bit by Chuck McManis, Aug 1988	*/
/* Modified 05/91 by CBM for use with iffparse modules          */
/*								*/
/*--------------------------------------------------------------*/

#include &#034;iffp/ilbmapp.h&#034;
#include &#060;stdio.h&#062;

#define NO  0
#define YES 1

void PSprite(struct BitMap *bm, FILE *fp, UBYTE *name, int p, BOOL dohead);
void PrCRLF(FILE *fp);
void PrintBob(struct BitMap *bm, FILE *fp, UBYTE *name);
void PrintSprite(struct BitMap *bm, FILE *fp, UBYTE *name,
		 BOOL attach, BOOL dohdr);

static BOOL doCRLF;
char sp_colors[] = &#034;.oO@&#034;;

void PrCRLF(FILE *fp)
{
	if (doCRLF)
		fprintf(fp, &#034;%c%c&#034;, 0xD, 0xA);
	else
		fprintf(fp, &#034;\n&#034;);
}

void PrintBob(struct BitMap *bm, FILE *fp, UBYTE *name)
{
	register UWORD 	*wp;	/* Pointer to the bitmap data */

	short 	p,i,j,nb;	/* temporaries */
	short 	nwords = (bm-&#062;BytesPerRow/2)*bm-&#062;Rows;

	fprintf(fp, &#034;/*----- bitmap : w = %ld, h = %ld ------ */&#034;,
		    bm-&#062;BytesPerRow*8, bm-&#062;Rows);

	PrCRLF(fp);

	for (p = 0; p &#060; bm-&#062;Depth; ++p) {	/* For each bit plane */
		wp = (UWORD *)bm-&#062;Planes[p];
		fprintf(fp, &#034;/*------ plane # %ld: --------*/&#034;, p);
		PrCRLF(fp);
		fprintf(fp, &#034;UWORD %s%c[%ld] = { &#034;, name, (p?('0'+p):' '), nwords);
		PrCRLF(fp);
		for (j = 0; j &#060; bm-&#062;Rows; j++, wp += (bm-&#062;BytesPerRow &#062;&#062; 1)) {
			fprintf(fp, &#034;	&#034;);
			for (nb = 0; nb &#060; (bm-&#062;BytesPerRow) &#062;&#062; 1; nb++)
				fprintf(fp, &#034;0x%04x,&#034;, *(wp+nb));
			if (bm-&#062;BytesPerRow &#060;= 6) {
 				fprintf(fp, &#034;\t/* &#034;);
				for (nb = 0; nb &#060; (bm-&#062;BytesPerRow) &#062;&#062; 1; nb++)
					for (i=0 ; i&#060;16; i++)
						fprintf(fp, &#034;%c&#034;,
					    (((*(wp+nb)&#062;&#062;(15-i))&#038;1) ? '*' : '.'));
				fprintf(fp, &#034; */&#034;);
			}
			PrCRLF(fp);

		}
		fprintf(fp,&#034;	};&#034;);
		PrCRLF(fp);
	}
}



void PSprite(struct BitMap *bm, FILE *fp, UBYTE *name, int p, BOOL dohead)
{
	UWORD 	*wp0, *wp1;	/* Pointer temporaries 	*/
	short 	i, j, nwords,	/* Counter temporaries 	*/
		color;		/* pixel color		*/
	short 	wplen = bm-&#062;BytesPerRow/2;

	nwords =  2*bm-&#062;Rows + (dohead?4:0);
	wp0 = (UWORD *)bm-&#062;Planes[p];
	wp1 = (UWORD *)bm-&#062;Planes[p+1];

	fprintf(fp, &#034;UWORD %s[%ld] = {&#034;, name, nwords);
	PrCRLF(fp);

	if (dohead) {
		fprintf(fp,&#034;  0x0000, 0x0000, /* VStart, VStop */&#034;);
		PrCRLF(fp);
	}
	for (j=0 ; j &#060; bm-&#062;Rows; j++) {
		fprintf(fp, &#034;  0x%04x, 0x%04x&#034;, *wp0, *wp1);
		if (dohead || (j != bm-&#062;Rows-1)) {
			fprintf(fp, &#034;,&#034;);
		}
		fprintf(fp, &#034;\t/*  &#034;);
		for (i = 0; i &#060; 16; i++) {
			color = ((*wp1 &#062;&#062; (14-i)) &#038; 2) + ((*wp0 &#062;&#062; (15-i)) &#038; 1);
			fprintf(fp, &#034;%c&#034;, sp_colors[color]);
		}
		fprintf(fp,&#034;  */&#034;);
		PrCRLF(fp);
		wp0 += wplen;
		wp1 += wplen;
	}
	if (dohead)
		fprintf(fp, &#034;  0x0000, 0x0000 }; /* End of Sprite */&#034;);
	else
		fprintf(fp,&#034; };&#034;);
	PrCRLF(fp);
	PrCRLF(fp);
}

void PrintSprite(struct BitMap *bm, FILE *fp, UBYTE *name,
		 BOOL attach, BOOL dohdr)
{
	fprintf(fp,&#034;/*----- Sprite format: h = %ld ------ */&#034;, bm-&#062;Rows);
	PrCRLF(fp);

	if (bm-&#062;Depth &#062; 1) {
		fprintf(fp, &#034;/*--Sprite containing lower order two planes:   */&#034;);
		PrCRLF(fp);
		PSprite(bm, fp, name, 0, dohdr);
	}
	if (attach &#038;&#038; (bm-&#062;Depth &#062; 3) ) {
		strcat(name, &#034;1&#034;);
		fprintf(fp, &#034;/*--Sprite containing higher order two planes:   */&#034;);
		PrCRLF(fp);
		PSprite(bm, fp, name, 2, dohdr);
	}
}

#define BOB 	0
#define SPRITE 	1

/* BMPrintCRep
 * Passed pointer to BitMap structure, C filehandle opened for write,
 * name associated with file, and string describing the output
 * format desired (see cases below), outputs C representation of the ILBM.
 */
void BMPrintCRep(struct BitMap *bm, FILE *fp, UBYTE *name, UBYTE *fmt)
{
	BOOL attach, doHdr;
	char c;
	SHORT type;

	doCRLF = NO;
	doHdr = YES;
	type = BOB;
	attach = NO;
	while ( (c=*fmt++) != 0 )
		switch (c) {
			case 'b':
				type = BOB;
				break;
			case 's':
				type = SPRITE;
				attach = NO;
				break;
			case 'a':
				type = SPRITE;
				attach = YES;
				break;
			case 'n':
				doHdr = NO;
				break;
			case 'c':
				doCRLF = YES;
				break;
		}
	switch(type) {
		case BOB:
			PrintBob(bm, fp, name);
			break;
		case SPRITE:
			PrintSprite(bm, fp, name, attach, doHdr);
			break;
	}
}
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
