<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/34.11 FILE="Devices/Dev_examples/Cia_Interval.c" NODE="MAIN" TITLE="Devices/Dev_examples/Cia_Interval.c" -->
<head>
<title>Devices/Dev_examples/Cia_Interval.c</title>
</head>
<body>
<img src="../images/toc_d.gif" alt="[Contents]">
<img src="../images/index_d.gif" alt="[Index]">
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../Devices_Manual_guide/node01A1.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../Devices_Manual_guide/node01A3.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
/*
 * Cia_Interval.c
 *
 * Demonstrate allocation and use of a cia interval timer
 *
 * Compile with SAS C 5.10  lc -b1 -cfistq -v -y -L
 *
 * Run from CLI only
 */

#include &#060;exec/types.h&#062;
#include &#060;exec/memory.h&#062;
#include &#060;exec/tasks.h&#062;
#include &#060;exec/interrupts.h&#062;
#include &#060;hardware/cia.h&#062;
#include &#060;resources/cia.h&#062;

#include &#060;clib/exec_protos.h&#062;
#include &#060;clib/cia_protos.h&#062;

#include &#060;stdlib.h&#062;
#include &#060;stdio.h&#062;
#include &#060;string.h&#062;


/* prototypes */

void    StartTimer      (struct freetimer *ft, struct exampledata *ed);
int     FindFreeTimer   (struct freetimer *ft, int preferA);
int     TryTimer        (struct freetimer *ft);
void    main            ( USHORT, char **);


/* see usage of these defines in StartTimer() below */

#define COUNTDOWN 20
#define HICOUNT 0xFF
#define LOCOUNT 0xFF

#define STOPA_AND  CIACRAF_TODIN |CIACRAF_PBON | CIACRAF_OUTMODE | CIACRAF_SPMODE

        /*
        ;
        ; AND mask for use with control register A
        ; (interval timer A on either CIA)
        ;
        ; STOP -
        ;       START bit 0 == 0 (STOP IMMEDIATELY)
        ;       PBON  bit 1 == same
        ;       OUT   bit 2 == same
        ;       RUN   bit 3 == 0 (SET CONTINUOUS MODE)
        ;       LOAD  bit 4 == 0 (NO FORCE LOAD)
        ;       IN    bit 5 == 0 (COUNTS 02 PULSES)
        ;       SP    bit 6 == same
        ;       TODIN bit 7 == same (unused on ciacra)

        */

#define STOPB_AND  CIACRBF_ALARM | CIACRBF_PBON | CIACRBF_OUTMODE

        /*
        ;
        ; AND mask for use with control register B
        ; (interval timer B on either CIA)
        ;
        ; STOP -
        ;       START bit 0 == 0 (STOP IMMEDIATELY)
        ;       PBON  bit 1 == same
        ;       OUT   bit 2 == same
        ;       RUN   bit 3 == 0 (SET CONTINUOUS MODE)
        ;       LOAD  bit 4 == 0 (NO FORCE LOAD)
        ;       IN0   bit 5 == 0 (COUNTS 02 PULSES)
        ;       IN1   bit 6 == 0 (COUNTS 02 PULSES)
        ;       ALARM bit 7 == same (TOD alarm control bit)

        */

#define STARTA_OR  CIACRAF_START

        /*
        ;
        ; OR mask for use with control register A
        ; (interval timer A on either CIA)
        ;
        ; START -
        ;
        ;       START bit 0 == 1 (START TIMER)
        ;
        ;       All other bits unaffected.
        ;

        */

#define STARTB_OR  CIACRBF_START

        /*
        ;
        ; OR mask for use with control register B
        ; (interval timer A on either CIA)
        ;
        ; START -
        ;
        ;       START bit 0 == 1 (START TIMER)
        ;
        ;       All other bits unaffected.
        ;

        */


/*
 * Structure which will be used to hold all relevant information about
 * the cia timer we manage to allocate.
 *
 */

struct freetimer
{
    struct Library *ciabase;        /* CIA Library Base             */
    ULONG  timerbit;                /* timer bit allocated          */
    struct CIA *cia;                /* ptr to hardware              */
    UBYTE *ciacr;                   /* ptr to control register      */
    UBYTE *cialo;                   /* ptr to low byte of timer     */
    UBYTE *ciahi;                   /* ptr to high byte of timer    */
    struct Interrupt timerint;      /* Interrupt structure          */
    UBYTE  stopmask;                /* Stop/set-up timer            */
    UBYTE  startmask;               /* Start timer                  */
};

/*
 * Structure which will be used by the interrupt routine called
 * when our cia interval timer generates an interrupt.
 *
 */

struct exampledata
{
    struct Task *task;      /* task to signal */
    ULONG   signal;         /* Signal bit to use */
    ULONG   counter;
};


struct CIA *ciaa = (struct CIA *)0xbfe001;
struct CIA *ciab = (struct CIA *)0xbfd000;


#ifdef LATTICE
int CXBRK(void) { return(0); }  /* Disable SAS CTRL/C handling */
int chkabort(void) { return(0); }  /* really */
#endif

/*
 * This is the interrupt routine which will be called when our CIA
 * interval timer counts down.
 *
 * This example decrements a counter each time the interrupt routine
 * is called until the counter reaches 0, at which time it signals
 * our main task.
 *
 * Note that interrupt handling code should be efficient, and will
 * generally be written in assembly code.  Signaling another task
 * such as this example does is also a useful way of handling
 * interrupts in an expedient manner.
 */

void __asm ExampleInterrupt(register __a1 struct exampledata *ed)
{
if (ed-&#062;counter)
    {
    ed-&#062;counter--;                  /* decrement counter */
    }
else
    {
    ed-&#062;counter = COUNTDOWN;        /* reset counter     */

    Signal(ed-&#062;task,(1L &#060;&#060; ed-&#062;signal));
    }
}


/***********************************
 *  main()
 ***********************************/

void main(USHORT argc,char **argv)
{
struct freetimer ft;
struct exampledata ed;

/* Set up data which will be passed to interrupt */

ed.task = FindTask(0L);

if (ed.signal = AllocSignal(-1L))
    {
    /* Prepare freetimer structure : set-up interrupt */

    ft.timerint.is_Node.ln_Type = NT_INTERRUPT;
    ft.timerint.is_Node.ln_Pri  = 0;
    ft.timerint.is_Node.ln_Name = &#034;cia_example&#034;;

    ft.timerint.is_Data         = (APTR)&#038;ed;
    ft.timerint.is_Code         = (APTR)ExampleInterrupt;

    /* Call function to find a free CIA interval timer
     * with flag indicating that we prefer a CIA-A timer.
     */

    printf(&#034;Attempting to allocate a free timer\n&#034;);

    if (FindFreeTimer(&#038;ft,TRUE))
        {
        if (ft.cia == ciaa)
            {
            printf(&#034;CIA-A timer &#034;);
            }
        else
            {
            printf(&#034;CIA-B timer &#034;);
            }

        if (ft.timerbit == CIAICRB_TA)
            {
            printf(&#034;A allocated\n&#034;);
            }
        else
            {
            printf(&#034;B allocated\n&#034;);
            }


        /* We found a free interval timer.  Let's start it running. */

        StartTimer(&#038;ft,&#038;ed);

        /* Wait for a signal */

        printf(&#034;Waiting for signal bit %ld\n&#034;,ed.signal);

        Wait(1L&#060;&#060;ed.signal);

        printf(&#034;We woke up!\n&#034;);

        /* Release the interval timer */

        RemICRVector(ft.ciabase,ft.timerbit,&#038;ft.timerint);

        }
    else
        {
        printf(&#034;No CIA interval timer available\n&#034;);
        }

    FreeSignal(ed.signal);
    }
}


/*
 * This routine sets up the interval timer we allocated with
 * AddICRVector().  Note that we may have already received one, or
 * more interrupts from our timer.  Make no assumptions about the
 * initial state of any of the hardware registers we will be using.
 *
 */

void StartTimer(struct freetimer *ft, struct exampledata *ed)
{
register struct CIA *cia;

cia = ft-&#062;cia;

/* Note that there are differences between control register A,
 * and B on each CIA (e.g., the TOD alarm bit, and INMODE bits.
 */

if (ft-&#062;timerbit == CIAICRB_TA)
    {
    ft-&#062;ciacr = &#038;cia-&#062;ciacra;       /* control register A   */
    ft-&#062;cialo = &#038;cia-&#062;ciatalo;      /* low byte counter     */
    ft-&#062;ciahi = &#038;cia-&#062;ciatahi;      /* high byte counter    */

    ft-&#062;stopmask = STOPA_AND;       /* set-up mask values   */
    ft-&#062;startmask = STARTA_OR;
    }
else
    {
    ft-&#062;ciacr = &#038;cia-&#062;ciacrb;       /* control register B   */
    ft-&#062;cialo = &#038;cia-&#062;ciatblo;      /* low byte counter     */
    ft-&#062;ciahi = &#038;cia-&#062;ciatbhi;      /* high byte counter    */

    ft-&#062;stopmask = STOPB_AND;       /* set-up mask values   */
    ft-&#062;startmask = STARTB_OR;
    }


/* Modify control register within Disable().  This is done to avoid
 * race conditions since our compiler may generate code such as:
 *
 *      value = Read hardware byte
 *      AND  value with MASK
 *      Write value to hardware byte
 *
 * If we take a task switch in the middle of this sequence, two tasks
 * trying to modify the same register could trash each others' bits.
 *
 * Normally this code would be written in assembly language using atomic
 * instructions so that the Disable() would not be needed.
 */


Disable();

/* STOP timer, set 02 pulse count-down mode, set continuous mode */

*ft-&#062;ciacr &#038;= ft-&#062;stopmask;
Enable();

/* Clear signal bit - interrupt will signal us later */
SetSignal(0L,1L&#060;&#060;ed-&#062;signal);

/* Count-down X # of times */
ed-&#062;counter = COUNTDOWN;

/* Start the interval timer - we will start the counter after
 * writing the low, and high byte counter values
 */

*ft-&#062;cialo = LOCOUNT;
*ft-&#062;ciahi = HICOUNT;

/* Turn on start bit - same bit for both A, and B control regs  */

Disable();
*ft-&#062;ciacr |= ft-&#062;startmask;

Enable();
}

/*
 * A routine to find a free interval timer.
 *
 * This routine makes no assumptions about which interval timers
 * (if any) are available for use.  Currently there are two interval
 * timers per CIA chip.
 *
 * Because CIA usage may change in the future, your code should use
 * a routine like this to find a free interval timer.
 *
 * Note that the routine takes a preference flag (which is used to
 * to indicate that you would prefer an interval timer on CIA-A).
 * If the flag is FALSE, it means that you would prefer an interval
 * timer on CIA-B.
 *
 */

FindFreeTimer(struct freetimer *ft, int preferA)
{
struct CIABase *ciaabase, *ciabbase;

/* get pointers to both resource bases */

ciaabase = OpenResource(CIAANAME);
ciabbase = OpenResource(CIABNAME);

/* try for a CIA-A timer first ? */

if (preferA)
    {
    ft-&#062;ciabase = ciaabase; /* library address  */
    ft-&#062;cia     = ciaa;     /* hardware address */
    }
else
    {
    ft-&#062;ciabase = ciabbase; /* library address  */
    ft-&#062;cia     = ciab;     /* hardware address */
    }

if (TryTimer(ft))
    return(TRUE);

/* try for an interval timer on the other cia */

if (!(preferA))
    {
    ft-&#062;ciabase = ciaabase; /* library address  */
    ft-&#062;cia     = ciaa;     /* hardware address */
    }
else
    {
    ft-&#062;ciabase = ciabbase; /* library address  */
    ft-&#062;cia     = ciab;     /* hardware address */
    }

if (TryTimer(ft))
    return(TRUE);

return(FALSE);

}

/*
 * Try to obtain a free interval timer on a CIA.
 */

TryTimer(struct freetimer *ft)
{

if (!(AddICRVector(ft-&#062;ciabase,CIAICRB_TA,&#038;ft-&#062;timerint)))
    {
    ft-&#062;timerbit = CIAICRB_TA;
    return(TRUE);
    }

if (!(AddICRVector(ft-&#062;ciabase,CIAICRB_TB,&#038;ft-&#062;timerint)))
    {
    ft-&#062;timerbit = CIAICRB_TB;
    return(TRUE);
    }

return(FALSE);
}
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
