<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/34.11 FILE="Devices/Dev_5" NODE="5-3-2" TITLE="5 / Gameport Events / Setting Gameport Event Trigger Conditions" INDEX="Devices/Dev_Index/MAIN" -->
<head>
<title>5 / Gameport Events / Setting Gameport Event Trigger Conditions</title>
</head>
<body>
<img src="../images/toc_d.gif" alt="[Contents]">
<a href="../Devices_Manual_guide/node012A.html"><img src="../images/index.gif" alt="[Index]" border=0></a>
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../Devices_Manual_guide/node00B5.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../Devices_Manual_guide/node00B7.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
You set the conditions that can trigger a gameport event by passing an I/O
request to the device with <a href="../Includes_and_Autodocs_2._guide/node04BE.html">GPD_SETTRIGGER</a> set in io_Command and the
<a name="line4">address of a GamePortTrigger structure set in io_Data.</a>

<a name="line6">The information needed for gameport trigger setting is placed into a</a>
GamePortTrigger data structure which is defined in the include file
<a name="line8">devices/<a href="../Includes_and_Autodocs_2._guide/node0039.html">gameport.h</a>.</a>

    struct GamePortTrigger
    {
        UWORD    gpt_Keys;      /* key transition triggers */
        UWORD    gpt_Timeout;   /* time trigger (vertical blank units) */
        UWORD    gpt_XDelta;    /* X distance trigger */
        UWORD    gpt_YDelta;    /* Y distance trigger */
    }

<a name="line18">A few points to keep in mind with the <a href="../Includes_and_Autodocs_2._guide/node04BE.html">GPD_SETTRIGGER</a> command are:</a>

    *  Setting GPTF_UPKEYS enables the reporting of upward transitions.
       Setting GPTF_DOWNKEYS enables the reporting of downward transitions.
       These flags may both be specified.

    *  The field gpt_Timeout specifies the time interval (in vertical blank
       units) between reports in the absence of another trigger condition.
       In other words, an event is generated every gpt_Timeout ticks.
       Vertical blank units may differ from country to country (e.g 60 Hz
       NTSC, 50 Hz PAL.)  To find out the exact frequency use this code
       fragment:

       #include &#060;exec/execbase.h&#062;
       extern struct ExecBase *SysBase;

<a name="line34">       UBYTE get_frequency(void)</a>
       {
       return((UBYTE)SysBase-&#062;VBlankFrequency);
       }

    *  The gpt_XDelta and gpt_YDelta fields specify the x and y distances
<a name="line40">       which, if exceeded, trigger a report.</a>

For a mouse controller, you can trigger on a certain minimum-sized move in
either the x or y direction, on up or down transitions of the mouse
buttons, on a timed basis, or any combination of these conditions.

For example, suppose you normally signal mouse events if the mouse moves
at least 10 counts in either the x or y directions. If you are moving the
cursor to keep up with mouse movements and the user moves the mouse less
than 10 counts, after a period of time you will want to update the
position of the cursor to exactly match the mouse position. Thus the timed
report of current mouse counts would be preferred. The following structure
would be used:

    #define XMOVE 10
    #define YMOVE 10

    struct GamePortTrigger GameTR =
    {
        GPTF_UPKEYS | GPTF_DOWNKEYS, /* trigger on all key transitions */
        1800,                  /* and every 36(PAL) or 30(NTSC) seconds */
        XMOVE,                 /* for any 10 in an x or y direction */
        YMOVE
<a name="line63">    };</a>

For a joystick controller, you can select timed reports as well as
button-up and button-down report trigger conditions. For an absolute
joystick specify a value of one (1) for the GameTR_XDelta and
GameTR_YDelta fields or you will not get any direction events. You set the
trigger conditions by using the following code or its equivalent:

    struct IOStdReq *GameIO;

    void set_trigger_conditions(struct GamePortTrigger *GameTR)
    {
    GameIO-&#062;io_Command = GPD_SETTRIGGER;    /* set trigger conditions */
    GameIO-&#062;io_Data = (APTR)GameTR;         /* from GameTR */
    GameIO-&#062;io_Length = sizeof(struct GamePortTrigger);
    DoIO(GameIO);
    }

   Triggers and Reads.
   -------------------
   If a task sets trigger conditions and does not ask for the position
   reports the gameport device will queue them up anyway. If the trigger
   conditions occur again and the gameport device buffer is filled, the
   additional triggers will be ignored until the buffer is read by a
   device read request (<a href="../Devices_Manual_guide/node00B5.html">GPD_READEVENT</a>) or a system CMD_CLEAR command
   flushes the buffer.
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
