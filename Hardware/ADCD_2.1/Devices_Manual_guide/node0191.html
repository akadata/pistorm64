<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/34.11 FILE="Lib_examples/rawkey.c" NODE="MAIN" TITLE="Lib_examples/rawkey.c" -->
<head>
<title>Lib_examples/rawkey.c</title>
</head>
<body>
<img src="../images/toc_d.gif" alt="[Contents]">
<img src="../images/index_d.gif" alt="[Index]">
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../Devices_Manual_guide/node0190.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../Devices_Manual_guide/node0192.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
;/* rawkey.c - Execute me to compile me with SAS C 5.10
LC -b1 -cfistq -v -y -j73 rawkey.c
Blink FROM LIB:c.o,rawkey.o TO rawkey LIBRARY LIB:LC.lib,LIB:Amiga.lib
quit
**
** The following example uses RawKeyConvert() to convert the
** IDCMP_RAWKEY input stream into an ANSI input stream.  See the
** &#034;Console Device&#034; chapter in the Amiga ROM Kernel Reference Manual:
** Devices for more information on RawKeyConvert() and the data it
** returns.
**
** rawkey.c - How to correctly convert from RAWKEY to keymapped ASCII
*/
#define INTUI_V36_NAMES_ONLY

#include &#060;exec/types.h&#062;
#include &#060;exec/memory.h&#062;
#include &#060;intuition/intuition.h&#062;
#include &#060;devices/inputevent.h&#062;
#include &#060;clib/exec_protos.h&#062;
#include &#060;clib/intuition_protos.h&#062;
#include &#060;clib/console_protos.h&#062;
#include &#060;stdio.h&#062;

#ifdef LATTICE
int CXBRK(void)    { return(0); }  /* Disable Lattice CTRL/C handling */
int chkabort(void) { return(0); }  /* really */
#endif

/* our function prototypes */
LONG deadKeyConvert(struct IntuiMessage *msg, UBYTE *kbuffer,
                    LONG kbsize, struct KeyMap *kmap, struct InputEvent *ievent);
VOID print_qualifiers(ULONG qual);
BOOL doKeys(struct IntuiMessage *msg, struct InputEvent *ievent,
                    UBYTE **buffer, ULONG *bufsize);
VOID process_window(struct Window *win, struct InputEvent *ievent,
                    UBYTE **buffer, ULONG *bufsize);

/* A buffer is created for RawKeyConvert() to put its output. BUFSIZE is the size of
** the buffer in bytes.  NOTE that this program starts out with a buffer size of 2.
** This is only to show how the buffer is automatically increased in size  by this
** example!  In an application, start with a much larger buffer and you will probably
** never have to increase its size. 128 bytes or so should do the trick, but always
** be able to change the size if required.
*/
#define BUFSIZE (2)

struct Library *IntuitionBase, *ConsoleDevice;

/* main() - set-up everything used by program. */
VOID main(int argc, char **argv)
{
struct Window *win;
struct IOStdReq ioreq;
struct InputEvent *ievent;
UBYTE *buffer;
ULONG bufsize = BUFSIZE;

if(IntuitionBase = OpenLibrary(&#034;intuition.library&#034;,37)) {
    /* Open the console device just to do keymapping. (unit -1 means any unit) */
    if (0 == OpenDevice(&#034;console.device&#034;,-1,(struct IORequest *)&#038;ioreq,0)) {
        ConsoleDevice = (struct Library *)ioreq.io_Device;

        /* Allocate the initial character buffer used by deadKeyConvert() and RawKeyConvert()
        ** for returning translated characters. If the characters generated by these routines
        ** cannot fit into the buffer, the application must pass a larger buffer.  This is
        ** done in this code by freeing the old buffer and allocating a new one.
        */
        if (buffer = AllocMem(bufsize,MEMF_CLEAR)) {
            if (ievent = AllocMem(sizeof(struct InputEvent),MEMF_CLEAR)) {
                if (win = OpenWindowTags(NULL,
                        WA_Width, 300,
                        WA_Height, 50,
                        WA_Flags, WFLG_DEPTHGADGET | WFLG_CLOSEGADGET | WFLG_ACTIVATE,
                        WA_IDCMP, IDCMP_CLOSEWINDOW | IDCMP_RAWKEY,
                        WA_Title, &#034;Raw Key Example&#034;,
                        TAG_END)) {
                    printf(&#034;Press keyboard keys to see ASCII conversion from rawkey\n&#034;);
                    printf(&#034;Unprintable characters will be shown as %c\n\n&#034;,0x7f);
                    process_window(win,ievent,&#038;buffer,&#038;bufsize);
                    CloseWindow(win);
                    }
                FreeMem(ievent,sizeof(struct InputEvent));
                }
            /* Buffer can be freed elsewhere in the program so test first. */
            if (buffer != NULL)
                FreeMem(buffer,bufsize);
            }
        CloseDevice((struct IORequest *)&#038;ioreq);
        }
    CloseLibrary(IntuitionBase);
    }
}

/* Convert RAWKEYs into VANILLAKEYs, also shows special keys like HELP, Cursor Keys,
** FKeys, etc.  It returns:
**   -2 if not a RAWKEY event.
**   -1 if not enough room in the buffer, try again with a bigger buffer.
**   otherwise, returns the number of characters placed in the buffer.
*/
LONG deadKeyConvert(struct IntuiMessage *msg, UBYTE *kbuffer,
    LONG kbsize, struct KeyMap *kmap, struct InputEvent *ievent)
{
if (msg-&#062;Class != IDCMP_RAWKEY) return(-2);
ievent-&#062;ie_Class = IECLASS_RAWKEY;
ievent-&#062;ie_Code = msg-&#062;Code;
ievent-&#062;ie_Qualifier = msg-&#062;Qualifier;
ievent-&#062;ie_position.ie_addr = *((APTR*)msg-&#062;IAddress);

return(RawKeyConvert(ievent,kbuffer,kbsize,kmap));
}

/* print_qualifiers() - print out the values found in the qualifier bits of
** the message. This will print out all of the qualifier bits set.
*/
VOID print_qualifiers(ULONG qual)
{
printf(&#034;Qual:&#034;);
if (qual &#038; IEQUALIFIER_LSHIFT)         printf(&#034;LShft,&#034;);
if (qual &#038; IEQUALIFIER_RSHIFT)         printf(&#034;RShft,&#034;);
if (qual &#038; IEQUALIFIER_CAPSLOCK)       printf(&#034;CapLok,&#034;);
if (qual &#038; IEQUALIFIER_CONTROL)        printf(&#034;Ctrl,&#034;);
if (qual &#038; IEQUALIFIER_LALT)           printf(&#034;LAlt,&#034;);
if (qual &#038; IEQUALIFIER_RALT)           printf(&#034;RAlt,&#034;);
if (qual &#038; IEQUALIFIER_LCOMMAND)       printf(&#034;LCmd,&#034;);
if (qual &#038; IEQUALIFIER_RCOMMAND)       printf(&#034;RCmd,&#034;);
if (qual &#038; IEQUALIFIER_NUMERICPAD)     printf(&#034;NumPad,&#034;);
if (qual &#038; IEQUALIFIER_REPEAT)         printf(&#034;Rpt,&#034;);
if (qual &#038; IEQUALIFIER_INTERRUPT)      printf(&#034;Intrpt,&#034;);
if (qual &#038; IEQUALIFIER_MULTIBROADCAST) printf(&#034;Multi Broadcast,&#034;);
if (qual &#038; IEQUALIFIER_MIDBUTTON)      printf(&#034;MidBtn,&#034;);
if (qual &#038; IEQUALIFIER_RBUTTON)        printf(&#034;RBtn,&#034;);
if (qual &#038; IEQUALIFIER_LEFTBUTTON)     printf(&#034;LBtn,&#034;);
if (qual &#038; IEQUALIFIER_RELATIVEMOUSE)  printf(&#034;RelMouse,&#034;);
}

/* doKeys() - Show what keys were pressed. */
BOOL doKeys(struct IntuiMessage *msg, struct InputEvent *ievent,
            UBYTE **buffer, ULONG *bufsize)
{
USHORT char_pos;
USHORT numchars;
BOOL   ret_code = TRUE;
UBYTE  realc, c;

/* deadKeyConvert() returns -1 if there was not enough space in the buffer to
** convert the string. Here, the routine increases the size of the buffer on the
** fly...Set the return code to FALSE on failure.
*/
numchars = deadKeyConvert(msg, *buffer, *bufsize - 1, NULL, ievent);
while ((numchars == -1) &#038;&#038; (*buffer != NULL)) {
    /* conversion failed, buffer too small. try to double the size of the buffer. */
    FreeMem(*buffer, *bufsize);
    *bufsize = *bufsize &#060;&#060; 1;
    printf(&#034;Increasing buffer size to %d\n&#034;, *bufsize);

    if (NULL == (*buffer = AllocMem(*bufsize, MEMF_CLEAR)))  ret_code = FALSE;
    else  numchars = deadKeyConvert(msg, *buffer, *bufsize - 1, NULL, ievent);
    }

/* numchars contains the number of characters placed within the buffer.  Key up events and   */
/* key sequences that do not generate any data for the program (like deadkeys) will return   */
/* zero.  Special keys (like HELP, the cursor keys, FKeys, etc.) return multiple characters  */
/* that have to then be parsed by the application.  Allocation failed above if buffer is NULL*/
if (*buffer != NULL) {
    /* if high bit set, then this is a key up otherwise this is a key down */
    if (msg-&#062;Code &#038; 0x80)
          printf(&#034;Key Up:   &#034;);
    else
          printf(&#034;Key Down: &#034;);

    print_qualifiers(msg-&#062;Qualifier);
    printf(&#034; rawkey #%d maps to %d ASCII character(s)\n&#034;, 0x7F &#038; msg-&#062;Code, numchars);
    for (char_pos = 0; char_pos &#060; numchars; char_pos++) {
        realc = c = (*buffer)[char_pos];
        if ((c &#060;= 0x1F)||((c &#062;= 0x80)&#038;&#038;(c &#060; 0xa0)))
            c = 0x7f;
        printf(&#034;  %3d ($%02x) = %c\n&#034;, realc, realc, c);
        }
    }
return(ret_code);
}

/* process_window() - simple event loop.  Note that the message is not replied
** to until the end of the loop so that it may be used in the doKeys() call.
*/
VOID process_window(struct Window *win, struct InputEvent *ievent,
    UBYTE **buffer, ULONG *bufsize)
{
struct IntuiMessage *msg;
BOOL done;

done = FALSE;
while (done == FALSE) {
    Wait((1L&#060;&#060;win-&#062;UserPort-&#062;mp_SigBit));
    while ((done == FALSE) &#038;&#038; (msg = (struct IntuiMessage *)GetMsg(win-&#062;UserPort))) {
        switch (msg-&#062;Class) {     /* handle our events */
            case IDCMP_CLOSEWINDOW:
                done = TRUE;
                break;
            case IDCMP_RAWKEY:
                if (FALSE == doKeys(msg,ievent,buffer,bufsize))
                    done = TRUE;
                break;
            }
        ReplyMsg((struct Message *)msg);
        }
    }
}
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
