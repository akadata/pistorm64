<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/34.11 FILE="Devices/Dev_examples/Key_Reset.c" NODE="MAIN" TITLE="Devices/Dev_examples/Key_Reset.c" -->
<head>
<title>Devices/Dev_examples/Key_Reset.c</title>
</head>
<body>
<img src="../images/toc_d.gif" alt="[Contents]">
<img src="../images/index_d.gif" alt="[Index]">
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../Devices_Manual_guide/node019E.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../Devices_Manual_guide/node01A0.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
/*
 * Key_Reset.c
 *
 * This is in two parts...
 *
 * Compile this C code with SAS C 5.10:
 *      lc -b1 -cfistq -v -y Key_Reset
 *
 * Assemble the ASM code with Adapt
 *  HX68 KeyHandler.a to KeyHandler.o
 *
 * Link with:
 * Blink FROM LIB:c.o+Key_Reset.o+KeyHandler.o TO
 *        Key_Reset LIB LIB:lc.lib LIB:amiga.lib
 */

/*
 * Keyboard device reset handler example...
 */
#include &#060;exec/types.h&#062;
#include &#060;exec/io.h&#062;
#include &#060;exec/ports.h&#062;
#include &#060;exec/memory.h&#062;
#include &#060;devices/keyboard.h&#062;
#include &#060;intuition/intuition.h&#062;
#include &#060;exec/interrupts.h&#062;

#include &#060;clib/exec_protos.h&#062;
#include &#060;clib/alib_protos.h&#062;
#include &#060;clib/intuition_protos.h&#062;
#include &#060;clib/dos_protos.h&#062;

#include &#060;stdio.h&#062;

#ifdef LATTICE
int CXBRK(void) { return(0); }     /* Disable SAS CTRL/C handling */
int chkabort(void) { return(0); }  /* really */
void main();
#endif

extern VOID ResetHandler();

UBYTE NameString[]=&#034;Reset Handler Test&#034;;

struct NewWindow mywin={0,0,178,10,0,1,CLOSEWINDOW,
                      WINDOWDRAG|WINDOWCLOSE|SIMPLE_REFRESH|NOCAREREFRESH
                      NULL,NULL,NameString,NULL,NULL,0,0,0,0,WBENCHSCREEN};

extern struct IntuitionBase *IntuitionBase;

struct MyData
    {
    struct Task  *MyTask;
           ULONG MySignal;
    };

/*
 * This routine opens a window and waits for the one event that
 * can happen (CLOSEWINDOW)
 */
short WaitForUser(ULONG MySignal)
{
struct Window  *win;
       short   ret=0;

if (IntuitionBase=(struct IntuitionBase *)
                   OpenLibrary(&#034;intuition.library&#034;,0L))
    {
    if (win=(struct Window *)OpenWindow(&#038;mywin))
        {
        ret=(MySignal==Wait(MySignal | (1L &#060;&#060; win-&#062;UserPort-&#062;mp_SigBit)));
        CloseWindow(win);
        }
    else
        printf(&#034;Error: Could not open window\n&#034;);
    CloseLibrary((struct Library *)IntuitionBase);
    }
else
    printf(&#034;Error: Could not open intution.library\n&#034;);
return(ret);
}

VOID main(int argc, char *argv[])
{
struct IOStdReq  *KeyIO;
struct MsgPort   *KeyMP;
struct Interrupt *keyHandler;
struct MyData    MyDataStuff;
       ULONG     MySignal;

if ((MySignal=AllocSignal(-1L))!=-1)
    {
    MyDataStuff.MyTask=FindTask(NULL);
    MyDataStuff.MySignal=1L &#060;&#060; MySignal;

    if (KeyMP=CreatePort(NULL,NULL))
        {
        if (keyHandler =
                AllocMem(sizeof(struct Interrupt),MEMF_PUBLIC|MEMF_CLEAR))
            {
            if (KeyIO=(struct IOStdReq *)
                      CreateExtIO(KeyMP,sizeof(struct IOStdReq)))
                {
                if (!OpenDevice(&#034;keyboard.device&#034;,NULL,(struct IORequest *)
                                                        KeyIO,NULL))
                    {
                    keyHandler-&#062;is_Code=ResetHandler;
                    keyHandler-&#062;is_Data=(APTR)&#038;MyDataStuff;

                    /*
                     * Note that only software interrupt priorities
                     * can be used for the .ln_Pri on the reset
                     * handler...
                     */
                    keyHandler-&#062;is_Node.ln_Pri=16;

                    keyHandler-&#062;is_Node.ln_Name=NameString;
                    KeyIO-&#062;io_Data=(APTR)keyHandler;
                    KeyIO-&#062;io_Command=KBD_ADDRESETHANDLER;
                    DoIO((struct IORequest *)KeyIO);

                    if (WaitForUser(MyDataStuff.MySignal))
                        {
                        if (argc) /* Check for CLI */
                            {
                            printf(&#034;System going down\n&#034;);
                            printf(&#034;Cleaning up...\n&#034;);
                            /* Show a delay, like cleanup... */
                            Delay(20);
                            printf(&#034;*Poof*\n&#034;);
                            }
                        /* We are done with our cleanup */

                        KeyIO-&#062;io_Data=(APTR)keyHandler;
                        KeyIO-&#062;io_Command=KBD_RESETHANDLERDONE;
                        DoIO((struct IORequest *)KeyIO);
                        /*
                         * Note that since the above call
                         * tells the system it is safe to reboot
                         * and will cause the reboot if this
                         * task was the last to say so, the call
                         * never really returns...  The system
                         * just reboots...
                         */
                        }

                    KeyIO-&#062;io_Data=(APTR)keyHandler;
                    KeyIO-&#062;io_Command=KBD_REMRESETHANDLER;
                    DoIO((struct IORequest *)KeyIO);

                    CloseDevice((struct IORequest *)KeyIO);
                    }
                else
                    printf(&#034;Error: Could not open keyboard.device\n&#034;);

                DeleteExtIO((struct IORequest *)KeyIO);
                }
            else
                printf(&#034;Error: Could not create I/O request\n&#034;);

            FreeMem(keyHandler,sizeof(struct Interrupt));
            }
        else
            printf(&#034;Error: Could not allocate memory for interrupt\n&#034;);

        DeletePort(KeyMP);
        }
    else
        printf(&#034;Error: Could not create message port\n&#034;);

    FreeSignal(MySignal);
    }
else
    printf(&#034;Error: Could not allocate signal\n&#034;);
}
\kern -20pt
************************************************************************
<a name="line178">*       KeyHandler.a</a>
*
* Keyboard reset handler that signals the task in the structure...
*
* See Key_Reset.c for details on how to compile/assemble/link...
*
************************************************************************
* Required includes...
*
        INCDIR  &#034;include:&#034;
        INCLUDE &#034;exec/types.i&#034;
        INCLUDE &#034;exec/io.i&#034;
        INCLUDE &#034;devices/keyboard.i&#034;
*
        xref    _AbsExecBase    ; We get this from outside...
        xref    _LVOSignal      ; We get this from outside...
*
************************************************************************
* Make the entry point external...
*
        xdef    _ResetHandler
*
************************************************************************
*
* This is the input handler
* The is_Data field is passed to you in a1.
*
* This is the structure that is passed in A1 in this example...
*
        STRUCTURE       MyData,0
        APTR            MyTask
        ULONG           MySignal
*
************************************************************************
* The handler gets called here...
*
_ResetHandler:  move.l  MySignal(a1),d0 ; Get signal to send
                move.l  MyTask(a1),a1           ; Get task
*
* Now signal the task...
*
                move.l  a6,-(sp)        ; Save the stack...
                move.l  _AbsExecBase,a6 ; Get ExecBase
                jsr     _LVOSignal(a6)  ; Send the signal
                move.l  (sp)+,a6        ; Restore A6
*
* Return to let other handlers execute.
*
                rts                     ; return from handler...
*
                END
************************************************************************
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
