<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/34.11 FILE="Devices/Dev_1" NODE="1-4" TITLE="1 Introduction Amiga System Devices / Synchronous vs. Asynchronous Requests" INDEX="Devices/Dev_Index/MAIN" -->
<head>
<title>1 Introduction Amiga System Devices / Synchronous vs. Asynchronous Requests</title>
</head>
<body>
<img src="../images/toc_d.gif" alt="[Contents]">
<a href="../Devices_Manual_guide/node012A.html"><img src="../images/index.gif" alt="[Index]" border=0></a>
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../Devices_Manual_guide/node0008.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../Devices_Manual_guide/node000A.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
As stated above, you can send I/O requests to a device synchronously or
asynchronously.  The choice of which to use is largely a function of your
<a name="line4">application.</a>

Synchronous requests use the <a href="../Includes_and_Autodocs_2._guide/node034B.html">DoIO()</a> function.  <a href="../Includes_and_Autodocs_2._guide/node034B.html">DoIO()</a> will not return
control to your application until the I/O request has been satisfied by
the device.  The advantage of this is that you don't have to monitor the
message port for the device reply because <a href="../Includes_and_Autodocs_2._guide/node034B.html">DoIO()</a> takes care of all the
message handling. The disadvantage is that your application will be tied
up while the I/O request is being processed, and should the request not
complete for some reason, <a href="../Includes_and_Autodocs_2._guide/node034B.html">DoIO()</a> will not return and your application will
<a name="line13">hang.</a>

Asynchronous requests use the <a href="../Includes_and_Autodocs_2._guide/node037A.html">SendIO()</a> and <a href="../Includes_and_Autodocs_2._guide/node0141.html">BeginIO()</a> functions. Both
return to your application almost immediately after you call them.  This
allows you to do other operations, including sending more I/O requests to
the device.

   Do Not Touch!
   -------------
   When you use <a href="../Includes_and_Autodocs_2._guide/node037A.html">SendIO()</a> or <a href="../Includes_and_Autodocs_2._guide/node0141.html">BeginIO()</a>, the I/O request you pass to the
   device and any associated data buffers should be considered
   read-only. Once you send it to the device, you must not modify it in
   any way until you receive the reply message from the device or abort
   the request (though you must still wait for a reply). Any exceptions
<a name="line27">   to this rule are documented in the autodoc for the device.</a>

Sending multiple asynchronous I/O requests to a device can be tricky
because devices require them to be unique and initialized.  This means
you can't use an I/O request that's still in the queue, but you need the
<a name="line32">fields which were initialized in it when you opened the device.  The</a>
solution is to copy the initialized I/O request to another I/O request(s)
before sending anything to the device.

Regardless of what you do while you are waiting for an asynchronous I/O
request to return, you need to have some mechanism for knowing when the
request has been done.  There are two basic methods for doing this.

The first involves putting your application into a wait state until the
device returns the I/O request to the message port of your application.
<a name="line42">You can use the <a href="../Includes_and_Autodocs_2._guide/node038B.html">WaitIO()</a>, <a href="../Includes_and_Autodocs_2._guide/node038A.html">Wait()</a> or <a href="../Includes_and_Autodocs_2._guide/node038C.html">WaitPort()</a> function to wait for the</a>
return of the I/O request.

<a href="../Includes_and_Autodocs_2._guide/node038B.html">WaitIO()</a> not only waits for the return of the I/O request, it also takes
care of all the message handling functions.  This is very convenient, but
you can pay for this convenience: your application will hang in the
unlikely event that the I/O request does not return.

<a href="../Includes_and_Autodocs_2._guide/node038A.html">Wait()</a> waits for a signal to be sent to the message port.  It will awaken
your task when the signal arrives, but you are responsible for all of the
message handling.

<a href="../Includes_and_Autodocs_2._guide/node038C.html">WaitPort()</a> waits for the message port to be non-empty.  It returns a
pointer to the message in the port, but you are responsible for all of the
<a name="line56">message handling.</a>

The second method to detect when the request is complete involves using
the <a href="../Includes_and_Autodocs_2._guide/node033E.html">CheckIO()</a> function.  CheckIO() takes an I/O request as its argument
and returns an indication of whether or not it has been completed. When
CheckIO() returns the completed indication, you will still have to remove
the I/O request from the message port.
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
