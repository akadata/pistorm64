<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- AG2HTML: CONVERTER=AG2HTML/1.1 FORMAT=AMIGAGUIDE/34.11 FILE="Devices/iffp/iff.h" NODE="MAIN" TITLE="Devices/iffp/iff.h" -->
<head>
<title>Devices/iffp/iff.h</title>
</head>
<body>
<img src="../images/toc_d.gif" alt="[Contents]">
<img src="../images/index_d.gif" alt="[Index]">
<img src="../images/help_d.gif" alt="[Help]">
<img src="../images/retrace_d.gif" alt="[Retrace]">
<a href="../Devices_Manual_guide/node02E4.html"><img src="../images/prev.gif" alt="[Browse &#060;]" border=0></a>
<a href="../Devices_Manual_guide/node02E6.html"><img src="../images/next.gif" alt="[Browse &#062;]" border=0></a>
<hr>
<pre>
<!-- AG2HTML: BODY=START -->
/*
 *
 * iff.h:	General Definitions for IFFParse modules
 *
 * 6/27/91
 */

#ifndef IFFP_IFF_H
#define IFFP_IFF_H

#include &#034;iffp/compiler.h&#034;

#ifndef EXEC_TYPES_H
#include &#060;exec/types.h&#062;
#endif
#ifndef EXEC_MEMORY_H
#include &#060;exec/memory.h&#062;
#endif
#ifndef UTILITY_TAGITEM_H
#include &#060;utility/tagitem.h&#062;
#endif
#ifndef UTILITY_HOOKS_H
#include &#060;utility/hooks.h&#062;
#endif
#ifndef LIBRARIES_IFFPARSE_H
#include &#060;libraries/iffparse.h&#062;
#endif

#include &#060;stdio.h&#062;
#include &#060;stdlib.h&#062;
#include &#060;string.h&#062;

#ifndef MYDEBUG_H
#include &#034;iffp/debug.h&#034;
#endif

#ifndef NO_PROTOS
#include &#060;clib/exec_protos.h&#062;
#include &#060;clib/iffparse_protos.h&#062;
#endif

#ifndef MAX
#define	MAX(a,b)	((a) &#062; (b) ? (a) : (b))
#endif
#ifndef MIN
#define	MIN(a,b)	((a) &#060; (b) ? (a) : (b))
#endif
#ifndef ABS
#define	ABS(x)		((x) &#060; 0 ? -(x) : (x))
#endif


#define CkErr(expression)  {if (!error) error = (expression);}
#define ChunkMoreBytes(cn)	(cn-&#062;cn_Size - cn-&#062;cn_Scan)
#define IS_ODD(a)		(a &#038; 1)

#define IFF_OKAY	0L
#define	CLIENT_ERROR	1L
#define NOFILE          5L

#define message printf

/* Generic Chunk ID's we may encounter */
#define	ID_ANNO		MAKE_ID('A','N','N','O')
#define	ID_AUTH		MAKE_ID('A','U','T','H')
#define	ID_CHRS		MAKE_ID('C','H','R','S')
#define	ID_Copyright	MAKE_ID('(','c',')',' ')
#define	ID_CSET		MAKE_ID('C','S','E','T')
#define	ID_FVER		MAKE_ID('F','V','E','R')
#define	ID_NAME		MAKE_ID('N','A','M','E')
#define ID_TEXT		MAKE_ID('T','E','X','T')
#define ID_BODY		MAKE_ID('B','O','D','Y')


/* Used to keep track of allocated IFFHandle, and whether file is
 * clipboard or not, filename, copied chunks, etc.
 * This structure is included in the beginning of every
 * form-specific info structure used by the example modules.
 */
struct ParseInfo {
	/* general parse.c related */
	struct  IFFHandle *iff;		/* to be alloc'd with AllocIFF */
	UBYTE	*filename;		/* current filename of this ui */
	LONG	*propchks;		/* properties to get */
	LONG	*collectchks;		/* properties to collect */
	LONG	*stopchks;		/* stop on these (like BODY) */
	BOOL    opened;			/* this iff has been opened */
	BOOL	clipboard;		/* file is clipboard */
	BOOL	hunt;			/* we are parsing a complex file */
	BOOL	Reserved1;		/* must be zero for now */

	/* for copychunks.c - for read/modify/write programs
	 * and programs that need to keep parsed chunk info
	 * around after closing file.
	 * Deallocated by freechunklist();
	 */
	struct Chunk *copiedchunks;

	/* application may hang its own list of new chunks here
	 * just to keep it with the frame.
	 */
	struct Chunk *newchunks;

	ULONG	Reserved[8];
	};


/*
 * Used by some modules to save or pass a singly linked list of chunks
 */
struct Chunk {
	struct  Chunk *ch_Next;
	long	ch_Type;
	long	ch_ID;
        long    ch_Size;
        void    *ch_Data;
};


#ifndef NO_PROTOS
/* parse.c */
LONG openifile(struct ParseInfo *,UBYTE *,ULONG);
void closeifile(struct ParseInfo *);
LONG parseifile(struct ParseInfo *,
		LONG, LONG, LONG *, LONG *, LONG *);
LONG getcontext(struct IFFHandle *);
LONG nextcontext(struct IFFHandle *);
LONG currentchunkis(struct IFFHandle *, LONG type, LONG id);
LONG contextis(struct IFFHandle *, LONG type, LONG id);
UBYTE *findpropdata(struct IFFHandle *iff, LONG type, LONG id);
void initiffasstdio(struct IFFHandle *);
UBYTE *IFFerr(LONG);
LONG chkcnt(LONG *);
long PutCk(struct IFFHandle *iff, long id, long size, void *data);

/* copychunks.c */
struct Chunk *copychunks(struct IFFHandle *iff,
                 LONG *propchks, LONG *collectchks, ULONG memtype);
void freechunklist(struct Chunk *first);
struct Chunk *findchunk(struct Chunk *first, long type, long id);
long writechunklist(struct IFFHandle *iff, struct Chunk *first);
#endif /* NO_PROTOS */

#endif /* IFFP_IFF_H */
<!-- AG2HTML: BODY=END -->
</pre>

<!-- [amigadev.elowar.com] Automatically generated content... -->
<hr />
<pre>[Back to <a href="http://amigadev.elowar.com/">Amiga Developer Docs</a>]</pre>
<!-- [amigadev.elowar.com] End of automatically generated content. -->

</body>
</html>
