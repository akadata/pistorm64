26 / Servicing Interrupts / Environment ]" border=0> Interrupts execute in an environment different from that of tasks. All interrupts execute in supervisor mode and utilize the single system stack. This stack is large enough to handle extreme cases of nested interrupts (of higher priorities). Interrupt processing has no effect on task stack usage. All interrupt processing code, both handlers and servers, is invoked as assembly code subroutines. Normal assembly code register conventions dictate that the D0, D1, A0 and A1 registers be free for scratch use. In the case of an interrupt handler, some of these registers also contain data that may be useful to the handler code. See the section on handlers below. Because interrupt processing executes outside the context of most system activities, certain data structures will not be self-consistent and must be considered off limits for all practical purposes. This happens because certain system operations are not atomic in nature and might be interrupted only after executing part of an important instruction sequence. For example, memory allocation and deallocation routines do not disable interrupts. This results in the possibility of interrupting a memory-related routine. In such a case, a memory linked list may be inconsistent during and interrupt. Therefore, interrupt routines must not use any memory allocation or deallocation functions. In addition, interrupts may not call any system function which might allocate memory, wait, manipulate unprotected lists, or modify ExecBase ->ThisTask data (for example Forbid() , Permit() , and mathieee libraries). In practice, this means that very few system calls may be used within interrupt code. The following functions may generally be used safely within interrupts: Alert() , Disable() , Enable() , Signal() , Cause() , GetMsg() , PutMsg() , ReplyMsg() , FindPort() , FindTask() and if you are manipulating your own List structures while in an interrupt: AddHead() , AddTail() , RemHead() , RemTail() , FindName() In addition, certain devices (notably the timer device) specifically allow limited use of SendIO() and BeginIO() within interrupts. [Back to Amiga Developer Docs ]