25 / Semaphore Functions / The Signal Semaphore ]" border=0> Exec semaphores are signal based. Using signal semaphores is the easiest way to protect shared, single-access resources in the Amiga. Your task will sleep until the semaphore is available for use. The SignalSemaphore structure is as follows: struct SignalSemaphore { struct Node ss_Link; SHORT ss_NestCount; struct MinList ss_WaitQueue; struct SemaphoreRequest ss_MultipleLink; struct Task *ss_Owner; SHORT ss_QueueCount; }; ss_Link is the node structure used to link semaphores together. The ln_Pri and ln_Name fields are used to set the priority of the semaphore in a list and to name the semaphore for public access. If a semaphore is not public the ln_Name and ln_Pri fields may be left NULL. ss_NestCount is the count of number of locks the current owner has on the semaphore. ss_WaitQueue is the List header for the list of other tasks waiting for this semaphore. ss_MultipleLink is the SemaphoreRequest used by ObtainSemaphoreList() . ss_Owner is the pointer to the current owning task. ss_QueueCount is the number of other tasks waiting for the semaphore. A practical application of a SignalSemaphore would be to use it as the base of a shared data structure. For example: struct SharedList { struct SignalSemaphore sl_Semaphore; struct MinList sl_List; }; Creating a SignalSemaphore Structure Making a SignalSemaphore Available to the Public Obtaining a SignalSemaphore Exclusively Obtaining a Shared SignalSemaphore Checking a SignalSemaphore Releasing a SignalSemaphore Removing a SignalSemaphore Structure [Back to Amiga Developer Docs ]