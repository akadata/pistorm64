20 Exec Memory Allocation / Other Memory Functions ]" border=0> Allocate() and Deallocate() use a memory region header, called MemHeader , as part of the calling sequence. You can build your own local header to manage memory locally. This structure takes the form: struct MemHeader { struct Node mh_Node; UWORD mh_Attributes; /* characteristics of region */ struct MemChunk *mh_First; /* first free region */ APTR mh_Lower; /* lower memory bound */ APTR mh_Upper; /* upper memory bound + 1 */ ULONG mh_Free; /* total number of free bytes */ }; mh_Attributes is ignored by Allocate() and Deallocate() . mh_First is the pointer to the first MemChunk structure. mh_Lower is the lowest address within the memory block. This must be a multiple of eight bytes. mh_Upper is the highest address within the memory block + 1. The highest address will itself be a multiple of eight if the block was allocated to you by AllocMem() . mh_Free is the total free space. This structure is included in the include files memory.h > and memory.i >. The following sample code fragment shows the correct initialization of a MemHeader structure. It assumes that you wish to allocate a block of memory from the global pool and thereafter manage it yourself using Allocate() and Deallocate() . allocate.c How Memory Is Tagged. --------------------- Only free memory is "tagged" using a MemChunk linked list. Once memory is allocated, the system has no way of determining which task now has control of that memory. If you allocate memory from the system, be sure to deallocate it when your task exits. You can accomplish this with matched deallocations, or by adding a MemList to your task's tc_MemEntry , or you can deallocate the memory in the finalPC routine (which can be specified if you perform AddTask() yourself). Allocating Memory at an Absolute Address Adding Memory to the System Pool [Back to Amiga Developer Docs ]