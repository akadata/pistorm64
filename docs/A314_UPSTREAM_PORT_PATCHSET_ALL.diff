diff --git a/docs/A314_UPSTREAM_PORT_PLAN.md b/docs/A314_UPSTREAM_PORT_PLAN.md
new file mode 100644
index 00000000..0290b011
--- /dev/null
+++ b/docs/A314_UPSTREAM_PORT_PLAN.md
@@ -0,0 +1,182 @@
+# A314 Upstream Forward Port Plan (PiStorm64)
+
+## Scope
+- Working baseline: `src/a314/` (PiStorm64). Backup: `src/a314.orig/`.
+- Staging reference: `src/a314/import/upstream/` (A501 expansion-port hardware).
+- Primary targets: disk, remotewb, libremote.
+- Secondary reference only: a314d, a314device.
+
+## Task 1: Device Layer Comparison
+
+### a314device (Amiga-side)
+
+PiStorm64 (`src/a314/a314device/`)
+- Single transport model tied to PiStorm shared memory and emulator integration.
+- `a314driver.c` implements the driver task for the CPU-socket transport.
+- `int_server.asm` signals based on PiStorm shared event flags.
+- `device.c` exports only basic device vectors plus `translate_address_a314`.
+- `proto_a314.h` only exposes `TranslateAddressA314` (identity macro).
+
+Upstream (`src/a314/import/upstream/a314device/`)
+- Multiple models (TD/FE/CP) with separate interrupt servers and bus interfaces.
+- Adds `driver_task.c`, `pi_if_*.c`, `int_server_*.asm`, `cmem.*`, `check_a314_mapping.asm`, `handshake_fe.h`.
+- `device.c` exports additional LVOs: alloc/free/read/write mem, translate address.
+- `memory_allocator.*` implements 64K A314 RAM allocator for CP model.
+- `config_file.*` parses `DEVS:a314.config` (clockport address, interrupt line).
+
+A501-specific (do not port)
+- `pi_if_td.c`, `pi_if_fe.c`, `pi_if_cp.c` (GPIO/clockport register access).
+- `int_server_*` for TD/FE/CP models (hardware IRQ lines).
+- `cmem.*` and `check_a314_mapping.asm` (SPI SRAM / mapping probe).
+- `handshake_fe.h` and CP config parsing (`config_file.*`).
+
+Transport-agnostic candidates (already present or low value)
+- `sockets.*` protocol logic is common but already present in PiStorm.
+- `debug.*` is generic logging but uses upstream process logger and VBCC pragmas.
+
+### a314d (Pi-side)
+
+PiStorm64 (`src/a314/a314.cc`)
+- Integrated into the emulator; no GPIO/SPI.
+- Uses `ps_read_8/ps_write_8` and mapped memory regions.
+- Explicit little-endian framing for client message headers (`<IIB`).
+- On-demand service spawning from `a314d.conf`.
+
+Upstream (`src/a314/import/upstream/a314d/a314d.cc`)
+- Hardware models TD/FE/CP with SPI/GPIO, interrupts, and device overlays.
+- Uses `/dev/spidev*`, `/dev/gpiomem`, `spi-a314-overlay.dts`.
+- No explicit LE header framing in the Python helper (`a314d.py`).
+
+Conclusion
+- Do not port upstream a314d or a314device hardware backends to PiStorm64.
+- Only transport-agnostic helpers (Python client helper) are useful, but must be endian-fixed.
+
+## Task 2: Service Feasibility and Port Plan
+
+### 2A: disk
+
+Feasibility verdict: Feasible with minor changes.
+
+Pi-side (copy to `src/a314/files_pi/`)
+- `src/a314/files_pi/disk.py`
+- `src/a314/files_pi/disk.conf`
+- `src/a314/files_pi/a314d.py` (shared helper)
+
+Amiga-side (copy to `src/a314/software-amiga/`)
+- `src/a314/software-amiga/disk_pistorm/device.c`
+- `src/a314/software-amiga/disk_pistorm/debug.c`
+- `src/a314/software-amiga/disk_pistorm/debug.h`
+- `src/a314/software-amiga/disk_pistorm/romtag.asm`
+- `src/a314/software-amiga/a314disk-mountlist`
+
+PiStorm-specific changes
+- Replace `AllocMemA314`/`FreeMemA314` with Exec `AllocMem`/`FreeMem` in disk device.
+- Keep `TranslateAddressA314` identity macro (PiStorm transport).
+
+Endianness
+- A314d header framing: explicit LE (`<IIB`, `<IIBII`, `<IIBI`).
+- Disk payloads remain BE (`>BBHII`, `>BBB`, `>BBBBI`).
+
+Emulator integration
+- None required; uses existing A314 read/write memory requests.
+
+Minimal test plan
+1. Start service via `a314d.conf` entry.
+2. Mount PD0: using `a314disk-mountlist` entry or equivalent Mountlist entry.
+3. Use `nc localhost 23890`:
+   - `insert 0 /path/to/test.adf`
+   - `eject 0`
+4. Verify read/write behavior with file copy on PD0:
+   - Create file, reboot, verify persistence on ADF/HDF.
+
+### 2B: remotewb
+
+Feasibility verdict: Feasible with performance caveats.
+
+Pi-side (copy to `src/a314/files_pi/`)
+- `src/a314/files_pi/remotewb.py`
+- `src/a314/files_pi/remotewb_client.html`
+- `src/a314/files_pi/pointer.cur`
+- `src/a314/files_pi/bpls2gif/` (dependency; build C extension)
+
+Amiga-side (copy to `src/a314/software-amiga/`)
+- `src/a314/software-amiga/remotewb_pistorm/remotewb.c`
+- `src/a314/software-amiga/remotewb_pistorm/vblank_server.asm`
+
+Performance risks
+- Frequent `MSG_READ_MEM_REQ` for 61440 bytes per frame.
+- VBlank-triggered updates can saturate bus if CPU is busy.
+- Websocket traffic is bursty; ensure `TCP_NODELAY` is set (already upstream).
+
+Endianness
+- A314d header framing: explicit LE (`<IIB`, `<IIBII`).
+- Amiga-side payloads remain BE (screen geometry, palette, input events).
+
+Emulator integration
+- None required. Uses read-mem requests over existing A314 transport.
+
+Minimal test plan
+1. Build and install `remotewb` Amiga client (`C:RemoteWB`).
+2. Start `remotewb.py` and open `remotewb_client.html` in a browser.
+3. Launch `RemoteWB` on Amiga; verify screen updates and mouse/keyboard input.
+
+### 2C: libremote (bsdsocket proxy)
+
+Feasibility verdict: Feasible, moderate risk from message volume and latency.
+
+Scope cut (now)
+- Port `bsdsocket.py` service and the `libremote` Amiga library.
+- Skip example library (`example.py`, `libdecl-example.json`, `example_client.c`).
+
+Pi-side (copy to `src/a314/files_pi/`)
+- `src/a314/files_pi/bsdsocket.py`
+- `src/a314/files_pi/a314d.py` (shared helper)
+
+Amiga-side (copy to `src/a314/software-amiga/`)
+- `src/a314/software-amiga/libremote_pistorm/library.c`
+- `src/a314/software-amiga/libremote_pistorm/messages.h`
+- `src/a314/software-amiga/libremote_pistorm/romtag.asm`
+- `src/a314/software-amiga/libremote_pistorm/gen_stubs.py`
+- `src/a314/software-amiga/libremote_pistorm/gen_proto.py`
+- `src/a314/software-amiga/libremote_pistorm/libdecl-bsdsocket.json`
+
+PiStorm-specific changes
+- Replace `AllocMemA314`/`FreeMemA314` with Exec `AllocMem`/`FreeMem` for the bounce buffer.
+
+Endianness
+- A314d header framing: explicit LE (`<IIB`, `<IIBII`).
+- Libremote protocol messages are BE (as in `messages.h`).
+
+Emulator integration
+- None required. Uses read/write memory requests already supported in `a314.cc`.
+
+Minimal test plan
+1. Install `bsdsocket.library` in `L:` on the Amiga.
+2. Start `bsdsocket.py` service.
+3. Use a minimal socket client (e.g. open/close socket + gethostname) and verify returns.
+
+## Endianness Checklist (enforce everywhere)
+- A314 client header: `struct.pack('<IIB', length, stream_id, type)`.
+- A314 read/write mem requests: `struct.pack('<IIBII', 8, 0, MSG_READ_MEM_REQ, addr, len)`.
+- Amiga payloads remain BE as per the C side protocol definitions.
+- Do not use `struct.pack('=')` or `struct.unpack('=')`.
+
+## Emulator Integration Notes
+- No changes required to `src/emulator.c` or `src/emulator.h` for disk/remotewb/libremote.
+- Only revisit emulator changes if adding A314Base LVOs (Alloc/Free/Read/Write) or non-identity address translation.
+
+## Patchset Plan
+
+Patchset 1 (introduce files + build wiring; no enable by default)
+- Add new Pi-side scripts and Amiga sources for disk/remotewb/libremote.
+- Add `a314d.py` helper for services.
+- Add build scripts and README for the new services.
+
+Patchset 2 (endian fixes + logging + stable defaults)
+- Convert all A314 header framing to explicit LE (`<`).
+- Add one-time header sanity check with fail-closed behavior.
+- Replace `AllocMemA314` usage in new Amiga sources.
+- Set disk.conf default to empty auto-insert and add config file override.
+
+Patchset 3 (integration wiring)
+- Not needed unless you want to add new A314 device LVOs or enforce address translation checks.
diff --git a/docs/A314_UPSTREAM_PORT_README.md b/docs/A314_UPSTREAM_PORT_README.md
new file mode 100644
index 00000000..541e7cc8
--- /dev/null
+++ b/docs/A314_UPSTREAM_PORT_README.md
@@ -0,0 +1,83 @@
+# A314 Upstream Services (PiStorm64) Build and Test
+
+This README covers how to build the Amiga-side binaries with `/opt/amiga/bin/m68k-amigaos-gcc`, run the Pi-side services, and test disk/remotewb/libremote. Paths below assume the repo root is `/home/smalley/pistorm64`.
+
+## Toolchain Prereqs
+- `/opt/amiga/bin/m68k-amigaos-gcc`
+- `/opt/amiga/bin/vasmm68k_mot` (for `.asm` files)
+- Python 3 for `gen_stubs.py` (libremote)
+
+Ensure toolchain is on PATH:
+```
+export PATH=/opt/amiga/bin:$PATH
+```
+
+## Build: disk
+```
+cd src/a314/software-amiga/disk_pistorm
+vasmm68k_mot -Fhunk -quiet romtag.asm -o romtag.o
+m68k-amigaos-gcc -m68000 -O2 -c device.c -o device.o
+m68k-amigaos-gcc -m68000 -O2 -c debug.c -o debug.o
+m68k-amigaos-gcc -m68000 -nostartfiles -o ../a314disk.device romtag.o device.o debug.o -lamiga
+```
+Install on Amiga:
+- `Devs:a314disk.device`
+- `Devs:MountList` (merge entry from `src/a314/software-amiga/a314disk-mountlist`)
+
+## Build: remotewb
+```
+cd src/a314/software-amiga/remotewb_pistorm
+vasmm68k_mot -Fhunk -quiet vblank_server.asm -o vblank_server.o
+m68k-amigaos-gcc -m68000 -O2 -c remotewb.c -o remotewb.o
+m68k-amigaos-gcc -m68000 -nostartfiles -o ../remotewb remotewb.o vblank_server.o -lamiga
+```
+Install on Amiga:
+- `C:RemoteWB` (from `src/a314/software-amiga/remotewb` output)
+
+## Build: libremote (bsdsocket.library)
+```
+cd src/a314/software-amiga/libremote_pistorm
+python3 gen_stubs.py libdecl-bsdsocket.json
+vasmm68k_mot -Fhunk -quiet romtag.asm -o romtag.o
+m68k-amigaos-gcc -m68000 -O2 -c library.c -o library.o
+m68k-amigaos-gcc -m68000 -nostartfiles -o ../bsdsocket.library romtag.o library.o -lamiga
+```
+Install on Amiga:
+- `L:bsdsocket.library`
+
+## Pi-side services
+Enable services by adding entries to `src/a314/files_pi/a314d.conf` (not enabled by default). Example lines:
+```
+disk       python3 /home/smalley/pistorm64/src/a314/files_pi/disk.py
+remotewb   python3 /home/smalley/pistorm64/src/a314/files_pi/remotewb.py
+bsl        python3 /home/smalley/pistorm64/src/a314/files_pi/bsdsocket.py
+```
+
+Optional dependency for RemoteWB:
+```
+cd src/a314/files_pi/bpls2gif
+python3 setup.py build_ext --inplace
+```
+
+## Tests
+
+Disk
+1. Start `disk.py` (via a314d on-demand).
+2. Use `nc localhost 23890`:
+   - `insert 0 /path/to/test.adf`
+   - `eject 0`
+3. On Amiga, mount `PD0:` and verify read/write to the ADF/HDF.
+
+RemoteWB
+1. Start `remotewb.py`.
+2. Open `src/a314/files_pi/remotewb_client.html` in a browser.
+3. On Amiga, run `RemoteWB` and verify screen updates + input.
+
+Libremote (bsdsocket)
+1. Start `bsdsocket.py`.
+2. On Amiga, run a minimal bsdsocket client (open socket, gethostname, close).
+
+## Endianness Rules (critical)
+- A314 client headers must be explicit little-endian (`<IIB`, `<IIBII`, `<IIBI`).
+- Amiga payload structures remain big-endian.
+- Avoid `struct.pack('=')` and `struct.unpack('=')`.
diff --git a/src/a314/files_pi/a314d.py b/src/a314/files_pi/a314d.py
new file mode 100644
index 00000000..65336535
--- /dev/null
+++ b/src/a314/files_pi/a314d.py
@@ -0,0 +1,139 @@
+# -*- coding: utf-8 -*-
+
+# Copyright (c) 2022 Niklas Ekström
+
+import logging
+import socket
+import struct
+import sys
+
+logger = logging.getLogger(__name__)
+
+MAX_MESSAGE_SIZE = 1024 * 1024
+
+class A314d(object):
+    MSG_REGISTER_REQ        = 1
+    MSG_REGISTER_RES        = 2
+    MSG_DEREGISTER_REQ      = 3
+    MSG_DEREGISTER_RES      = 4
+    MSG_READ_MEM_REQ        = 5
+    MSG_READ_MEM_RES        = 6
+    MSG_WRITE_MEM_REQ       = 7
+    MSG_WRITE_MEM_RES       = 8
+    MSG_CONNECT             = 9
+    MSG_CONNECT_RESPONSE    = 10
+    MSG_DATA                = 11
+    MSG_EOS                 = 12
+    MSG_RESET               = 13
+    _KNOWN_TYPES = {
+        MSG_REGISTER_REQ,
+        MSG_REGISTER_RES,
+        MSG_DEREGISTER_REQ,
+        MSG_DEREGISTER_RES,
+        MSG_READ_MEM_REQ,
+        MSG_READ_MEM_RES,
+        MSG_WRITE_MEM_REQ,
+        MSG_WRITE_MEM_RES,
+        MSG_CONNECT,
+        MSG_CONNECT_RESPONSE,
+        MSG_DATA,
+        MSG_EOS,
+        MSG_RESET,
+    }
+
+    def __init__(self, service_name):
+        self._bad_header_logged = False
+        if '-ondemand' in sys.argv:
+            index = sys.argv.index('-ondemand')
+            fd = int(sys.argv[index + 1])
+            self.drv = socket.socket(fileno=fd)
+        else:
+            self.drv = socket.socket()
+            self.drv.connect(('localhost', 7110))
+            self.drv.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
+
+            self.send_register_req(service_name.encode())
+            _, _, payload = self.wait_for_msg()
+            success = payload[0] == 1
+            if not success:
+                raise RuntimeError(f'Unable to register service "{service_name}" with a314d')
+
+    def close(self):
+        self.drv.close()
+
+    def fileno(self):
+        return self.drv.fileno()
+
+    def _fail_bad_header(self, plen, stream_id, ptype):
+        if not self._bad_header_logged:
+            logger.error(
+                'Bad A314d header (len=%d stream=%d type=%d). Check endian framing.',
+                plen,
+                stream_id,
+                ptype,
+            )
+            self._bad_header_logged = True
+        raise RuntimeError('Bad A314d header')
+
+    def wait_for_msg(self):
+        header = b''
+        while len(header) < 9:
+            data = self.drv.recv(9 - len(header))
+            if not data:
+                logger.error('Connection to a314d was closed, terminating.')
+                exit(-1)
+            header += data
+        (plen, stream_id, ptype) = struct.unpack('<IIB', header)
+        if plen > MAX_MESSAGE_SIZE or ptype not in self._KNOWN_TYPES:
+            self._fail_bad_header(plen, stream_id, ptype)
+        payload = b''
+        while len(payload) < plen:
+            data = self.drv.recv(plen - len(payload))
+            if not data:
+                logger.error('Connection to a314d was closed, terminating.')
+                exit(-1)
+            payload += data
+        return (stream_id, ptype, payload)
+
+    def send_register_req(self, name):
+        m = struct.pack('<IIB', len(name), 0, self.MSG_REGISTER_REQ) + name
+        self.drv.sendall(m)
+
+    def send_read_mem_req(self, address, length):
+        m = struct.pack('<IIBII', 8, 0, self.MSG_READ_MEM_REQ, address, length)
+        self.drv.sendall(m)
+
+    def read_mem(self, address, length):
+        self.send_read_mem_req(address, length)
+        _, ptype, payload = self.wait_for_msg()
+        if ptype != self.MSG_READ_MEM_RES:
+            logger.error('Expected MSG_READ_MEM_RES but got %s. Shutting down.', ptype)
+            exit(-1)
+        return payload
+
+    def send_write_mem_req(self, address, data):
+        m = struct.pack('<IIBI', 4 + len(data), 0, self.MSG_WRITE_MEM_REQ, address) + data
+        self.drv.sendall(m)
+
+    def write_mem(self, address, data):
+        self.send_write_mem_req(address, data)
+        _, ptype, _ = self.wait_for_msg()
+        if ptype != self.MSG_WRITE_MEM_RES:
+            logger.error('Expected MSG_WRITE_MEM_RES but got %s. Shutting down.', ptype)
+            exit(-1)
+
+    def send_connect_response(self, stream_id, result):
+        m = struct.pack('<IIBB', 1, stream_id, self.MSG_CONNECT_RESPONSE, result)
+        self.drv.sendall(m)
+
+    def send_data(self, stream_id, data):
+        m = struct.pack('<IIB', len(data), stream_id, self.MSG_DATA) + data
+        self.drv.sendall(m)
+
+    def send_eos(self, stream_id):
+        m = struct.pack('<IIB', 0, stream_id, self.MSG_EOS)
+        self.drv.sendall(m)
+
+    def send_reset(self, stream_id):
+        m = struct.pack('<IIB', 0, stream_id, self.MSG_RESET)
+        self.drv.sendall(m)
diff --git a/src/a314/files_pi/bpls2gif/bpls2gif.c b/src/a314/files_pi/bpls2gif/bpls2gif.c
new file mode 100644
index 00000000..ad63d6f1
--- /dev/null
+++ b/src/a314/files_pi/bpls2gif/bpls2gif.c
@@ -0,0 +1,354 @@
+/*
+ * Copyright (c) 2018 Niklas Ekström
+ */
+
+#define PY_SSIZE_T_CLEAN
+
+#include <Python.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+
+#define COLORS 8
+#define CHUNKLEN 255
+
+struct _Node
+{
+	uint16_t children[COLORS];
+};
+typedef struct _Node Node;
+
+static Node *nodes;
+
+static void init_node(uint16_t code)
+{
+	Node *node = &nodes[code];
+	for (int i = 0; i < COLORS; i++)
+		node->children[i] = 0xffff;
+}
+
+static uint8_t *buffer;
+static int capacity;
+static int length;
+
+static void append_byte(uint8_t b)
+{
+	if (length == capacity)
+	{
+		capacity *= 2;
+		buffer = realloc(buffer, capacity);
+	}
+
+	buffer[length++] = b;
+}
+
+static int chunk_left = 0;
+
+static void flush_byte(uint8_t b)
+{
+	if (!chunk_left)
+	{
+		append_byte(CHUNKLEN);
+		chunk_left = CHUNKLEN;
+	}
+
+	append_byte(b);
+	chunk_left--;
+}
+
+#define c2p(c) &nodes[c]
+#define p2c(p) (((uint32_t)((intptr_t)p - (intptr_t)nodes)) / sizeof(Node))
+
+static const uint32_t clear_code = 256;
+static const uint32_t eoi_code = 257;
+static uint32_t next_code = 258;
+
+static int clen;
+
+static uint32_t buf;
+static int blen;
+
+static Node *prefix;
+
+static void begin_encode(void)
+{
+	chunk_left = 0;
+
+	for (int i = 0; i < COLORS; i++)
+		init_node(i);
+
+	next_code = 258;
+	clen = 9;
+
+	buf = 0;
+	blen = 0;
+
+	buf |= clear_code << blen;
+	blen += clen;
+
+	prefix = NULL;
+}
+
+static void end_encode(void)
+{
+	buf |= p2c(prefix) << blen;
+	blen += clen;
+
+	buf |= eoi_code << blen;
+	blen += clen;
+
+	while (blen > 0)
+	{
+		flush_byte(buf);
+		buf >>= 8;
+		blen -= 8;
+	}
+
+	if (chunk_left)
+	{
+		int used = CHUNKLEN - chunk_left;
+		buffer[length - used - 1] = used;
+	}
+}
+
+static void encode(uint8_t *pixels, int count)
+{
+	uint32_t *cp = (uint32_t *)pixels;
+	uint32_t *end = (uint32_t *)(pixels + (count / 2));
+
+	uint32_t ibuf = *cp++;
+	int ilen = 8;
+
+	if (!prefix)
+	{
+		uint8_t K = ibuf & 0xf;
+		ibuf >>= 4;
+		ilen--;
+		prefix = &nodes[K];
+	}
+
+	while (cp < end || ilen)
+	{
+		if (!ilen)
+		{
+			ibuf = *cp++;
+			ilen = 8;
+		}
+
+		uint8_t K = ibuf & 0xf;
+		ibuf >>= 4;
+		ilen--;
+
+		if (prefix->children[K] != 0xffff)
+			prefix = c2p(prefix->children[K]);
+		else
+		{
+			buf |= p2c(prefix) << blen;
+			blen += clen;
+
+			init_node(next_code);
+			prefix->children[K] = next_code;
+
+			if (next_code == (1U << clen))
+				clen++;
+			next_code++;
+
+			prefix = &nodes[K];
+
+			if (next_code == 4095)
+			{
+				buf |= clear_code << blen;
+				blen += clen;
+
+				for (int i = 0; i < COLORS; i++)
+					init_node(i);
+
+				clen = 9;
+				next_code = 258;
+			}
+
+			while (blen >= 8)
+			{
+				flush_byte(buf);
+				buf >>= 8;
+				blen -= 8;
+			}
+		}
+	}
+}
+
+#define W 640
+#define H 256
+#define BLOCK_HEIGHT 32
+#define BPL_SIZE (W * H / 8)
+#define BPL_COUNT 3
+
+static uint8_t pal[8*3] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+
+static void copy_bpls_to_pixels(uint8_t *pixels, uint8_t *bpls, int b)
+{
+	memset(pixels, 0, W * BLOCK_HEIGHT / 2);
+
+	bpls += b * BLOCK_HEIGHT * W / 8;
+	for (int i = 0; i < BPL_COUNT; i++)
+	{
+		uint8_t *src = bpls;
+		uint32_t *dst = (uint32_t *)pixels;
+
+		int shift = 28 - (7 - i);
+
+		for (int j = 0; j < BLOCK_HEIGHT * W / 8; j++)
+		{
+			uint8_t x = *src++;
+			uint32_t bits = 0;
+			for (int k = 0; k < 8; k++)
+			{
+				bits = (bits >> 4) | ((x & 0x80) << shift);
+				x <<= 1;
+			}
+			*dst++ |= bits;
+		}
+		bpls += BPL_SIZE;
+	}
+}
+
+static uint8_t *pixels;
+
+static void write_gif(uint8_t *bpls)
+{
+	uint8_t *p = buffer;
+	memcpy(p, "GIF89a", 6);
+	p += 6;
+	*((short *)p) = W;
+	p += 2;
+	*((short *)p) = H;
+	p += 2;
+	*p++ = 0xf7;
+	*p++ = 0;
+	*p++ = 0;
+	memset(p, 0, 768);
+	memcpy(p, pal, sizeof(pal));
+	p += 768;
+	*p++ = 0x2c;
+	*((short *)p) = 0;
+	p += 2;
+	*((short *)p) = 0;
+	p += 2;
+	*((short *)p) = W;
+	p += 2;
+	*((short *)p) = H;
+	p += 2;
+	*p++ = 0;
+	*p++ = 8;
+	length = p - buffer;
+
+	begin_encode();
+	for (int b = 0; b < H / BLOCK_HEIGHT; b++)
+	{
+		copy_bpls_to_pixels(pixels, bpls, b);
+		encode(pixels, W * BLOCK_HEIGHT);
+	}
+	end_encode();
+
+	append_byte(0);
+	append_byte(0x3b);
+}
+
+#if PY_MAJOR_VERSION > 2
+#define BYTEARRAY_FORMAT "y#"
+#else
+#define BYTEARRAY_FORMAT "s#"
+#endif
+
+static PyObject *b2g_set_palette(PyObject *self, PyObject *args)
+{
+	char *buf;
+	Py_ssize_t len;
+
+	if (!PyArg_ParseTuple(args, BYTEARRAY_FORMAT, &buf, &len))
+		return NULL;
+
+	if (len != 24) {
+		PyErr_SetString(PyExc_RuntimeError, "Must be 8*3 = 24 bytes (r, g, b).");
+		return NULL;
+	}
+
+	memcpy(pal, buf, 24);
+
+	Py_INCREF(Py_None);
+	return Py_None;
+}
+
+static PyObject *b2g_encode(PyObject *self, PyObject *args)
+{
+	char *buf;
+	Py_ssize_t len;
+
+	if (!PyArg_ParseTuple(args, BYTEARRAY_FORMAT, &buf, &len))
+		return NULL;
+
+	if (len != 80*256*3) {
+		PyErr_SetString(PyExc_RuntimeError, "Must be 3 bitplanes of 256 rows with 80 bytes per row (total of 61440 bytes).");
+		return NULL;
+	}
+
+	write_gif((uint8_t *)buf);
+
+	return Py_BuildValue(BYTEARRAY_FORMAT, buffer, length);
+}
+
+static char module_docstring[] =
+"Encode an image given as a set of Amiga bitplanes as a GIF file.";
+
+static char set_palette_docstring[] =
+"Set palette to use for image. Input is a string of r, g, b color values.";
+
+static char encode_docstring[] =
+"Encode bitplanes as GIF, using the palette given previously.";
+
+static PyMethodDef module_methods[] = {
+	{"set_palette", b2g_set_palette, METH_VARARGS, set_palette_docstring },
+	{"encode", b2g_encode, METH_VARARGS, encode_docstring},
+	{NULL, NULL, 0, NULL}
+};
+
+#if PY_MAJOR_VERSION > 2
+static struct PyModuleDef bpls2gif_module = {
+   PyModuleDef_HEAD_INIT,
+   "bpls2gif",
+   module_docstring,
+   -1,
+   module_methods
+};
+#endif
+
+#if PY_MAJOR_VERSION > 2
+PyMODINIT_FUNC PyInit_bpls2gif(void)
+#else
+PyMODINIT_FUNC initbpls2gif(void)
+#endif
+{
+#if PY_MAJOR_VERSION > 2
+	PyObject *m = PyModule_Create(&bpls2gif_module);
+	if (m == NULL)
+		return NULL;
+#else
+	PyObject *m = Py_InitModule3("bpls2gif", module_methods, module_docstring);
+	if (m == NULL)
+		return;
+#endif
+
+	nodes = malloc(4096 * sizeof(Node));
+	pixels = malloc(W * BLOCK_HEIGHT / 2);
+
+	buffer = malloc(4096);
+	capacity = 4096;
+	length = 0;
+
+#if PY_MAJOR_VERSION > 2
+	return m;
+#else
+	return;
+#endif
+}
diff --git a/src/a314/files_pi/bpls2gif/setup.py b/src/a314/files_pi/bpls2gif/setup.py
new file mode 100644
index 00000000..4831f424
--- /dev/null
+++ b/src/a314/files_pi/bpls2gif/setup.py
@@ -0,0 +1,12 @@
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+
+from distutils.core import setup, Extension
+
+setup(  name            = "bpls2gif",
+        version         = "1.0",
+        description     = "Encode Amiga bitplanes as GIF file",
+        author          = "Niklas Ekström",
+        url             = "http://github.com/niklasekstrom/a314",
+        ext_modules     = [Extension("bpls2gif", ["bpls2gif.c"])]
+)
diff --git a/src/a314/files_pi/bsdsocket.py b/src/a314/files_pi/bsdsocket.py
new file mode 100644
index 00000000..ca3893e6
--- /dev/null
+++ b/src/a314/files_pi/bsdsocket.py
@@ -0,0 +1,1267 @@
+#!/usr/bin/python3
+# -*- coding: utf-8 -*-
+
+# Copyright (c) 2024 Niklas Ekström
+
+import logging
+logging.basicConfig(format='%(levelname)s, %(asctime)s, %(name)s, line %(lineno)d: %(message)s', level=logging.DEBUG)
+
+from a314d import A314d
+import queue
+import select
+import socket
+import struct
+import threading
+import time
+from typing import Dict, List, Tuple, Optional, Any
+
+logger = logging.getLogger(__name__)
+
+MAX_MESSAGE_SIZE = 1024 * 1024
+_bad_header_logged = False
+
+# These must match constants in messages.h.
+MSG_SIGNALS                 = 1
+MSG_OP_REQ                  = 2
+MSG_OP_RES                  = 3
+MSG_ALLOC_MEM_REQ           = 4
+MSG_ALLOC_MEM_RES           = 5
+MSG_FREE_MEM_REQ            = 6
+MSG_FREE_MEM_RES            = 7
+MSG_READ_MEM_REQ            = 8
+MSG_READ_MEM_RES            = 9
+MSG_WRITE_MEM_REQ           = 10
+MSG_WRITE_MEM_RES           = 11
+MSG_COPY_FROM_BOUNCE_REQ    = 12
+MSG_COPY_FROM_BOUNCE_RES    = 13
+MSG_COPY_TO_BOUNCE_REQ      = 14
+MSG_COPY_TO_BOUNCE_RES      = 15
+MSG_COPY_STR_TO_BOUNCE_REQ  = 16
+MSG_COPY_STR_TO_BOUNCE_RES  = 17
+MSG_COPY_TAG_LIST_TO_BOUNCE_REQ = 18
+MSG_COPY_TAG_LIST_TO_BOUNCE_RES = 19
+
+QITEM_RESET = 1
+QITEM_READ_BOUNCE_COMPLETE = 2
+QITEM_WRITE_BOUNCE_COMPLETE = 3
+QITEM_SIGNALS = 4
+QITEM_OP_REQ = 5
+QITEM_ALLOC_MEM_RES = 6
+QITEM_FREE_MEM_RES = 7
+QITEM_READ_MEM_RES = 8
+QITEM_WRITE_MEM_RES = 9
+QITEM_COPY_FROM_BOUNCE_RES = 10
+QITEM_COPY_TO_BOUNCE_RES = 11
+QITEM_COPY_STR_TO_BOUNCE_RES = 12
+QITEM_COPY_TAG_LIST_TO_BOUNCE_RES = 13
+
+SERVICE_NAME = 'bsl'
+KNOWN_PTYPES = {
+    A314d.MSG_REGISTER_REQ,
+    A314d.MSG_REGISTER_RES,
+    A314d.MSG_DEREGISTER_REQ,
+    A314d.MSG_DEREGISTER_RES,
+    A314d.MSG_READ_MEM_REQ,
+    A314d.MSG_READ_MEM_RES,
+    A314d.MSG_WRITE_MEM_REQ,
+    A314d.MSG_WRITE_MEM_RES,
+    A314d.MSG_CONNECT,
+    A314d.MSG_CONNECT_RESPONSE,
+    A314d.MSG_DATA,
+    A314d.MSG_EOS,
+    A314d.MSG_RESET,
+}
+
+def _fail_bad_header(plen, stream_id, ptype):
+    global _bad_header_logged
+    if not _bad_header_logged:
+        logger.error(
+            'Bad A314d header (len=%d stream=%d type=%d). Check endian framing.',
+            plen,
+            stream_id,
+            ptype,
+        )
+        _bad_header_logged = True
+    raise SystemExit(1)
+
+FN_SOCKET = 0
+FN_BIND = 1
+FN_LISTEN = 2
+FN_ACCEPT = 3
+FN_CONNECT = 4
+FN_SENDTO = 5
+FN_SEND = 6
+FN_RECVFROM = 7
+FN_RECV = 8
+FN_SHUTDOWN = 9
+FN_SETSOCKOPT = 10
+FN_GETSOCKOPT = 11
+FN_GETSOCKNAME = 12
+FN_GETPEERNAME = 13
+FN_IOCTLSOCKET = 14
+FN_CLOSESOCKET = 15
+FN_WAITSELECT = 16
+FN_SETSOCKETSIGNALS = 17
+FN_GETDTABLESIZE = 18
+FN_OBTAINSOCKET = 19
+FN_RELEASESOCKET = 20
+FN_RELEASECOPYOFSOCKET = 21
+FN_ERRNO = 22
+FN_SETERRNOPTR = 23
+FN_INET_NTOA = 24
+FN_INET_ADDR = 25
+FN_INET_LNAOF = 26
+FN_INET_NETOF = 27
+FN_INET_MAKEADDR = 28
+FN_INET_NETWORK = 29
+FN_GETHOSTBYNAME = 30
+FN_GETHOSTBYADDR = 31
+FN_GETNETBYNAME = 32
+FN_GETNETBYADDR = 33
+FN_GETSERVBYNAME = 34
+FN_GETSERVBYPORT = 35
+FN_GETPROTOBYNAME = 36
+FN_GETPROTOBYNUMBER = 37
+FN_VSYSLOG = 38
+FN_DUP2SOCKET = 39
+FN_SENDMSG = 40
+FN_RECVMSG = 41
+FN_GETHOSTNAME = 42
+FN_GETHOSTID = 43
+FN_SOCKETBASETAGLIST = 44
+FN_GETSOCKETEVENTS = 45
+
+TAG_DONE = 0
+TAG_IGNORE = 1
+TAG_MORE = 2
+TAG_SKIP = 3
+TAG_USER = 0x80000000
+SBTF_REF = 0x8000
+
+SBTC_BREAKMASK      = 1
+SBTC_SIGIOMASK      = 2
+SBTC_SIGURGMASK     = 3
+SBTC_SIGEVENTMASK   = 4
+SBTC_ERRNO          = 6
+SBTC_HERRNO         = 7
+SBTC_DTABLESIZE     = 8
+SBTC_FDCALLBACK     = 9
+SBTC_LOGSTAT        = 10
+SBTC_LOGTAGPTR      = 11
+SBTC_LOGFACILITY    = 12
+SBTC_LOGMASK        = 13
+SBTC_ERRNOSTRPTR    = 14
+SBTC_HERRNOSTRPTR   = 15
+SBTC_IOERRNOSTRPTR  = 16
+SBTC_S2ERRNOSTRPTR  = 17
+SBTC_S2WERRNOSTRPTR = 18
+SBTC_ERRNOBYTEPTR   = 21
+SBTC_ERRNOWORDPTR   = 22
+SBTC_ERRNOLONGPTR   = 24
+SBTC_HERRNOLONGPTR  = 25
+SBTC_RELEASESTRPTR  = 29
+
+EINTR = 4
+EBADF = 9
+ETIMEDOUT = 60
+ECONNREFUSED = 61
+
+class AmSocket:
+    def __init__(self, slot: int, sock: socket.socket) -> None:
+        self.slot = slot
+        self.sock = sock
+
+class LibInstance:
+    def __init__(self, service: 'LibRemoteService', stream_id: int) -> None:
+        self.service = service
+        self.stream_id = stream_id
+        self.queue = queue.Queue()
+        self.notify_sock, self.wait_sock = socket.socketpair()
+
+        self.wait_first_message = True
+        self.bb_address = 0
+        self.bb_size = 0
+
+        self.break_mask = 4096 # SIGBREAKF_CTRL_C
+        self.log_tag_ptr = 0
+        self.errno_ptr = 0
+        self.errno_size = 0
+        self.herrno_ptr = None
+
+        # Store the latest errno value locally, as it may be asked for.
+        self.errno = 0
+
+        self.return_mem_address = 0
+        self.sockets: Dict[int, AmSocket] = {}
+
+        threading.Thread(target=self.run).start()
+
+    # Put items on queue.
+    def process_stream_reset(self):
+        self.queue.put((QITEM_RESET, None))
+        self.notify_sock.send(b'#')
+
+    def process_read_mem_complete(self, address: int, data: bytes):
+        self.queue.put((QITEM_READ_BOUNCE_COMPLETE, data))
+        self.notify_sock.send(b'#')
+
+    def process_write_mem_complete(self, address: int):
+        self.queue.put((QITEM_WRITE_BOUNCE_COMPLETE, None))
+        self.notify_sock.send(b'#')
+
+    def process_signals(self, signals: int):
+        self.queue.put((QITEM_SIGNALS, signals))
+        self.notify_sock.send(b'#')
+
+    def process_op_req(self, op: int, args: bytes):
+        self.queue.put((QITEM_OP_REQ, (op, args)))
+        self.notify_sock.send(b'#')
+
+    def process_alloc_mem_res(self, address: int):
+        self.queue.put((QITEM_ALLOC_MEM_RES, address))
+        self.notify_sock.send(b'#')
+
+    def process_free_mem_res(self):
+        self.queue.put((QITEM_FREE_MEM_RES, None))
+        self.notify_sock.send(b'#')
+
+    def process_read_mem_res(self, data: bytes):
+        self.queue.put((QITEM_READ_MEM_RES, data))
+        self.notify_sock.send(b'#')
+
+    def process_write_mem_res(self):
+        self.queue.put((QITEM_WRITE_MEM_RES, None))
+        self.notify_sock.send(b'#')
+
+    def process_copy_from_bounce_res(self):
+        self.queue.put((QITEM_COPY_FROM_BOUNCE_RES, None))
+        self.notify_sock.send(b'#')
+
+    def process_copy_to_bounce_res(self):
+        self.queue.put((QITEM_COPY_TO_BOUNCE_RES, None))
+        self.notify_sock.send(b'#')
+
+    def process_copy_str_to_bounce_res(self, length: int):
+        self.queue.put((QITEM_COPY_STR_TO_BOUNCE_RES, length))
+        self.notify_sock.send(b'#')
+
+    def process_copy_tag_list_to_bounce_res(self, length: int):
+        self.queue.put((QITEM_COPY_TAG_LIST_TO_BOUNCE_RES, length))
+        self.notify_sock.send(b'#')
+
+    # Wait for queue item.
+    def wait_any_qitem(self, timeout: Optional[float] = None) -> Tuple[int, Any]:
+        rl, _, _ = select.select([self.wait_sock], [], [], timeout)
+        if self.wait_sock not in rl:
+            raise queue.Empty()
+        hash = self.wait_sock.recv(1)
+        assert hash == b'#'
+        return self.queue.get(block=False)
+
+    def wait_qitem(self, match_qitem: int):
+        while True:
+            qitem, arg = self.wait_any_qitem()
+            if qitem == QITEM_RESET:
+                raise InterruptedError()
+            elif qitem == match_qitem:
+                return arg
+
+    # Blocking functions to run commands on Amiga.
+    def alloc_mem(self, length: int) -> int:
+        self.service.send_alloc_mem_req(self.stream_id, length)
+        return self.wait_qitem(QITEM_ALLOC_MEM_RES)
+
+    def free_mem(self, address: int) -> int:
+        self.service.send_free_mem_req(self.stream_id, address)
+        return self.wait_qitem(QITEM_FREE_MEM_RES)
+
+    def read_mem(self, address: int, length: int) -> bytes:
+        self.service.send_read_mem_req(self.stream_id, [(address, length)])
+        return self.wait_qitem(QITEM_READ_MEM_RES)
+
+    def multi_read_mem(self, descs: List[Tuple[int, int]]) -> List[bytes]:
+        self.service.send_read_mem_req(self.stream_id, descs)
+        combined: bytes = self.wait_qitem(QITEM_READ_MEM_RES)
+        bufs = []
+        offset = 0
+        for _, length in descs:
+            bufs.append(combined[offset:offset + length])
+            offset += length
+        return bufs
+
+    def write_mem(self, address: int, buf: bytes) -> None:
+        self.multi_write_mem([(address, buf)])
+
+    def multi_write_mem(self, descs: List[Tuple[int, bytes]]) -> None:
+        self.service.send_write_mem_req(self.stream_id, descs)
+        self.wait_qitem(QITEM_WRITE_MEM_RES)
+
+    def copy_from_bounce(self, mem_address: int, bounce_address: int, length: int) -> None:
+        self.multi_copy_from_bounce([(mem_address, bounce_address, length)])
+
+    def multi_copy_from_bounce(self, copies: List[Tuple[int, int, int]]) -> None:
+        self.service.send_copy_from_bounce_req(self.stream_id, copies)
+        self.wait_qitem(QITEM_COPY_FROM_BOUNCE_RES)
+
+    def copy_to_bounce(self, bounce_address: int, mem_address: int, length: int) -> None:
+        self.multi_copy_to_bounce([(bounce_address, mem_address, length)])
+
+    def multi_copy_to_bounce(self, copies: List[Tuple[int, int, int]]) -> None:
+        self.service.send_copy_to_bounce_req(self.stream_id, copies)
+        self.wait_qitem(QITEM_COPY_TO_BOUNCE_RES)
+
+    def copy_str_to_bounce(self, bounce_address: int, str_address: int) -> int:
+        self.service.send_copy_str_to_bounce_req(self.stream_id, bounce_address, str_address)
+        return self.wait_qitem(QITEM_COPY_STR_TO_BOUNCE_RES)
+
+    def copy_tag_list_to_bounce(self, bounce_address: int, tag_list_address: int) -> int:
+        self.service.send_copy_tag_list_to_bounce_req(self.stream_id, bounce_address, tag_list_address)
+        return self.wait_qitem(QITEM_COPY_TAG_LIST_TO_BOUNCE_RES)
+
+    # Read from/write to bounce buffer.
+    def read_bounce(self, address: int, length: int) -> bytes:
+        self.service.start_read_mem(self.stream_id, address, length)
+        return self.wait_qitem(QITEM_READ_BOUNCE_COMPLETE)
+
+    def write_bounce(self, address: int, data: bytes) -> None:
+        self.service.start_write_mem(self.stream_id, address, data)
+        self.wait_qitem(QITEM_WRITE_BOUNCE_COMPLETE)
+
+    def read_str(self, address: int) -> str:
+        length = self.copy_str_to_bounce(self.bb_address, address)
+        data = self.read_bounce(self.bb_address, length)
+        return data.decode('latin-1')
+
+    def read_tag_list(self, address: int) -> List[Tuple[int, int]]:
+        length = self.copy_tag_list_to_bounce(self.bb_address, address)
+        data = self.read_bounce(self.bb_address, length)
+        arr = struct.unpack(f'>{len(data) // 4}I', data)
+        return list(zip(arr[0::2], arr[1::2]))
+
+    def set_errno(self, errno: Optional[int]):
+        if errno is not None:
+            self.errno = errno
+            if self.errno_ptr:
+                size = self.errno_size
+                fmt = '>B' if size == 1 else ('>H' if size == 2 else '>I')
+                data = struct.pack(fmt, errno)
+                self.write_mem(self.errno_ptr, data)
+
+    # The implemented library functions.
+    def handle_socket_op(self, domain: int, type_: int, protocol: int):
+        logger.debug('handle_socket_op(domain=%s, type_=%s, protocol=%s)', domain, type_, protocol)
+
+        AF_INET         = 2
+        SOCK_STREAM     = 1
+        SOCK_DGRAM      = 2
+
+        result = 2**32 - 1
+
+        slot = min(i for i in range(64) if i not in self.sockets)
+
+        if domain == AF_INET:
+            if type_ == SOCK_STREAM:
+                self.sockets[slot] = AmSocket(slot, socket.socket())
+                result = slot
+            elif type_ == SOCK_DGRAM:
+                self.sockets[slot] = AmSocket(slot, socket.socket(type=socket.SOCK_DGRAM))
+                result = slot
+
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_bind_op(self, sock: int, name: int, namelen: int):
+        logger.debug('handle_bind_op(sock=%s, name=%s, namelen=%s)', sock, name, namelen)
+        result = 2**32 - 1
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_listen_op(self, sock: int, backlog: int):
+        logger.debug('handle_listen_op(sock=%s, backlog=%s)', sock, backlog)
+        result = 2**32 - 1
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_accept_op(self, sock: int, addr: int, addrlen: int):
+        logger.debug('handle_accept_op(sock=%s, addr=%s, addrlen=%s)', sock, addr, addrlen)
+        result = 2**32 - 1
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_connect_op(self, sock: int, name: int, namelen: int):
+        logger.debug('handle_connect_op(sock=%s, name=%s, namelen=%s)', sock, name, namelen)
+
+        data = self.read_mem(name, namelen)
+
+        (port,) = struct.unpack('>H', data[2:4])
+        host = '.'.join(map(str, data[4:8]))
+        addr = (host, port)
+        #logger.debug('addr=%s', addr)
+
+        # TODO: Handle non blocking operation.
+
+        result = 2**32 - 1
+        signals_consumed = 0
+        errno = None
+
+        s = self.sockets.get(sock)
+        if not s:
+            errno = EBADF
+        else:
+            s.sock.setblocking(False)
+
+            try:
+                s.sock.connect(addr)
+            except BlockingIOError:
+                while True:
+                    rl, wl, _ = select.select([s.sock, self.wait_sock], [s.sock], [])
+
+                    if s.sock in rl or s.sock in wl:
+                        try:
+                            s.sock.getpeername()
+                            result = 0
+                        except:
+                            # TODO: What errno should be returned here?
+                            errno = ETIMEDOUT
+                        break
+
+                    if self.wait_sock in rl:
+                        hash = self.wait_sock.recv(1)
+                        assert hash == b'#'
+                        qitem, signals = self.queue.get(block=False)
+                        assert qitem == QITEM_SIGNALS
+                        signals_consumed = signals & self.break_mask
+                        if signals_consumed:
+                            errno = EINTR
+                            break
+            except:
+                # TODO: What errno should be returned here?
+                errno = ECONNREFUSED
+
+            s.sock.setblocking(True)
+
+        self.set_errno(errno)
+        self.service.send_op_res(self.stream_id, result, signals_consumed)
+
+    def handle_sendto_op(self, sock: int, buf: int, len_: int, flags: int, to: int, tolen: int):
+        logger.debug('handle_sendto_op(sock=%s, buf=%s, len_=%s, flags=%s, to=%s, tolen=%s)', sock, buf, len_, flags, to, tolen)
+        result = 2**32 - 1
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_send_op(self, sock: int, buf: int, len_: int, flags: int):
+        logger.debug('handle_send_op(sock=%s, buf=%s, len_=%s, flags=%s)', sock, buf, len_, flags)
+
+        s = self.sockets.get(sock)
+        if not s:
+            # TODO: Set/write errno.
+            result = 2**32 - 1
+        else:
+            data = b''
+            addr = buf
+
+            while len(data) < len_:
+                take = min(len_ - len(data), self.bb_size)
+                self.copy_to_bounce(self.bb_address, addr, take)
+                data += self.read_bounce(self.bb_address, take)
+                addr += take
+
+            sent = s.sock.send(data)
+            #logger.debug('Sent %d bytes (of %d), data: %s', sent, len(data), data)
+            result = sent
+
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_recvfrom_op(self, sock: int, buf: int, len_: int, flags: int, addr: int, addrlen: int):
+        logger.debug('handle_recvfrom_op(sock=%s, buf=%s, len_=%s, flags=%s, addr=%s, addrlen=%s)', sock, buf, len_, flags, addr, addrlen)
+        result = 2**32 - 1
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_recv_op(self, sock: int, buf: int, len_: int, flags: int):
+        logger.debug('handle_recv_op(sock=%s, buf=%s, len_=%s, flags=%s)', sock, buf, len_, flags)
+
+        MSG_PEEK = 2
+
+        s = self.sockets.get(sock)
+        if not s:
+            # TODO: Set/write errno.
+            result = 2**32 - 1
+        else:
+            recv_flags = 0
+            if flags & MSG_PEEK:
+                recv_flags |= socket.MSG_PEEK
+
+            data = s.sock.recv(len_, recv_flags)
+
+            addr = buf
+            offset = 0
+
+            while offset < len(data):
+                take = min(len(data) - offset, self.bb_size)
+
+                self.write_bounce(self.bb_address, data[offset:offset + take])
+                self.copy_from_bounce(addr, self.bb_address, take)
+
+                offset += take
+                addr += take
+
+            result = len(data)
+
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    # Attempt at optimized version.
+    # Unfortunately doesn't seem to give better performance.
+    def handle_recv_op_opt(self, sock: int, buf: int, len_: int, flags: int):
+        logger.debug('handle_recv_op(sock=%s, buf=%s, len_=%s, flags=%s)', sock, buf, len_, flags)
+
+        MSG_PEEK = 2
+
+        s = self.sockets.get(sock)
+        if not s:
+            # TODO: Set/write errno.
+            result = 2**32 - 1
+        else:
+            recv_flags = 0
+            if flags & MSG_PEEK:
+                recv_flags |= socket.MSG_PEEK
+
+            data = s.sock.recv(len_, recv_flags)
+
+            if len(data) <= self.bb_size:
+                self.write_bounce(self.bb_address, data)
+                self.copy_from_bounce(buf, self.bb_address, len(data))
+            else:
+                offset = 0
+                bb_addr = self.bb_address
+                mem_addr = buf
+
+                take = min(len(data) - offset, self.bb_size // 2)
+                self.write_bounce(bb_addr, data[offset:offset + take])
+                self.service.send_copy_from_bounce_req(self.stream_id, [(mem_addr, bb_addr, take)])
+
+                pending_copy_from_count = 1
+
+                offset += take
+                bb_addr = (self.bb_address + self.bb_size // 2) if bb_addr == self.bb_address else self.bb_address
+                mem_addr += take
+
+                while offset < len(data):
+                    if pending_copy_from_count == 2:
+                        self.wait_qitem(QITEM_COPY_FROM_BOUNCE_RES)
+                        pending_copy_from_count -= 1
+
+                    take = min(len(data) - offset, self.bb_size // 2)
+                    self.service.start_write_mem(self.stream_id, bb_addr, data[offset:offset + take])
+
+                    while True:
+                        qitem, _ = self.queue.get()
+                        if qitem == QITEM_RESET:
+                            raise InterruptedError()
+                        elif qitem == QITEM_COPY_FROM_BOUNCE_RES:
+                            pending_copy_from_count -= 1
+                        elif qitem == QITEM_WRITE_BOUNCE_COMPLETE:
+                            break
+
+                    self.service.send_copy_from_bounce_req(self.stream_id, [(mem_addr, bb_addr, take)])
+                    pending_copy_from_count += 1
+
+                    offset += take
+                    bb_addr = (self.bb_address + self.bb_size // 2) if bb_addr == self.bb_address else self.bb_address
+                    mem_addr += take
+
+                while pending_copy_from_count:
+                    self.wait_qitem(QITEM_COPY_FROM_BOUNCE_RES)
+                    pending_copy_from_count -= 1
+
+            result = len(data)
+
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_shutdown_op(self, sock: int, how: int):
+        logger.debug('handle_shutdown_op(sock=%s, how=%s)', sock, how)
+        result = 2**32 - 1
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_setsockopt_op(self, sock: int, level: int, optname: int, optval: int, optlen: int):
+        logger.debug('handle_setsockopt_op(sock=%s, level=%s, optname=%s, optval=%s, optlen=%s)', sock, level, optname, optval, optlen)
+        result = 2**32 - 1
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_getsockopt_op(self, sock: int, level: int, optname: int, optval: int, optlen: int):
+        logger.debug('handle_getsockopt_op(sock=%s, level=%s, optname=%s, optval=%s, optlen=%s)', sock, level, optname, optval, optlen)
+        result = 2**32 - 1
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_getsockname_op(self, sock: int, name: int, namelen: int):
+        logger.debug('handle_getsockname_op(sock=%s, name=%s, namelen=%s)', sock, name, namelen)
+        result = 2**32 - 1
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_getpeername_op(self, sock: int, name: int, namelen: int):
+        logger.debug('handle_getpeername_op(sock=%s, name=%s, namelen=%s)', sock, name, namelen)
+        result = 2**32 - 1
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_ioctlsocket_op(self, sock: int, req: int, argp: int):
+        logger.debug('handle_ioctlsocket_op(sock=%s, req=%s, argp=%s)', sock, req, argp)
+        result = 2**32 - 1
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_closesocket_op(self, sock: int):
+        logger.debug('handle_closesocket_op(sock=%s)', sock)
+
+        s = self.sockets.get(sock)
+        if not s:
+            # TODO: Set/write errno.
+            result = 2**32 - 1
+        else:
+            try:
+                s.sock.close()
+            except:
+                pass
+            del self.sockets[sock]
+            result = 0
+
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_waitselect_op(self, nfds: int, read_fds: int, write_fds: int, except_fds: int, _timeout: int, signals: int):
+        logger.debug('handle_waitselect_op(nfds=%s, read_fds=%s, write_fds=%s, except_fds=%s, _timeout=%s, signals=%s)', nfds, read_fds, write_fds, except_fds, _timeout, signals)
+
+        # NOTE: FD_SETSIZE is currently hardcoded to 32 bits (one ULONG).
+        # TODO: Look at nfds to see how many ULONGs to copy.
+
+        read_reqs = []
+
+        if read_fds:
+            read_reqs.append((read_fds, 4))
+
+        if write_fds:
+            read_reqs.append((write_fds, 4))
+
+        if except_fds:
+            read_reqs.append((except_fds, 4))
+
+        if _timeout:
+            read_reqs.append((_timeout, 8))
+
+        if signals:
+            read_reqs.append((signals, 4))
+
+        if read_reqs:
+            bufs = self.multi_read_mem(read_reqs)
+
+        # Extract.
+        offset = 0
+        rfds = 0
+        wfds = 0
+        xfds = 0
+        timeout_val = None
+        signals_val = 0
+
+        if read_fds:
+            (rfds,) = struct.unpack('>I', bufs[offset])
+            offset += 1
+
+        if write_fds:
+            (wfds,) = struct.unpack('>I', bufs[offset])
+            offset += 1
+
+        if except_fds:
+            (xfds,) = struct.unpack('>I', bufs[offset])
+            offset += 1
+
+        if _timeout:
+            sec, usec = struct.unpack('>II', bufs[offset])
+            timeout_val = sec + usec / 1e6
+            offset += 1
+
+        if signals:
+            (signals_val,) = struct.unpack('>I', bufs[offset])
+            offset += 1
+
+        logger.debug('rfds=%s, wfds=%s, xfds=%s, timeout=%s, signals=%s)', rfds, wfds, xfds, timeout_val, signals_val)
+
+        # TODO: Validate that these sockets are available.
+
+        rlist = []
+        wlist = []
+        xlist = []
+
+        for s in self.sockets.values():
+            if rfds & (1 << s.slot):
+                rlist.append(s.sock)
+
+            if wfds & (1 << s.slot):
+                wlist.append(s.sock)
+
+            if xfds & (1 << s.slot):
+                xlist.append(s.sock)
+
+        # TODO: Handle signals, both break signals and signals given in the function call.
+
+        rlist_out, wlist_out, xlist_out = select.select(rlist, wlist, xlist, timeout_val)
+
+        rfds_out = 0
+        wfds_out = 0
+        xfds_out = 0
+
+        for s in self.sockets.values():
+            if s.sock in rlist_out:
+                rfds_out |= 1 << s.slot
+
+            if s.sock in wlist_out:
+                wfds_out |= 1 << s.slot
+
+            if s.sock in xlist_out:
+                xfds_out |= 1 << s.slot
+
+        # Update Xfds.
+        write_reqs = []
+
+        if read_fds:
+            write_reqs.append((read_fds, struct.pack('>I', rfds_out)))
+
+        if write_fds:
+            write_reqs.append((write_fds, struct.pack('>I', wfds_out)))
+
+        if except_fds:
+            write_reqs.append((except_fds, struct.pack('>I', xfds_out)))
+
+        if signals:
+            write_reqs.append((signals, struct.pack('>I', 0)))
+
+        if write_reqs:
+            self.multi_write_mem(write_reqs)
+
+        result = len(set(rlist_out) | set(wlist_out) | set(xlist_out))
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_setsocketsignals_op(self, int_mask: int, io_mask: int, urgent_mask: int):
+        logger.debug('handle_setsocketsignals_op(int_mask=%s, io_mask=%s, urgent_mask=%s)', int_mask, io_mask, urgent_mask)
+        result = 0
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_getdtablesize_op(self):
+        logger.debug('handle_getdtablesize_op()')
+        result = 2**32 - 1
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_obtainsocket_op(self, id_: int, domain: int, type_: int, protocol: int):
+        logger.debug('handle_obtainsocket_op(id_=%s, domain=%s, type_=%s, protocol=%s)', id_, domain, type_, protocol)
+        result = 2**32 - 1
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_releasesocket_op(self, sock: int, id_: int):
+        logger.debug('handle_releasesocket_op(sock=%s, id_=%s)', sock, id_)
+        result = 2**32 - 1
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_releasecopyofsocket_op(self, sock: int, id_: int):
+        logger.debug('handle_releasecopyofsocket_op(sock=%s, id_=%s)', sock, id_)
+        result = 2**32 - 1
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_errno_op(self):
+        logger.debug('handle_errno_op()')
+        result = 2**32 - 1
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_seterrnoptr_op(self, errno_ptr: int, size: int):
+        logger.debug('handle_seterrnoptr_op(errno_ptr=%s, size=%s)', errno_ptr, size)
+        result = 0
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_inet_ntoa_op(self, ip: int):
+        logger.debug('handle_inet_ntoa_op(ip=%s)', ip)
+
+        if not self.return_mem_address:
+            self.return_mem_address = self.alloc_mem(512)
+
+        if self.return_mem_address:
+            data = struct.pack('>I', ip)
+            data = '.'.join(str(x) for x in data)
+            data = data.encode('latin-1') + b'\x00'
+            #logger.debug('data=%s', data)
+            self.write_mem(self.return_mem_address, data)
+
+        result = self.return_mem_address
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_inet_addr_op(self, cp: int):
+        logger.debug('handle_inet_addr_op(cp=%s)', cp)
+        s = self.read_str(cp)
+        #logger.debug('cp=%s', s)
+        try:
+            (result,) = struct.unpack('>I', bytes(map(int, s.split('.'))))
+        except:
+            result = 2**32 - 1
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_inet_lnaof_op(self, in_: int):
+        logger.debug('handle_inet_lnaof_op(in_=%s)', in_)
+        result = 0
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_inet_netof_op(self, in_: int):
+        logger.debug('handle_inet_netof_op(in_=%s)', in_)
+        result = 0
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_inet_makeaddr_op(self, net: int, host: int):
+        logger.debug('handle_inet_makeaddr_op(net=%s, host=%s)', net, host)
+        result = 0
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_inet_network_op(self, cp: int):
+        logger.debug('handle_inet_network_op(cp=%s)', cp)
+        result = 0
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_gethostbyname_op(self, name: int):
+        logger.debug('handle_gethostbyname_op(name=%s)', name)
+        data = self.read_str(name)
+        host_addr = socket.gethostbyname(data)
+        logger.debug('host_addr=%s', host_addr)
+
+        result = 0
+
+        if not self.return_mem_address:
+            self.return_mem_address = self.alloc_mem(512)
+
+        if self.return_mem_address:
+            # Create hostent struct.
+            data = struct.pack('>IIIII', name, 0, 2, 4, self.return_mem_address + 20)
+            data += struct.pack('>II', self.return_mem_address + 28, 0)
+            data += bytes(map(int, host_addr.split('.')))
+
+            self.write_mem(self.return_mem_address, data)
+
+            result = self.return_mem_address
+
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_gethostbyaddr_op(self, addr: int, len_: int, type_: int):
+        logger.debug('handle_gethostbyaddr_op(addr=%s, len_=%s, type_=%s)', addr, len_, type_)
+        result = 0
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_getnetbyname_op(self, name: int):
+        logger.debug('handle_getnetbyname_op(name=%s)', name)
+        result = 0
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_getnetbyaddr_op(self, net: int, type_: int):
+        logger.debug('handle_getnetbyaddr_op(net=%s, type_=%s)', net, type_)
+        result = 0
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_getservbyname_op(self, name: int, proto: int):
+        logger.debug('handle_getservbyname_op(name=%s, proto=%s)', name, proto)
+        result = 0
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_getservbyport_op(self, port: int, proto: int):
+        logger.debug('handle_getservbyport_op(port=%s, proto=%s)', port, proto)
+        result = 0
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_getprotobyname_op(self, name: int):
+        logger.debug('handle_getprotobyname_op(name=%s)', name)
+        result = 0
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_getprotobynumber_op(self, proto: int):
+        logger.debug('handle_getprotobynumber_op(proto=%s)', proto)
+        result = 0
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_vsyslog_op(self, pri: int, msg: int, args_: int):
+        logger.debug('handle_vsyslog_op(pri=%s, msg=%s, args_=%s)', pri, msg, args_)
+        result = 0
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_dup2socket_op(self, old_socket: int, new_socket: int):
+        logger.debug('handle_dup2socket_op(old_socket=%s, new_socket=%s)', old_socket, new_socket)
+        result = 2**32 - 1
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_sendmsg_op(self, sock: int, msg: int, flags: int):
+        logger.debug('handle_sendmsg_op(sock=%s, msg=%s, flags=%s)', sock, msg, flags)
+        result = 2**32 - 1
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_recvmsg_op(self, sock: int, msg: int, flags: int):
+        logger.debug('handle_recvmsg_op(sock=%s, msg=%s, flags=%s)', sock, msg, flags)
+        result = 2**32 - 1
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_gethostname_op(self, name: int, namelen: int):
+        logger.debug('handle_gethostname_op(name=%s, namelen=%s)', name, namelen)
+        result = 2**32 - 1
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_gethostid_op(self):
+        logger.debug('handle_gethostid_op()')
+        result = 0
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_socketbasetaglist_op(self, tags: int):
+        logger.debug('handle_socketbasetaglist_op(tags=%s)', tags)
+        tl = self.read_tag_list(tags)
+
+        #logger.debug('Tag list: %s', tl)
+
+        result = 0
+
+        for i, (key, value) in enumerate(tl):
+            if key & TAG_USER:
+                key &= 0xffff
+                is_ref = (key & SBTF_REF) != 0
+                key &= 0x7fff
+                is_set = (key & 1) != 0
+                key >>= 1
+
+                #logger.debug('Tag: key=%s, is_ref=%s, is_set=%s, value=%s', key, is_ref, is_set, value)
+
+                if not is_set or is_ref:
+                    result = i + 1
+                    break
+
+                if key == SBTC_BREAKMASK:
+                    self.break_mask = value
+                elif key == SBTC_LOGTAGPTR:
+                    self.log_tag_ptr = value
+                elif key == SBTC_ERRNOLONGPTR:
+                    self.errno_ptr = value
+                    self.errno_size = 4
+                elif key == SBTC_HERRNOLONGPTR:
+                    self.herrno_ptr = value
+                else:
+                    result = i + 1
+                    break
+            elif key not in (TAG_DONE, TAG_MORE):
+                logger.debug('Unknown tag: key=%s, value=%s', key, value)
+                result = i + 1
+                break
+
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_getsocketevents_op(self, event_ptr: int):
+        logger.debug('handle_getsocketevents_op(event_ptr=%s)', event_ptr)
+        result = 2**32 - 1
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    # Dispatcher loop.
+    def run(self):
+        try:
+            while True:
+                op, args = self.wait_qitem(QITEM_OP_REQ)
+                if op == FN_SOCKET:
+                    self.handle_socket_op(*struct.unpack(">3I", args))
+                elif op == FN_BIND:
+                    self.handle_bind_op(*struct.unpack(">3I", args))
+                elif op == FN_LISTEN:
+                    self.handle_listen_op(*struct.unpack(">2I", args))
+                elif op == FN_ACCEPT:
+                    self.handle_accept_op(*struct.unpack(">3I", args))
+                elif op == FN_CONNECT:
+                    self.handle_connect_op(*struct.unpack(">3I", args))
+                elif op == FN_SENDTO:
+                    self.handle_sendto_op(*struct.unpack(">6I", args))
+                elif op == FN_SEND:
+                    self.handle_send_op(*struct.unpack(">4I", args))
+                elif op == FN_RECVFROM:
+                    self.handle_recvfrom_op(*struct.unpack(">6I", args))
+                elif op == FN_RECV:
+                    self.handle_recv_op(*struct.unpack(">4I", args))
+                elif op == FN_SHUTDOWN:
+                    self.handle_shutdown_op(*struct.unpack(">2I", args))
+                elif op == FN_SETSOCKOPT:
+                    self.handle_setsockopt_op(*struct.unpack(">5I", args))
+                elif op == FN_GETSOCKOPT:
+                    self.handle_getsockopt_op(*struct.unpack(">5I", args))
+                elif op == FN_GETSOCKNAME:
+                    self.handle_getsockname_op(*struct.unpack(">3I", args))
+                elif op == FN_GETPEERNAME:
+                    self.handle_getpeername_op(*struct.unpack(">3I", args))
+                elif op == FN_IOCTLSOCKET:
+                    self.handle_ioctlsocket_op(*struct.unpack(">3I", args))
+                elif op == FN_CLOSESOCKET:
+                    self.handle_closesocket_op(*struct.unpack(">1I", args))
+                elif op == FN_WAITSELECT:
+                    self.handle_waitselect_op(*struct.unpack(">6I", args))
+                elif op == FN_SETSOCKETSIGNALS:
+                    self.handle_setsocketsignals_op(*struct.unpack(">3I", args))
+                elif op == FN_GETDTABLESIZE:
+                    self.handle_getdtablesize_op()
+                elif op == FN_OBTAINSOCKET:
+                    self.handle_obtainsocket_op(*struct.unpack(">4I", args))
+                elif op == FN_RELEASESOCKET:
+                    self.handle_releasesocket_op(*struct.unpack(">2I", args))
+                elif op == FN_RELEASECOPYOFSOCKET:
+                    self.handle_releasecopyofsocket_op(*struct.unpack(">2I", args))
+                elif op == FN_ERRNO:
+                    self.handle_errno_op()
+                elif op == FN_SETERRNOPTR:
+                    self.handle_seterrnoptr_op(*struct.unpack(">2I", args))
+                elif op == FN_INET_NTOA:
+                    self.handle_inet_ntoa_op(*struct.unpack(">1I", args))
+                elif op == FN_INET_ADDR:
+                    self.handle_inet_addr_op(*struct.unpack(">1I", args))
+                elif op == FN_INET_LNAOF:
+                    self.handle_inet_lnaof_op(*struct.unpack(">1I", args))
+                elif op == FN_INET_NETOF:
+                    self.handle_inet_netof_op(*struct.unpack(">1I", args))
+                elif op == FN_INET_MAKEADDR:
+                    self.handle_inet_makeaddr_op(*struct.unpack(">2I", args))
+                elif op == FN_INET_NETWORK:
+                    self.handle_inet_network_op(*struct.unpack(">1I", args))
+                elif op == FN_GETHOSTBYNAME:
+                    self.handle_gethostbyname_op(*struct.unpack(">1I", args))
+                elif op == FN_GETHOSTBYADDR:
+                    self.handle_gethostbyaddr_op(*struct.unpack(">3I", args))
+                elif op == FN_GETNETBYNAME:
+                    self.handle_getnetbyname_op(*struct.unpack(">1I", args))
+                elif op == FN_GETNETBYADDR:
+                    self.handle_getnetbyaddr_op(*struct.unpack(">2I", args))
+                elif op == FN_GETSERVBYNAME:
+                    self.handle_getservbyname_op(*struct.unpack(">2I", args))
+                elif op == FN_GETSERVBYPORT:
+                    self.handle_getservbyport_op(*struct.unpack(">2I", args))
+                elif op == FN_GETPROTOBYNAME:
+                    self.handle_getprotobyname_op(*struct.unpack(">1I", args))
+                elif op == FN_GETPROTOBYNUMBER:
+                    self.handle_getprotobynumber_op(*struct.unpack(">1I", args))
+                elif op == FN_VSYSLOG:
+                    self.handle_vsyslog_op(*struct.unpack(">3I", args))
+                elif op == FN_DUP2SOCKET:
+                    self.handle_dup2socket_op(*struct.unpack(">2I", args))
+                elif op == FN_SENDMSG:
+                    self.handle_sendmsg_op(*struct.unpack(">3I", args))
+                elif op == FN_RECVMSG:
+                    self.handle_recvmsg_op(*struct.unpack(">3I", args))
+                elif op == FN_GETHOSTNAME:
+                    self.handle_gethostname_op(*struct.unpack(">2I", args))
+                elif op == FN_GETHOSTID:
+                    self.handle_gethostid_op()
+                elif op == FN_SOCKETBASETAGLIST:
+                    self.handle_socketbasetaglist_op(*struct.unpack(">1I", args))
+                elif op == FN_GETSOCKETEVENTS:
+                    self.handle_getsocketevents_op(*struct.unpack(">1I", args))
+        except InterruptedError:
+            logger.info('LibInstance thread was RESET')
+        except:
+            logger.exception('LibInstance thread crashed')
+
+        self.wait_sock.close()
+        self.notify_sock.close()
+
+class LibRemoteService:
+    def __init__(self):
+        self.a314d = A314d(SERVICE_NAME)
+        self.instances: Dict[int, LibInstance] = {}
+        self.read_mem_queue = []
+        self.write_mem_queue = []
+        self.send_lock = threading.Lock()
+        self.rbuf = b''
+
+    def start_read_mem(self, stream_id: int, address: int, length: int):
+        with self.send_lock:
+            self.read_mem_queue.append((stream_id, address))
+            self.a314d.send_read_mem_req(address, length)
+
+    def start_write_mem(self, stream_id: int, address: int, data: bytes):
+        with self.send_lock:
+            self.write_mem_queue.append((stream_id, address))
+            self.a314d.send_write_mem_req(address, data)
+
+    def send_op_res(self, stream_id: int, result: int, signals_consumed: int, copy_reqs: List[Tuple[int, int, int]] = None, write_reqs: List[Tuple[int, bytes]] = None):
+        copy_reqs_count = 0 if copy_reqs is None else len(copy_reqs)
+        data = struct.pack('>BBII', MSG_OP_RES, copy_reqs_count, result, signals_consumed)
+
+        if copy_reqs:
+            for dst, src, length in copy_reqs:
+                data += struct.pack('>III', dst, src, length)
+
+        if write_reqs:
+            for dst, buf in write_reqs:
+                data += struct.pack('>IB', dst, len(buf))
+                if (len(buf) & 1) == 0:
+                    data += b'\x00'
+                data += buf
+
+        with self.send_lock:
+            self.a314d.send_data(stream_id, data)
+
+    def send_alloc_mem_req(self, stream_id: int, length: int):
+        with self.send_lock:
+            data = struct.pack('>BBI', MSG_ALLOC_MEM_REQ, 0, length)
+            self.a314d.send_data(stream_id, data)
+
+    def send_free_mem_req(self, stream_id: int, address: int):
+        with self.send_lock:
+            data = struct.pack('>BBI', MSG_FREE_MEM_REQ, 0, address)
+            self.a314d.send_data(stream_id, data)
+
+    def send_read_mem_req(self, stream_id: int, descs: List[Tuple[int, int]]):
+        data = struct.pack('>BB', MSG_READ_MEM_REQ, 0)
+        for src, length in descs:
+            data += struct.pack('>IBB', src, length, 0)
+
+        with self.send_lock:
+            self.a314d.send_data(stream_id, data)
+
+    def send_write_mem_req(self, stream_id: int, descs: List[Tuple[int, bytes]]):
+        data = struct.pack('>BB', MSG_WRITE_MEM_REQ, 0)
+        for dst, buf in descs:
+            data += struct.pack('>IB', dst, len(buf))
+            if (len(buf) & 1) == 0:
+                data += b'\x00'
+            data += buf
+
+        with self.send_lock:
+            self.a314d.send_data(stream_id, data)
+
+    def send_copy_from_bounce_req(self, stream_id: int, copies: List[Tuple[int, int, int]]):
+        data = struct.pack('>BB', MSG_COPY_FROM_BOUNCE_REQ, len(copies))
+        for dst, src, length in copies:
+            data += struct.pack('>III', dst, src, length)
+
+        with self.send_lock:
+            self.a314d.send_data(stream_id, data)
+
+    def send_copy_to_bounce_req(self, stream_id: int, copies: List[Tuple[int, int, int]]):
+        data = struct.pack('>BB', MSG_COPY_TO_BOUNCE_REQ, len(copies))
+        for dst, src, length in copies:
+            data += struct.pack('>III', dst, src, length)
+
+        with self.send_lock:
+            self.a314d.send_data(stream_id, data)
+
+    def send_copy_str_to_bounce_req(self, stream_id: int, bounce_address: int, str_address: int):
+        with self.send_lock:
+            data = struct.pack('>BBII', MSG_COPY_STR_TO_BOUNCE_REQ, 0, bounce_address, str_address)
+            self.a314d.send_data(stream_id, data)
+
+    def send_copy_tag_list_to_bounce_req(self, stream_id: int, bounce_address: int, tag_list_address: int):
+        with self.send_lock:
+            data = struct.pack('>BBII', MSG_COPY_TAG_LIST_TO_BOUNCE_REQ, 0, bounce_address, tag_list_address)
+            self.a314d.send_data(stream_id, data)
+
+    def process_stream_connect(self, stream_id: int, name: bytes):
+        if name == SERVICE_NAME.encode():
+            logger.info('Amiga connected to LibRemote service')
+            self.instances[stream_id] = LibInstance(self, stream_id)
+            self.a314d.send_connect_response(stream_id, 0)
+        else:
+            self.a314d.send_connect_response(stream_id, 3)
+
+    def process_stream_data(self, stream_id: int, payload: bytes):
+        inst = self.instances.get(stream_id)
+        if not inst:
+            return
+
+        if inst.wait_first_message:
+            inst.bb_address, inst.bb_size = struct.unpack('>II', payload)
+            inst.wait_first_message = False
+            return
+
+        kind = payload[0]
+
+        if kind == MSG_SIGNALS:
+            (signals,) = struct.unpack('>I', payload[2:])
+            inst.process_signals(signals)
+        elif kind == MSG_OP_REQ:
+            inst.process_op_req(payload[1], payload[2:])
+        elif kind == MSG_ALLOC_MEM_RES:
+            (address,) = struct.unpack('>I', payload[2:])
+            inst.process_alloc_mem_res(address)
+        elif kind == MSG_FREE_MEM_RES:
+            inst.process_free_mem_res()
+        elif kind == MSG_READ_MEM_RES:
+            inst.process_read_mem_res(payload[2:])
+        elif kind == MSG_WRITE_MEM_RES:
+            inst.process_write_mem_res()
+        elif kind == MSG_COPY_FROM_BOUNCE_RES:
+            inst.process_copy_from_bounce_res()
+        elif kind == MSG_COPY_TO_BOUNCE_RES:
+            inst.process_copy_to_bounce_res()
+        elif kind == MSG_COPY_STR_TO_BOUNCE_RES:
+            (length,) = struct.unpack('>I', payload[2:])
+            inst.process_copy_str_to_bounce_res(length)
+        elif kind == MSG_COPY_TAG_LIST_TO_BOUNCE_RES:
+            (length,) = struct.unpack('>I', payload[2:])
+            inst.process_copy_tag_list_to_bounce_res(length)
+
+    def process_stream_eos(self, stream_id: int):
+        raise AssertionError('EOS is not supposed to be used')
+
+    def process_stream_reset(self, stream_id: int):
+        inst = self.instances.get(stream_id)
+        if inst:
+            inst.process_stream_reset()
+            del self.instances[stream_id]
+            logger.info('Amiga disconnected from LibRemote service')
+
+    def process_read_mem_res(self, payload: bytes):
+        stream_id, address = self.read_mem_queue.pop(0)
+        inst = self.instances.get(stream_id)
+        if inst:
+            inst.process_read_mem_complete(address, payload)
+
+    def process_write_mem_res(self):
+        stream_id, address = self.write_mem_queue.pop(0)
+        inst = self.instances.get(stream_id)
+        if inst:
+            inst.process_write_mem_complete(address)
+
+    def process_drv_msg(self, stream_id: int, ptype: int, payload: bytes):
+        if ptype == self.a314d.MSG_CONNECT:
+            self.process_stream_connect(stream_id, payload)
+        elif ptype == self.a314d.MSG_DATA:
+            self.process_stream_data(stream_id, payload)
+        elif ptype == self.a314d.MSG_EOS:
+            self.process_stream_eos(stream_id)
+        elif ptype == self.a314d.MSG_RESET:
+            self.process_stream_reset(stream_id)
+        elif ptype == self.a314d.MSG_READ_MEM_RES:
+            self.process_read_mem_res(payload)
+        elif ptype == self.a314d.MSG_WRITE_MEM_RES:
+            self.process_write_mem_res()
+
+    def handle_a314d_readable(self):
+        buf = self.a314d.drv.recv(8192)
+        if not buf:
+            logger.error('Connection to a314d was closed, shutting down')
+            exit(-1)
+
+        self.rbuf += buf
+        while True:
+            if len(self.rbuf) < 9:
+                break
+
+            (plen, stream_id, ptype) = struct.unpack('<IIB', self.rbuf[:9])
+            if plen > MAX_MESSAGE_SIZE or ptype not in KNOWN_PTYPES:
+                _fail_bad_header(plen, stream_id, ptype)
+            if len(self.rbuf) < 9 + plen:
+                break
+
+            payload = self.rbuf[9:9+plen]
+            self.rbuf = self.rbuf[9+plen:]
+
+            self.process_drv_msg(stream_id, ptype, payload)
+
+    def run(self):
+        logger.info('LibRemote service started')
+
+        while True:
+            try:
+                rl, _, _ = select.select([self.a314d], [], [], 10.0)
+            except KeyboardInterrupt:
+                break
+
+            if self.a314d in rl:
+                self.handle_a314d_readable()
+
+        self.a314d.close()
+
+        logger.info('LibRemote service stopped')
+
+if __name__ == '__main__':
+    service = LibRemoteService()
+    service.run()
diff --git a/src/a314/files_pi/disk.conf b/src/a314/files_pi/disk.conf
new file mode 100644
index 00000000..185d8586
--- /dev/null
+++ b/src/a314/files_pi/disk.conf
@@ -0,0 +1,3 @@
+{
+    "auto-insert": []
+}
diff --git a/src/a314/files_pi/disk.py b/src/a314/files_pi/disk.py
new file mode 100644
index 00000000..f19a2bfa
--- /dev/null
+++ b/src/a314/files_pi/disk.py
@@ -0,0 +1,370 @@
+#!/usr/bin/python3
+# -*- coding: utf-8 -*-
+
+# Copyright (c) 2021 Niklas Ekström
+
+import logging
+logging.basicConfig(format='%(levelname)s, %(asctime)s, %(name)s, line %(lineno)d: %(message)s', level=logging.INFO)
+
+import io
+import json
+import logging
+import os
+import select
+import socket
+import struct
+import sys
+from typing import Optional, Tuple, List, Dict
+
+from a314d import A314d
+
+logger = logging.getLogger(__name__)
+
+SERVICE_NAME = 'disk'
+
+READ_TRACK_REQ = 1
+WRITE_TRACK_REQ = 2
+READ_TRACK_RES = 3
+WRITE_TRACK_RES = 4
+INSERT_NOTIFY = 5
+EJECT_NOTIFY = 6
+SET_GEOMETRY = 7
+
+OP_RES_OK = 0
+OP_RES_NOT_PRESENT = 1
+OP_RES_WRITE_PROTECTED = 2
+
+NUM_DRIVES = 4
+
+DEFAULT_CONF_FILE = os.path.join(os.path.dirname(__file__), 'disk.conf')
+try:
+    idx = sys.argv.index('-conf-file')
+    CONF_FILE = sys.argv[idx + 1]
+except (ValueError, IndexError):
+    CONF_FILE = DEFAULT_CONF_FILE
+
+MAX_MESSAGE_SIZE = 1024 * 1024
+_bad_header_logged = False
+
+KNOWN_PTYPES = {
+    A314d.MSG_REGISTER_REQ,
+    A314d.MSG_REGISTER_RES,
+    A314d.MSG_DEREGISTER_REQ,
+    A314d.MSG_DEREGISTER_RES,
+    A314d.MSG_READ_MEM_REQ,
+    A314d.MSG_READ_MEM_RES,
+    A314d.MSG_WRITE_MEM_REQ,
+    A314d.MSG_WRITE_MEM_RES,
+    A314d.MSG_CONNECT,
+    A314d.MSG_CONNECT_RESPONSE,
+    A314d.MSG_DATA,
+    A314d.MSG_EOS,
+    A314d.MSG_RESET,
+}
+
+def _fail_bad_header(plen, stream_id, ptype):
+    global _bad_header_logged
+    if not _bad_header_logged:
+        logger.error(
+            'Bad A314d header (len=%d stream=%d type=%d). Check endian framing.',
+            plen,
+            stream_id,
+            ptype,
+        )
+        _bad_header_logged = True
+    raise SystemExit(1)
+
+class Drive(object):
+    def __init__(self, unit: int):
+        self.unit = unit
+        self.f: Optional[io.BufferedRandom] = None
+        self.writable = False
+        self.geometry: Optional[Tuple[int, int, int]] = None
+        self.geometry_sent = False
+
+class DiskService(object):
+    def __init__(self):
+        self.a314d = A314d(SERVICE_NAME)
+
+        self.control_server_socket = socket.socket()
+        self.control_server_socket.bind(('localhost', 23890))
+        self.control_server_socket.listen(10)
+
+        self.control_sockets: List[socket.socket] = []
+        self.drives = [Drive(i) for i in range(NUM_DRIVES)]
+        self.auto_insert: Dict[int, Tuple[str, bool]] = {}
+        self.current_stream_id: Optional[int] = None
+        self.rbuf = b''
+        self.mem_read_queue = []
+        self.mem_write_queue = []
+
+    def load_config(self):
+        try:
+            with open(CONF_FILE, 'rt') as f:
+                j = json.load(f)
+        except FileNotFoundError:
+            logger.warning('Disk config not found: %s', CONF_FILE)
+            return
+
+        for e in j.get('auto-insert', []):
+            unit: int = e['unit']
+            filename: str = e['filename']
+            rw: bool = e.get('rw', False)
+            self.auto_insert[unit] = (filename, rw)
+
+    def eject_adf(self, unit: int):
+        drive = self.drives[unit]
+        if not drive.f:
+            return f"No disk in unit {unit} to eject"
+
+        drive.f.close()
+        drive.f = None
+
+        if self.current_stream_id is not None:
+            self.a314d.send_data(self.current_stream_id, struct.pack('>BB', EJECT_NOTIFY, unit))
+
+        return f"Ejected disk from unit {unit}"
+
+    def insert_adf(self, unit: int, filename: str, writable=False):
+        self.eject_adf(unit)
+
+        try:
+            f = open(filename, 'r+b')
+        except:
+            return f"Failed to open disk file '{filename}'"
+
+        f.seek(0, 2)
+        size = f.tell()
+
+        if size == 80*2*11*512:
+            geometry = (2, 11, 80)
+        elif size < 2**20:
+            f.close()
+            return "Failed: HDF must be at least 1 MB"
+        elif (size & (2**14 - 1)) != 0:
+            f.close()
+            return "Failed: HDF size must be a multiple of 16 kB"
+        else:
+            geometry = (1, 32, size // (2**14))
+
+        drive = self.drives[unit]
+
+        if drive.geometry_sent and drive.geometry != geometry:
+            f.close()
+            return "Failed: A disk with a different geometry was previously inserted"
+
+        drive.f = f
+        drive.writable = writable
+        drive.geometry = geometry
+
+        if self.current_stream_id is not None:
+            if not drive.geometry_sent:
+                self.a314d.send_data(self.current_stream_id, struct.pack('>BBBBI', SET_GEOMETRY, unit, *geometry))
+                drive.geometry_sent = True
+            self.a314d.send_data(self.current_stream_id, struct.pack('>BBB', INSERT_NOTIFY, unit, 1 if writable else 0))
+
+        return f"Inserted disk file '{filename}' in unit {unit}"
+
+    boot_code = bytes([
+        0x43, 0xFA, 0x00, 0x18, 0x4E, 0xAE, 0xFF, 0xA0,
+        0x4A, 0x80, 0x67, 0x0A, 0x20, 0x40, 0x20, 0x68,
+        0x00, 0x16, 0x70, 0x00, 0x4E, 0x75, 0x70, 0xFF,
+        0x60, 0xFA, 0x64, 0x6F, 0x73, 0x2E, 0x6C, 0x69,
+        0x62, 0x72, 0x61, 0x72, 0x79])
+
+    boot_code_silent = bytes([
+        0x43, 0xFA, 0x00, 0x3E, 0x70, 0x25, 0x4E, 0xAE,
+        0xFD, 0xD8, 0x4A, 0x80, 0x67, 0x0C, 0x22, 0x40,
+        0x08, 0xE9, 0x00, 0x06, 0x00, 0x22, 0x4E, 0xAE,
+        0xFE, 0x62, 0x43, 0xFA, 0x00, 0x18, 0x4E, 0xAE,
+        0xFF, 0xA0, 0x4A, 0x80, 0x67, 0x0A, 0x20, 0x40,
+        0x20, 0x68, 0x00, 0x16, 0x70, 0x00, 0x4E, 0x75,
+        0x70, 0xFF, 0x4E, 0x75, 0x64, 0x6F, 0x73, 0x2E,
+        0x6C, 0x69, 0x62, 0x72, 0x61, 0x72, 0x79, 0x00,
+        0x65, 0x78, 0x70, 0x61, 0x6E, 0x73, 0x69, 0x6F,
+        0x6E, 0x2E, 0x6C, 0x69, 0x62, 0x72, 0x61, 0x72,
+        0x79])
+
+    def fixup_boot_block(self, disk_data: bytes, drive: Drive):
+        assert type(drive.f) is io.BufferedRandom
+        assert type(drive.geometry) is tuple
+
+        checksum = struct.unpack_from('>I', disk_data, 4)[0]
+
+        if disk_data[:3] == b'DOS' and checksum == 0:
+            size = len(disk_data)
+            if size < 1024:
+                drive.f.seek(0, 0)
+                disk_data = drive.f.read(1024)
+
+            dd = bytearray(disk_data)
+            dd[12:12 + len(self.boot_code_silent)] = self.boot_code_silent
+
+            geometry = drive.geometry
+            sector_count = geometry[0] * geometry[1] * geometry[2]
+            dd[8:12] = struct.pack('>I', sector_count // 2)
+
+            arr = struct.unpack_from('>256I', dd)
+            checksum = 0
+            for x in arr:
+                checksum += x
+                if checksum >= 2**32:
+                    checksum = checksum - 2**32 + 1
+            checksum = checksum ^ (2**32-1)
+            dd[4:8] = struct.pack('>I', checksum)
+
+            disk_data = bytes(dd[:size])
+
+        return disk_data
+
+    def process_stream_data(self, stream_id: int, data: bytes):
+        kind, unit, length, offset, address = struct.unpack('>BBHII', data)
+        drive = self.drives[unit]
+        if kind == READ_TRACK_REQ:
+            if not drive.f:
+                self.a314d.send_data(stream_id, struct.pack('>BBB', READ_TRACK_RES, unit, OP_RES_NOT_PRESENT))
+                return
+
+            drive.f.seek(offset, 0)
+            disk_data = drive.f.read(length)
+            if offset == 0:
+                disk_data = self.fixup_boot_block(disk_data, drive)
+
+            self.mem_write_queue.append((stream_id, unit))
+            self.a314d.send_write_mem_req(address, disk_data)
+        elif kind == WRITE_TRACK_REQ:
+            if not drive.f:
+                self.a314d.send_data(stream_id, struct.pack('>BBB', WRITE_TRACK_RES, unit, OP_RES_NOT_PRESENT))
+                return
+            if not drive.writable:
+                self.a314d.send_data(stream_id, struct.pack('>BBB', WRITE_TRACK_RES, unit, OP_RES_WRITE_PROTECTED))
+                return
+            self.mem_read_queue.append((stream_id, unit, offset))
+            self.a314d.send_read_mem_req(address, length)
+
+    def process_write_mem_res(self):
+        stream_id, unit = self.mem_write_queue.pop(0)
+        if stream_id == self.current_stream_id:
+            self.a314d.send_data(stream_id, struct.pack('>BBB', READ_TRACK_RES, unit, OP_RES_OK))
+
+    def process_read_mem_res(self, disk_data: bytes):
+        stream_id, unit, offset = self.mem_read_queue.pop(0)
+        drive = self.drives[unit]
+        if stream_id == self.current_stream_id:
+            if not drive.f:
+                self.a314d.send_data(stream_id, struct.pack('>BBB', WRITE_TRACK_RES, unit, OP_RES_NOT_PRESENT))
+                return
+
+            drive.f.seek(offset, 0)
+            drive.f.write(disk_data)
+            self.a314d.send_data(stream_id, struct.pack('>BBB', WRITE_TRACK_RES, unit, OP_RES_OK))
+
+    def process_drv_msg(self, stream_id: int, ptype: int, payload: bytes):
+        if ptype == self.a314d.MSG_CONNECT:
+            if payload == SERVICE_NAME.encode() and self.current_stream_id is None:
+                logger.info('Amiga connected to disk service')
+                self.current_stream_id = stream_id
+                self.a314d.send_connect_response(stream_id, 0)
+
+                for unit, (filename, writable) in self.auto_insert.items():
+                    self.insert_adf(unit, filename, writable)
+            else:
+                self.a314d.send_connect_response(stream_id, 3)
+        elif ptype == self.a314d.MSG_READ_MEM_RES:
+            self.process_read_mem_res(payload)
+        elif ptype == self.a314d.MSG_WRITE_MEM_RES:
+            self.process_write_mem_res()
+        elif self.current_stream_id == stream_id:
+            if ptype == self.a314d.MSG_DATA:
+                self.process_stream_data(stream_id, payload)
+            elif ptype == self.a314d.MSG_EOS:
+                raise AssertionError('EOS is not supposed to be in use')
+            elif ptype == self.a314d.MSG_RESET:
+                self.current_stream_id = None
+                for i in range(4):
+                    self.eject_adf(i)
+                    self.drives[i].geometry_sent = False
+                logger.info('Amiga disconnected from disk service')
+
+    def handle_a314d_readable(self):
+        buf = self.a314d.drv.recv(8192)
+        if not buf:
+            logger.error('Connection to a314d was closed, shutting down')
+            exit(-1)
+
+        self.rbuf += buf
+        while True:
+            if len(self.rbuf) < 9:
+                break
+
+            (plen, stream_id, ptype) = struct.unpack('<IIB', self.rbuf[:9])
+            if plen > MAX_MESSAGE_SIZE or ptype not in KNOWN_PTYPES:
+                _fail_bad_header(plen, stream_id, ptype)
+            if len(self.rbuf) < 9 + plen:
+                break
+
+            payload = self.rbuf[9:9+plen]
+            self.rbuf = self.rbuf[9+plen:]
+
+            self.process_drv_msg(stream_id, ptype, payload)
+
+    def handle_control_socket_readable(self, s: socket.socket):
+        buf = s.recv(512)
+        if not buf:
+            s.close()
+            self.control_sockets.remove(s)
+            return
+
+        try:
+            buf = buf.decode('utf-8')
+            arr = buf.strip().split(' ')
+            cmd = arr[0]
+            if cmd == 'eject':
+                unit = int(arr[1])
+                res = self.eject_adf(unit)
+            elif cmd == 'insert':
+                unit = int(arr[1])
+                rw = arr[2] == '-rw'
+                idx = 3 if rw else 2
+                fn = ' '.join(arr[idx:])
+                res = self.insert_adf(unit, fn, rw)
+            else:
+                res = f"Unknown command '{cmd}'"
+        except:
+            res = "Exception raised when processing command"
+        s.sendall((res + '\n').encode('utf-8'))
+        s.shutdown(socket.SHUT_WR)
+        s.close()
+        self.control_sockets.remove(s)
+
+    def run(self):
+        self.load_config()
+
+        logger.info('Disk service is running')
+
+        while True:
+            try:
+                rl = [self.a314d, self.control_server_socket] + self.control_sockets
+                rl, _, _ = select.select(rl, [], [], 10.0)
+            except KeyboardInterrupt:
+                break
+
+            for s in rl:
+                if s == self.a314d:
+                    self.handle_a314d_readable()
+                elif s == self.control_server_socket:
+                    cs, _ = self.control_server_socket.accept()
+                    self.control_sockets.append(cs)
+                else:
+                    self.handle_control_socket_readable(s)
+
+        for s in self.control_sockets:
+            s.close()
+        self.control_server_socket.close()
+        self.a314d.close()
+
+        logger.info('Disk service stopped')
+
+if __name__ == '__main__':
+    service = DiskService()
+    service.run()
diff --git a/src/a314/files_pi/pointer.cur b/src/a314/files_pi/pointer.cur
new file mode 100644
index 00000000..6f897c1e
Binary files /dev/null and b/src/a314/files_pi/pointer.cur differ
diff --git a/src/a314/files_pi/remotewb.py b/src/a314/files_pi/remotewb.py
new file mode 100644
index 00000000..fb017b4c
--- /dev/null
+++ b/src/a314/files_pi/remotewb.py
@@ -0,0 +1,341 @@
+#!/usr/bin/python3
+# -*- coding: utf-8 -*-
+
+# Copyright (c) 2018 Niklas Ekström
+
+import asyncio
+import json
+import struct
+import time
+import websockets
+import socket
+import os
+import sys
+
+MSG_REGISTER_REQ		= 1
+MSG_REGISTER_RES		= 2
+MSG_DEREGISTER_REQ		= 3
+MSG_DEREGISTER_RES		= 4
+MSG_READ_MEM_REQ		= 5
+MSG_READ_MEM_RES		= 6
+MSG_WRITE_MEM_REQ		= 7
+MSG_WRITE_MEM_RES		= 8
+MSG_CONNECT		    	= 9
+MSG_CONNECT_RESPONSE	        = 10
+MSG_DATA		    	= 11
+MSG_EOS			    	= 12
+MSG_RESET		    	= 13
+
+MAX_MESSAGE_SIZE = 1024 * 1024
+_bad_header_logged = False
+
+KNOWN_PTYPES = {
+    MSG_REGISTER_REQ,
+    MSG_REGISTER_RES,
+    MSG_DEREGISTER_REQ,
+    MSG_DEREGISTER_RES,
+    MSG_READ_MEM_REQ,
+    MSG_READ_MEM_RES,
+    MSG_WRITE_MEM_REQ,
+    MSG_WRITE_MEM_RES,
+    MSG_CONNECT,
+    MSG_CONNECT_RESPONSE,
+    MSG_DATA,
+    MSG_EOS,
+    MSG_RESET,
+}
+
+def _fail_bad_header(plen, stream_id, ptype):
+    global _bad_header_logged
+    if not _bad_header_logged:
+        print(
+            f'Bad A314d header (len={plen} stream={stream_id} type={ptype}). Check endian framing.'
+        )
+        _bad_header_logged = True
+    raise SystemExit(1)
+
+protocol = None
+
+class MyProtocol(asyncio.Protocol):
+    def connection_made(self, transport):
+        global protocol
+        protocol = self
+
+        print('Connection to driver made')
+
+        self.transport = transport
+        sock = transport.get_extra_info('socket')
+
+        if sock.family == socket.AF_UNIX:
+            asyncio.ensure_future(create_websockets_server())
+        else:
+            sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
+            name = 'remotewb'
+            msg = struct.pack('<IIB', len(name), 0, MSG_REGISTER_REQ) + name.encode()
+            self.transport.write(msg)
+
+        self.rbuf = b''
+        self.active_stream_id = None
+        self.ptr = None
+        self.first_msg = True
+
+    def handle_msg(self, stream_id, mtype, msg):
+        if mtype == MSG_REGISTER_RES:
+            if msg[0] == 1:
+                print('Registered name successfully')
+                asyncio.ensure_future(create_websockets_server())
+            else:
+                print('Unable to register name with driver, shutting down')
+                self.transport.close()
+        elif mtype == MSG_CONNECT:
+            if self.active_stream_id is not None:
+                msg = struct.pack('<IIB', 0, self.active_stream_id, MSG_RESET)
+                self.transport.write(msg)
+            self.active_stream_id = stream_id
+            msg = struct.pack('<IIB', 1, self.active_stream_id, MSG_CONNECT_RESPONSE) + b'\x00'
+            self.transport.write(msg)
+            self.first_msg = True
+            print('Amiga connected')
+        elif mtype == MSG_DATA:
+            if self.active_stream_id == stream_id:
+                if self.first_msg:
+                    w, h, d, bpr, ptr, count = struct.unpack('>HHHHIH', msg[:14])
+                    cmap = struct.unpack('>' + ('H' * count), msg[14:14 + 2*count])
+                    self.w = w
+                    self.h = h
+                    self.d = d
+                    self.bpr = bpr
+                    self.ptr = ptr
+                    self.cmap = cmap
+                    self.first_msg = False
+                    print('Received data from app', w, h, d, ptr, cmap)
+                else:
+                    x, y = struct.unpack('>HH', msg)
+                    start_read_screenshot()
+        elif mtype == MSG_EOS:
+            if self.active_stream_id == stream_id:
+                msg = struct.pack('<IIB', 0, self.active_stream_id, MSG_EOS)
+                self.transport.write(msg)
+                self.active_stream_id = None
+        elif mtype == MSG_RESET:
+            if self.active_stream_id == stream_id:
+                self.active_stream_id = None
+        elif mtype == MSG_READ_MEM_RES:
+            read_screenshot_completed(msg)
+
+    def data_received(self, data):
+        self.rbuf += data
+
+        while True:
+            if len(self.rbuf) < 9:
+                break
+
+            mlen, stream_id, mtype = struct.unpack('<IIB', self.rbuf[:9])
+            if mlen > MAX_MESSAGE_SIZE or mtype not in KNOWN_PTYPES:
+                _fail_bad_header(mlen, stream_id, mtype)
+
+            if len(self.rbuf) < 9 + mlen:
+                break
+
+            payload = self.rbuf[9:9+mlen]
+            self.rbuf = self.rbuf[9+mlen:]
+            self.handle_msg(stream_id, mtype, payload)
+
+    def connection_lost(self, exc):
+        print('Connection to driver lost', exc)
+        if ws_server:
+            ws_server.close()
+            ws_server.wait_closed()
+        loop.stop()
+
+loop = asyncio.get_event_loop()
+ws_server = None
+active_browser = None
+
+if os.name == 'nt':
+    from PIL import Image
+    import io
+
+    def bpls2gif(bpls):
+        pixels = bytearray(640*256)
+        for i in range(3):
+            bit = 1 << i
+            for y in range(256):
+                for b in range(80):
+                    by = bpls[(i * 256 + y) * 80 + b]
+                    for j in range(8):
+                        if by & (1 << (7 - j)):
+                            pixels[y*640 + b * 8 + j] |= bit
+
+        pal = []
+        for i in range(8):
+            c = protocol.cmap[i]
+            r = (c & 0x0f00) >> 8
+            g = (c & 0x00f0) >> 4
+            b = (c & 0x000f)
+            pal.append((r << 4) | r)
+            pal.append((g << 4) | g)
+            pal.append((b << 4) | b)
+
+        im = Image.frombytes('P', (640, 256), bytes(pixels))
+        im.putpalette(pal)
+
+        with io.BytesIO() as output:
+            im.save(output, format = 'GIF')
+            contents = output.getvalue()
+            return contents
+else:
+    import bpls2gif as b2g
+
+    pal_set = False
+
+    def bpls2gif(bpls):
+        global pal_set
+        if not pal_set:
+            pal = []
+            for i in range(8):
+                c = protocol.cmap[i]
+                r = (c & 0x0f00) >> 8
+                g = (c & 0x00f0) >> 4
+                b = (c & 0x000f)
+                pal.append((r << 4) | r)
+                pal.append((g << 4) | g)
+                pal.append((b << 4) | b)
+            b2g.set_palette(bytes(pal))
+            pal_set = True
+        return b2g.encode(bpls)
+
+async def send_img_to_active_browser(gif):
+    jpart = json.dumps({'image':1, 'amiga_present':1}).encode()
+    msg = len(jpart).to_bytes(4, 'big') + jpart + gif
+    await active_browser.send(msg)
+
+is_reading_screen = False
+
+current_mouse = (0, 0, 0)
+last_sent = (0, 0, 0)
+event_q = []
+
+def got_browser_event(e):
+    global current_mouse
+
+    if 'kc' in e:
+        d = e['d']
+        kc = e['kc']
+        event_q.append(('k', d, kc))
+    else:
+        x, y, b = e['x'], e['y'], e['b']
+        cx, cy, cb = current_mouse
+
+        if (b ^ cb) & 1:
+            cb ^= 1
+            event_q.append(('m', x, y, cb))
+        if (b ^ cb) & 2:
+            cb ^= 2
+            event_q.append(('m', x, y, cb))
+
+        current_mouse = (x, y, b)
+
+pc_to_ami = {8: 65, 9: 66, 13: 68, 20: 98, 27: 69, 32: 64, 37: 79, 38: 76, 39: 78, 40: 77, 46: 70, 47: 95, 48: 10, 49: 1, 50: 2, 51: 3, 52: 4, 53: 5, 54: 6, 55: 7, 56: 8, 57: 9, 65: 32, 66: 53, 67: 51, 68: 34, 69: 18, 70: 35, 71: 36, 72: 37, 73: 23, 74: 38, 75: 39, 76: 40, 77: 55, 78: 54, 79: 24, 80: 25, 81: 16, 82: 19, 83: 33, 84: 20, 85: 22, 86: 52, 87: 17, 88: 50, 89: 21, 90: 49, 91: 102, 92: 103, 96: 15, 97: 29, 98: 30, 99: 31, 100: 45, 101: 46, 102: 47, 103: 61, 104: 62, 105: 63, 106: 93, 107: 94, 109: 74, 110: 60, 111: 92, 112: 80, 113: 81, 114: 82, 115: 83, 116: 84, 117: 85, 118: 86, 119: 87, 120: 88, 121: 89, 160: 96, 161: 97, 162: 99, 164: 100, 165: 101, 186: 27, 187: 11, 188: 56, 189: 58, 190: 57, 191: 43, 192: 41, 219: 12, 221: 26, 222: 42, 226: 48}
+
+def send_buffered_events():
+    global last_sent
+    if len(event_q) == 0 and last_sent == current_mouse:
+        return
+
+    lst = b''
+
+    while len(event_q) != 0 and len(lst) < 240:
+        e = event_q.pop(0)
+        if e[0] == 'k':
+            _, d, kc = e
+            n = 0x4000 | pc_to_ami.get(kc, 0x40)
+            if d == 'u':
+                n |= 0x2000
+            lst += struct.pack('>H', n)
+        elif e[0] == 'm':
+            _, x, y, b = e
+            lst += struct.pack('>HHH', x, y, b)
+            last_sent = (x, y, b)
+
+    if len(event_q) == 0 and last_sent != current_mouse:
+        x, y, b = current_mouse
+        lst += struct.pack('>HHH', x, y, b)
+        last_sent = current_mouse
+
+    msg = struct.pack('<IIB', len(lst), protocol.active_stream_id, MSG_DATA) + lst
+    protocol.transport.write(msg)
+
+def read_screenshot_completed(bpls):
+    global is_reading_screen
+    is_reading_screen = False
+    if active_browser is not None and protocol is not None and protocol.active_stream_id is not None:
+        if protocol.bpr == 240:
+            src = bpls
+            dst = bytearray(80*256*3)
+            for i in range(256):
+                for j in range(3):
+                    sr = 3*i + j
+                    dr = j*256 + i
+                    dst[dr*80:(dr+1)*80] = src[sr*80:(sr+1)*80]
+            bpls = bytes(dst)
+        gif = bpls2gif(bpls)
+        asyncio.ensure_future(send_img_to_active_browser(gif))
+        send_buffered_events()
+
+def start_read_screenshot():
+    global last_read_started, is_reading_screen
+    if active_browser is not None and protocol is not None and protocol.active_stream_id is not None and not is_reading_screen:
+        is_reading_screen = True
+        msg = struct.pack('<IIBII', 8, 0, MSG_READ_MEM_REQ, protocol.ptr, 3*256*80)
+        protocol.transport.write(msg)
+
+async def browser_handler(websocket, path):
+    global active_browser
+
+    print('Connection to ', path, ' was made')
+
+    is_active = active_browser is None
+    if is_active:
+        active_browser = websocket
+
+    ami_present = False
+    if protocol is not None and protocol.active_stream_id is not None:
+        ami_present = True
+
+    jpart = json.dumps({'is_active':(1 if is_active else 0), 'amiga_present':(1 if ami_present else 0)}).encode()
+    msg = len(jpart).to_bytes(4, 'big') + jpart
+    await websocket.send(msg)
+
+    try:
+        while True:
+            msg = await websocket.recv()
+            if is_active and ami_present:
+                e = json.loads(msg)
+                got_browser_event(e)
+    except websockets.exceptions.ConnectionClosed:
+        pass
+    finally:
+        print('Connection to ', path, ' was closed')
+
+        if is_active:
+            active_browser = None
+
+async def create_websockets_server():
+    global ws_server
+    ws_server = await websockets.serve(browser_handler, '0.0.0.0', 6789, loop = loop)
+    print('Websocket server created')
+
+try:
+    idx = sys.argv.index('-ondemand')
+except ValueError:
+    idx = -1
+
+if idx != -1:
+    fd = int(sys.argv[idx + 1])
+    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM, 0, fd)
+    asyncio.ensure_future(loop.create_unix_connection(lambda: MyProtocol(), path = None, sock = sock))
+else:
+    asyncio.ensure_future(loop.create_connection(lambda: MyProtocol(), 'localhost', 7110))
+
+loop.run_forever()
diff --git a/src/a314/files_pi/remotewb_client.html b/src/a314/files_pi/remotewb_client.html
new file mode 100644
index 00000000..ead6b051
--- /dev/null
+++ b/src/a314/files_pi/remotewb_client.html
@@ -0,0 +1,115 @@
+<!DOCTYPE html>
+<html>
+    <head>
+        <title>RemoteWB -- A314</title>
+        <style type="text/css">
+        </style>
+    </head>
+    <body oncontextmenu="return false;">
+	<div align="center">
+		<p>
+			<a id="screenHolder" href="#" draggable="false">
+				<img id="screen" width="640px" height="512px" style="cursor:url('pointer.cur'),auto;image-rendering:pixelated;" draggable="false"/>
+			</a>
+		</p>
+		<p>
+			<span id="isActive"></span>
+		</p>
+		<p>
+			<span id="amigaPresent"/>
+		</p>
+	</div>
+
+        <script>
+		var screenImg = document.querySelector("#screen");
+		var screenHolder = document.querySelector("#screenHolder");
+		var isActiveSpan = document.querySelector("#isActive");
+		var amigaPresentSpan = document.querySelector("#amigaPresent");
+		var decoder = new TextDecoder();
+		var websocket = new WebSocket("ws://192.168.1.144:6789/");
+		websocket.binaryType = "arraybuffer";
+
+		var pressed = new Set();
+
+		screenHolder.onkeydown = function(e) {
+			if (!pressed.has(e.code)) {
+				pressed.add(e.code);
+				var kc = e.keyCode;
+				if (e.code == 'ShiftLeft')
+					kc = 0xa0;
+				else if (e.code == 'ShiftRight')
+					kc = 0xa1;
+				else if (e.code == 'ControlLeft')
+					kc = 0xa2;
+				else if (e.code == 'ControlRight')
+					kc = 0xa3;
+				else if (e.code == 'AltLeft')
+					kc = 0xa4;
+				else if (e.code == 'AltRight')
+					kc = 0xa5;
+				websocket.send(JSON.stringify({d: 'd', kc: kc}));
+			}
+			return false;
+		};
+
+		screenHolder.onkeyup = function(e) {
+			pressed.delete(e.code);
+			var kc = e.keyCode;
+			if (e.code == 'ShiftLeft')
+				kc = 0xa0;
+			else if (e.code == 'ShiftRight')
+				kc = 0xa1;
+			else if (e.code == 'ControlLeft')
+				kc = 0xa2;
+			else if (e.code == 'ControlRight')
+				kc = 0xa3;
+			else if (e.code == 'AltLeft')
+				kc = 0xa4;
+			else if (e.code == 'AltRight')
+				kc = 0xa5;
+			websocket.send(JSON.stringify({d: 'u', kc: kc}));
+			return false;
+		};
+
+		function report(e) {
+			var rect = screenImg.getBoundingClientRect();
+			var x = Math.round(e.clientX - rect.left);
+			var y = Math.round(e.clientY - rect.top);
+			websocket.send(JSON.stringify({x: x, y: y, b: e.buttons}));
+		}
+
+		screenImg.onmousedown = report;
+		screenImg.onmouseup = report;
+		screenImg.onmousemove = report;
+
+		websocket.onmessage = function (event) {
+			var length = new DataView(event.data.slice(0, 4)).getInt32();
+			var jsonText = decoder.decode(event.data.slice(4, 4 + length));
+			var jsonObj = JSON.parse(jsonText);
+
+			if ('is_active' in jsonObj)
+			{
+				if (jsonObj.is_active)
+					isActiveSpan.textContent = "Is active";
+				else
+					isActiveSpan.textContent = "Some other browser is active, try again later";
+			}
+
+			if ('amiga_present' in jsonObj)
+			{
+				if (jsonObj.amiga_present)
+					amigaPresentSpan.textContent = "Amiga is present";
+				else
+					amigaPresentSpan.textContent = "Amiga is currently not connected";
+			}
+
+			if ('image' in jsonObj)
+			{
+				var imgData = event.data.slice(4 + length);
+				var blob = new Blob([imgData], {type: "image/gif"});
+				screenImg.src = URL.createObjectURL(blob);
+			}
+		};
+        </script>
+    </body>
+</html>
diff --git a/src/a314/software-amiga/a314disk-mountlist b/src/a314/software-amiga/a314disk-mountlist
new file mode 100644
index 00000000..51ec390d
--- /dev/null
+++ b/src/a314/software-amiga/a314disk-mountlist
@@ -0,0 +1,55 @@
+PD0:	Device = a314disk.device
+	Unit   = 0
+	Flags  = 1
+	Surfaces  = 2
+	BlocksPerTrack = 11
+	Reserved = 2
+	Interleave = 0
+	LowCyl = 0
+	HighCyl = 79
+	Buffers = 2
+	BufMemType = 0
+	MaxTransfer = 5632
+#
+
+PD1:	Device = a314disk.device
+	Unit   = 1
+	Flags  = 1
+	Surfaces  = 2
+	BlocksPerTrack = 11
+	Reserved = 2
+	Interleave = 0
+	LowCyl = 0
+	HighCyl = 79
+	Buffers = 2
+	BufMemType = 0
+	MaxTransfer = 5632
+#
+
+PD2:	Device = a314disk.device
+	Unit   = 2
+	Flags  = 1
+	Surfaces  = 2
+	BlocksPerTrack = 11
+	Reserved = 2
+	Interleave = 0
+	LowCyl = 0
+	HighCyl = 79
+	Buffers = 2
+	BufMemType = 0
+	MaxTransfer = 5632
+#
+
+PD3:	Device = a314disk.device
+	Unit   = 3
+	Flags  = 1
+	Surfaces  = 2
+	BlocksPerTrack = 11
+	Reserved = 2
+	Interleave = 0
+	LowCyl = 0
+	HighCyl = 79
+	Buffers = 2
+	BufMemType = 0
+	MaxTransfer = 5632
+#
diff --git a/src/a314/software-amiga/disk_pistorm/build.sh b/src/a314/software-amiga/disk_pistorm/build.sh
new file mode 100755
index 00000000..f1f0c452
--- /dev/null
+++ b/src/a314/software-amiga/disk_pistorm/build.sh
@@ -0,0 +1,9 @@
+#!/usr/bin/env sh
+set -e
+
+PATH=/opt/amiga/bin:$PATH
+
+vasmm68k_mot -Fhunk -quiet romtag.asm -o romtag.o
+m68k-amigaos-gcc -m68000 -O2 -c device.c -o device.o
+m68k-amigaos-gcc -m68000 -O2 -c debug.c -o debug.o
+m68k-amigaos-gcc -m68000 -nostartfiles -o ../a314disk.device romtag.o device.o debug.o -lamiga
diff --git a/src/a314/software-amiga/disk_pistorm/debug.c b/src/a314/software-amiga/disk_pistorm/debug.c
new file mode 100644
index 00000000..0f55973c
--- /dev/null
+++ b/src/a314/software-amiga/disk_pistorm/debug.c
@@ -0,0 +1,179 @@
+#include <exec/types.h>
+#include <libraries/dos.h>
+
+#include <proto/exec.h>
+#include <proto/dos.h>
+
+#include "debug.h"
+
+#if !DEBUG
+void dbg_init()
+{
+}
+
+void debug_process_run()
+{
+}
+
+void dbg(const char* fmt, ...)
+{
+}
+#else
+
+#define LOG_SIZE 16
+
+extern void debug_process_seglist();
+static const char debug_process_name[] = "logger-process";
+static struct Process *debug_process = NULL;
+
+static char msg_bufs[LOG_SIZE][128];
+static volatile msg_lengths[LOG_SIZE];
+static volatile UWORD dbg_head = 0;
+static volatile UWORD dbg_tail = 0;
+static volatile UWORD dbg_reserved_tail = 0;
+static volatile BOOL dropped_message = FALSE;
+
+static const char print_dropped[] = "A message was dropped\n";
+
+struct ExecBase *SysBase;
+struct DosLibrary *DOSBase;
+
+void dbg_init()
+{
+    SysBase = *(struct ExecBase **)4;
+    DOSBase = (struct DosLibrary *)OpenLibrary(DOSNAME, 0);
+
+    struct MsgPort *process_mp = CreateProc(
+        (char *)debug_process_name,
+        20,
+        ((ULONG)debug_process_seglist) >> 2,
+        2048);
+
+    if (process_mp)
+        debug_process = (struct Process *)((char *)process_mp - sizeof(struct Task));
+}
+
+void debug_process_run()
+{
+    BPTR dbg_con = Open("CON:200/0/440/256/a314disk", MODE_NEWFILE);
+
+    while (TRUE)
+    {
+        Wait(SIGBREAKF_CTRL_D);
+
+        while (dbg_head != dbg_tail)
+        {
+            Write(dbg_con, msg_bufs[dbg_head], msg_lengths[dbg_head]);
+            msg_lengths[dbg_head] = 0;
+            dbg_head = (dbg_head + 1) & (LOG_SIZE - 1);
+        }
+
+        if (dropped_message)
+        {
+            Write(dbg_con, (char *)print_dropped, sizeof(print_dropped) - 1);
+            dropped_message = FALSE;
+        }
+    }
+}
+
+void dbg(const char* fmt, ...)
+{
+    Disable();
+    int my_slot = dbg_reserved_tail;
+    int next_slot = (my_slot + 1) & (LOG_SIZE - 1);
+
+    if (next_slot == dbg_head)
+    {
+        dropped_message = TRUE;
+        Enable();
+        return;
+    }
+
+    dbg_reserved_tail = next_slot;
+    Enable();
+
+    char numbuf[16];
+
+    const char *p = fmt;
+    char *q = msg_bufs[my_slot];
+
+    ULONG *args = (ULONG *)&fmt;
+    args++;
+
+    while (*p != 0)
+    {
+        char c = *p++;
+        if (c == '$')
+        {
+            c = *p++;
+            if (c == 'b')
+            {
+                ULONG x = *args++;
+                *q++ = '$';
+                for (int i = 0; i < 2; i++)
+                {
+                    int ni = (x >> ((1 - i) * 4)) & 0xf;
+                    *q++ = (ni >= 10) ? ('a' + (ni - 10)) : ('0' + ni);
+                }
+            }
+            else if (c == 'w')
+            {
+                ULONG x = *args++;
+                *q++ = '$';
+                for (int i = 0; i < 4; i++)
+                {
+                    int ni = (x >> ((3 - i) * 4)) & 0xf;
+                    *q++ = (ni >= 10) ? ('a' + (ni - 10)) : ('0' + ni);
+                }
+            }
+            else if (c == 'l')
+            {
+                ULONG x = *args++;
+                *q++ = '$';
+                for (int i = 0; i < 8; i++)
+                {
+                    int ni = (x >> ((7 - i) * 4)) & 0xf;
+                    *q++ = (ni >= 10) ? ('a' + (ni - 10)) : ('0' + ni);
+                }
+            }
+            else if (c == 'S')
+            {
+                unsigned char *s = (unsigned char *)*args++;
+                int l = *s++;
+                for (int i = 0; i < l; i++)
+                    *q++ = *s++;
+            }
+            else if (c == 's')
+            {
+                unsigned char *s = (unsigned char *)*args++;
+                while (*s)
+                    *q++ = *s++;
+            }
+            else if (c == '$')
+            {
+                *q++ = '$';
+            }
+            else
+            {
+                *q++ = '$';
+                *q++ = c;
+            }
+        }
+        else
+        {
+            *q++ = c;
+        }
+    }
+    *q++ = '\n';
+
+    Disable();
+    msg_lengths[my_slot] = q - msg_bufs[my_slot];
+
+    while (dbg_tail != dbg_reserved_tail && msg_lengths[dbg_tail] != 0)
+        dbg_tail = (dbg_tail + 1) & (LOG_SIZE - 1);
+    Enable();
+
+    if (debug_process)
+        Signal(&debug_process->pr_Task, SIGBREAKF_CTRL_D);
+}
+#endif
diff --git a/src/a314/software-amiga/disk_pistorm/debug.h b/src/a314/software-amiga/disk_pistorm/debug.h
new file mode 100644
index 00000000..cf37caa0
--- /dev/null
+++ b/src/a314/software-amiga/disk_pistorm/debug.h
@@ -0,0 +1,4 @@
+#define DEBUG 0
+
+extern void dbg_init();
+extern void dbg(const char* fmt, ...);
diff --git a/src/a314/software-amiga/disk_pistorm/device.c b/src/a314/software-amiga/disk_pistorm/device.c
new file mode 100644
index 00000000..97ba8e90
--- /dev/null
+++ b/src/a314/software-amiga/disk_pistorm/device.c
@@ -0,0 +1,812 @@
+/*
+ * Copyright (c) 2021 Niklas Ekström
+ */
+
+#include <exec/types.h>
+#include <exec/execbase.h>
+#include <exec/devices.h>
+#include <exec/errors.h>
+#include <exec/ports.h>
+#include <devices/timer.h>
+#include <devices/trackdisk.h>
+#include <libraries/dos.h>
+#include <libraries/dosextens.h>
+#include <libraries/filehandler.h>
+#include <libraries/expansion.h>
+#include <libraries/expansionbase.h>
+
+#include <proto/alib.h>
+#include <proto/exec.h>
+#include <proto/expansion.h>
+
+#include <string.h>
+#include <stdarg.h>
+#include <stdint.h>
+
+#include "../a314device/a314.h"
+#include "../a314device/proto_a314.h"
+
+#include "debug.h"
+
+// VBCC unnecessairly warns when a loop has a single iteration.
+#pragma dontwarn 208
+
+#define SysBase (*(struct ExecBase **)4)
+#define A314Base (dev->a314_base)
+
+#ifndef INVALID_A314_ADDRESS
+#define INVALID_A314_ADDRESS ((ULONG)-1)
+#endif
+
+static ULONG alloc_a314_buffer(ULONG length)
+{
+    APTR buf = AllocMem(length, MEMF_PUBLIC | MEMF_CLEAR);
+    if (!buf)
+        return INVALID_A314_ADDRESS;
+    return (ULONG)buf;
+}
+
+static void free_a314_buffer(ULONG address, ULONG length)
+{
+    if (address != INVALID_A314_ADDRESS)
+        FreeMem((APTR)address, length);
+}
+
+#ifndef TD_GETGEOMETRY
+// Needed to compile with AmigaOS 1.3 headers.
+#define TD_GETGEOMETRY    (CMD_NONSTD+13)
+
+#define DG_DIRECT_ACCESS    0
+#define DGF_REMOVABLE       1
+
+struct DriveGeometry
+{
+    ULONG    dg_SectorSize;
+    ULONG    dg_TotalSectors;
+    ULONG    dg_Cylinders;
+    ULONG    dg_CylSectors;
+    ULONG    dg_Heads;
+    ULONG    dg_TrackSectors;
+    ULONG    dg_BufMemType;
+    UBYTE    dg_DeviceType;
+    UBYTE    dg_Flags;
+    UWORD    dg_Reserved;
+};
+#endif
+
+// Defines.
+
+#define DEVICE_NAME             "a314disk.device"
+#define SERVICE_NAME            "disk"
+
+#define TASK_PRIORITY           10
+#define TASK_STACK_SIZE         2048
+
+#define UNIT_COUNT              4
+#define AUTOBOOT_UNIT_COUNT     1
+
+#define SIGB_A314               30
+#define SIGB_OP_REQ             29
+
+#define SIGF_A314               (1UL << SIGB_A314)
+#define SIGF_OP_REQ             (1UL << SIGB_OP_REQ)
+
+#define BOOT_PRIORITY           -5
+
+// TRACK_SIZE = 5632
+#define TRACK_SIZE              (NUMSECS * TD_SECTOR)
+
+#define MSG_READ_TRACK_REQ      1
+#define MSG_WRITE_TRACK_REQ     2
+#define MSG_READ_TRACK_RES      3
+#define MSG_WRITE_TRACK_RES     4
+#define MSG_INSERT_NOTIFY       5
+#define MSG_EJECT_NOTIFY        6
+#define MSG_SET_GEOMETRY        7
+
+#define OP_RES_OK               0
+#define OP_RES_NOT_PRESENT      1
+#define OP_RES_WRITE_PROTECTED  2
+
+// Structs.
+
+struct DriveState
+{
+    struct IOStdReq *change_int;
+    struct Interrupt *remove_int;
+    ULONG *env_vec;
+    volatile ULONG change_num;
+    volatile ULONG opencnt;
+    volatile BOOL present;
+    volatile BOOL write_protected;
+    UWORD unit;
+    UWORD heads;
+    UWORD sectors_per_track;
+    ULONG cylinders;
+};
+
+#pragma pack(push, 1)
+struct RequestMsg
+{
+    UBYTE kind;
+    UBYTE unit;
+    UWORD length;
+    ULONG offset;
+    ULONG address;
+};
+#pragma pack(pop)
+
+#pragma pack(push, 1)
+struct ResponseMsg
+{
+    UBYTE kind;
+    UBYTE unit;
+    union
+    {
+        UBYTE error; // READ_/WRITE_TRACK_RES
+        UBYTE writable; // INSERT_NOTIFY
+        struct // SET_GEOMETRY
+        {
+            UBYTE heads;
+            UBYTE sectors_per_track;
+            ULONG cylinders;
+        } geometry;
+    } u;
+};
+#pragma pack(pop)
+
+struct DiskDevice
+{
+    struct Library lib;
+
+    BPTR saved_seg_list;
+
+    struct MsgPort op_req_mp;
+    struct MsgPort a314_mp;
+
+    struct A314_IORequest read_ior;
+    struct A314_IORequest write_ior;
+    struct A314_IORequest reset_ior;
+
+    struct Library *a314_base;
+
+    ULONG track_buffer_address;
+
+    struct DriveState drive_states[UNIT_COUNT];
+
+    void *task_stack;
+    struct Task task;
+
+    struct List request_queue;
+    volatile struct IOStdReq *pending_operation;
+
+    LONG a314_socket;
+
+    BOOL pending_connect;
+    BOOL pending_read;
+    BOOL pending_write;
+    BOOL pending_reset;
+    BOOL connection_resetted;
+
+    struct RequestMsg req_msg;
+    struct ResponseMsg res_msg;
+};
+
+// Constants.
+
+const char device_name[] = DEVICE_NAME;
+const char id_string[] = DEVICE_NAME " 1.0 (29 April 2021)";
+
+static const char service_name[] = SERVICE_NAME;
+static const char a314_device_name[] = A314_NAME;
+
+// Procedures.
+
+void NewList(struct List *l)
+{
+    l->lh_Head = (struct Node *)&(l->lh_Tail);
+    l->lh_Tail = NULL;
+    l->lh_TailPred = (struct Node *)&(l->lh_Head);
+}
+
+static void send_a314_cmd(struct DiskDevice *dev, struct A314_IORequest *ior, UWORD cmd, char *buffer, int length)
+{
+    ior->a314_Request.io_Command = cmd;
+    ior->a314_Request.io_Error = 0;
+    ior->a314_Socket = dev->a314_socket;
+    ior->a314_Buffer = buffer;
+    ior->a314_Length = length;
+    SendIO((struct IORequest *)ior);
+}
+
+static void send_request_if_possible(struct DiskDevice *dev)
+{
+    if (dev->connection_resetted || dev->pending_operation)
+        return;
+
+    struct IOStdReq *ior = NULL;
+
+    while (TRUE)
+    {
+        ior = (struct IOStdReq *)RemHead(&dev->request_queue);
+        if (!ior)
+            return;
+
+        struct DriveState *ds = (struct DriveState *)ior->io_Unit;
+        if (ds->present)
+        {
+            dev->req_msg.unit = ds->unit;
+            break;
+        }
+        else
+        {
+            ior->io_Error = TDERR_DiskChanged;
+            ReplyMsg(&ior->io_Message);
+        }
+    }
+
+    dev->pending_operation = ior;
+
+    // TODO: Should handle that a read/write request can be larger
+    // than the track buffer, by splitting up transfer.
+
+    ULONG buf_address = TranslateAddressA314(ior->io_Data);
+
+    switch (ior->io_Command)
+    {
+    case CMD_READ:
+        dev->req_msg.kind = MSG_READ_TRACK_REQ;
+        break;
+
+    case TD_FORMAT:
+    case CMD_WRITE:
+        if (buf_address == INVALID_A314_ADDRESS)
+            WriteMemA314(dev->track_buffer_address, ior->io_Data, ior->io_Length);
+        dev->req_msg.kind = MSG_WRITE_TRACK_REQ;
+        break;
+    }
+
+    if (buf_address == INVALID_A314_ADDRESS)
+        buf_address = dev->track_buffer_address;
+
+    dev->req_msg.length = ior->io_Length;
+    dev->req_msg.offset = ior->io_Offset;
+    dev->req_msg.address = buf_address;
+
+    send_a314_cmd(dev, &dev->write_ior, A314_WRITE, (char *)&dev->req_msg, sizeof(struct RequestMsg));
+    dev->pending_write = TRUE;
+}
+
+static void handle_eject_msg(struct DriveState *ds)
+{
+    ds->change_num++;
+    ds->present = FALSE;
+
+    struct Interrupt *remove_int = ds->remove_int;
+    if (remove_int)
+        Cause(remove_int);
+
+    struct IOStdReq *change_int = ds->change_int;
+    if (change_int)
+        Cause((struct Interrupt *)change_int->io_Data);
+}
+
+static void handle_insert_msg(struct DriveState *ds, struct ResponseMsg *msg)
+{
+    ds->write_protected = msg->u.writable == 0;
+    ds->change_num++;
+    ds->present = TRUE;
+
+    struct Interrupt *remove_int = ds->remove_int;
+    if (remove_int)
+        Cause(remove_int);
+
+    struct IOStdReq *change_int = ds->change_int;
+    if (change_int)
+        Cause((struct Interrupt *)change_int->io_Data);
+}
+
+static void handle_set_geometry_msg(struct DriveState *ds, struct ResponseMsg *msg)
+{
+    ds->heads = msg->u.geometry.heads;
+    ds->sectors_per_track = msg->u.geometry.sectors_per_track;
+    ds->cylinders = msg->u.geometry.cylinders;
+
+    ULONG *ev = ds->env_vec;
+    if (ev)
+    {
+        ev[DE_NUMHEADS] = msg->u.geometry.heads;
+        ev[DE_BLKSPERTRACK] = msg->u.geometry.sectors_per_track;
+        ev[DE_UPPERCYL] = msg->u.geometry.cylinders - 1;
+    }
+}
+
+static void handle_response_msg(struct DiskDevice *dev)
+{
+    struct DriveState *ds = &dev->drive_states[dev->res_msg.unit];
+
+    switch (dev->res_msg.kind)
+    {
+    case MSG_READ_TRACK_RES:
+    case MSG_WRITE_TRACK_RES:
+        switch (dev->res_msg.u.error)
+        {
+        case OP_RES_OK:
+            if (dev->res_msg.kind == MSG_READ_TRACK_RES &&
+                    TranslateAddressA314(dev->pending_operation->io_Data) == INVALID_A314_ADDRESS)
+                ReadMemA314(dev->pending_operation->io_Data, dev->track_buffer_address, dev->pending_operation->io_Length);
+            dev->pending_operation->io_Actual = dev->pending_operation->io_Length;
+            break;
+
+        case OP_RES_NOT_PRESENT:
+            dev->pending_operation->io_Error = TDERR_DiskChanged;
+            break;
+
+        case OP_RES_WRITE_PROTECTED:
+            dev->pending_operation->io_Error = TDERR_WriteProt;
+            break;
+        }
+
+        ReplyMsg(&dev->pending_operation->io_Message);
+        dev->pending_operation = NULL;
+        break;
+
+    case MSG_EJECT_NOTIFY:
+        handle_eject_msg(ds);
+        break;
+
+    case MSG_INSERT_NOTIFY:
+        handle_insert_msg(ds, &dev->res_msg);
+        break;
+
+    case MSG_SET_GEOMETRY:
+        handle_set_geometry_msg(ds, &dev->res_msg);
+        break;
+    }
+}
+
+static void handle_a314_reply(struct DiskDevice *dev, struct A314_IORequest *ior)
+{
+    switch (ior->a314_Request.io_Command)
+    {
+    case A314_CONNECT:
+        dev->pending_connect = FALSE;
+        if (ior->a314_Request.io_Error != A314_CONNECT_OK)
+            dev->connection_resetted = TRUE;
+        break;
+
+    case A314_READ:
+        dev->pending_read = FALSE;
+        if (dev->read_ior.a314_Request.io_Error == A314_READ_OK)
+            handle_response_msg(dev);
+        else if (dev->read_ior.a314_Request.io_Error == A314_READ_RESET)
+            dev->connection_resetted = TRUE;
+        break;
+
+    case A314_WRITE:
+        dev->pending_write = FALSE;
+        if (dev->write_ior.a314_Request.io_Error != A314_WRITE_OK)
+            dev->connection_resetted = TRUE;
+        break;
+
+    case A314_RESET:
+        dev->pending_reset = FALSE;
+        break;
+    }
+
+    // TODO: If connection resets (Pi shuts down or crashes)
+    // then should eject disks from all drives automatically,
+    // and reply to any pending requests.
+
+    if (!dev->connection_resetted && !dev->pending_connect && !dev->pending_read)
+    {
+        send_a314_cmd(dev, &dev->read_ior, A314_READ, (char *)&dev->res_msg, sizeof(struct ResponseMsg));
+        dev->pending_read = TRUE;
+    }
+}
+
+static void task_main()
+{
+    struct DiskDevice *dev = (struct DiskDevice *)FindTask(NULL)->tc_UserData;
+
+    send_a314_cmd(dev, &dev->read_ior, A314_CONNECT, (char *)service_name, strlen(service_name));
+    dev->pending_connect = TRUE;
+
+    while (TRUE)
+    {
+        ULONG sigs = Wait(SIGF_A314 | SIGF_OP_REQ);
+
+        if (sigs & SIGF_A314)
+        {
+            struct A314_IORequest *ior;
+            while ((ior = (struct A314_IORequest *)GetMsg(&dev->a314_mp)))
+                handle_a314_reply(dev, ior);
+        }
+
+        if (sigs & SIGF_OP_REQ)
+        {
+            struct IOStdReq *ior;
+            while ((ior = (struct IOStdReq *)GetMsg(&dev->op_req_mp)))
+                AddTail(&dev->request_queue, &ior->io_Message.mn_Node);
+        }
+
+        send_request_if_possible(dev);
+    }
+}
+
+static void init_task(struct DiskDevice *dev)
+{
+    char *stack = dev->task_stack;
+    struct Task *task = &dev->task;
+    task->tc_Node.ln_Type = NT_TASK;
+    task->tc_Node.ln_Pri = TASK_PRIORITY;
+    task->tc_Node.ln_Name = (char *)device_name;
+    task->tc_SPLower = (APTR)stack;
+    task->tc_SPUpper = (APTR)(stack + TASK_STACK_SIZE);
+    task->tc_SPReg = (APTR)(stack + TASK_STACK_SIZE);
+    NewList(&task->tc_MemEntry);
+    task->tc_UserData = (void *)dev;
+
+    AddTask(task, (void *)task_main, 0);
+}
+
+static void init_message_port(struct MsgPort *mp, UBYTE sig_bit, struct Task *sig_task)
+{
+    mp->mp_Node.ln_Type = NT_MSGPORT;
+    mp->mp_Flags = PA_SIGNAL;
+    mp->mp_SigBit = sig_bit;
+    mp->mp_SigTask = sig_task;
+    NewList(&mp->mp_MsgList);
+}
+
+static void init_a314_ioreq(struct A314_IORequest *ior, struct MsgPort *mp)
+{
+    ior->a314_Request.io_Message.mn_ReplyPort = mp;
+    ior->a314_Request.io_Message.mn_Length = sizeof(struct A314_IORequest);
+    ior->a314_Request.io_Message.mn_Node.ln_Type = NT_REPLYMSG;
+}
+
+static void get_geometry(struct DriveState *ds, struct DriveGeometry *geom)
+{
+    ULONG numtracks = ds->cylinders * ds->heads;
+    geom->dg_SectorSize = TD_SECTOR;
+    geom->dg_TotalSectors = numtracks * ds->sectors_per_track;
+    geom->dg_Cylinders = ds->cylinders;
+    geom->dg_CylSectors = ds->sectors_per_track * ds->heads;
+    geom->dg_Heads = ds->heads;
+    geom->dg_TrackSectors = ds->sectors_per_track;
+    geom->dg_BufMemType = 0;
+    geom->dg_DeviceType = DG_DIRECT_ACCESS;
+    geom->dg_Flags = DGF_REMOVABLE;
+}
+
+static void begin_io(__reg("a6") struct DiskDevice *dev, __reg("a1") struct IOStdReq *ior)
+{
+    if (!ior || !ior->io_Unit)
+        return;
+
+    struct DriveState *ds = (void *)ior->io_Unit;
+
+    dbg("begin_io, unit=$b, command=$w, flags=$w", ds->unit, ior->io_Command, ior->io_Flags);
+
+    ior->io_Error = 0;
+    ior->io_Actual = 0;
+
+    switch (ior->io_Command)
+    {
+    case CMD_RESET:
+    case CMD_CLEAR:
+    case CMD_UPDATE:
+    case TD_MOTOR:
+    case TD_SEEK:
+        break;
+
+    case TD_REMOVE:
+        ds->remove_int = (struct Interrupt *)ior->io_Data;
+        break;
+
+    case TD_PROTSTATUS:
+        ior->io_Actual = ds->write_protected;
+        break;
+
+    case TD_CHANGESTATE:
+        ior->io_Actual = ds->present ? 0 : 1;
+        break;
+
+    case TD_CHANGENUM:
+        ior->io_Actual = ds->change_num;
+        break;
+
+    case TD_GETDRIVETYPE:
+        ior->io_Actual = DRIVE3_5;
+        break;
+
+    case TD_GETNUMTRACKS:
+        ior->io_Actual = ds->cylinders * ds->heads;
+        break;
+
+    case TD_GETGEOMETRY:
+        get_geometry(ds, (struct DriveGeometry *)ior->io_Data);
+        break;
+
+    case TD_ADDCHANGEINT:
+        if (ds->change_int)
+            ior->io_Error = IOERR_ABORTED;
+        else
+        {
+            ds->change_int = ior;
+            ior->io_Flags &= ~IOF_QUICK;
+            ior = NULL;
+        }
+        break;
+
+    case TD_REMCHANGEINT:
+        if (ds->change_int == ior)
+            ds->change_int = NULL;
+        break;
+
+    case CMD_READ:
+        dbg("CMD_READ, unit=$b, offset=$l, length=$l, data=$l", ds->unit, ior->io_Offset, ior->io_Length, ior->io_Data);
+        if (!ds->present)
+            ior->io_Error = TDERR_DiskChanged;
+        else
+        {
+            PutMsg(&dev->op_req_mp, &ior->io_Message);
+            ior->io_Flags &= ~IOF_QUICK;
+            ior = NULL;
+        }
+        break;
+
+    case TD_FORMAT:
+    case CMD_WRITE:
+        dbg("CMD_WRITE, unit=$b, offset=$l, length=$l, data=$l", ds->unit, ior->io_Offset, ior->io_Length, ior->io_Data);
+        if (!ds->present)
+            ior->io_Error = TDERR_DiskChanged;
+        else if (ds->write_protected)
+            ior->io_Error = TDERR_WriteProt;
+        else
+        {
+            PutMsg(&dev->op_req_mp, &ior->io_Message);
+            ior->io_Flags &= ~IOF_QUICK;
+            ior = NULL;
+        }
+        break;
+
+    default:
+        ior->io_Error = IOERR_NOCMD;
+        break;
+    }
+
+    if (ior && !(ior->io_Flags & IOF_QUICK))
+        ReplyMsg(&ior->io_Message);
+}
+
+static ULONG abort_io(__reg("a6") struct DiskDevice *dev, __reg("a1") struct IOStdReq *ior)
+{
+    return IOERR_NOCMD;
+}
+
+static ULONG get_socket_id()
+{
+    struct timerequest tr;
+    memset(&tr, 0, sizeof(tr));
+    tr.tr_node.io_Message.mn_Length = sizeof(tr);
+    tr.tr_node.io_Message.mn_Node.ln_Type = NT_REPLYMSG;
+
+    OpenDevice(TIMERNAME, UNIT_VBLANK, &tr.tr_node, 0);
+    tr.tr_node.io_Command = TR_GETSYSTIME;
+    DoIO(&tr.tr_node);
+    CloseDevice(&tr.tr_node);
+
+    return tr.tr_time.tv_secs * TICKS_PER_SECOND;
+}
+
+struct MountListEntry
+{
+    struct DeviceNode dev_node;
+    struct FileSysStartupMsg fssm;
+    ULONG env_vec[20];
+    char drive_name[8];
+    char device_name[20];
+    struct BootNode boot_node;
+};
+
+static ULONG env_vec_template[20] = {
+    19,             // DE_TABLESIZE
+    128,            // DE_SIZEBLOCK
+    0,              // DE_SECORG
+    2,              // DE_NUMHEADS
+    1,              // DE_SECSPERBLK
+    11,             // DE_BLKSPERTRACK
+    2,              // DE_RESERVEDBLKS
+    0,              // DE_PREFAC
+    0,              // DE_INTERLEAVE
+    0,              // DE_LOWCYL
+    79,             // DE_UPPERCYL
+    2,              // DE_NUMBUFFERS
+    0,              // DE_BUFMEMTYPE
+    TRACK_SIZE,     // DE_MAXTRANSFER
+    0x7fffffff,     // DE_MASK
+    BOOT_PRIORITY,  // DE_BOOTPRI
+    ID_DOS_DISK,    // DE_DOSTYPE
+    0,              // DE_BAUD
+    0,              // DE_CONTROL
+    2               // DE_BOOTBLOCKS
+};
+
+static void add_boot_node(struct ExpansionBase *expansion_base, struct DriveState *ds)
+{
+    struct MountListEntry *mle = AllocMem(sizeof(struct MountListEntry), MEMF_PUBLIC | MEMF_CLEAR);
+
+    //mle->dev_node.dn_Type = DLT_DEVICE;
+    mle->dev_node.dn_StackSize = 600;
+    mle->dev_node.dn_Priority = 10;
+    mle->dev_node.dn_Startup = ((ULONG)(&mle->fssm)) >> 2;
+    mle->dev_node.dn_Name = ((ULONG)(&mle->drive_name[0])) >> 2;
+
+    mle->fssm.fssm_Unit = ds->unit;
+    mle->fssm.fssm_Device = ((ULONG)(&mle->device_name[0])) >> 2;
+    mle->fssm.fssm_Environ = ((ULONG)(&mle->env_vec[0])) >> 2;
+
+    memcpy(mle->env_vec, env_vec_template, sizeof(env_vec_template));
+    ds->env_vec = mle->env_vec;
+
+    *(ULONG *)(&mle->drive_name[0]) = (3 << 24) | ('P' << 16) | ('D' << 8) | ('0' + ds->unit);
+
+    mle->device_name[0] = sizeof(device_name);
+    memcpy(&mle->device_name[1], device_name, sizeof(device_name));
+
+    mle->boot_node.bn_Node.ln_Type = NT_BOOTNODE;
+    mle->boot_node.bn_Node.ln_Pri = BOOT_PRIORITY;
+    mle->boot_node.bn_DeviceNode = (APTR)&mle->dev_node;
+
+    Forbid();
+    Enqueue(&expansion_base->MountList, &mle->boot_node.bn_Node);
+    Permit();
+}
+
+static struct Library *init_device(__reg("a6") struct ExecBase *sys_base, __reg("a0") BPTR seg_list, __reg("d0") struct DiskDevice *dev)
+{
+    dev->saved_seg_list = seg_list;
+
+    dev->lib.lib_Node.ln_Type = NT_DEVICE;
+    dev->lib.lib_Node.ln_Name = (char *)device_name;
+    dev->lib.lib_Flags = LIBF_SUMUSED | LIBF_CHANGED;
+    dev->lib.lib_Version = 1;
+    dev->lib.lib_Revision = 0;
+    dev->lib.lib_IdString = (APTR)id_string;
+
+    init_message_port(&dev->a314_mp, SIGB_A314, &dev->task);
+    init_message_port(&dev->op_req_mp, SIGB_OP_REQ, &dev->task);
+
+    init_a314_ioreq(&dev->read_ior, &dev->a314_mp);
+
+    if (OpenDevice((char *)a314_device_name, 0, &dev->read_ior.a314_Request, 0))
+        goto fail1;
+
+    dev->a314_base = &(dev->read_ior.a314_Request.io_Device->dd_Library);
+
+    memcpy(&dev->write_ior, &dev->read_ior, sizeof(struct A314_IORequest));
+    memcpy(&dev->reset_ior, &dev->read_ior, sizeof(struct A314_IORequest));
+
+    dev->track_buffer_address = alloc_a314_buffer(TRACK_SIZE);
+    if (dev->track_buffer_address == INVALID_A314_ADDRESS)
+        goto fail2;
+
+    for (int i = 0; i < UNIT_COUNT; i++)
+    {
+        struct DriveState *ds = &dev->drive_states[i];
+        ds->unit = i;
+        ds->heads = 2; // Default to floppy disk geometry.
+        ds->sectors_per_track = 11;
+        ds->cylinders = 80;
+    }
+
+    NewList(&dev->request_queue);
+
+    dev->a314_socket = get_socket_id();
+
+    dev->task_stack = AllocMem(TASK_STACK_SIZE, MEMF_CLEAR);
+    if (!dev->task_stack)
+        goto fail3;
+
+    if (!seg_list)
+    {
+        struct ExpansionBase *expansion_base = (struct ExpansionBase *)OpenLibrary(EXPANSIONNAME, 0);
+
+        if (expansion_base)
+        {
+            for (int i = 0; i < AUTOBOOT_UNIT_COUNT; i++)
+                add_boot_node(expansion_base, &dev->drive_states[i]);
+
+            CloseLibrary(&expansion_base->LibNode);
+        }
+    }
+
+    init_task(dev);
+
+    dbg_init();
+    dbg("Started");
+
+    return &dev->lib;
+
+fail3:
+    free_a314_buffer(dev->track_buffer_address, TRACK_SIZE);
+
+fail2:
+    CloseDevice(&dev->read_ior.a314_Request);
+
+fail1:
+    FreeMem((char *)dev - dev->lib.lib_NegSize, dev->lib.lib_NegSize + dev->lib.lib_PosSize);
+    return NULL;
+}
+
+static BPTR expunge(__reg("a6") struct DiskDevice *dev)
+{
+    // Currently no support for unloading device driver.
+    if (dev->lib.lib_OpenCnt != 0)
+    {
+        dev->lib.lib_Flags |= LIBF_DELEXP;
+        return 0;
+    }
+
+    return 0;
+}
+
+static void open(__reg("a6") struct DiskDevice *dev, __reg("a1") struct IORequest *ior, __reg("d0") ULONG unitnum, __reg("d1") ULONG flags)
+{
+    dbg("open device, unit=$l, ior=$l, flags=$l", (ULONG)unitnum, (ULONG)ior, (ULONG)flags);
+
+    ior->io_Error = IOERR_OPENFAIL;
+    ior->io_Message.mn_Node.ln_Type = NT_REPLYMSG;
+
+    if (unitnum >= UNIT_COUNT)
+        return;
+
+    struct DriveState *ds = &dev->drive_states[unitnum];
+    ds->opencnt++;
+    dev->lib.lib_OpenCnt++;
+
+    ior->io_Unit = (void *)ds;
+    ior->io_Error = 0;
+}
+
+static BPTR close(__reg("a6") struct DiskDevice *dev, __reg("a1") struct IORequest *ior)
+{
+    dbg("close device, ior=$l", ior);
+
+    if (!ior || !ior->io_Unit)
+        return 0;
+
+    struct DriveState *ds = (void *)ior->io_Unit;
+    ds->opencnt--;
+
+    ior->io_Device = NULL;
+    ior->io_Unit = NULL;
+
+    dev->lib.lib_OpenCnt--;
+
+    if (dev->lib.lib_OpenCnt == 0 && (dev->lib.lib_Flags & LIBF_DELEXP))
+        return expunge(dev);
+
+    return 0;
+}
+
+static ULONG device_vectors[] =
+{
+    (ULONG)open,
+    (ULONG)close,
+    (ULONG)expunge,
+    0,
+    (ULONG)begin_io,
+    (ULONG)abort_io,
+    -1,
+};
+
+ULONG auto_init_tables[] =
+{
+    sizeof(struct DiskDevice),
+    (ULONG)device_vectors,
+    0,
+    (ULONG)init_device,
+};
diff --git a/src/a314/software-amiga/disk_pistorm/romtag.asm b/src/a314/software-amiga/disk_pistorm/romtag.asm
new file mode 100644
index 00000000..fc55164b
--- /dev/null
+++ b/src/a314/software-amiga/disk_pistorm/romtag.asm
@@ -0,0 +1,34 @@
+    XDEF    _debug_process_seglist
+    XREF    _debug_process_run
+
+RTC_MATCHWORD:  equ    $4afc
+RTF_AUTOINIT:   equ    (1<<7)
+RTF_COLDSTART:  equ    (1<<0)
+NT_DEVICE:      equ    3
+VERSION:        equ    1
+PRIORITY:       equ    -5
+
+        section    code,code
+
+        moveq    #-1,d0
+        rts
+
+romtag:
+        dc.w    RTC_MATCHWORD
+        dc.l    romtag
+        dc.l    endcode
+        dc.b    RTF_AUTOINIT | RTF_COLDSTART
+        dc.b    VERSION
+        dc.b    NT_DEVICE
+        dc.b    PRIORITY
+        dc.l    _device_name
+        dc.l    _id_string
+        dc.l    _auto_init_tables
+endcode:
+
+        cnop    0,4
+
+        dc.l    16
+_debug_process_seglist:
+        dc.l    0
+        jmp     _debug_process_run
diff --git a/src/a314/software-amiga/libremote_pistorm/build-library.sh b/src/a314/software-amiga/libremote_pistorm/build-library.sh
new file mode 100755
index 00000000..955ed28f
--- /dev/null
+++ b/src/a314/software-amiga/libremote_pistorm/build-library.sh
@@ -0,0 +1,4 @@
+set -e
+set -x
+python gen_stubs.py $1
+vc +aos68k -I${NDK32}/Include_H romtag.asm library.c -nostdlib -O2 -o $1.library
diff --git a/src/a314/software-amiga/libremote_pistorm/build.sh b/src/a314/software-amiga/libremote_pistorm/build.sh
new file mode 100755
index 00000000..812ffb3c
--- /dev/null
+++ b/src/a314/software-amiga/libremote_pistorm/build.sh
@@ -0,0 +1,9 @@
+#!/usr/bin/env sh
+set -e
+
+PATH=/opt/amiga/bin:$PATH
+
+python3 gen_stubs.py libdecl-bsdsocket.json
+vasmm68k_mot -Fhunk -quiet romtag.asm -o romtag.o
+m68k-amigaos-gcc -m68000 -O2 -c library.c -o library.o
+m68k-amigaos-gcc -m68000 -nostartfiles -o ../bsdsocket.library romtag.o library.o -lamiga
diff --git a/src/a314/software-amiga/libremote_pistorm/gen_proto.py b/src/a314/software-amiga/libremote_pistorm/gen_proto.py
new file mode 100644
index 00000000..7bb21689
--- /dev/null
+++ b/src/a314/software-amiga/libremote_pistorm/gen_proto.py
@@ -0,0 +1,51 @@
+import json
+import sys
+
+in_file = f'libdecl-{sys.argv[1]}.json'
+out_file = f'proto_{sys.argv[1]}.h'
+
+with open(in_file, 'rt') as f:
+    libdecl = json.load(f)
+
+funcs = libdecl['funcs']
+
+library_name = libdecl['library-name'].replace('.library', '').lower()
+guard = f'__PROTO_{library_name.upper()}_H'
+
+contents = f'#ifndef {guard}\n'
+contents += f'#define {guard}\n\n'
+contents += '#include <exec/types.h>\n\n'
+
+contents += f'#define {library_name.upper()}_LIB_NAME "{libdecl["library-name"]}"\n\n'
+
+base = libdecl['library-base']
+
+contents += f'extern struct Library *{base};\n\n'
+
+def gen_reg_anon(reg):
+    if reg[0] == 'd':
+        return f'__reg("{reg}") ULONG'
+    else:
+        return f'__reg("{reg}") void *'
+
+for i, func in enumerate(funcs):
+    name = func['name']
+    rtype = func['return-type']
+    args = func['args']
+    offset = -(i + 5) * 6
+
+    if len(args):
+        reglist = ', ' + ', '.join(gen_reg_anon(reg) for reg, _, _ in args)
+    else:
+        reglist = ''
+
+    paramlist1 = ', '.join(name for _, name, _ in args)
+    paramlist2 = f'{base}, {paramlist1}' if paramlist1 else base
+
+    contents += f'{rtype} __{name}(__reg("a6") void *{reglist})="\\tjsr\\t{offset}(a6)";\n'
+    contents += f'#define {name}({paramlist1}) __{name}({paramlist2})\n\n'
+
+contents += f'#endif /* {guard} */\n'
+
+with open(out_file, 'wt') as f:
+    f.write(contents)
diff --git a/src/a314/software-amiga/libremote_pistorm/gen_stubs.py b/src/a314/software-amiga/libremote_pistorm/gen_stubs.py
new file mode 100644
index 00000000..6bf4cdaf
--- /dev/null
+++ b/src/a314/software-amiga/libremote_pistorm/gen_stubs.py
@@ -0,0 +1,73 @@
+import json
+import sys
+
+in_file = f'libdecl-{sys.argv[1]}.json'
+
+with open(in_file, 'rt') as f:
+    libdecl = json.load(f)
+
+funcs = libdecl['funcs']
+
+contents = '#include "messages.h"\n\n'
+
+contents += f'#define LIBRARY_NAME "{libdecl["library-name"]}"\n'
+contents += f'#define SERVICE_NAME "{libdecl["service-name"]}"\n\n'
+
+contents += '''struct LibRemote;
+static ULONG null_func();
+static BPTR expunge();
+static BPTR close(__reg("a6") struct LibRemote *lib);
+static ULONG send_request(__reg("a6") struct LibRemote *lib, UBYTE *write_buf, ULONG write_length);
+
+'''
+
+contents += f'#define LVO_COUNT {len(funcs) + 4}\n\n'
+
+def gen_param(reg):
+    if reg[0] == 'd':
+        return f'__reg("{reg}") ULONG {reg}'
+    else:
+        return f'__reg("{reg}") void *{reg}'
+
+for i, func in enumerate(funcs):
+    args = func.get('args', [])
+    contents += f'static ULONG func_{i}(__reg("a6") struct LibRemote *lib'
+    if len(args):
+        contents += ', ' + ', '.join(gen_param(reg) for reg, _, _ in args)
+    contents += ')\n{\n'
+    contents += f'    UBYTE write_buf[256];\n'
+    for j, (reg, _, _) in enumerate(args):
+        contents += f'    *(ULONG *)&write_buf[{2 + j*4}] = (ULONG){reg};\n'
+    contents += '    write_buf[0] = MSG_OP_REQ;\n'
+    contents += f'    write_buf[1] = {i};\n'
+    contents += f'    return send_request(lib, write_buf, {2 + len(args)*4});\n'
+    contents += '}\n\n'
+
+contents += '''static ULONG funcs_vector[] =
+{
+    (ULONG)null_func,
+    (ULONG)close,
+    (ULONG)expunge,
+    (ULONG)null_func,
+'''
+
+for i, _ in enumerate(funcs):
+    contents += f'    (ULONG)func_{i},\n'
+
+contents += '''};
+
+'''
+
+contents += '''static void fill_lvos(__reg("a6") struct LibRemote *lib)
+{
+    for (int i = 0; i < LVO_COUNT; i++)
+    {
+        UBYTE *lvo = (UBYTE *)lib - ((i + 1) * 6);
+        *(UWORD *)lvo = 0x4ef9;
+        *(ULONG *)&lvo[2] = funcs_vector[i];
+    }
+}
+'''
+
+with open('stubs.h', 'wt') as f:
+    f.write(contents)
diff --git a/src/a314/software-amiga/libremote_pistorm/libdecl-bsdsocket.json b/src/a314/software-amiga/libremote_pistorm/libdecl-bsdsocket.json
new file mode 100644
index 00000000..d480bfae
--- /dev/null
+++ b/src/a314/software-amiga/libremote_pistorm/libdecl-bsdsocket.json
@@ -0,0 +1,393 @@
+{
+    "library-name": "bsdsocket.library",
+    "service-name": "bsl",
+    "library-base": "SocketBase",
+    "funcs": [
+        {
+            "name": "socket",
+            "return-type": "LONG",
+            "args": [
+                ["d0", "domain", "LONG"],
+                ["d1", "type", "LONG"],
+                ["d2", "protocol", "LONG"]
+            ]
+        },
+        {
+            "name": "bind",
+            "return-type": "LONG",
+            "args": [
+                ["d0", "sock", "LONG"],
+                ["a0", "name", "struct sockaddr *"],
+                ["d1", "namelen", "socklen_t"]
+            ]
+        },
+        {
+            "name": "listen",
+            "return-type": "LONG",
+            "args": [
+                ["d0", "sock", "LONG"],
+                ["d1", "backlog", "LONG"]
+            ]
+        },
+        {
+            "name": "accept",
+            "return-type": "LONG",
+            "args": [
+                ["d0", "sock", "LONG"],
+                ["a0", "addr", "struct sockaddr *"],
+                ["a1", "addrlen", "socklen_t *"]
+            ]
+        },
+        {
+            "name": "connect",
+            "return-type": "LONG",
+            "args": [
+                ["d0", "sock", "LONG"],
+                ["a0", "name", "struct sockaddr *"],
+                ["d1", "namelen", "socklen_t"]
+            ]
+        },
+        {
+            "name": "sendto",
+            "return-type": "LONG",
+            "args": [
+                ["d0", "sock", "LONG"],
+                ["a0", "buf", "APTR"],
+                ["d1", "len", "LONG"],
+                ["d2", "flags", "LONG"],
+                ["a1", "to", "struct sockaddr *"],
+                ["d3", "tolen", "socklen_t"]
+            ]
+        },
+        {
+            "name": "send",
+            "return-type": "LONG",
+            "args": [
+                ["d0", "sock", "LONG"],
+                ["a0", "buf", "APTR"],
+                ["d1", "len", "LONG"],
+                ["d2", "flags", "LONG"]
+            ]
+        },
+        {
+            "name": "recvfrom",
+            "return-type": "LONG",
+            "args": [
+                ["d0", "sock", "LONG"],
+                ["a0", "buf", "APTR"],
+                ["d1", "len", "LONG"],
+                ["d2", "flags", "LONG"],
+                ["a1", "addr", "struct sockaddr *"],
+                ["a2", "addrlen", "socklen_t *"]
+            ]
+        },
+        {
+            "name": "recv",
+            "return-type": "LONG",
+            "args": [
+                ["d0", "sock", "LONG"],
+                ["a0", "buf", "APTR"],
+                ["d1", "len", "LONG"],
+                ["d2", "flags", "LONG"]
+            ]
+        },
+        {
+            "name": "shutdown",
+            "return-type": "LONG",
+            "args": [
+                ["d0", "sock", "LONG"],
+                ["d1", "how", "LONG"]
+            ]
+        },
+        {
+            "name": "setsockopt",
+            "return-type": "LONG",
+            "args": [
+                ["d0", "sock", "LONG"],
+                ["d1", "level", "LONG"],
+                ["d2", "optname", "LONG"],
+                ["a0", "optval", "APTR"],
+                ["d3", "optlen", "socklen_t"]
+            ]
+        },
+        {
+            "name": "getsockopt",
+            "return-type": "LONG",
+            "args": [
+                ["d0", "sock", "LONG"],
+                ["d1", "level", "LONG"],
+                ["d2", "optname", "LONG"],
+                ["a0", "optval", "APTR"],
+                ["a1", "optlen", "socklen_t *"]
+            ]
+        },
+        {
+            "name": "getsockname",
+            "return-type": "LONG",
+            "args": [
+                ["d0", "sock", "LONG"],
+                ["a0", "name", "struct sockaddr *"],
+                ["a1", "namelen", "socklen_t *"]
+            ]
+        },
+        {
+            "name": "getpeername",
+            "return-type": "LONG",
+            "args": [
+                ["d0", "sock", "LONG"],
+                ["a0", "name", "struct sockaddr *"],
+                ["a1", "namelen", "socklen_t *"]
+            ]
+        },
+        {
+            "name": "IoctlSocket",
+            "return-type": "LONG",
+            "args": [
+                ["d0", "sock", "LONG"],
+                ["d1", "req", "ULONG"],
+                ["a0", "argp", "APTR"]
+            ]
+        },
+        {
+            "name": "CloseSocket",
+            "return-type": "LONG",
+            "args": [
+                ["d0", "sock", "LONG"]
+            ]
+        },
+        {
+            "name": "WaitSelect",
+            "return-type": "LONG",
+            "args": [
+                ["d0", "nfds", "LONG"],
+                ["a0", "read_fds", "APTR"],
+                ["a1", "write_fds", "APTR"],
+                ["a2", "except_fds", "APTR"],
+                ["a3", "_timeout", "struct timeval *"],
+                ["d1", "signals", "ULONG *"]
+            ]
+        },
+        {
+            "name": "SetSocketSignals",
+            "return-type": "VOID",
+            "args": [
+                ["d0", "int_mask", "ULONG"],
+                ["d1", "io_mask", "ULONG"],
+                ["d2", "urgent_mask", "ULONG"]
+            ]
+        },
+        {
+            "name": "getdtablesize",
+            "return-type": "LONG",
+            "args": [
+            ]
+        },
+        {
+            "name": "ObtainSocket",
+            "return-type": "LONG",
+            "args": [
+                ["d0", "id", "LONG"],
+                ["d1", "domain", "LONG"],
+                ["d2", "type", "LONG"],
+                ["d3", "protocol", "LONG"]
+            ]
+        },
+        {
+            "name": "ReleaseSocket",
+            "return-type": "LONG",
+            "args": [
+                ["d0", "sock", "LONG"],
+                ["d1", "id", "LONG"]
+            ]
+        },
+        {
+            "name": "ReleaseCopyOfSocket",
+            "return-type": "LONG",
+            "args": [
+                ["d0", "sock", "LONG"],
+                ["d1", "id", "LONG"]
+            ]
+        },
+        {
+            "name": "Errno",
+            "return-type": "LONG",
+            "args": [
+            ]
+        },
+        {
+            "name": "SetErrnoPtr",
+            "return-type": "VOID",
+            "args": [
+                ["a0", "errno_ptr", "APTR"],
+                ["d0", "size", "LONG"]
+            ]
+        },
+        {
+            "name": "Inet_NtoA",
+            "return-type": "STRPTR",
+            "args": [
+                ["d0", "ip", "in_addr_t"]
+            ]
+        },
+        {
+            "name": "inet_addr",
+            "return-type": "in_addr_t",
+            "args": [
+                ["a0", "cp", "STRPTR"]
+            ]
+        },
+        {
+            "name": "Inet_LnaOf",
+            "return-type": "in_addr_t",
+            "args": [
+                ["d0", "in", "in_addr_t"]
+            ]
+        },
+        {
+            "name": "Inet_NetOf",
+            "return-type": "in_addr_t",
+            "args": [
+                ["d0", "in", "in_addr_t"]
+            ]
+        },
+        {
+            "name": "Inet_MakeAddr",
+            "return-type": "in_addr_t",
+            "args": [
+                ["d0", "net", "in_addr_t"],
+                ["d1", "host", "in_addr_t"]
+            ]
+        },
+        {
+            "name": "inet_network",
+            "return-type": "in_addr_t",
+            "args": [
+                ["a0", "cp", "STRPTR"]
+            ]
+        },
+        {
+            "name": "gethostbyname",
+            "return-type": "struct hostent *",
+            "args": [
+                ["a0", "name", "STRPTR"]
+            ]
+        },
+        {
+            "name": "gethostbyaddr",
+            "return-type": "struct hostent *",
+            "args": [
+                ["a0", "addr", "STRPTR"],
+                ["d0", "len", "LONG"],
+                ["d1", "type", "LONG"]
+            ]
+        },
+        {
+            "name": "getnetbyname",
+            "return-type": "struct netent *",
+            "args": [
+                ["a0", "name", "STRPTR"]
+            ]
+        },
+        {
+            "name": "getnetbyaddr",
+            "return-type": "struct netent *",
+            "args": [
+                ["d0", "net", "in_addr_t"],
+                ["d1", "type", "LONG"]
+            ]
+        },
+        {
+            "name": "getservbyname",
+            "return-type": "struct servent *",
+            "args": [
+                ["a0", "name", "STRPTR"],
+                ["a1", "proto", "STRPTR"]
+            ]
+        },
+        {
+            "name": "getservbyport",
+            "return-type": "struct servent *",
+            "args": [
+                ["d0", "port", "LONG"],
+                ["a0", "proto", "STRPTR"]
+            ]
+        },
+        {
+            "name": "getprotobyname",
+            "return-type": "struct protoent *",
+            "args": [
+                ["a0", "name", "STRPTR"]
+            ]
+        },
+        {
+            "name": "getprotobynumber",
+            "return-type": "struct protoent *",
+            "args": [
+                ["d0", "proto", "LONG"]
+            ]
+        },
+        {
+            "name": "vsyslog",
+            "return-type": "VOID",
+            "args": [
+                ["d0", "pri", "LONG"],
+                ["a0", "msg", "STRPTR"],
+                ["a1", "args", "APTR"]
+            ]
+        },
+        {
+            "name": "Dup2Socket",
+            "return-type": "LONG",
+            "args": [
+                ["d0", "old_socket", "LONG"],
+                ["d1", "new_socket", "LONG"]
+            ]
+        },
+        {
+            "name": "sendmsg",
+            "return-type": "LONG",
+            "args": [
+                ["d0", "sock", "LONG"],
+                ["a0", "msg", "struct msghdr *"],
+                ["d1", "flags", "LONG"]
+            ]
+        },
+        {
+            "name": "recvmsg",
+            "return-type": "LONG",
+            "args": [
+                ["d0", "sock", "LONG"],
+                ["a0", "msg", "struct msghdr *"],
+                ["d1", "flags", "LONG"]
+            ]
+        },
+        {
+            "name": "gethostname",
+            "return-type": "LONG",
+            "args": [
+                ["a0", "name", "STRPTR"],
+                ["d0", "namelen", "LONG"]
+            ]
+        },
+        {
+            "name": "gethostid",
+            "return-type": "in_addr_t",
+            "args": [
+            ]
+        },
+        {
+            "name": "SocketBaseTagList",
+            "return-type": "LONG",
+            "args": [
+                ["a0", "tags", "struct TagItem *"]
+            ]
+        },
+        {
+            "name": "GetSocketEvents",
+            "return-type": "LONG",
+            "args": [
+                ["a0", "event_ptr", "ULONG *"]
+            ]
+        }
+    ]
+}
\ No newline at end of file
diff --git a/src/a314/software-amiga/libremote_pistorm/library.c b/src/a314/software-amiga/libremote_pistorm/library.c
new file mode 100644
index 00000000..2d301df6
--- /dev/null
+++ b/src/a314/software-amiga/libremote_pistorm/library.c
@@ -0,0 +1,505 @@
+#include <stdint.h>
+#include <string.h>
+
+#include <exec/types.h>
+#include <exec/ports.h>
+#include <exec/libraries.h>
+#include <exec/semaphores.h>
+#include <dos/dos.h>
+#include <utility/tagitem.h>
+
+#include <proto/exec.h>
+#include <proto/dos.h>
+
+#include "../a314device/a314.h"
+#include "../a314device/proto_a314.h"
+
+#include "messages.h"
+#include "stubs.h"
+
+#define SysBase             (*(struct ExecBase **)4)
+
+#define LIB_NEG_SIZE        (LVO_COUNT*6)
+
+#define BOUNCE_BUFFER_SIZE  (16*1024)
+
+// Must keep VERSION in romtag.asm in sync.
+#define LIB_VERSION     3
+#define LIB_REVISION    0
+#define LIB_DATE        "28.5.2024"
+
+#define VSTR(s) STR(s)
+#define STR(s) #s
+
+const char library_name[] = LIBRARY_NAME;
+const char id_string[] = LIBRARY_NAME " " VSTR(LIB_VERSION) "." VSTR(LIB_REVISION) " (" LIB_DATE ")\n\r";
+const char service_name[] = SERVICE_NAME;
+
+static BPTR saved_seg_list;
+static struct Library *global_lib;
+struct Library *A314Base;
+
+struct MemChunkHdr
+{
+    struct MemChunkHdr *next;
+    uint32_t size;
+};
+
+struct LibRemote
+{
+    struct Library lib;
+    struct MsgPort mp;
+    struct A314_IORequest write_req;
+    struct A314_IORequest read_req;
+    uint32_t bounce_buffer_address;
+    struct MemChunkHdr *chunks;
+    uint8_t read_buf[256];
+};
+
+static uint32_t alloc_a314_buffer(uint32_t length)
+{
+    APTR buf = AllocMem(length, MEMF_PUBLIC | MEMF_CLEAR);
+    return (uint32_t)buf;
+}
+
+static void free_a314_buffer(uint32_t address, uint32_t length)
+{
+    if (address)
+        FreeMem((APTR)address, length);
+}
+
+static uint32_t null_func()
+{
+    return 0;
+}
+
+static BPTR expunge()
+{
+    if (global_lib->lib_OpenCnt != 0)
+    {
+        global_lib->lib_Flags |= LIBF_DELEXP;
+        return 0;
+    }
+
+    Remove(&global_lib->lib_Node);
+    FreeMem((char *)global_lib - global_lib->lib_NegSize, global_lib->lib_NegSize + global_lib->lib_PosSize);
+    global_lib = NULL;
+
+    BPTR seg_list = saved_seg_list;
+    saved_seg_list = 0;
+    return seg_list;
+}
+
+static BPTR close(__reg("a6") struct LibRemote *lib)
+{
+    struct MemChunkHdr *chunk = lib->chunks;
+    while (chunk)
+    {
+        struct MemChunkHdr *next = chunk->next;
+        FreeMem(chunk, chunk->size);
+        chunk = next;
+    }
+
+    // Reset connection.
+    lib->write_req.a314_Buffer = NULL;
+    lib->write_req.a314_Length = 0;
+    lib->write_req.a314_Request.io_Command = A314_RESET;
+    DoIO(&lib->write_req.a314_Request);
+
+    free_a314_buffer(lib->bounce_buffer_address, BOUNCE_BUFFER_SIZE);
+
+    CloseDevice(&lib->write_req.a314_Request);
+
+    FreeMem((char *)lib - lib->lib.lib_NegSize, lib->lib.lib_NegSize + lib->lib.lib_PosSize);
+
+    global_lib->lib_OpenCnt--;
+
+    if (global_lib->lib_OpenCnt == 0 && (global_lib->lib_Flags & LIBF_DELEXP) != 0)
+        return expunge();
+    else
+        return 0;
+}
+
+static uint32_t alloc_chunk(__reg("a6") struct LibRemote *lib, uint32_t length)
+{
+    struct MemChunkHdr *chunk = AllocMem(length + 8, MEMF_ANY);
+
+    if (!chunk)
+        return 0;
+
+    chunk->next = lib->chunks;
+    chunk->size = length + 8;
+    lib->chunks = chunk;
+    return (uint32_t)chunk + 8;
+}
+
+static void free_chunk(__reg("a6") struct LibRemote *lib, uint32_t address)
+{
+    struct MemChunkHdr *chunk = (void *)(address - 8);
+
+    if (lib->chunks == chunk)
+        lib->chunks = chunk->next;
+    else
+    {
+        struct MemChunkHdr *prev_chunk = lib->chunks;
+
+        while (prev_chunk)
+        {
+            if (prev_chunk->next == chunk)
+            {
+                prev_chunk->next = chunk->next;
+                break;
+            }
+            prev_chunk = prev_chunk->next;
+        }
+    }
+
+    FreeMem(chunk, chunk->size);
+}
+
+static int get_tag_list_length(struct TagItem *tag_list)
+{
+    int count = 1;
+    while (tag_list->ti_Tag != TAG_DONE && tag_list->ti_Tag != TAG_MORE)
+    {
+        tag_list++;
+        count++;
+    }
+    return count * sizeof(struct TagItem);
+}
+
+static uint32_t send_request(__reg("a6") struct LibRemote *lib, uint8_t *write_buf, uint32_t write_length)
+{
+    uint8_t *read_buf = lib->read_buf;
+
+    lib->read_req.a314_Buffer = read_buf;
+    lib->read_req.a314_Length = sizeof(lib->read_buf);
+    lib->read_req.a314_Request.io_Command = A314_READ;
+    SendIO(&lib->read_req.a314_Request);
+
+    lib->write_req.a314_Buffer = write_buf;
+    lib->write_req.a314_Length = write_length;
+    lib->write_req.a314_Request.io_Command = A314_WRITE;
+    SendIO(&lib->write_req.a314_Request);
+
+    BOOL pending_read = TRUE;
+    BOOL pending_write = TRUE;
+
+    uint32_t signals_received = 0;
+    uint32_t signals_to_send = 0;
+
+    while (TRUE)
+    {
+        uint32_t new_signals = Wait(-1);
+
+        signals_received |= new_signals & ~SIGF_SINGLE;
+        signals_to_send |= new_signals & ~SIGF_SINGLE;
+
+        if (new_signals & SIGF_SINGLE)
+        {
+            struct A314_IORequest *req;
+            while (req = (struct A314_IORequest *)GetMsg(&lib->mp))
+            {
+                if (req == &lib->write_req)
+                    pending_write = FALSE;
+                else // if (req == &lib->read_req)
+                    pending_read = FALSE;
+            }
+        }
+
+        if (!pending_write && !pending_read)
+        {
+            uint8_t kind = read_buf[0];
+
+            if (kind == MSG_OP_RES)
+                break;
+
+            if (kind == MSG_ALLOC_MEM_REQ)
+            {
+                struct AllocMemReqMsg *req = (struct AllocMemReqMsg *)read_buf;
+                uint32_t addr = alloc_chunk(lib, req->length);
+
+                write_buf[0] = MSG_ALLOC_MEM_RES;
+                *(uint32_t *)&write_buf[2] = addr;
+                write_length = 6;
+            }
+            else if (kind == MSG_FREE_MEM_REQ)
+            {
+                struct FreeMemReqMsg *req = (struct FreeMemReqMsg *)read_buf;
+                free_chunk(lib, req->address);
+
+                write_buf[0] = MSG_FREE_MEM_RES;
+                write_length = 1;
+            }
+            else if (kind == MSG_READ_MEM_REQ)
+            {
+                uint8_t *read_mem_desc = &read_buf[2];
+
+                write_buf[0] = MSG_READ_MEM_RES;
+                write_length = 2;
+                uint8_t *write_to = &write_buf[2];
+
+                while (read_mem_desc - read_buf < lib->read_req.a314_Length)
+                {
+                    uint32_t src = *(uint32_t *)read_mem_desc;
+                    read_mem_desc += 4;
+
+                    uint8_t len = *read_mem_desc++;
+                    read_mem_desc++;
+
+                    memcpy(write_to, (void *)src, len);
+
+                    write_to += len;
+                    write_length += len;
+                }
+            }
+            else if (kind == MSG_WRITE_MEM_REQ)
+            {
+                uint8_t *write_mem_desc = &read_buf[2];
+
+                while (write_mem_desc - read_buf < lib->read_req.a314_Length)
+                {
+                    uint32_t dst = *(uint32_t *)write_mem_desc;
+                    write_mem_desc += 4;
+
+                    uint8_t len = *write_mem_desc++;
+                    if ((len & 1) == 0)
+                        write_mem_desc++;
+
+                    memcpy((void *)dst, write_mem_desc, len);
+
+                    write_mem_desc += len;
+                }
+
+                write_buf[0] = MSG_WRITE_MEM_RES;
+                write_length = 1;
+            }
+            else if (kind == MSG_COPY_FROM_BOUNCE_REQ)
+            {
+                struct CopyFromBounceReqMsg *req = (struct CopyFromBounceReqMsg *)read_buf;
+                struct CopyDesc *cd = (struct CopyDesc *)&req[1];
+
+                for (int i = 0; i < req->copy_count; i++)
+                {
+                    ReadMemA314((void *)cd->dst, cd->src, cd->len);
+                    cd++;
+                }
+
+                write_buf[0] = MSG_COPY_FROM_BOUNCE_RES;
+                write_length = 1;
+            }
+            else if (kind == MSG_COPY_TO_BOUNCE_REQ)
+            {
+                struct CopyToBounceReqMsg *req = (struct CopyToBounceReqMsg *)read_buf;
+                struct CopyDesc *cd = (struct CopyDesc *)&req[1];
+
+                for (int i = 0; i < req->copy_count; i++)
+                {
+                    WriteMemA314(cd->dst, (void *)cd->src, cd->len);
+                    cd++;
+                }
+
+                write_buf[0] = MSG_COPY_TO_BOUNCE_RES;
+                write_length = 1;
+            }
+            else if (kind == MSG_COPY_STR_TO_BOUNCE_REQ)
+            {
+                struct CopyStrToBounceReqMsg *req = (struct CopyStrToBounceReqMsg *)read_buf;
+                uint32_t len = strlen((void *)req->str_address);
+
+                WriteMemA314(req->bounce_address, (void *)req->str_address, len);
+
+                write_buf[0] = MSG_COPY_STR_TO_BOUNCE_RES;
+                *(uint32_t *)&write_buf[2] = len;
+                write_length = 6;
+            }
+            else if (kind == MSG_COPY_TAG_LIST_TO_BOUNCE_REQ)
+            {
+                struct CopyTagListToBounceReqMsg *req = (struct CopyTagListToBounceReqMsg *)read_buf;
+                uint32_t len = get_tag_list_length((void *)req->tag_list_address);
+
+                WriteMemA314(req->bounce_address, (void *)req->tag_list_address, len);
+
+                write_buf[0] = MSG_COPY_TAG_LIST_TO_BOUNCE_RES;
+                *(uint32_t *)&write_buf[2] = len;
+                write_length = 6;
+            }
+            else
+            {
+                // TODO: Should handle this severe error in some other way.
+                // This means that received an unknown message.
+                write_buf[0] = kind + 1;
+                write_length = 1;
+            }
+
+            lib->read_req.a314_Buffer = read_buf;
+            lib->read_req.a314_Length = sizeof(lib->read_buf);
+            lib->read_req.a314_Request.io_Command = A314_READ;
+            SendIO(&lib->read_req.a314_Request);
+
+            lib->write_req.a314_Buffer = write_buf;
+            lib->write_req.a314_Length = write_length;
+            lib->write_req.a314_Request.io_Command = A314_WRITE;
+            SendIO(&lib->write_req.a314_Request);
+
+            pending_read = TRUE;
+            pending_write = TRUE;
+        }
+
+        if (!pending_write && signals_to_send)
+        {
+            write_buf[0] = MSG_SIGNALS;
+            *(uint32_t *)&write_buf[2] = signals_to_send;
+            write_length = 6;
+
+            signals_to_send = 0;
+
+            lib->write_req.a314_Buffer = write_buf;
+            lib->write_req.a314_Length = write_length;
+            lib->write_req.a314_Request.io_Command = A314_WRITE;
+            SendIO(&lib->write_req.a314_Request);
+
+            pending_write = TRUE;
+        }
+    }
+
+    struct OpResMsg *op_msg = (struct OpResMsg *)read_buf;
+    struct CopyDesc *cd = (struct CopyDesc *)&op_msg[1];
+
+    for (int i = 0; i < op_msg->copy_count; i++)
+    {
+        ReadMemA314((void *)cd->dst, cd->src, cd->len);
+        cd++;
+    }
+
+    uint8_t *write_mem_desc = (uint8_t *)cd;
+
+    while (write_mem_desc - read_buf < lib->read_req.a314_Length)
+    {
+        uint32_t dst = *(uint32_t *)write_mem_desc;
+        write_mem_desc += 4;
+
+        uint8_t len = *write_mem_desc++;
+        if ((len & 1) == 0)
+            write_mem_desc++;
+
+        memcpy((void *)dst, write_mem_desc, len);
+
+        write_mem_desc += len;
+    }
+
+    Signal(FindTask(NULL), signals_received & ~(op_msg->signals_consumed));
+
+    return op_msg->result;
+}
+
+static struct Library *open(__reg("a6") struct Library *glib, __reg("d0") uint32_t version)
+{
+    global_lib->lib_OpenCnt++;
+
+    BYTE *p = AllocMem(sizeof(struct LibRemote) + LIB_NEG_SIZE, MEMF_ANY | MEMF_CLEAR);
+    if (!p)
+        goto err_out0;
+
+    // Initialize library struct.
+    struct LibRemote *lib = (struct LibRemote *)(p + LIB_NEG_SIZE);
+    lib->lib.lib_Node.ln_Type = NT_LIBRARY;
+    lib->lib.lib_Node.ln_Name = (char *)library_name;
+    lib->lib.lib_NegSize = LIB_NEG_SIZE;
+    lib->lib.lib_PosSize = sizeof(struct LibRemote);
+    lib->lib.lib_Version = LIB_VERSION;
+    lib->lib.lib_Revision = LIB_REVISION;
+    lib->lib.lib_IdString = id_string;
+    lib->lib.lib_OpenCnt = 1;
+
+    fill_lvos(lib);
+
+    // Create message port.
+    lib->mp.mp_Node.ln_Type = NT_MSGPORT;
+    lib->mp.mp_Node.ln_Name = (void *)library_name;
+    lib->mp.mp_Flags = PA_SIGNAL;
+    lib->mp.mp_SigTask = FindTask(NULL);
+    lib->mp.mp_SigBit = SIGB_SINGLE;
+
+    // Open a314.device.
+    lib->write_req.a314_Request.io_Message.mn_Length = sizeof(struct A314_IORequest);
+    lib->write_req.a314_Request.io_Message.mn_ReplyPort = &lib->mp;
+    if (OpenDevice(A314_NAME, 0, &lib->write_req.a314_Request, 0))
+        goto err_out1;
+
+    // Get unique socket identifier.
+    struct DosLibrary *DOSBase = (struct DosLibrary *)OpenLibrary(DOSNAME, 0);
+    struct DateStamp ds;
+    DateStamp(&ds);
+    lib->write_req.a314_Socket = (ds.ds_Minute * 60 * TICKS_PER_SECOND) + ds.ds_Tick;
+    CloseLibrary((struct Library *)DOSBase);
+
+    memcpy(&lib->read_req, &lib->write_req, sizeof(struct A314_IORequest));
+
+    // Allocate bounce buffer.
+    A314Base = (struct Library *)lib->read_req.a314_Request.io_Device;
+
+    lib->bounce_buffer_address = alloc_a314_buffer(BOUNCE_BUFFER_SIZE);
+    if (!lib->bounce_buffer_address)
+        goto err_out2;
+
+    // Connect to service.
+    lib->write_req.a314_Buffer = (char *)service_name;
+    lib->write_req.a314_Length = sizeof(service_name) - 1;
+    lib->write_req.a314_Request.io_Command = A314_CONNECT;
+
+    if (DoIO(&lib->write_req.a314_Request) != A314_CONNECT_OK)
+        goto err_out3;
+
+    // Send open message.
+    uint32_t open_msg[2] = {lib->bounce_buffer_address, BOUNCE_BUFFER_SIZE};
+
+    lib->write_req.a314_Buffer = (void *)&open_msg[0];
+    lib->write_req.a314_Length = sizeof(open_msg);
+    lib->write_req.a314_Request.io_Command = A314_WRITE;
+    DoIO(&lib->write_req.a314_Request);
+
+    global_lib->lib_Flags &= ~LIBF_DELEXP;
+    return &lib->lib;
+
+err_out3:
+    free_a314_buffer(lib->bounce_buffer_address, BOUNCE_BUFFER_SIZE);
+
+err_out2:
+    CloseDevice(&lib->write_req.a314_Request);
+
+err_out1:
+    FreeMem((char *)lib - lib->lib.lib_NegSize, lib->lib.lib_NegSize + lib->lib.lib_PosSize);
+
+err_out0:
+    global_lib->lib_OpenCnt--;
+    return NULL;
+}
+
+static uint32_t library_vectors[] =
+{
+    (uint32_t)open,
+    (uint32_t)null_func,
+    (uint32_t)expunge,
+    (uint32_t)null_func,
+    -1,
+};
+
+static struct Library *init_library(__reg("a6") struct ExecBase *sys_base, __reg("a0") BPTR seg_list, __reg("d0") struct Library *lib)
+{
+    saved_seg_list = seg_list;
+    global_lib = lib;
+
+    lib->lib_Version = LIB_VERSION;
+    lib->lib_Revision = LIB_REVISION;
+
+    return lib;
+}
+
+uint32_t auto_init_tables[] =
+{
+    sizeof(struct Library),
+    (uint32_t)library_vectors,
+    0,
+    (uint32_t)init_library,
+};
diff --git a/src/a314/software-amiga/libremote_pistorm/messages.h b/src/a314/software-amiga/libremote_pistorm/messages.h
new file mode 100644
index 00000000..4d8f5e50
--- /dev/null
+++ b/src/a314/software-amiga/libremote_pistorm/messages.h
@@ -0,0 +1,156 @@
+#ifndef __LIBREMOTE_MESSAGES_H
+#define __LIBREMOTE_MESSAGES_H
+
+#include <stdint.h>
+
+#define MSG_SIGNALS                 1
+#define MSG_OP_REQ                  2
+#define MSG_OP_RES                  3
+#define MSG_ALLOC_MEM_REQ           4
+#define MSG_ALLOC_MEM_RES           5
+#define MSG_FREE_MEM_REQ            6
+#define MSG_FREE_MEM_RES            7
+#define MSG_READ_MEM_REQ            8
+#define MSG_READ_MEM_RES            9
+#define MSG_WRITE_MEM_REQ           10
+#define MSG_WRITE_MEM_RES           11
+#define MSG_COPY_FROM_BOUNCE_REQ    12
+#define MSG_COPY_FROM_BOUNCE_RES    13
+#define MSG_COPY_TO_BOUNCE_REQ      14
+#define MSG_COPY_TO_BOUNCE_RES      15
+#define MSG_COPY_STR_TO_BOUNCE_REQ  16
+#define MSG_COPY_STR_TO_BOUNCE_RES  17
+#define MSG_COPY_TAG_LIST_TO_BOUNCE_REQ 18
+#define MSG_COPY_TAG_LIST_TO_BOUNCE_RES 19
+
+struct CopyDesc
+{
+    uint32_t dst;
+    uint32_t src;
+    uint32_t len;
+};
+
+struct SignalsMsg // Amiga -> Pi
+{
+    uint8_t kind;
+    uint8_t pad;
+    uint32_t signals;
+};
+
+struct OpReqMsg // Amiga -> Pi
+{
+    uint8_t kind;
+    uint8_t op;
+};
+
+struct OpResMsg // Pi -> Amiga
+{
+    uint8_t kind;
+    uint8_t copy_count;
+    uint32_t result;
+    uint32_t signals_consumed;
+};
+
+struct AllocMemReqMsg // Pi -> Amiga
+{
+    uint8_t kind;
+    uint8_t pad;
+    uint32_t length;
+};
+
+struct AllocMemResMsg // Amiga -> Pi
+{
+    uint8_t kind;
+    uint8_t pad;
+    uint32_t address;
+};
+
+struct FreeMemReqMsg // Pi -> Amiga
+{
+    uint8_t kind;
+    uint8_t pad;
+    uint32_t address;
+};
+
+struct FreeMemResMsg // Amiga -> Pi
+{
+    uint8_t kind;
+};
+
+struct ReadMemReqMsg // Pi -> Amiga
+{
+    uint8_t kind;
+    uint8_t pad;
+};
+
+struct ReadMemResMsg // Amiga -> Pi
+{
+    uint8_t kind;
+    uint8_t pad;
+};
+
+struct WriteMemReqMsg // Pi -> Amiga
+{
+    uint8_t kind;
+    uint8_t pad;
+};
+
+struct WriteMemResMsg // Amiga -> Pi
+{
+    uint8_t kind;
+    uint8_t pad;
+};
+
+struct CopyFromBounceReqMsg // Pi -> Amiga
+{
+    uint8_t kind;
+    uint8_t copy_count;
+};
+
+struct CopyFromBounceResMsg // Amiga -> Pi
+{
+    uint8_t kind;
+};
+
+struct CopyToBounceReqMsg // Pi -> Amiga
+{
+    uint8_t kind;
+    uint8_t copy_count;
+};
+
+struct CopyToBounceResMsg // Amiga -> Pi
+{
+    uint8_t kind;
+};
+
+struct CopyStrToBounceReqMsg // Pi -> Amiga
+{
+    uint8_t kind;
+    uint8_t pad;
+    uint32_t bounce_address;
+    uint32_t str_address;
+};
+
+struct CopyStrToBounceResMsg // Amiga -> Pi
+{
+    uint8_t kind;
+    uint8_t pad;
+    uint32_t length;
+};
+
+struct CopyTagListToBounceReqMsg // Pi -> Amiga
+{
+    uint8_t kind;
+    uint8_t pad;
+    uint32_t bounce_address;
+    uint32_t tag_list_address;
+};
+
+struct CopyTagListToBounceResMsg // Amiga -> Pi
+{
+    uint8_t kind;
+    uint8_t pad;
+    uint32_t length;
+};
+
+#endif /* __LIBREMOTE_MESSAGES_H */
diff --git a/src/a314/software-amiga/libremote_pistorm/romtag.asm b/src/a314/software-amiga/libremote_pistorm/romtag.asm
new file mode 100644
index 00000000..8e8ec741
--- /dev/null
+++ b/src/a314/software-amiga/libremote_pistorm/romtag.asm
@@ -0,0 +1,27 @@
+    XREF    _library_name
+    XREF    _id_string
+    XREF    _auto_init_tables
+
+RTC_MATCHWORD:  equ     $4afc
+RTF_AUTOINIT:   equ     (1<<7)
+NT_LIBRARY:     equ     9
+VERSION:        equ     3
+PRIORITY:       equ     0
+
+    section CODE,CODE
+
+    moveq   #-1,d0
+    rts
+
+romtag:
+    dc.w    RTC_MATCHWORD
+    dc.l    romtag
+    dc.l    endcode
+    dc.b    RTF_AUTOINIT
+    dc.b    VERSION
+    dc.b    NT_LIBRARY
+    dc.b    PRIORITY
+    dc.l    _library_name
+    dc.l    _id_string
+    dc.l    _auto_init_tables
+endcode:
diff --git a/src/a314/software-amiga/remotewb_pistorm/build.sh b/src/a314/software-amiga/remotewb_pistorm/build.sh
new file mode 100755
index 00000000..d5de5a04
--- /dev/null
+++ b/src/a314/software-amiga/remotewb_pistorm/build.sh
@@ -0,0 +1,8 @@
+#!/usr/bin/env sh
+set -e
+
+PATH=/opt/amiga/bin:$PATH
+
+vasmm68k_mot -Fhunk -quiet vblank_server.asm -o vblank_server.o
+m68k-amigaos-gcc -m68000 -O2 -c remotewb.c -o remotewb.o
+m68k-amigaos-gcc -m68000 -nostartfiles -o ../remotewb remotewb.o vblank_server.o -lamiga
diff --git a/src/a314/software-amiga/remotewb_pistorm/remotewb.c b/src/a314/software-amiga/remotewb_pistorm/remotewb.c
new file mode 100644
index 00000000..e0103f5c
--- /dev/null
+++ b/src/a314/software-amiga/remotewb_pistorm/remotewb.c
@@ -0,0 +1,511 @@
+/*
+ * Copyright (c) 2018 Niklas Ekström
+ */
+
+#include <exec/types.h>
+#include <exec/ports.h>
+#include <exec/tasks.h>
+#include <exec/nodes.h>
+#include <exec/lists.h>
+#include <exec/execbase.h>
+#include <exec/memory.h>
+
+#include <devices/input.h>
+#include <devices/inputevent.h>
+#include <graphics/gfx.h>
+#include <graphics/gfxbase.h>
+#include <graphics/view.h>
+#include <intuition/intuition.h>
+#include <intuition/intuitionbase.h>
+#include <intuition/screens.h>
+#include <libraries/dos.h>
+
+#include <hardware/intbits.h>
+
+#include <proto/alib.h>
+#include <proto/exec.h>
+#include <proto/dos.h>
+#include <proto/intuition.h>
+#include <proto/graphics.h>
+
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+
+#include "../a314device/a314.h"
+#include "../a314device/proto_a314.h"
+
+struct IntuitionBase *IntuitionBase = NULL;
+struct GfxBase *GfxBase = NULL;
+
+struct Library *A314Base = NULL;
+
+struct MsgPort *mp;
+
+ULONG socket;
+
+struct A314_IORequest *cmsg;
+struct A314_IORequest *rmsg;
+UBYTE arbuf[256];
+struct A314_IORequest *wmsg;
+UBYTE awbuf[256];
+
+BOOL pending_a314_read = FALSE;
+BOOL pending_a314_write = FALSE;
+BOOL pending_a314_reset = FALSE;
+
+BOOL stream_closed = FALSE;
+
+struct MsgPort *id_mp;
+struct IOStdReq *id_req;
+struct InputEvent generated_event;
+
+struct VBlankData
+{
+	struct Task *task;
+	ULONG signal;
+};
+
+struct VBlankData vblank_data;
+extern void VBlankServer();
+struct Interrupt vblank_interrupt;
+
+void start_a314_cmd(struct A314_IORequest *msg, UWORD command, char *buffer, int length)
+{
+	msg->a314_Request.io_Command = command;
+	msg->a314_Request.io_Error = 0;
+
+	msg->a314_Socket = socket;
+	msg->a314_Buffer = buffer;
+	msg->a314_Length = length;
+
+	SendIO((struct IORequest *)msg);
+}
+
+LONG a314_connect(char *name)
+{
+	socket = time(NULL);
+	start_a314_cmd(cmsg, A314_CONNECT, name, strlen(name));
+	return WaitIO((struct IORequest *)cmsg);
+}
+
+void start_a314_read()
+{
+	start_a314_cmd(rmsg, A314_READ, arbuf, 255);
+	pending_a314_read = TRUE;
+}
+
+void start_a314_write(int length)
+{
+	start_a314_cmd(wmsg, A314_WRITE, awbuf, length);
+	pending_a314_write = TRUE;
+}
+
+LONG sync_a314_write(int length)
+{
+	start_a314_write(length);
+	pending_a314_write = FALSE;
+	return WaitIO((struct IORequest *)wmsg);
+}
+
+void start_a314_reset()
+{
+	start_a314_cmd(cmsg, A314_RESET, NULL, 0);
+	pending_a314_reset = TRUE;
+}
+
+LONG sync_a314_reset()
+{
+	start_a314_reset();
+	pending_a314_reset = FALSE;
+	return WaitIO((struct IORequest *)cmsg);
+}
+
+struct Screen *find_wb_screen()
+{
+	struct Screen *screen = IntuitionBase->FirstScreen;
+	while (screen)
+	{
+		if ((screen->Flags & SCREENTYPE) == WBENCHSCREEN)
+			return screen;
+		screen = screen->NextScreen;
+	}
+	return NULL;
+}
+
+int blen = 0;
+
+void append_ulong(ULONG x)
+{
+	*((ULONG *)&awbuf[blen]) = x;
+	blen += 4;
+}
+
+void append_uword(UWORD x)
+{
+	*((UWORD *)&awbuf[blen]) = x;
+	blen += 2;
+}
+
+WORD last_b = 0;
+WORD kbd_qual = 0;
+
+void send_generated_mouse_event(WORD dx, WORD dy, WORD b)
+{
+	generated_event.ie_NextEvent = NULL;
+	generated_event.ie_Class = IECLASS_RAWMOUSE;
+	generated_event.ie_SubClass = 0;
+
+	UWORD code = IECODE_NOBUTTON;
+	if (!(last_b & 1) && (b & 1))
+		code = IECODE_LBUTTON;
+	else if ((last_b & 1) && !(b & 1))
+		code = IECODE_UP_PREFIX | IECODE_LBUTTON;
+	else if (!(last_b & 2) && (b & 2))
+		code = IECODE_RBUTTON;
+	else if ((last_b & 2) && !(b & 2))
+		code = IECODE_UP_PREFIX | IECODE_RBUTTON;
+	generated_event.ie_Code = code;
+
+	UWORD qual = IEQUALIFIER_RELATIVEMOUSE | kbd_qual;
+	if (b & 1)
+		qual |= IEQUALIFIER_LEFTBUTTON;
+	if (b & 2)
+		qual |= IEQUALIFIER_RBUTTON;
+	generated_event.ie_Qualifier = qual;
+
+	generated_event.ie_X = dx;
+	generated_event.ie_Y = dy;
+
+	id_req->io_Data = (void *)&generated_event;
+	id_req->io_Command = IND_WRITEEVENT;
+	id_req->io_Flags = 0;
+	id_req->io_Length = sizeof(struct InputEvent);
+	DoIO((struct IORequest *)id_req);
+}
+
+void send_generated_keyboard_event(UBYTE up, UBYTE kc)
+{
+	generated_event.ie_NextEvent = NULL;
+	generated_event.ie_Class = IECLASS_RAWKEY;
+	generated_event.ie_SubClass = 0;
+	generated_event.ie_Code = up | kc;
+
+	UWORD qual = kbd_qual;
+	if (last_b & 1)
+		qual |= IEQUALIFIER_LEFTBUTTON;
+	if (last_b & 2)
+		qual |= IEQUALIFIER_RBUTTON;
+	switch (kc)
+	{
+	case 0x5a:
+	case 0x5b:
+	case 0x5c:
+	case 0x5d:
+	case 0x3d:
+	case 0x3e:
+	case 0x3f:
+	case 0x4a:
+	case 0x2d:
+	case 0x2e:
+	case 0x2f:
+	case 0x5e:
+	case 0x1d:
+	case 0x1e:
+	case 0x1f:
+	case 0x43:
+	case 0x0f:
+	case 0x3c:
+		qual |= IEQUALIFIER_NUMERICPAD;
+		break;
+	}
+	generated_event.ie_Qualifier = qual;
+
+	generated_event.ie_X = 0;
+	generated_event.ie_Y = 0;
+
+	id_req->io_Data = (void *)&generated_event;
+	id_req->io_Command = IND_WRITEEVENT;
+	id_req->io_Flags = 0;
+	id_req->io_Length = sizeof(struct InputEvent);
+	DoIO((struct IORequest *)id_req);
+}
+
+void handle_a314_read_completed()
+{
+	pending_a314_read = FALSE;
+
+	if (stream_closed)
+		return;
+
+	int res = rmsg->a314_Request.io_Error;
+	if (res == A314_READ_OK)
+	{
+		int length = rmsg->a314_Length;
+
+		WORD *p = (WORD *)&arbuf[0];
+
+		WORD cx = IntuitionBase->MouseX;
+		WORD cy = IntuitionBase->MouseY;
+
+		while (length > 0)
+		{
+			WORD x = *p++;
+
+			if (x & 0x4000)
+			{
+				UBYTE up = (x & 0x2000) ? 0x80 : 0;
+				UBYTE kc = x & 0x7f;
+
+				if (kc >= 0x60 && kc <= 0x67)
+				{
+					UWORD qual = 1 << (kc - 0x60);
+					if (up)
+						kbd_qual &= ~qual;
+					else
+						kbd_qual |= qual;
+				}
+
+				send_generated_keyboard_event(up, kc);
+
+				length -= 2;
+			}
+			else
+			{
+				WORD y = *p++;
+				WORD b = *p++;
+
+				if (b == last_b)
+				{
+					send_generated_mouse_event(x - cx, y - cy, last_b);
+					cx = x;
+					cy = y;
+				}
+				else
+				{
+					if (cx != x || cy != y)
+					{
+						send_generated_mouse_event(x - cx, y - cy, last_b);
+						cx = x;
+						cy = y;
+					}
+					send_generated_mouse_event(0, 0, b);
+					last_b = b;
+				}
+
+				length -= 6;
+			}
+		}
+
+		start_a314_read();
+	}
+	else if (res == A314_READ_EOS)
+	{
+		start_a314_reset();
+		stream_closed = TRUE;
+	}
+	else if (res == A314_READ_RESET)
+		stream_closed = TRUE;
+}
+
+void handle_vblank_signal()
+{
+	blen = 0;
+	append_uword(IntuitionBase->MouseX);
+	append_uword(IntuitionBase->MouseY);
+	
+	if (!pending_a314_write)
+		start_a314_write(blen);
+}
+
+int main()
+{
+	mp = CreatePort(NULL, 0);
+	cmsg = (struct A314_IORequest *)CreateExtIO(mp, sizeof(struct A314_IORequest));
+
+	if (OpenDevice(A314_NAME, 0, (struct IORequest *)cmsg, 0) != 0)
+	{
+		printf("Unable to open a314.device\n");
+		goto fail_out1;
+	}
+
+	A314Base = &(cmsg->a314_Request.io_Device->dd_Library);
+
+	wmsg = (struct A314_IORequest *)CreateExtIO(mp, sizeof(struct A314_IORequest));
+	rmsg = (struct A314_IORequest *)CreateExtIO(mp, sizeof(struct A314_IORequest));
+	memcpy(wmsg, cmsg, sizeof(struct A314_IORequest));
+	memcpy(rmsg, cmsg, sizeof(struct A314_IORequest));
+
+	if (a314_connect("remotewb") != A314_CONNECT_OK)
+	{
+		printf("Unable to connect to remotewb service\n");
+		goto fail_out2;
+	}
+
+	IntuitionBase = (struct IntuitionBase *)OpenLibrary("intuition.library", 0);
+	GfxBase = (struct GfxBase *)OpenLibrary("graphics.library", 0);
+
+	Forbid();
+
+	struct Screen *screen = find_wb_screen();
+	if (!screen)
+	{
+		Permit();
+		printf("Unable to find workbench screen\n");
+		sync_a314_reset();
+		goto fail_out3;
+	}
+
+	struct BitMap *bm = &(screen->BitMap);
+
+	if (screen->Width != 640 || screen->Height != 256 || bm->Depth != 3 || (bm->BytesPerRow != 80 && bm->BytesPerRow != 240))
+	{
+		Permit();
+		printf("Wrong screen resolution; it is %hdx%hdx%hhu but must be 640x256x3\n", screen->Width, screen->Height, bm->Depth);
+		sync_a314_reset();
+		goto fail_out3;
+	}
+
+	append_uword(screen->Width);
+	append_uword(screen->Height);
+	append_uword(bm->Depth);
+	append_uword(bm->BytesPerRow);
+
+	ULONG ptr = TranslateAddressA314(bm->Planes[0]);
+
+	if (ptr == -1)
+	{
+		int depth = bm->Depth;
+		int size = 80 * 256;
+
+		UBYTE *p = AllocMem(size * depth, MEMF_A314 | MEMF_CHIP);
+		if (!p)
+		{
+			Permit();
+			printf("Unable to allocate enough A314 chip memory\n");
+			sync_a314_reset();
+			goto fail_out3;
+		}
+
+		if (bm->BytesPerRow == 80)
+		{
+			UBYTE *old_planes[8];
+
+			for (int i = 0; i < depth; i++)
+			{
+				UBYTE *op = bm->Planes[i];
+				UBYTE *np = p + (i * size);
+				memcpy(np, op, size);
+				old_planes[i] = op;
+				bm->Planes[i] = np;
+			}
+
+			RemakeDisplay();
+
+			for (int i = 0; i < depth; i++)
+				FreeMem(old_planes[i], size);
+
+			ptr = TranslateAddressA314(bm->Planes[0]);
+		}
+		else if (bm->BytesPerRow == 240)
+		{
+			UBYTE *old_ptr = bm->Planes[0];
+
+			memcpy(p, old_ptr, size * depth);
+
+			for (int i = 0; i < depth; i++)
+				bm->Planes[i] = p + (i * 80);
+
+			RemakeDisplay();
+
+			FreeMem(old_ptr, size * depth);
+
+			ptr = TranslateAddressA314(bm->Planes[0]);
+		}
+	}
+
+	append_ulong(ptr);
+
+	struct ColorMap *cm = screen->ViewPort.ColorMap;
+	append_uword(cm->Count);
+	for (int i = 0; i < cm->Count; i++)
+		append_uword(((UWORD *)cm->ColorTable)[i] & 0xfff);
+
+	Permit();
+
+	sync_a314_write(blen);
+
+	id_mp = CreatePort(NULL, 0);
+	id_req = (struct IOStdReq *)CreateExtIO(id_mp, sizeof(struct IOStdReq));
+	OpenDevice("input.device", 0, (struct IORequest *)id_req, 0);
+
+	start_a314_read();
+
+	BYTE vblank_sigbit = AllocSignal(-1);
+
+	ULONG vblanksig = 1 << vblank_sigbit;
+	ULONG portsig = 1 << mp->mp_SigBit;
+
+	vblank_data.task = FindTask(NULL);
+	vblank_data.signal = vblanksig;
+
+	vblank_interrupt.is_Node.ln_Type = NT_INTERRUPT;
+	vblank_interrupt.is_Node.ln_Pri = -60;
+	vblank_interrupt.is_Node.ln_Name = NULL;
+	vblank_interrupt.is_Data = (APTR)&vblank_data;
+	vblank_interrupt.is_Code = VBlankServer;
+
+	AddIntServer(INTB_VERTB, &vblank_interrupt);
+
+	printf("Press ctrl-c to exit...\n");
+
+	while (TRUE)
+	{
+		ULONG signal = Wait(vblanksig | portsig | SIGBREAKF_CTRL_C);
+		if (signal & vblanksig)
+		{
+			handle_vblank_signal();
+		}
+
+		if (signal & portsig)
+		{
+			struct Message *msg;
+			while (msg = GetMsg(mp))
+			{
+				if (msg == (struct Message *)rmsg)
+					handle_a314_read_completed();
+				else if (msg == (struct Message *)wmsg)
+					pending_a314_write = FALSE;
+				else if (msg == (struct Message *)cmsg)
+					pending_a314_reset = FALSE;
+			}
+		}
+
+		if (signal & SIGBREAKF_CTRL_C)
+		{
+			start_a314_reset();
+			stream_closed = TRUE;
+		}
+
+		if (stream_closed && !pending_a314_read && !pending_a314_write && !pending_a314_reset)
+			break;
+	}
+
+	RemIntServer(INTB_VERTB, &vblank_interrupt);
+	FreeSignal(vblank_sigbit);
+	
+	CloseDevice((struct IORequest *)id_req);
+	DeleteExtIO((struct IORequest *)id_req);
+	DeletePort(id_mp);
+fail_out3:
+	CloseLibrary((struct Library *)GfxBase);
+	CloseLibrary((struct Library *)IntuitionBase);;
+fail_out2:
+	CloseDevice((struct IORequest *)cmsg);
+	DeleteExtIO((struct IORequest *)rmsg);
+	DeleteExtIO((struct IORequest *)wmsg);
+fail_out1:
+	DeleteExtIO((struct IORequest *)cmsg);
+	DeletePort(mp);
+	return 0;
+}
diff --git a/src/a314/software-amiga/remotewb_pistorm/vblank_server.asm b/src/a314/software-amiga/remotewb_pistorm/vblank_server.asm
new file mode 100644
index 00000000..14a0c24c
--- /dev/null
+++ b/src/a314/software-amiga/remotewb_pistorm/vblank_server.asm
@@ -0,0 +1,18 @@
+
+	XDEF	_VBlankServer
+	CODE
+
+;struct VBlankData
+;{
+;	struct Task *task;
+;	ULONG signal;
+;};
+
+	; a1 points to VBlankData structure
+_VBlankServer:
+	move.l	$4.w,a6
+	move.l	4(a1),d0	; signal
+	move.l	0(a1),a1	; task
+	jsr	-324(a6)
+	moveq	#0,d0
+	rts
