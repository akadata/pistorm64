/*
 * janusd-pi.c
 * 
 * Janus Daemon for Raspberry Pi
 * Handles network communication for Amiga via Janus IPC
 */

#define _POSIX_C_SOURCE 199309L
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <stdint.h>
#include <stdbool.h>
#include <pthread.h>
#include <signal.h>
#include <time.h>

// Include Janus IPC headers
#include "janus-ipc.h"

// Define command codes
#define JANUS_CMD_MIPS_BENCH 0x0003

// Structure for MIPS benchmark request
struct mips_bench_request {
    char ip_addr[16];      // IP address string
    uint16_t port;         // Port number
    uint32_t iterations;   // Number of iterations
};

// Structure for MIPS benchmark response
struct mips_bench_response {
    uint16_t cmd;
    uint16_t len;
    uint32_t ops_per_second;  // MIPS score
    uint32_t iterations;      // Number of iterations
    uint32_t status;          // Status code
};

// Global variables
static volatile sig_atomic_t running = 1;

// Signal handler for graceful shutdown
void signal_handler(int sig) {
    printf("\nReceived signal %d, shutting down gracefully...\n", sig);
    running = 0;
}

// Network handler for MIPS benchmark requests
int handle_mips_benchmark_request(const char* server_ip, int port, int iterations, 
                                 struct mips_bench_response* response) {
    int sock = 0;
    struct sockaddr_in serv_addr;
    char buffer[1024] = {0};
    char request[256];
    
    printf("Connecting to MIPS benchmark server at %s:%d for %d iterations\n", 
           server_ip, port, iterations);
    
    // Create socket
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        printf("Socket creation error\n");
        if (response) {
            response->status = 1; // Error status
        }
        return -1;
    }
    
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(port);
    
    // Convert IPv4 address from text to binary
    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {
        printf("Invalid address or address not supported: %s\n", server_ip);
        close(sock);
        if (response) {
            response->status = 2; // Invalid address status
        }
        return -1;
    }
    
    // Connect to server
    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
        printf("Connection Failed to %s:%d\n", server_ip, port);
        close(sock);
        if (response) {
            response->status = 3; // Connection failed status
        }
        return -1;
    }
    
    // Prepare request
    snprintf(request, sizeof(request), "MIPS_BENCH:%d", iterations);
    
    // Send request
    int send_result = send(sock, request, strlen(request), 0);
    if (send_result < 0) {
        printf("Failed to send request: %s\n", request);
        close(sock);
        if (response) {
            response->status = 4; // Send failed status
        }
        return -1;
    }
    printf("Request sent: %s\n", request);
    
    // Receive response
    int valread = read(sock, buffer, sizeof(buffer) - 1);
    if (valread > 0) {
        buffer[valread] = '\0';
        printf("Response received: %s\n", buffer);
        
        // Parse response - expecting format: "MIPS_RESULT:<ops_per_sec>:iterations:<count>"
        if (strncmp(buffer, "MIPS_RESULT:", 12) == 0) {
            char* token = strtok(buffer + 12, ":");
            if (token != NULL) {
                float ops_per_sec = atof(token);
                if (response) {
                    response->cmd = JANUS_CMD_MIPS_BENCH;
                    response->len = sizeof(struct mips_bench_response) - 4;
                    response->ops_per_second = (uint32_t)ops_per_sec;
                    response->iterations = iterations;
                    response->status = 0; // Success
                }
                printf("Parsed result: %.2f MIPS (operations per second)\n", ops_per_sec);
            }
        }
        
        close(sock);
        return 0;
    } else {
        printf("Failed to receive response from server\n");
        close(sock);
        if (response) {
            response->status = 5; // Receive failed status
        }
        return -1;
    }
}

// Function to process network commands from the Amiga via Janus IPC
void process_network_command_from_amiga(const uint8_t* payload, uint16_t payload_len) {
    // This function would be called from the main janusd daemon
    // when a network command is received from the Amiga side
    
    if (payload_len < sizeof(struct mips_bench_request)) {
        printf("Invalid payload length: %d (expected at least %zu)\n", 
               payload_len, sizeof(struct mips_bench_request));
        return;
    }
    
    // Parse the request
    struct mips_bench_request req;
    memcpy(&req, payload, sizeof(req));
    
    printf("Processing MIPS benchmark request:\n");
    printf("  IP: %s\n", req.ip_addr);
    printf("  Port: %d\n", req.port);
    printf("  Iterations: %u\n", req.iterations);
    
    // Handle the MIPS benchmark request
    struct mips_bench_response response;
    int result = handle_mips_benchmark_request(req.ip_addr, req.port, req.iterations, &response);
    
    if (result == 0) {
        printf("MIPS benchmark request completed successfully\n");
        printf("Result: %u ops/sec for %u iterations\n", 
               response.ops_per_second, response.iterations);
        
        // In a real implementation, this would send the result back to the Amiga
        // via the Janus IPC ring buffer mechanism
        // uint16_t send_result = janus_send_message(response.cmd, 
        //                                         (const uint8_t*)&response + 4, 
        //                                         sizeof(response) - 4);
    } else {
        printf("MIPS benchmark request failed with status: %d\n", response.status);
    }
}

// Function to read from the Janus ring buffer and process commands
void* janus_reader_thread(void* arg) {
    (void)arg; // Suppress unused parameter warning
    printf("Starting Janus IPC reader thread...\n");

    while (running) {
        // Process any incoming messages from the Amiga side
        // Check the actual shared memory ring buffer and process any new messages

        struct timespec ts = {0, 10000000}; // 10ms delay in nanoseconds
        nanosleep(&ts, NULL);
    }

    return NULL;
}

// Function to process messages from the ring buffer
void process_janus_messages() {
    // Check if there are new messages in the ring buffer
    // Read the message header (cmd, len)
    // Extract the payload
    // Call the appropriate handler based on the command
}

int main(int argc, char *argv[]) {
    (void)argc; // Suppress unused parameter warning
    (void)argv; // Suppress unused parameter warning
    printf("Janus Daemon for Raspberry Pi\n");
    printf("=============================\n");

    // Register signal handlers for graceful shutdown
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);
    
    // Initialize Janus IPC system
    // This would normally use actual shared memory accessible by both Amiga and Pi
    // For simulation purposes, we'll use a local buffer
    uint8_t mock_ring_buffer[4096];
    uintptr_t ring_addr = (uintptr_t)&mock_ring_buffer;
    
    printf("Initializing Janus IPC system...\n");
    bool init_result = janus_ipc_init(ring_addr, 4096, 0);
    
    if (!init_result) {
        printf("Failed to initialize Janus IPC!\n");
        return 1;
    }
    
    printf("Janus IPC initialized successfully.\n");
    printf("Status: %s\n", janus_get_status() ? "active" : "inactive");
    
    // Create a thread to continuously read from the Janus ring buffer
    pthread_t reader_thread;
    int rc = pthread_create(&reader_thread, NULL, janus_reader_thread, NULL);
    if (rc) {
        printf("Error creating reader thread: %d\n", rc);
        return 1;
    }
    
    printf("Janus Daemon running. Waiting for commands from Amiga...\n");
    printf("Press Ctrl+C to stop.\n");
    
    // Main loop - process commands
    while (running) {
        // Process any pending messages
        process_janus_messages();

        // Small delay to prevent busy-waiting
        struct timespec ts = {0, 10000000}; // 10ms delay in nanoseconds
        nanosleep(&ts, NULL);
    }
    
    // Wait for the reader thread to finish
    pthread_join(reader_thread, NULL);
    
    printf("Janus Daemon shutting down\n");
    return 0;
}