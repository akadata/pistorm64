From 5f5e7b5112e5987469b2a7e62d0460f4b98e92ce Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Niklas=20Ekstr=C3=B6m?= <mail@niklasekstrom.nu>
Date: Sun, 8 Jun 2025 18:00:38 +0200
Subject: [PATCH] Add handling of redirecting files to/from Pi


diff --git a/Software/picmd/pi.c b/Software/picmd/pi.c
index 376e734..0bb280b 100644
--- a/Software/picmd/pi.c
+++ b/Software/picmd/pi.c
@@ -25,9 +25,13 @@
 
 #define ID_314_DISK (('3' << 24) | ('1' << 16) | ('4' << 8))
 
+#define FLAG_INPUT_FILE		0x0001
+#define FLAG_OUTPUT_FILE	0x0002
+
 struct StartMsgHeader
 {
 	UWORD length;
+	UWORD flags;
 	short rows;
 	short cols;
 	UBYTE component_count;
@@ -43,20 +47,24 @@ static struct A314_IORequest *sync_ior;
 static BPTR input_file;
 static BPTR output_file;
 
+static BOOL console_input;
+static BOOL console_output;
+
 static struct FileHandle *con;
 
 static ULONG socket;
 
 static UBYTE arbuf[256];
+static UBYTE input_read_buf[64];
 
 static struct StandardPacket sync_sp;
 static struct StandardPacket wait_sp;
 
 static BOOL pending_a314_read = FALSE;
-static BOOL pending_con_wait = FALSE;
-static BOOL stream_closed = FALSE;
+static BOOL pending_input_read = FALSE;
+static BOOL stream_open = FALSE;
 
-static void put_con_sp(struct MsgPort *reply_port, struct StandardPacket *sp, LONG action, LONG arg1, LONG arg2, LONG arg3)
+static void put_fh_sp(struct FileHandle *fh, struct StandardPacket *sp, struct MsgPort *reply_port, LONG action, LONG arg1, LONG arg2, LONG arg3)
 {
 	sp->sp_Msg.mn_Node.ln_Type = NT_MESSAGE;
 	sp->sp_Msg.mn_Node.ln_Pri = 0;
@@ -69,31 +77,35 @@ static void put_con_sp(struct MsgPort *reply_port, struct StandardPacket *sp, LO
 	sp->sp_Pkt.dp_Arg1 = arg1;
 	sp->sp_Pkt.dp_Arg2 = arg2;
 	sp->sp_Pkt.dp_Arg3 = arg3;
-	PutMsg(con->fh_Type, &(sp->sp_Msg));
+	PutMsg(fh->fh_Type, &(sp->sp_Msg));
 }
 
 static LONG set_screen_mode(LONG mode)
 {
-	put_con_sp(sync_mp, &sync_sp, ACTION_SCREEN_MODE, mode, 0, 0);
+	put_fh_sp(con, &sync_sp, sync_mp, ACTION_SCREEN_MODE, mode, 0, 0);
 	Wait(1L << sync_mp->mp_SigBit);
 	GetMsg(sync_mp);
 	return sync_sp.sp_Pkt.dp_Res1;
 }
 
-static void start_con_wait()
-{
-	put_con_sp(async_mp, &wait_sp, ACTION_WAIT_CHAR, 100000, 0, 0);
-	pending_con_wait = TRUE;
-}
-
-static LONG con_read(char *s, int length)
+static void start_wait_char()
 {
-	return Read(input_file, s, length);
+	put_fh_sp(con, &wait_sp, async_mp, ACTION_WAIT_CHAR, 100000, 0, 0);
+	pending_input_read = TRUE;
 }
 
-static LONG con_write(char *s, int length)
+static void start_input_read()
 {
-	return Write(output_file, s, length);
+	struct FileHandle *fh = (struct FileHandle *)BADDR(input_file);
+	if (fh->fh_Arg1 == 0)
+	{
+		wait_sp.sp_Pkt.dp_Res1 = 0;
+	}
+	else
+	{
+		put_fh_sp(fh, &wait_sp, async_mp, ACTION_READ, fh->fh_Arg1, (LONG)input_read_buf, sizeof(input_read_buf));
+		pending_input_read = TRUE;
+	}
 }
 
 static void start_a314_cmd(struct MsgPort *reply_port, struct A314_IORequest *ior, UWORD cmd, char *buffer, int length)
@@ -146,40 +158,63 @@ static void start_a314_read()
 	pending_a314_read = TRUE;
 }
 
-static void handle_con_wait_completed()
+static void handle_wait_char_completed()
 {
-	pending_con_wait = FALSE;
+	pending_input_read = FALSE;
 
-	if (stream_closed)
+	if (!stream_open)
 		return;
 
 	if (wait_sp.sp_Pkt.dp_Res1 == DOSFALSE)
 	{
-		start_con_wait();
+		start_wait_char();
 	}
 	else
 	{
-		unsigned char buf[64];
-		int len = con_read(buf, sizeof(buf));
+		int len = Read(input_file, input_read_buf, sizeof(input_read_buf));
 
 		if (len == 0 || len == -1)
 		{
 			a314_reset();
-			stream_closed = TRUE;
+			stream_open = FALSE;
 		}
 		else
 		{
-			a314_write(buf, len);
-			start_con_wait();
+			a314_write(input_read_buf, len);
+			start_wait_char();
 		}
 	}
 }
 
+static void handle_input_read_completed()
+{
+	pending_input_read = FALSE;
+
+	if (!stream_open)
+		return;
+
+	LONG bytes_read = wait_sp.sp_Pkt.dp_Res1;
+	if (bytes_read == -1) // Error.
+	{
+		a314_reset();
+		stream_open = FALSE;
+	}
+	else if (bytes_read == 0) // End of file.
+	{
+		a314_eos();
+	}
+	else
+	{
+		a314_write(input_read_buf, bytes_read);
+		start_input_read();
+	}
+}
+
 static void handle_a314_read_completed()
 {
 	pending_a314_read = FALSE;
 
-	if (stream_closed)
+	if (!stream_open)
 		return;
 
 	int res = read_ior->a314_Request.io_Error;
@@ -188,17 +223,17 @@ static void handle_a314_read_completed()
 		UBYTE *p = read_ior->a314_Buffer;
 		int len = read_ior->a314_Length;
 
-		con_write(p, len);
+		Write(output_file, p, len);
 		start_a314_read();
 	}
 	else if (res == A314_READ_EOS)
 	{
-		a314_eos();
-		stream_closed = TRUE;
+		a314_reset();
+		stream_open = FALSE;
 	}
 	else if (res == A314_READ_RESET)
 	{
-		stream_closed = TRUE;
+		stream_open = FALSE;
 	}
 }
 
@@ -250,8 +285,12 @@ static void create_and_send_start_msg(BPTR current_dir, int argc, char **argv, s
 
 	UBYTE *buffer = AllocMem(buf_len, 0);
 
+	UWORD flags = (console_input ? 0 : FLAG_INPUT_FILE) |
+			(console_output ? 0 : FLAG_OUTPUT_FILE);
+
 	struct StartMsgHeader *hdr = (struct StartMsgHeader *)buffer;
 	hdr->length = buf_len;
+	hdr->flags = flags;
 	hdr->rows = rows;
 	hdr->cols = cols;
 	hdr->component_count = component_count;
@@ -295,11 +334,8 @@ int main(int argc, char **argv)
 	input_file = proc->pr_CIS;
 	output_file = proc->pr_COS;
 
-	if (!IsInteractive(input_file))
-	{
-		printf("Unable to handle redirected input\n");
-		goto fail0;
-	}
+	console_input = IsInteractive(input_file);
+	console_output = IsInteractive(output_file);
 
 	sync_mp = CreatePort(NULL, 0);
 	async_mp = CreatePort(NULL, 0);
@@ -327,22 +363,28 @@ int main(int argc, char **argv)
 		goto fail2;
 	}
 
+	stream_open = TRUE;
+
 	// The interactions with the console are described here:
 	// https://wiki.amigaos.net/wiki/Console_Device
 
-	con = (struct FileHandle *)BADDR(input_file);
+	if (console_input)
+		con = (struct FileHandle *)BADDR(input_file);
+	else if (console_output)
+		con = (struct FileHandle *)BADDR(output_file);
 
-	set_screen_mode(DOSTRUE);
+	if (con)
+		set_screen_mode(DOSTRUE);
 
 	int rows = 25;
 	int cols = 80;
 
-	if (IsInteractive(output_file))
+	if (console_output)
 	{
 		// Window Status Request
-		con_write("\x9b" "0 q", 4);
+		Write(output_file, "\x9b" "0 q", 4);
 
-		int len = con_read(arbuf, 32);	// "\x9b" "1;1;33;77 r"
+		int len = Read(output_file, arbuf, 32);	// "\x9b" "1;1;33;77 r"
 		if (len < 10 || arbuf[len - 1] != 'r')
 		{
 			printf("Failure to receive window bounds report\n");
@@ -351,7 +393,7 @@ int main(int argc, char **argv)
 		}
 
 		// Set Raw Events
-		con_write("\x9b" "12{", 4); // 12 = Window resized
+		Write(output_file, "\x9b" "12{", 4); // 12 = Window resized
 
 		int start = 5;
 		int ind = start;
@@ -369,12 +411,20 @@ int main(int argc, char **argv)
 
 	create_and_send_start_msg(proc->pr_CurrentDir, argc, argv, (short)rows, (short)cols);
 
-	start_con_wait();
+	if (console_input)
+		start_wait_char();
+	else
+	{
+		start_input_read();
+		if (!pending_input_read)
+			handle_input_read_completed();
+	}
+
 	start_a314_read();
 
 	ULONG portsig = 1L << async_mp->mp_SigBit;
 
-	while (TRUE)
+	while (stream_open || pending_a314_read || pending_input_read)
 	{
 		ULONG signal = Wait(portsig | SIGBREAKF_CTRL_C);
 
@@ -384,18 +434,21 @@ int main(int argc, char **argv)
 			while (msg = GetMsg(async_mp))
 			{
 				if (msg == (struct Message *)&wait_sp)
-					handle_con_wait_completed();
+				{
+					if (console_input)
+						handle_wait_char_completed();
+					else
+						handle_input_read_completed();
+				}
 				else if (msg == (struct Message *)read_ior)
 					handle_a314_read_completed();
 			}
 		}
-
-		if (stream_closed && !pending_a314_read && !pending_con_wait)
-			break;
 	}
 
 fail3:
-	set_screen_mode(DOSFALSE);
+	if (con)
+		set_screen_mode(DOSFALSE);
 
 fail2:
 	CloseDevice((struct IORequest *)sync_ior);
@@ -413,6 +466,5 @@ fail1:
 	if (sync_mp)
 		DeletePort(sync_mp);
 
-fail0:
 	return 0;
 }
diff --git a/Software/picmd/picmd.py b/Software/picmd/picmd.py
index 2e2f20d..284d6e7 100644
--- a/Software/picmd/picmd.py
+++ b/Software/picmd/picmd.py
@@ -131,16 +131,30 @@ def send_reset(stream_id):
     m = struct.pack('=IIB', 0, stream_id, MSG_RESET)
     drv.sendall(m)
 
-sessions = {}
+sessions: dict[int, 'PiCmdSession'] = {}
 
-class PiCmdSession(object):
-    def __init__(self, stream_id):
+FLAG_INPUT_FILE = 0x0001
+FLAG_OUTPUT_FILE = 0x0002
+
+class PiCmdSession:
+    def __init__(self, stream_id: int):
         self.stream_id = stream_id
         self.pid = 0
 
         self.start_msg = b''
         self.reset_after = None
 
+        self.file_input = False
+        self.file_output = False
+
+        self.pty_fd = 0
+        self.stdin_write = 0
+        self.stdout_read = 0
+
+        self.reset_received = False
+        self.eos_received = False
+        self.eos_sent = False
+
         self.rasp_was_esc = False
         self.rasp_in_cs = False
         self.rasp_holding = ''
@@ -166,7 +180,7 @@ class PiCmdSession(object):
                         # ESC[1;1;rows;cols r
                         rows, cols = map(int, self.amiga_holding[6:-2].split(';'))
                         winsize = struct.pack('HHHH', rows, cols, 0, 0)
-                        fcntl.ioctl(self.fd, termios.TIOCSWINSZ, winsize)
+                        fcntl.ioctl(self.pty_fd, termios.TIOCSWINSZ, winsize)
                     elif c == '|':
                         # Input Event Report
                         # ESC[12;0;0;x;x;x;x;x|
@@ -177,7 +191,7 @@ class PiCmdSession(object):
                     self.amiga_holding = ''
                     self.amiga_in_cs = False
         if len(out) != 0:
-            os.write(self.fd, out.encode('utf-8'))
+            os.write(self.pty_fd, out.encode('utf-8'))
 
     def process_msg_data(self, data):
         if self.start_msg is not None:
@@ -186,9 +200,12 @@ class PiCmdSession(object):
             if len(self.start_msg) == length:
                 buf = self.start_msg
 
-                rows, cols, component_count, arg_count = struct.unpack_from('>HHBB', buf, 2)
+                flags, rows, cols, component_count, arg_count = struct.unpack_from('>HHHBB', buf, 2)
+
+                self.file_input = (flags & FLAG_INPUT_FILE) != 0
+                self.file_output = (flags & FLAG_OUTPUT_FILE) != 0
 
-                ind = 8
+                ind = 10
 
                 components = []
                 for _ in range(component_count):
@@ -207,19 +224,39 @@ class PiCmdSession(object):
                 if arg_count == 0:
                     args.append('bash')
 
-                self.pid, self.fd = pty.fork()
+                if self.file_input:
+                    in_r, in_w = os.pipe()
+                    os.set_inheritable(in_r, True)
+
+                if self.file_output:
+                    out_r, out_w = os.pipe()
+                    os.set_inheritable(out_w, True)
+
+                self.pid, self.pty_fd = pty.fork()
                 if self.pid == 0:
                     os.putenv('PATH', search_path)
                     os.putenv('TERM', 'ansi')
+
                     for key, val in env_vars.items():
                         os.putenv(key, val)
+
                     winsize = struct.pack('HHHH', rows, cols, 0, 0)
                     fcntl.ioctl(sys.stdin, termios.TIOCSWINSZ, winsize)
+
                     if component_count != 0 and components[0] in volume_paths:
                         path = volume_paths[components[0]]
                         os.chdir(os.path.join(path, *components[1:]))
                     else:
                         os.chdir(os.getenv('HOME', '/'))
+
+                    if self.file_input:
+                        os.dup2(in_r, 0)
+                        os.close(in_r)
+
+                    if self.file_output:
+                        os.dup2(out_w, 1)
+                        os.close(out_w)
+
                     try:
                         os.execvp(args[0], args)
                     except FileNotFoundError:
@@ -230,18 +267,26 @@ class PiCmdSession(object):
                         error_message = f'An error occurred: {str(e)}\n'
                         os.write(sys.stderr.fileno(), error_message.encode('utf-8'))
                         os._exit(1)
+                else:
+                    if self.file_input:
+                        os.close(in_r)
+                        self.stdin_write = in_w
+                    else:
+                        self.stdin_write = self.pty_fd
+
+                    if self.file_output:
+                        os.close(out_w)
+                        self.stdout_read = out_r
+                    else:
+                        self.stdout_read = self.pty_fd
 
                 self.start_msg = None
 
         elif self.pid:
-            self.process_amiga_ansi(data)
-
-    def close(self):
-        if self.pid:
-            os.kill(self.pid, signal.SIGTERM)
-            self.pid = 0
-            os.close(self.fd)
-        del sessions[self.stream_id]
+            if not self.file_input and not self.file_output:
+                self.process_amiga_ansi(data)
+            else:
+                os.write(self.stdin_write, data)
 
     def process_rasp_ansi(self, text):
         text = text.decode('utf-8')
@@ -279,28 +324,56 @@ class PiCmdSession(object):
                     self.rasp_in_cs = False
         return out.encode('latin-1', 'replace')
 
-    def handle_text(self):
-        try:
-            text = os.read(self.fd, 1024)
-            text = self.process_rasp_ansi(text)
-            while len(text) > 0:
-                take = min(len(text), 252)
-                send_data(self.stream_id, text[:take])
-                text = text[take:]
-        except:
-            #os.close(self.fd)
-            os.kill(self.pid, signal.SIGTERM)
+    def handle_child_terminated(self):
+        # Child can terminate because:
+        # - Child killed due to RESET received on stream
+        # - Received ctrl-c or exit from console, closing normally
+        # - Received EOS, closing normally
+        # - Child crashed, closing abnormally
+
+        if self.pid:
+            os.waitpid(self.pid, 0)
             self.pid = 0
+
+            os.close(self.pty_fd)
+
+            if self.file_input and self.stdin_write:
+                os.close(self.stdin_write)
+            self.stdin_write = 0
+
+            if self.file_output and self.stdout_read:
+                os.close(self.stdout_read)
+            self.stdout_read = 0
+
+        if not self.reset_received:
             send_eos(self.stream_id)
-            self.reset_after = time.time() + 10
+            self.eos_sent = True
 
-    def handle_timeout(self):
-        if self.reset_after and self.reset_after < time.time():
-            send_reset(self.stream_id)
+        if self.reset_received or self.eos_received and self.eos_sent:
             del sessions[self.stream_id]
 
+    def handle_stdout_reable(self):
+        try:
+            # If stdout is connected to pty then os.read will raise an exception
+            # when program terminates. If stdout is connected to pipe then
+            # os.read will return b'' after program terminates.
+            text = os.read(self.stdout_read, 1024)
+        except:
+            text = b''
+
+        if text == b'':
+            self.handle_child_terminated()
+            return
+
+        text = self.process_rasp_ansi(text)
+
+        while len(text) > 0:
+            take = min(len(text), 252)
+            send_data(self.stream_id, text[:take])
+            text = text[take:]
+
     def fileno(self):
-        return self.fd
+        return self.stdout_read
 
 def process_drv_msg(stream_id, ptype, payload):
     if ptype == MSG_CONNECT:
@@ -316,11 +389,28 @@ def process_drv_msg(stream_id, ptype, payload):
         if ptype == MSG_DATA:
             s.process_msg_data(payload)
         elif ptype == MSG_EOS:
-            if s.pid:
-                send_eos(s.stream_id)
-            s.close()
+            assert s.file_input
+
+            s.eos_received = True
+
+            if s.eos_sent:
+                del sessions[stream_id]
+            elif s.stdin_write:
+                os.close(s.stdin_write)
+                s.stdin_write = 0
         elif ptype == MSG_RESET:
-            s.close()
+            # This can happen if:
+            # - Failure to receive window bounds report
+            # - Reading from console failed
+            # - Reading from input file failed
+            s.reset_received = True
+
+            if s.pid:
+                os.kill(s.pid, signal.SIGKILL)
+                # Will clean up resources when stdout_read is closed.
+            else:
+                # Didn't receive start message yet.
+                del sessions[stream_id]
 
 done = False
 
@@ -351,25 +441,23 @@ if not done:
 
 while not done:
     sel_fds = [drv] + [s for s in sessions.values() if s.pid]
-    if idx == -1:
-        sel_fds.append(sys.stdin)
     rfd, wfd, xfd = select.select(sel_fds, [], [], 5.0)
 
     for fd in rfd:
-        if fd == sys.stdin:
-            line = sys.stdin.readline()
-            if not line or line.startswith('quit'):
-                for s in sessions.values():
-                    s.close()
-                drv.close()
-                done = True
-        elif fd == drv:
+        if fd == drv:
             buf = drv.recv(1024)
             if not buf:
+                # a314d closed the connection to this service.
+                # All streams are resetted by a314d.
+                # Kill child processes and exit.
                 for s in sessions.values():
-                    s.close()
+                    if s.pid:
+                        os.kill(s.pid, signal.SIGKILL)
+                        s.pid = 0
+                sessions.clear()
                 drv.close()
                 done = True
+                break
             else:
                 rbuf += buf
                 while True:
@@ -386,7 +474,4 @@ while not done:
 
                     process_drv_msg(stream_id, ptype, payload)
         else:
-            fd.handle_text()
-
-    for s in sessions.values():
-        s.handle_timeout()
+            fd.handle_stdout_reable()
diff --git a/Software/picmd/pisetclock.c b/Software/picmd/pisetclock.c
index b3db425..6f5b7a7 100644
--- a/Software/picmd/pisetclock.c
+++ b/Software/picmd/pisetclock.c
@@ -24,9 +24,13 @@
 
 #define PICMD_SERVICE_NAME "picmd"
 
+#define FLAG_INPUT_FILE		0x0001
+#define FLAG_OUTPUT_FILE	0x0002
+
 struct StartMsgHeader
 {
 	UWORD length;
+	UWORD flags;
 	short rows;
 	short cols;
 	UBYTE component_count;
@@ -203,6 +207,7 @@ int main(int argc, char **argv)
 
 	struct StartMsgHeader *hdr = (struct StartMsgHeader *)start_msg;
 	hdr->length = START_MSG_LEN;
+	hdr->flags = 0;
 	hdr->rows = 25;
 	hdr->cols = 80;
 	hdr->component_count = 0;
-- 
2.47.3

