From 3b379e86def3015f91970ac646dca1e9e1fbc670 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Niklas=20Ekstr=C3=B6m?= <mail@niklasekstrom.nu>
Date: Tue, 28 May 2024 13:56:49 +0200
Subject: [PATCH 01/13] Add initial version of libremote

Includes a simple example library, and a client for that library.

diff --git a/.gitignore b/.gitignore
index f129551..e09d7c1 100644
--- a/.gitignore
+++ b/.gitignore
@@ -10,3 +10,7 @@ Software/**/.vscode
 Software/bin_amiga
 Software/bin_pi
 Software/bpls2gif/build
+Software/libremote/stubs.h
+Software/libremote/proto_lib.h
+Software/libremote/example.library
+Software/libremote/ExampleClient
diff --git a/Software/libremote/build.sh b/Software/libremote/build.sh
new file mode 100755
index 0000000..eb64bc6
--- /dev/null
+++ b/Software/libremote/build.sh
@@ -0,0 +1,6 @@
+set -x
+
+python gen_stubs.py
+python gen_proto.py
+vc +aos68k -I${NDK32}/Include_H romtag.asm library.c -nostdlib -o example.library
+vc +aos68k -I${NDK32}/Include_H example_client.c -o ExampleClient
diff --git a/Software/libremote/example_client.c b/Software/libremote/example_client.c
new file mode 100644
index 0000000..e8408fc
--- /dev/null
+++ b/Software/libremote/example_client.c
@@ -0,0 +1,27 @@
+#include <exec/types.h>
+
+#include <proto/exec.h>
+
+#include <stdio.h>
+
+#include "proto_lib.h"
+
+struct Library *ExampleBase;
+
+int main()
+{
+    ExampleBase = OpenLibrary(EXAMPLE_LIB_NAME, 0);
+    if (!ExampleBase)
+    {
+        printf("Unable to open " EXAMPLE_LIB_NAME "\n");
+        return 0;
+    }
+
+    const char expr[] = "5 + 17 // (3 + 1)";
+    printf("EvalExpr(%s) = %d\n", expr, EvalExpr(expr));
+
+    printf("Sleep(5) = %lu\n", Sleep(5));
+
+    CloseLibrary(ExampleBase);
+    return 0;
+}
diff --git a/Software/libremote/gen_proto.py b/Software/libremote/gen_proto.py
new file mode 100644
index 0000000..cd96fe0
--- /dev/null
+++ b/Software/libremote/gen_proto.py
@@ -0,0 +1,47 @@
+import json
+
+with open('libdecl.json', 'rt') as f:
+    libdecl = json.load(f)
+
+funcs = libdecl['funcs']
+
+library_name = libdecl['library-name'].replace('.library', '').lower()
+guard = f'__PROTO_{library_name.upper()}_H'
+
+contents = f'#ifndef {guard}\n'
+contents += f'#define {guard}\n\n'
+contents += '#include <exec/types.h>\n\n'
+
+contents += f'#define {library_name.upper()}_LIB_NAME "{libdecl["library-name"]}"\n\n'
+
+base = libdecl['library-base']
+
+contents += f'extern struct Library *{base};\n\n'
+
+def gen_reg_anon(reg):
+    if reg[0] == 'd':
+        return f'__reg("{reg}") ULONG'
+    else:
+        return f'__reg("{reg}") void *'
+
+for i, func in enumerate(funcs):
+    name = func['name']
+    rtype = func['return-type']
+    args = func['args']
+    offset = -(i + 5) * 6
+
+    if len(args):
+        reglist = ', ' + ', '.join(gen_reg_anon(reg) for reg, _, _ in args)
+    else:
+        reglist = ''
+
+    paramlist1 = ', '.join(name for _, name, _ in args)
+    paramlist2 = f'{base}, {paramlist1}' if paramlist1 else base
+
+    contents += f'{rtype} __{name}(__reg("a6") void *{reglist})="\\tjsr\\t{offset}(a6)";\n'
+    contents += f'#define {name}({paramlist1}) __{name}({paramlist2})\n\n'
+
+contents += f'#endif /* {guard} */\n'
+
+with open('proto_lib.h', 'wt') as f:
+    f.write(contents)
diff --git a/Software/libremote/gen_stubs.py b/Software/libremote/gen_stubs.py
new file mode 100644
index 0000000..6f3a47b
--- /dev/null
+++ b/Software/libremote/gen_stubs.py
@@ -0,0 +1,70 @@
+import json
+
+with open('libdecl.json', 'rt') as f:
+    libdecl = json.load(f)
+
+funcs = libdecl['funcs']
+
+contents = '#include "messages.h"\n\n'
+
+contents += f'#define LIBRARY_NAME "{libdecl["library-name"]}"\n'
+contents += f'#define SERVICE_NAME "{libdecl["service-name"]}"\n\n'
+
+contents += '''struct LibRemote;
+static ULONG null_func();
+static BPTR expunge();
+static BPTR close(__reg("a6") struct LibRemote *lib);
+static ULONG send_request(__reg("a6") struct LibRemote *lib, UBYTE *msg, ULONG length);
+
+'''
+
+contents += f'#define LVO_COUNT {len(funcs) + 4}\n\n'
+
+def gen_param(reg):
+    if reg[0] == 'd':
+        return f'__reg("{reg}") ULONG {reg}'
+    else:
+        return f'__reg("{reg}") void *{reg}'
+
+for i, func in enumerate(funcs):
+    args = func.get('args', [])
+    contents += f'static ULONG func_{i}(__reg("a6") struct LibRemote *lib'
+    if len(args):
+        contents += ', ' + ', '.join(gen_param(reg) for reg, _, _ in args)
+    contents += ')\n{\n'
+    contents += f'    UBYTE msg[{2 + len(args)*4}];\n'
+    for j, (reg, _, _) in enumerate(args):
+        contents += f'    *(ULONG *)&msg[{2 + j*4}] = (ULONG){reg};\n'
+    contents += '    msg[0] = MSG_OP_REQ;\n'
+    contents += f'    msg[1] = {i};\n'
+    contents += '    return send_request(lib, msg, sizeof(msg));\n'
+    contents += '}\n\n'
+
+contents += '''static ULONG funcs_vector[] =
+{
+    (ULONG)null_func,
+    (ULONG)close,
+    (ULONG)expunge,
+    (ULONG)null_func,
+'''
+
+for i, _ in enumerate(funcs):
+    contents += f'    (ULONG)func_{i},\n'
+
+contents += '''};
+
+'''
+
+contents += '''static void fill_lvos(__reg("a6") struct LibRemote *lib)
+{
+    for (int i = 0; i < LVO_COUNT; i++)
+    {
+        UBYTE *lvo = (UBYTE *)lib - ((i + 1) * 6);
+        *(UWORD *)lvo = 0x4ef9;
+        *(ULONG *)&lvo[2] = funcs_vector[i];
+    }
+}
+'''
+
+with open('stubs.h', 'wt') as f:
+    f.write(contents)
diff --git a/Software/libremote/libdecl.json b/Software/libremote/libdecl.json
new file mode 100644
index 0000000..8945526
--- /dev/null
+++ b/Software/libremote/libdecl.json
@@ -0,0 +1,21 @@
+{
+    "library-name": "example.library",
+    "service-name": "example",
+    "library-base": "ExampleBase",
+    "funcs": [
+        {
+            "name": "EvalExpr",
+            "return-type": "int",
+            "args": [
+                ["a0", "expr", "char *"]
+            ]
+        },
+        {
+            "name": "Sleep",
+            "return-type": "ULONG",
+            "args": [
+                ["d0", "secs", "int"]
+            ]
+        }
+    ]
+}
\ No newline at end of file
diff --git a/Software/libremote/library.c b/Software/libremote/library.c
new file mode 100644
index 0000000..7c485f2
--- /dev/null
+++ b/Software/libremote/library.c
@@ -0,0 +1,401 @@
+#include <stdint.h>
+#include <string.h>
+
+#include <exec/types.h>
+#include <exec/ports.h>
+#include <exec/libraries.h>
+#include <exec/semaphores.h>
+#include <dos/dos.h>
+
+#include <proto/exec.h>
+#include <proto/dos.h>
+
+#include "../a314device/a314.h"
+#include "../a314device/proto_a314.h"
+
+#include "messages.h"
+#include "stubs.h"
+
+#define SysBase             (*(struct ExecBase **)4)
+
+#define LIB_NEG_SIZE        (LVO_COUNT*6)
+
+#define BOUNCE_BUFFER_SIZE  (4*1024)
+
+// Must keep VERSION in romtag.asm in sync.
+#define LIB_VERSION     1
+#define LIB_REVISION    0
+#define LIB_DATE        "28.5.2024"
+
+#define VSTR(s) STR(s)
+#define STR(s) #s
+
+const char library_name[] = LIBRARY_NAME;
+const char id_string[] = LIBRARY_NAME " " VSTR(LIB_VERSION) "." VSTR(LIB_REVISION) " (" LIB_DATE ")";
+const char service_name[] = SERVICE_NAME;
+
+static BPTR saved_seg_list;
+static struct Library *global_lib;
+struct Library *A314Base;
+
+struct MemChunkHdr
+{
+    struct MemChunkHdr *next;
+    uint32_t size;
+};
+
+struct LibRemote
+{
+    struct Library lib;
+    struct MsgPort mp;
+    struct A314_IORequest write_req;
+    struct A314_IORequest read_req;
+    uint32_t bounce_buffer_address;
+    struct MemChunkHdr *chunks;
+    uint8_t read_buf[128];
+};
+
+static uint32_t null_func()
+{
+    return 0;
+}
+
+static BPTR expunge()
+{
+    if (global_lib->lib_OpenCnt != 0)
+    {
+        global_lib->lib_Flags |= LIBF_DELEXP;
+        return 0;
+    }
+
+    Remove(&global_lib->lib_Node);
+    FreeMem((char *)global_lib - global_lib->lib_NegSize, global_lib->lib_NegSize + global_lib->lib_PosSize);
+    global_lib = NULL;
+
+    BPTR seg_list = saved_seg_list;
+    saved_seg_list = 0;
+    return seg_list;
+}
+
+static BPTR close(__reg("a6") struct LibRemote *lib)
+{
+    struct MemChunkHdr *chunk = lib->chunks;
+    while (chunk)
+    {
+        struct MemChunkHdr *next = chunk->next;
+        FreeMem(chunk, chunk->size);
+        chunk = next;
+    }
+
+    // Reset connection.
+    lib->write_req.a314_Buffer = NULL;
+    lib->write_req.a314_Length = 0;
+    lib->write_req.a314_Request.io_Command = A314_RESET;
+    DoIO(&lib->write_req.a314_Request);
+
+    FreeMemA314(lib->bounce_buffer_address, BOUNCE_BUFFER_SIZE);
+
+    CloseDevice(&lib->write_req.a314_Request);
+
+    FreeMem((char *)lib - lib->lib.lib_NegSize, lib->lib.lib_NegSize + lib->lib.lib_PosSize);
+
+    global_lib->lib_OpenCnt--;
+
+    if (global_lib->lib_OpenCnt == 0 && (global_lib->lib_Flags & LIBF_DELEXP) != 0)
+        return expunge();
+    else
+        return 0;
+}
+
+static uint32_t alloc_chunk(__reg("a6") struct LibRemote *lib, uint32_t length)
+{
+    struct MemChunkHdr *chunk = AllocMem(length + 8, MEMF_ANY);
+
+    if (!chunk)
+        return 0;
+
+    chunk->next = lib->chunks;
+    chunk->size = length + 8;
+    lib->chunks = chunk;
+    return (uint32_t)chunk + 8;
+}
+
+static void free_chunk(__reg("a6") struct LibRemote *lib, uint32_t address)
+{
+    struct MemChunkHdr *chunk = (void *)(address - 8);
+
+    if (lib->chunks == chunk)
+        lib->chunks = chunk->next;
+    else
+    {
+        struct MemChunkHdr *prev_chunk = lib->chunks;
+
+        while (prev_chunk)
+        {
+            if (prev_chunk->next == chunk)
+            {
+                prev_chunk->next = chunk->next;
+                break;
+            }
+            prev_chunk = prev_chunk->next;
+        }
+    }
+
+    FreeMem(chunk, chunk->size);
+}
+
+static uint32_t send_request(__reg("a6") struct LibRemote *lib, uint8_t *msg, uint32_t length)
+{
+    lib->read_req.a314_Buffer = lib->read_buf;
+    lib->read_req.a314_Length = sizeof(lib->read_buf);
+    lib->read_req.a314_Request.io_Command = A314_READ;
+    SendIO(&lib->read_req.a314_Request);
+
+    lib->write_req.a314_Buffer = msg;
+    lib->write_req.a314_Length = length;
+    lib->write_req.a314_Request.io_Command = A314_WRITE;
+    SendIO(&lib->write_req.a314_Request);
+
+    uint8_t send_buf[8];
+
+    BOOL pending_read = TRUE;
+    BOOL pending_write = TRUE;
+
+    uint32_t signals_received = 0;
+    uint32_t signals_to_send = 0;
+    uint8_t msg_to_send = 0;
+    uint32_t done_arg;
+
+    while (pending_read || pending_write)
+    {
+        uint32_t new_signals = Wait(-1);
+
+        signals_received |= new_signals & ~SIGF_SINGLE;
+        signals_to_send |= new_signals & ~SIGF_SINGLE;
+
+        if (new_signals & SIGF_SINGLE)
+        {
+            struct A314_IORequest *req;
+            while (req = (struct A314_IORequest *)GetMsg(&lib->mp))
+            {
+                if (req == &lib->write_req)
+                    pending_write = FALSE;
+                else // if (req == &lib->read_req)
+                {
+                    uint8_t kind = lib->read_buf[0];
+
+                    if (kind == MSG_OP_RES)
+                        pending_read = FALSE;
+                    else
+                    {
+                        if (kind == MSG_ALLOC_MEM_REQ)
+                        {
+                            struct AllocMemReqMsg *req = (struct AllocMemReqMsg *)lib->read_buf;
+                            done_arg = alloc_chunk(lib, req->length);
+                            msg_to_send = MSG_ALLOC_MEM_RES;
+                        }
+                        else if (kind == MSG_FREE_MEM_REQ)
+                        {
+                            struct FreeMemReqMsg *req = (struct FreeMemReqMsg *)lib->read_buf;
+                            free_chunk(lib, req->address);
+                            msg_to_send = MSG_FREE_MEM_RES;
+                        }
+                        else if (kind == MSG_COPY_FROM_BOUNCE_REQ)
+                        {
+                            struct CopyFromBounceReqMsg *req = (struct CopyFromBounceReqMsg *)lib->read_buf;
+                            struct CopyDesc *cd = (struct CopyDesc *)&req[1];
+                            for (int i = 0; i < req->copy_count; i++)
+                            {
+                                ReadMemA314((void *)cd->dst, cd->src, cd->len);
+                                cd++;
+                            }
+                            msg_to_send = MSG_COPY_FROM_BOUNCE_RES;
+                        }
+                        else if (kind == MSG_COPY_TO_BOUNCE_REQ)
+                        {
+                            struct CopyToBounceReqMsg *req = (struct CopyToBounceReqMsg *)lib->read_buf;
+                            struct CopyDesc *cd = (struct CopyDesc *)&req[1];
+                            for (int i = 0; i < req->copy_count; i++)
+                            {
+                                WriteMemA314(cd->dst, (void *)cd->src, cd->len);
+                                cd++;
+                            }
+                            msg_to_send = MSG_COPY_TO_BOUNCE_RES;
+                        }
+                        else if (kind == MSG_COPY_STR_TO_BOUNCE_REQ)
+                        {
+                            struct CopyStrToBounceReqMsg *req = (struct CopyStrToBounceReqMsg *)lib->read_buf;
+                            uint32_t len = strlen((void *)req->str_address);
+                            WriteMemA314(req->bounce_address, (void *)req->str_address, len);
+                            msg_to_send = MSG_COPY_STR_TO_BOUNCE_RES;
+                            done_arg = len;
+                        }
+
+                        lib->read_req.a314_Buffer = lib->read_buf;
+                        lib->read_req.a314_Length = sizeof(lib->read_buf);
+                        lib->read_req.a314_Request.io_Command = A314_READ;
+                        SendIO(&lib->read_req.a314_Request);
+                    }
+                }
+            }
+        }
+
+        if (pending_read && !pending_write)
+        {
+            int16_t length = 0;
+
+            if (msg_to_send)
+            {
+                send_buf[0] = msg_to_send;
+                length = 1;
+                if (msg_to_send == MSG_ALLOC_MEM_RES || msg_to_send == MSG_COPY_STR_TO_BOUNCE_RES)
+                {
+                    *(uint32_t *)&send_buf[2] = done_arg;
+                    length = 6;
+                }
+                msg_to_send = 0;
+            }
+            else if (signals_to_send)
+            {
+                send_buf[0] = MSG_SIGNALS;
+                *(uint32_t *)&send_buf[2] = signals_to_send;
+                length = 6;
+                signals_to_send = 0;
+            }
+
+            if (length)
+            {
+                lib->write_req.a314_Buffer = send_buf;
+                lib->write_req.a314_Length = length;
+                lib->write_req.a314_Request.io_Command = A314_WRITE;
+                SendIO(&lib->write_req.a314_Request);
+
+                pending_write = TRUE;
+            }
+        }
+    }
+
+    struct OpResMsg *op_msg = (struct OpResMsg *)lib->read_buf;
+    struct CopyDesc *cd = (struct CopyDesc *)&op_msg[1];
+
+    for (int i = 0; i < op_msg->copy_count; i++)
+    {
+        ReadMemA314((void *)cd->dst, cd->src, cd->len);
+        cd++;
+    }
+
+    Signal(FindTask(NULL), signals_received & ~(op_msg->signals_consumed));
+
+    return op_msg->result;
+}
+
+static struct Library *open(__reg("a6") struct Library *glib, __reg("d0") uint32_t version)
+{
+    global_lib->lib_OpenCnt++;
+
+    BYTE *p = AllocMem(sizeof(struct LibRemote) + LIB_NEG_SIZE, MEMF_ANY | MEMF_CLEAR);
+    if (!p)
+        goto err_out0;
+
+    // Initialize library struct.
+    struct LibRemote *lib = (struct LibRemote *)(p + LIB_NEG_SIZE);
+    lib->lib.lib_Node.ln_Type = NT_LIBRARY;
+    lib->lib.lib_Node.ln_Name = (char *)library_name;
+    lib->lib.lib_NegSize = LIB_NEG_SIZE;
+    lib->lib.lib_PosSize = sizeof(struct LibRemote);
+    lib->lib.lib_Version = LIB_VERSION;
+    lib->lib.lib_Revision = LIB_REVISION;
+    lib->lib.lib_IdString = id_string;
+    lib->lib.lib_OpenCnt = 1;
+
+    fill_lvos(lib);
+
+    // Create message port.
+    lib->mp.mp_Node.ln_Type = NT_MSGPORT;
+    lib->mp.mp_Node.ln_Name = (void *)library_name;
+    lib->mp.mp_Flags = PA_SIGNAL;
+    lib->mp.mp_SigTask = FindTask(NULL);
+    lib->mp.mp_SigBit = SIGB_SINGLE;
+
+    // Open a314.device.
+    lib->write_req.a314_Request.io_Message.mn_Length = sizeof(struct A314_IORequest);
+    lib->write_req.a314_Request.io_Message.mn_ReplyPort = &lib->mp;
+    if (OpenDevice(A314_NAME, 0, &lib->write_req.a314_Request, 0))
+        goto err_out1;
+
+    // Get unique socket identifier.
+    struct DosLibrary *DOSBase = (struct DosLibrary *)OpenLibrary(DOSNAME, 0);
+    struct DateStamp ds;
+    DateStamp(&ds);
+    lib->write_req.a314_Socket = (ds.ds_Minute * 60 * TICKS_PER_SECOND) + ds.ds_Tick;
+    CloseLibrary((struct Library *)DOSBase);
+
+    memcpy(&lib->read_req, &lib->write_req, sizeof(struct A314_IORequest));
+
+    // Allocate bounce buffer.
+    A314Base = (struct Library *)lib->read_req.a314_Request.io_Device;
+
+    lib->bounce_buffer_address = AllocMemA314(BOUNCE_BUFFER_SIZE);
+    if (lib->bounce_buffer_address == INVALID_A314_ADDRESS)
+        goto err_out2;
+
+    // Connect to service.
+    lib->write_req.a314_Buffer = (char *)service_name;
+    lib->write_req.a314_Length = sizeof(service_name) - 1;
+    lib->write_req.a314_Request.io_Command = A314_CONNECT;
+
+    if (DoIO(&lib->write_req.a314_Request) != A314_CONNECT_OK)
+        goto err_out3;
+
+    // Send open message.
+    uint32_t open_msg[2] = {lib->bounce_buffer_address, BOUNCE_BUFFER_SIZE};
+
+    lib->write_req.a314_Buffer = (void *)&open_msg[0];
+    lib->write_req.a314_Length = sizeof(open_msg);
+    lib->write_req.a314_Request.io_Command = A314_WRITE;
+    DoIO(&lib->write_req.a314_Request);
+
+    global_lib->lib_Flags &= ~LIBF_DELEXP;
+    return &lib->lib;
+
+err_out3:
+    FreeMemA314(lib->bounce_buffer_address, BOUNCE_BUFFER_SIZE);
+
+err_out2:
+    CloseDevice(&lib->write_req.a314_Request);
+
+err_out1:
+    FreeMem((char *)lib - lib->lib.lib_NegSize, lib->lib.lib_NegSize + lib->lib.lib_PosSize);
+
+err_out0:
+    global_lib->lib_OpenCnt--;
+    return NULL;
+}
+
+static uint32_t library_vectors[] =
+{
+    (uint32_t)open,
+    (uint32_t)null_func,
+    (uint32_t)expunge,
+    (uint32_t)null_func,
+    -1,
+};
+
+static struct Library *init_library(__reg("a6") struct ExecBase *sys_base, __reg("a0") BPTR seg_list, __reg("d0") struct Library *lib)
+{
+    saved_seg_list = seg_list;
+    global_lib = lib;
+
+    lib->lib_Version = LIB_VERSION;
+    lib->lib_Revision = LIB_REVISION;
+
+    return lib;
+}
+
+uint32_t auto_init_tables[] =
+{
+    sizeof(struct Library),
+    (uint32_t)library_vectors,
+    0,
+    (uint32_t)init_library,
+};
diff --git a/Software/libremote/libremote.py b/Software/libremote/libremote.py
new file mode 100644
index 0000000..02895c2
--- /dev/null
+++ b/Software/libremote/libremote.py
@@ -0,0 +1,352 @@
+#!/usr/bin/python3
+# -*- coding: utf-8 -*-
+
+# Copyright (c) 2024 Niklas Ekstr√∂m
+
+import logging
+logging.basicConfig(format='%(levelname)s, %(asctime)s, %(name)s, line %(lineno)d: %(message)s', level=logging.INFO)
+
+from a314d import A314d
+import queue
+import select
+import struct
+import threading
+import time
+from typing import Dict
+
+logger = logging.getLogger(__name__)
+
+# These must match constants in messages.h.
+MSG_SIGNALS                 = 1
+MSG_OP_REQ                  = 2
+MSG_OP_RES                  = 3
+MSG_ALLOC_MEM_REQ           = 4
+MSG_ALLOC_MEM_RES           = 5
+MSG_FREE_MEM_REQ            = 6
+MSG_FREE_MEM_RES            = 7
+MSG_COPY_FROM_BOUNCE_REQ    = 8
+MSG_COPY_FROM_BOUNCE_RES    = 9
+MSG_COPY_TO_BOUNCE_REQ      = 10
+MSG_COPY_TO_BOUNCE_RES      = 11
+MSG_COPY_STR_TO_BOUNCE_REQ  = 12
+MSG_COPY_STR_TO_BOUNCE_RES  = 13
+
+QITEM_SIGNALS = 1
+QITEM_OP_REQ = 2
+QITEM_ALLOC_MEM_RES = 3
+QITEM_FREE_MEM_RES = 4
+QITEM_COPY_FROM_BOUNCE_RES = 5
+QITEM_COPY_TO_BOUNCE_RES = 6
+QITEM_COPY_STR_TO_BOUNCE_RES = 7
+QITEM_READ_MEM_COMPLETE = 8
+QITEM_WRITE_MEM_COMPLETE = 9
+QITEM_RESET = 10
+
+SERVICE_NAME = 'example'
+
+FN_EVALEXPR = 0
+FN_SLEEP = 1
+
+SIGBREAKB_CTRL_C = 12
+SIGBREAKB_CTRL_D = 13
+SIGBREAKB_CTRL_E = 14
+SIGBREAKB_CTRL_F = 15
+SIGBREAKF_CTRL_C = (1 << SIGBREAKB_CTRL_C)
+SIGBREAKF_CTRL_D = (1 << SIGBREAKB_CTRL_D)
+SIGBREAKF_CTRL_E = (1 << SIGBREAKB_CTRL_E)
+SIGBREAKF_CTRL_F = (1 << SIGBREAKB_CTRL_F)
+
+class ExampleInstance:
+    def __init__(self, service: 'LibRemoteService', stream_id: int) -> None:
+        self.service = service
+        self.stream_id = stream_id
+        self.queue = queue.Queue()
+
+        self.wait_first_message = True
+        self.bb_address = 0
+        self.bb_size = 0
+
+        threading.Thread(target=self.run).start()
+
+    # Put items on queue.
+    def process_signals(self, signals: int):
+        self.queue.put((QITEM_SIGNALS, signals))
+
+    def process_op_req(self, op: int, args: bytes):
+        self.queue.put((QITEM_OP_REQ, (op, args)))
+
+    def process_alloc_mem_res(self, address: int):
+        self.queue.put((QITEM_ALLOC_MEM_RES, address))
+
+    def process_free_mem_res(self):
+        self.queue.put((QITEM_FREE_MEM_RES, None))
+
+    def process_copy_from_bounce_res(self):
+        self.queue.put((QITEM_COPY_FROM_BOUNCE_RES, None))
+
+    def process_copy_to_bounce_res(self):
+        self.queue.put((QITEM_COPY_TO_BOUNCE_RES, None))
+
+    def process_copy_str_to_bounce_res(self, length: int):
+        self.queue.put((QITEM_COPY_STR_TO_BOUNCE_RES, length))
+
+    def process_read_mem_complete(self, address: int, data: bytes):
+        self.queue.put((QITEM_READ_MEM_COMPLETE, data))
+
+    def process_write_mem_complete(self, address: int):
+        self.queue.put((QITEM_WRITE_MEM_COMPLETE, None))
+
+    def process_stream_reset(self):
+        self.queue.put((QITEM_RESET, None))
+
+    # Wait for specific queue item.
+    def wait_qitem(self, match_qitem: int):
+        while True:
+            qitem, arg = self.queue.get()
+            if qitem == QITEM_RESET:
+                raise InterruptedError()
+            elif qitem == match_qitem:
+                return arg
+
+    def wait_signals(self, signals_mask: int, timeout_secs: int) -> int:
+        end_time = time.time() + timeout_secs
+        while True:
+            try:
+                time_left = max(end_time - time.time(), 0)
+                qitem, arg = self.queue.get(timeout=time_left)
+                if qitem == QITEM_RESET:
+                    raise InterruptedError()
+                elif qitem == QITEM_SIGNALS:
+                    arg &= signals_mask
+                    if arg:
+                        return arg
+            except queue.Empty:
+                return 0
+
+    # Blocking functions to run commands on Amiga.
+    def alloc_mem(self, length: int) -> int:
+        self.service.send_alloc_mem_req(self.stream_id, length)
+        return self.wait_qitem(QITEM_ALLOC_MEM_RES)
+
+    def free_mem(self, address: int) -> int:
+        self.service.send_free_mem_req(self.stream_id, address)
+        return self.wait_qitem(QITEM_FREE_MEM_RES)
+
+    def copy_from_bounce(self, mem_address: int, bounce_address: int, length: int) -> None:
+        self.service.send_copy_from_bounce_req(self.stream_id, mem_address, bounce_address, length)
+        self.wait_qitem(QITEM_COPY_FROM_BOUNCE_RES)
+
+    def copy_to_bounce(self, bounce_address: int, mem_address: int, length: int) -> None:
+        self.service.send_copy_to_bounce_req(self.stream_id, bounce_address, mem_address, length)
+        self.wait_qitem(QITEM_COPY_TO_BOUNCE_RES)
+
+    def copy_str_to_bounce(self, bounce_address: int, str_address: int) -> int:
+        self.service.send_copy_str_to_bounce_req(self.stream_id, bounce_address, str_address)
+        return self.wait_qitem(QITEM_COPY_STR_TO_BOUNCE_RES)
+
+    # Read from/write to bounce buffer.
+    def read_mem(self, address: int, length: int) -> bytes:
+        self.service.start_read_mem(self.stream_id, address, length)
+        return self.wait_qitem(QITEM_READ_MEM_COMPLETE)
+
+    def write_mem(self, address: int, data: bytes) -> None:
+        self.service.start_write_mem(self.stream_id, address, data)
+        self.wait_qitem(QITEM_WRITE_MEM_COMPLETE)
+
+    def read_str(self, address: int) -> str:
+        length = self.copy_str_to_bounce(self.bb_address, address)
+        data = self.read_mem(self.bb_address, length)
+        return data.decode('latin-1')
+
+    # The implemented library functions.
+    def handle_evalexpr_op(self, str_address: int):
+        expr = self.read_str(str_address)
+        try:
+            result = eval(expr)
+        except:
+            result = 0
+        self.service.send_op_res(self.stream_id, result, 0)
+
+    def handle_sleep_op(self, secs: int):
+        signals_consumed = self.wait_signals(SIGBREAKF_CTRL_C | SIGBREAKF_CTRL_D, secs)
+        result = signals_consumed
+        self.service.send_op_res(self.stream_id, result, signals_consumed)
+
+    # Dispatcher loop.
+    def run(self):
+        try:
+            while True:
+                op, args = self.wait_qitem(QITEM_OP_REQ)
+                if op == FN_EVALEXPR:
+                    (str_address,) = struct.unpack('>I', args)
+                    self.handle_evalexpr_op(str_address)
+                elif op == FN_SLEEP:
+                    (secs,) = struct.unpack('>I', args)
+                    self.handle_sleep_op(secs)
+        except InterruptedError:
+            logger.info('ExampleInstance thread was RESET')
+        except:
+            logger.exception('ExampleInstance thread crashed')
+
+class LibRemoteService:
+    def __init__(self):
+        self.a314d = A314d(SERVICE_NAME)
+        self.instances: Dict[int, ExampleInstance] = {}
+        self.read_mem_queue = []
+        self.write_mem_queue = []
+        self.send_lock = threading.Lock()
+        self.rbuf = b''
+
+    def start_read_mem(self, stream_id: int, address: int, length: int):
+        with self.send_lock:
+            self.read_mem_queue.append((stream_id, address))
+            self.a314d.send_read_mem_req(address, length)
+
+    def start_write_mem(self, stream_id: int, address: int, data: bytes):
+        with self.send_lock:
+            self.write_mem_queue.append((stream_id, address))
+            self.a314d.send_write_mem_req(address, data)
+
+    def send_op_res(self, stream_id: int, result: int, signals_consumed: int):
+        with self.send_lock:
+            data = struct.pack('>BBII', MSG_OP_RES, 0, result, signals_consumed)
+            self.a314d.send_data(stream_id, data)
+
+    def send_alloc_mem_req(self, stream_id: int, length: int):
+        with self.send_lock:
+            data = struct.pack('>BBI', MSG_ALLOC_MEM_REQ, 0, length)
+            self.a314d.send_data(stream_id, data)
+
+    def send_free_mem_req(self, stream_id: int, address: int):
+        with self.send_lock:
+            data = struct.pack('>BBI', MSG_FREE_MEM_REQ, 0, address)
+            self.a314d.send_data(stream_id, data)
+
+    def send_copy_from_bounce_req(self, stream_id: int, dst: int, src: int, length: int):
+        with self.send_lock:
+            data = struct.pack('>BBIII', MSG_COPY_FROM_BOUNCE_REQ, 1, dst, src, length)
+            self.a314d.send_data(stream_id, data)
+
+    def send_copy_to_bounce_req(self, stream_id: int, dst: int, src: int, length: int):
+        with self.send_lock:
+            data = struct.pack('>BBIII', MSG_COPY_TO_BOUNCE_REQ, 1, dst, src, length)
+            self.a314d.send_data(stream_id, data)
+
+    def send_copy_str_to_bounce_req(self, stream_id: int, bounce_address: int, str_address: int):
+        with self.send_lock:
+            data = struct.pack('>BBII', MSG_COPY_STR_TO_BOUNCE_REQ, 0, bounce_address, str_address)
+            self.a314d.send_data(stream_id, data)
+
+    def process_stream_connect(self, stream_id: int, name: bytes):
+        if name == SERVICE_NAME.encode():
+            logger.info('Amiga connected to LibRemote service')
+            self.instances[stream_id] = ExampleInstance(self, stream_id)
+            self.a314d.send_connect_response(stream_id, 0)
+        else:
+            self.a314d.send_connect_response(stream_id, 3)
+
+    def process_stream_data(self, stream_id: int, payload: bytes):
+        inst = self.instances.get(stream_id)
+        if not inst:
+            return
+
+        if inst.wait_first_message:
+            inst.bb_address, inst.bb_size = struct.unpack('>II', payload)
+            inst.wait_first_message = False
+            return
+
+        kind = payload[0]
+
+        if kind == MSG_SIGNALS:
+            (signals,) = struct.unpack('>I', payload[2:])
+            inst.process_signals(signals)
+        elif kind == MSG_OP_REQ:
+            inst.process_op_req(payload[1], payload[2:])
+        elif kind == MSG_ALLOC_MEM_RES:
+            (address,) = struct.unpack('>I', payload[2:])
+            inst.process_alloc_mem_res(address)
+        elif kind == MSG_FREE_MEM_RES:
+            inst.process_free_mem_res()
+        elif kind == MSG_COPY_FROM_BOUNCE_RES:
+            inst.process_copy_from_bounce_res()
+        elif kind == MSG_COPY_TO_BOUNCE_RES:
+            inst.process_copy_to_bounce_res()
+        elif kind == MSG_COPY_STR_TO_BOUNCE_RES:
+            (length,) = struct.unpack('>I', payload[2:])
+            inst.process_copy_str_to_bounce_res(length)
+
+    def process_stream_eos(self, stream_id: int):
+        raise AssertionError('EOS is not supposed to be used')
+
+    def process_stream_reset(self, stream_id: int):
+        inst = self.instances.get(stream_id)
+        if inst:
+            inst.process_stream_reset()
+            del self.instances[stream_id]
+            logger.info('Amiga disconnected from LibRemote service')
+
+    def process_read_mem_res(self, payload: bytes):
+        stream_id, address = self.read_mem_queue.pop(0)
+        inst = self.instances.get(stream_id)
+        if inst:
+            inst.process_read_mem_complete(address, payload)
+
+    def process_write_mem_res(self):
+        stream_id, address = self.write_mem_queue.pop(0)
+        inst = self.instances.get(stream_id)
+        if inst:
+            inst.process_write_mem_complete(address)
+
+    def process_drv_msg(self, stream_id: int, ptype: int, payload: bytes):
+        if ptype == self.a314d.MSG_CONNECT:
+            self.process_stream_connect(stream_id, payload)
+        elif ptype == self.a314d.MSG_DATA:
+            self.process_stream_data(stream_id, payload)
+        elif ptype == self.a314d.MSG_EOS:
+            self.process_stream_eos(stream_id)
+        elif ptype == self.a314d.MSG_RESET:
+            self.process_stream_reset(stream_id)
+        elif ptype == self.a314d.MSG_READ_MEM_RES:
+            self.process_read_mem_res(payload)
+        elif ptype == self.a314d.MSG_WRITE_MEM_RES:
+            self.process_write_mem_res()
+
+    def handle_a314d_readable(self):
+        buf = self.a314d.drv.recv(8192)
+        if not buf:
+            logger.error('Connection to a314d was closed, shutting down')
+            exit(-1)
+
+        self.rbuf += buf
+        while True:
+            if len(self.rbuf) < 9:
+                break
+
+            (plen, stream_id, ptype) = struct.unpack('=IIB', self.rbuf[:9])
+            if len(self.rbuf) < 9 + plen:
+                break
+
+            payload = self.rbuf[9:9+plen]
+            self.rbuf = self.rbuf[9+plen:]
+
+            self.process_drv_msg(stream_id, ptype, payload)
+
+    def run(self):
+        logger.info('LibRemote service started')
+
+        while True:
+            try:
+                rl, _, _ = select.select([self.a314d], [], [], 10.0)
+            except KeyboardInterrupt:
+                break
+
+            if self.a314d in rl:
+                self.handle_a314d_readable()
+
+        self.a314d.close()
+
+        logger.info('LibRemote service stopped')
+
+if __name__ == '__main__':
+    service = LibRemoteService()
+    service.run()
diff --git a/Software/libremote/messages.h b/Software/libremote/messages.h
new file mode 100644
index 0000000..86b7c6f
--- /dev/null
+++ b/Software/libremote/messages.h
@@ -0,0 +1,111 @@
+#ifndef __LIBREMOTE_MESSAGES_H
+#define __LIBREMOTE_MESSAGES_H
+
+#include <stdint.h>
+
+#define MSG_SIGNALS                 1
+#define MSG_OP_REQ                  2
+#define MSG_OP_RES                  3
+#define MSG_ALLOC_MEM_REQ           4
+#define MSG_ALLOC_MEM_RES           5
+#define MSG_FREE_MEM_REQ            6
+#define MSG_FREE_MEM_RES            7
+#define MSG_COPY_FROM_BOUNCE_REQ    8
+#define MSG_COPY_FROM_BOUNCE_RES    9
+#define MSG_COPY_TO_BOUNCE_REQ      10
+#define MSG_COPY_TO_BOUNCE_RES      11
+#define MSG_COPY_STR_TO_BOUNCE_REQ  12
+#define MSG_COPY_STR_TO_BOUNCE_RES  13
+
+struct CopyDesc
+{
+    uint32_t dst;
+    uint32_t src;
+    uint32_t len;
+};
+
+struct SignalsMsg // Amiga -> Pi
+{
+    uint8_t kind;
+    uint8_t pad;
+    uint32_t signals;
+};
+
+struct OpReqMsg // Amiga -> Pi
+{
+    uint8_t kind;
+    uint8_t op;
+};
+
+struct OpResMsg // Pi -> Amiga
+{
+    uint8_t kind;
+    uint8_t copy_count;
+    uint32_t result;
+    uint32_t signals_consumed;
+};
+
+struct AllocMemReqMsg // Pi -> Amiga
+{
+    uint8_t kind;
+    uint8_t pad;
+    uint32_t length;
+};
+
+struct AllocMemResMsg // Amiga -> Pi
+{
+    uint8_t kind;
+    uint8_t pad;
+    uint32_t address;
+};
+
+struct FreeMemReqMsg // Pi -> Amiga
+{
+    uint8_t kind;
+    uint8_t pad;
+    uint32_t address;
+};
+
+struct FreeMemResMsg // Amiga -> Pi
+{
+    uint8_t kind;
+};
+
+struct CopyFromBounceReqMsg // Pi -> Amiga
+{
+    uint8_t kind;
+    uint8_t copy_count;
+};
+
+struct CopyFromBounceResMsg // Amiga -> Pi
+{
+    uint8_t kind;
+};
+
+struct CopyToBounceReqMsg // Pi -> Amiga
+{
+    uint8_t kind;
+    uint8_t copy_count;
+};
+
+struct CopyToBounceResMsg // Amiga -> Pi
+{
+    uint8_t kind;
+};
+
+struct CopyStrToBounceReqMsg // Pi -> Amiga
+{
+    uint8_t kind;
+    uint8_t pad;
+    uint32_t bounce_address;
+    uint32_t str_address;
+};
+
+struct CopyStrToBounceResMsg // Amiga -> Pi
+{
+    uint8_t kind;
+    uint8_t pad;
+    uint32_t length;
+};
+
+#endif /* __LIBREMOTE_MESSAGES_H */
diff --git a/Software/libremote/romtag.asm b/Software/libremote/romtag.asm
new file mode 100644
index 0000000..c2f1d78
--- /dev/null
+++ b/Software/libremote/romtag.asm
@@ -0,0 +1,27 @@
+    XREF    _library_name
+    XREF    _id_string
+    XREF    _auto_init_tables
+
+RTC_MATCHWORD:  equ     $4afc
+RTF_AUTOINIT:   equ     (1<<7)
+NT_LIBRARY:     equ     9
+VERSION:        equ     1
+PRIORITY:       equ     0
+
+    section CODE,CODE
+
+    moveq   #-1,d0
+    rts
+
+romtag:
+    dc.w    RTC_MATCHWORD
+    dc.l    romtag
+    dc.l    endcode
+    dc.b    RTF_AUTOINIT
+    dc.b    VERSION
+    dc.b    NT_LIBRARY
+    dc.b    PRIORITY
+    dc.l    _library_name
+    dc.l    _id_string
+    dc.l    _auto_init_tables
+endcode:
-- 
2.47.3

