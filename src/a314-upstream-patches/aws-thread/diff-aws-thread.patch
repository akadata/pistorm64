diff --git a/Software/Makefile b/Software/Makefile
index fd0e3a4..80d33b6 100644
--- a/Software/Makefile
+++ b/Software/Makefile
@@ -3,7 +3,7 @@
 CPP=g++
 VC=vc
 
-all: bin_dir bin/a314d bin/a314.device bin/a314fs bin/pi bin/piaudio bin/remotewb bin/remote-mouse bin/videoplayer bin/diag bin/a314eth.device
+all: bin_dir bin/a314d bin/a314.device bin/a314fs bin/pi bin/piaudio bin/remotewb bin/remote-mouse bin/videoplayer bin/diag bin/a314eth.device bin/aws
 
 bin_dir:
 	mkdir -p bin
@@ -42,6 +42,9 @@ bin/diag: diag/diag.c
 bin/a314eth.device: a314device/a314.h a314device/proto_a314.h ethernet/romtag.asm ethernet/device.c ethernet/sana2.h ethernet/tagitem.h
 	${VC} ethernet/romtag.asm ethernet/device.c -O3 -nostdlib -o bin/a314eth.device -lamiga
 
+bin/aws: aws/aws.c aws/vblank_server.asm
+	${VC} aws/aws.c aws/vblank_server.asm -O3 -lamiga -o bin/aws
+
 install: all
 	mkdir -p /opt/a314
 	cp bin/a314d /opt/a314
@@ -52,6 +55,7 @@ install: all
 	cp remote-mouse/remote-mouse.py /opt/a314
 	cp videoplayer/videoplayer.py /opt/a314
 	cp ethernet/ethernet.py /opt/a314
+	cp aws/awsproxy.py /opt/a314
 	mkdir -p /etc/opt/a314
 	cp a314d/a314d.conf /etc/opt/a314
 	cp a314fs/a314fs.conf /etc/opt/a314
diff --git a/Software/a314d/a314d.conf b/Software/a314d/a314d.conf
index 03f2bb9..0048a1b 100644
--- a/Software/a314d/a314d.conf
+++ b/Software/a314d/a314d.conf
@@ -5,3 +5,4 @@ remotewb	python3	/opt/a314/remotewb.py
 remote-mouse	python3	/opt/a314/remote-mouse.py
 videoplayer	python3	/opt/a314/videoplayer.py
 ethernet	python3	/opt/a314/ethernet.py
+awsproxy	python3	/opt/a314/awsproxy.py
diff --git a/Software/aws/app.py b/Software/aws/app.py
new file mode 100644
index 0000000..2493b4b
--- /dev/null
+++ b/Software/aws/app.py
@@ -0,0 +1,90 @@
+#!/usr/bin/python3
+# -*- coding: utf-8 -*-
+
+# Copyright (c) 2021 Niklas Ekström
+
+import awslib
+import random
+import select
+import socket
+import sys
+
+window_sizes = {}
+
+class ConnectionCallbacks(object):
+    # Take care as these callbacks are executed in a separate thread!
+
+    # There is currently no synchronization in awslib,
+    # so you should not invoke connection methods on this thread.
+
+    # An option is to forward the notification to the main thread through a queue or socketpair.
+    def connection_closed(self, conn):
+        print('Connection closed')
+
+    def event_close_window(self, conn, wid):
+        print('Close button clicked for window {}'.format(wid))
+        # TODO: Close window, but not on this thread.
+
+conn = awslib.connect(ConnectionCallbacks())
+if conn is None:
+    print("Failed to connect to AWS")
+    exit(-1)
+
+def print_help():
+    print("Possible commands:")
+    print("  info")
+    print("  open <x> <y> <w> <h> <title>")
+    print("  close <wid>")
+    print("  flip <wid>")
+    print("  help")
+    print("  quit")
+
+print("Connected to AWS")
+print("Enter command (info/open/close/flip/help/quit):")
+
+while True:
+    arr = sys.stdin.readline().strip().split()
+    try:
+        if arr[0] == 'quit':
+            conn.close()
+            break
+        elif arr[0] == 'help':
+            print_help()
+        elif arr[0] == 'info':
+            w, h, d, pal = conn.get_wb_screen_info()
+            print('Screen info:')
+            print('  width={}, height={}, depth={}'.format(w, h, d))
+            print('  palette={}'.format([('%04x' % c) for c in pal]))
+        elif arr[0] == 'open':
+            x, y, w, h = int(arr[1]), int(arr[2]), int(arr[3]), int(arr[4])
+            title = ' '.join(arr[5:])
+            wid, size = conn.open_window(x, y, w, h, title)
+            if wid is None:
+                # TODO: Add error message?
+                # TODO: Maybe raise exception instead?
+                print('Failed to open window')
+            else:
+                width, height, depth = size
+                print('Window {} opened successfully with size {}x{}x{}'.format(wid, width, height, depth))
+                window_sizes[wid] = size
+        elif arr[0] == 'close':
+            wid = int(arr[1])
+            if wid not in window_sizes:
+                print('Unknown wid {}'.format(wid))
+            else:
+                conn.close_window(wid)
+                del window_sizes[wid]
+        elif arr[0] == 'flip':
+            wid = int(arr[1])
+            if wid not in window_sizes:
+                print('Unknown wid {}'.format(wid))
+            else:
+                w, h, d = window_sizes[wid]
+                w = (w + 15) & ~15
+                num_bytes = w * h * d // 8
+                buffer = bytes([random.randint(0, 255) for _ in range(num_bytes)])
+                conn.copy_flip_window(wid, buffer)
+        else:
+            print('Unknown command: {}'.format(arr[0]))
+    except Exception as e:
+        print('Caught exception:', e)
diff --git a/Software/aws/aws.c b/Software/aws/aws.c
new file mode 100644
index 0000000..edb0606
--- /dev/null
+++ b/Software/aws/aws.c
@@ -0,0 +1,537 @@
+/*
+ * Copyright (c) 2021 Niklas Ekström
+ */
+
+#include <exec/types.h>
+#include <exec/ports.h>
+#include <exec/tasks.h>
+#include <exec/nodes.h>
+#include <exec/lists.h>
+#include <exec/execbase.h>
+#include <exec/memory.h>
+#include <exec/interrupts.h>
+
+#include <libraries/dos.h>
+#include <intuition/intuition.h>
+#include <graphics/gfx.h>
+#include <hardware/intbits.h>
+
+#include <proto/exec.h>
+#include <proto/intuition.h>
+#include <proto/graphics.h>
+
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+
+#include "../a314device/a314.h"
+#include "../a314device/proto_a314.h"
+
+#define AWS_REQ_OPEN_WINDOW 1
+#define AWS_RES_OPEN_WINDOW_FAIL 2
+#define AWS_RES_OPEN_WINDOW_SUCCESS 3
+#define AWS_REQ_CLOSE_WINDOW 4
+#define AWS_REQ_FLIP_BUFFER 5
+#define AWS_REQ_WB_SCREEN_INFO 6
+#define AWS_RES_WB_SCREEN_INFO 7
+#define AWS_EVENT_CLOSE_WINDOW 8
+#define AWS_EVENT_FLIP_DONE 9
+
+struct WindowInfo
+{
+	struct WindowInfo *next;
+	struct WindowInfo *prev;
+	struct Window *window;
+	struct BitMap bm;
+	UBYTE *buffer;
+	UWORD buf_width;
+	UWORD buf_height;
+	UBYTE buf_depth;
+	UBYTE wid;
+	UBYTE redraw_after_vblank;
+	char title[65];
+};
+
+static struct WindowInfo *windows_head = NULL;
+static struct WindowInfo *windows_tail = NULL;
+
+struct VBlankData
+{
+	struct Task *task;
+	ULONG signal;
+};
+
+static struct VBlankData vblank_data;
+
+extern void VBlankServer();
+static struct Interrupt vblank_interrupt;
+
+struct Library *A314Base;
+struct IntuitionBase *IntuitionBase;
+struct GfxBase *GfxBase;
+
+static struct MsgPort *mp;
+static struct MsgPort *wmp;
+
+static struct A314_IORequest *cmsg;
+static struct A314_IORequest *rmsg;
+static struct A314_IORequest *wmsg;
+
+static ULONG socket;
+
+static UBYTE arbuf[256];
+static UBYTE awbuf[256];
+
+static BOOL pending_a314_read = FALSE;
+static BOOL pending_a314_write = FALSE;
+static BOOL pending_a314_reset = FALSE;
+
+static BOOL stream_closed = FALSE;
+
+static void start_a314_cmd(struct A314_IORequest *msg, UWORD command, char *buffer, int length)
+{
+	msg->a314_Request.io_Command = command;
+	msg->a314_Request.io_Error = 0;
+
+	msg->a314_Socket = socket;
+	msg->a314_Buffer = buffer;
+	msg->a314_Length = length;
+
+	SendIO((struct IORequest *)msg);
+}
+
+static LONG a314_connect(char *name)
+{
+	socket = time(NULL);
+	start_a314_cmd(cmsg, A314_CONNECT, name, strlen(name));
+	return WaitIO((struct IORequest *)cmsg);
+}
+
+static void start_a314_read()
+{
+	start_a314_cmd(rmsg, A314_READ, arbuf, 255);
+	pending_a314_read = TRUE;
+}
+
+static void wait_a314_write_complete()
+{
+	if (pending_a314_write)
+	{
+		WaitIO((struct IORequest *)wmsg);
+		pending_a314_write = FALSE;
+	}
+}
+
+static void start_a314_write(int length)
+{
+	start_a314_cmd(wmsg, A314_WRITE, awbuf, length);
+	pending_a314_write = TRUE;
+}
+
+static void start_a314_reset()
+{
+	start_a314_cmd(cmsg, A314_RESET, NULL, 0);
+	pending_a314_reset = TRUE;
+}
+
+static struct WindowInfo *find_window_by_id(ULONG wid)
+{
+	struct WindowInfo *wi = windows_head;
+	while (wi)
+	{
+		if (wi->wid == wid)
+			break;
+		wi = wi->next;
+	}
+	return wi;
+}
+
+static struct WindowInfo *find_window(struct Window *w)
+{
+	struct WindowInfo *wi = windows_head;
+	while (wi)
+	{
+		if (wi->window == w)
+			break;
+		wi = wi->next;
+	}
+	return wi;
+}
+
+static void append_window(struct WindowInfo *wi)
+{
+	wi->next = NULL;
+	wi->prev = windows_tail;
+	if (windows_tail)
+		windows_tail->next = wi;
+	else
+		windows_head = wi;
+	windows_tail = wi;
+}
+
+static void remove_window(struct WindowInfo *wi)
+{
+	if (wi->prev)
+		wi->prev->next = wi->next;
+	else
+		windows_head = wi->next;
+
+	if (wi->next)
+		wi->next->prev = wi->prev;
+	else
+		windows_tail = wi->prev;
+
+	wi->prev = NULL;
+	wi->next = NULL;
+}
+
+static void handle_req_open_window()
+{
+	struct WindowInfo *wi = (struct WindowInfo *)AllocMem(sizeof(struct WindowInfo), MEMF_CLEAR);
+
+	UBYTE wid = arbuf[1];
+	UWORD left = *(UWORD *)&arbuf[2];
+	UWORD top = *(UWORD *)&arbuf[4];
+	UWORD width = *(UWORD *)&arbuf[6];
+	UWORD height = *(UWORD *)&arbuf[8];
+
+	int title_len = rmsg->a314_Length - 10;
+	if (title_len > sizeof(wi->title) - 1)
+		title_len = sizeof(wi->title) - 1;
+	memcpy(wi->title, &arbuf[10], title_len);
+
+	struct NewWindow nw =
+	{
+		left, top,
+		width, height,
+		0, 1,
+		0,
+		WINDOWCLOSE | ACTIVATE | WINDOWDEPTH | WINDOWDRAG | SIMPLE_REFRESH,
+		NULL, NULL,
+		wi->title,
+		NULL, NULL,
+		0, 0,
+		0, 0,
+		WBENCHSCREEN
+	};
+
+	struct Window *w = OpenWindow(&nw);
+	if (w)
+	{
+		w->UserPort = mp;
+		ModifyIDCMP(w, CLOSEWINDOW | REFRESHWINDOW);
+
+		UWORD bw = w->Width - (w->BorderLeft + w->BorderRight);
+		UWORD bh = w->Height - (w->BorderTop + w->BorderBottom);
+		UWORD bd = w->WScreen->BitMap.Depth;
+
+		ULONG bpr = ((bw + 15) & ~15) >> 3;
+		wi->buffer = AllocMem(bpr * bh * bd, MEMF_A314 | MEMF_CHIP);
+		if (!wi->buffer)
+			CloseWindow(w);
+		else
+		{
+			wi->window = w;
+			wi->buf_width = bw;
+			wi->buf_height = bh;
+			wi->buf_depth = bd;
+			wi->wid = wid;
+
+			wi->bm.BytesPerRow = bpr;
+			wi->bm.Rows = bh;
+			wi->bm.Depth = bd;
+			for (int i = 0; i < bd; i++)
+				wi->bm.Planes[i] = wi->buffer + bpr * bh * i;
+
+			append_window(wi);
+
+			wait_a314_write_complete();
+
+			awbuf[0] = AWS_RES_OPEN_WINDOW_SUCCESS;
+			awbuf[1] = wid;
+			*(ULONG *)&awbuf[2] = TranslateAddressA314(wi->buffer);
+			*(UWORD *)&awbuf[6] = bw;
+			*(UWORD *)&awbuf[8] = bh;
+			*(UWORD *)&awbuf[10] = bd;
+			start_a314_write(12);
+			return;
+		}
+	}
+
+	FreeMem(wi, sizeof(struct WindowInfo));
+
+	wait_a314_write_complete();
+	awbuf[0] = AWS_RES_OPEN_WINDOW_FAIL;
+	awbuf[1] = wid;
+	start_a314_write(2);
+}
+
+static void close_window(struct WindowInfo *wi)
+{
+	remove_window(wi);
+
+	ULONG buffer_size = wi->bm.BytesPerRow * wi->bm.Rows * wi->bm.Depth;
+	FreeMem(wi->buffer, buffer_size);
+
+	wi->window->UserPort = NULL;
+	CloseWindow(wi->window);
+
+	FreeMem(wi, sizeof(struct WindowInfo));
+}
+
+static void handle_req_close_window()
+{
+	UBYTE wid = arbuf[1];
+	struct WindowInfo *wi = find_window_by_id(wid);
+	if (wi)
+		close_window(wi);
+}
+
+static void redraw_window(struct WindowInfo *wi)
+{
+	struct RastPort rp;
+	rp.Layer = NULL;
+	rp.BitMap = &wi->bm;
+	struct Window *w = wi->window;
+	ClipBlit(&rp, 0, 0, w->RPort, w->BorderLeft, w->BorderTop, wi->buf_width, wi->buf_height, 0xc0);
+}
+
+static void handle_req_flip_buffer()
+{
+	UBYTE wid = arbuf[1];
+	struct WindowInfo *wi = find_window_by_id(wid);
+	if (wi)
+		wi->redraw_after_vblank = 1;
+}
+
+static struct Screen *find_wb_screen()
+{
+	struct Screen *screen = IntuitionBase->FirstScreen;
+	while (screen)
+	{
+		if ((screen->Flags & SCREENTYPE) == WBENCHSCREEN)
+			return screen;
+		screen = screen->NextScreen;
+	}
+	return NULL;
+}
+
+static void handle_req_wb_screen_info()
+{
+	struct Screen *screen = find_wb_screen();
+
+	wait_a314_write_complete();
+
+	awbuf[0] = AWS_RES_WB_SCREEN_INFO;
+	awbuf[1] = 0;
+
+	UWORD *p = (UWORD *)&awbuf[2];
+	*p++ = screen->Width;
+	*p++ = screen->Height;
+	*p++ = screen->BitMap.Depth;
+
+	struct ColorMap *cm = screen->ViewPort.ColorMap;
+	int n = 1 << screen->BitMap.Depth;
+	if (n > cm->Count)
+		n = cm->Count;
+	for (int i = 0; i < n; i++)
+		*p++ = ((UWORD *)cm->ColorTable)[i] & 0xfff;
+
+	start_a314_write((UBYTE *)p - awbuf);
+}
+
+static void handle_intui_message(struct IntuiMessage *im)
+{
+	ULONG class = im->Class;
+	struct WindowInfo *wi = find_window(im->IDCMPWindow);
+	ReplyMsg((struct Message *)im);
+
+	switch (class)
+	{
+		case CLOSEWINDOW:
+			wait_a314_write_complete();
+			awbuf[0] = AWS_EVENT_CLOSE_WINDOW;
+			awbuf[1] = wi->wid;
+			start_a314_write(2);
+			break;
+
+		case REFRESHWINDOW:
+			BeginRefresh(wi->window);
+			redraw_window(wi);
+			EndRefresh(wi->window, TRUE);
+			break;
+	}
+}
+
+static void handle_a314_read_completed()
+{
+	pending_a314_read = FALSE;
+
+	if (stream_closed)
+		return;
+
+	int res = rmsg->a314_Request.io_Error;
+	if (res == A314_READ_OK)
+	{
+		switch (arbuf[0])
+		{
+			case AWS_REQ_OPEN_WINDOW:
+				handle_req_open_window();
+				break;
+			case AWS_REQ_CLOSE_WINDOW:
+				handle_req_close_window();
+				break;
+			case AWS_REQ_FLIP_BUFFER:
+				handle_req_flip_buffer();
+				break;
+			case AWS_REQ_WB_SCREEN_INFO:
+				handle_req_wb_screen_info();
+				break;
+		}
+
+		start_a314_read();
+	}
+	else if (res == A314_READ_EOS)
+	{
+		start_a314_reset();
+		stream_closed = TRUE;
+	}
+	else if (res == A314_READ_RESET)
+		stream_closed = TRUE;
+}
+
+static void handle_vblank()
+{
+	struct WindowInfo *wi = windows_head;
+	while (wi)
+	{
+		if (wi->redraw_after_vblank)
+			redraw_window(wi);
+
+		wi = wi->next;
+	}
+
+	wi = windows_head;
+	while (wi)
+	{
+		if (wi->redraw_after_vblank)
+		{
+			wait_a314_write_complete();
+			awbuf[0] = AWS_EVENT_FLIP_DONE;
+			awbuf[1] = wi->wid;
+			start_a314_write(2);
+
+			wi->redraw_after_vblank = 0;
+		}
+		wi = wi->next;
+	}
+}
+
+int main()
+{
+	LONG old_priority = SetTaskPri(FindTask(NULL), 20);
+
+	GfxBase = (struct GfxBase *)OpenLibrary("graphics.library", 0);
+	IntuitionBase = (struct IntuitionBase *)OpenLibrary("intuition.library", 0);
+
+	mp = CreatePort(NULL, 0);
+	wmp = CreatePort(NULL, 0);
+	cmsg = (struct A314_IORequest *)CreateExtIO(mp, sizeof(struct A314_IORequest));
+
+	if (OpenDevice(A314_NAME, 0, (struct IORequest *)cmsg, 0) != 0)
+	{
+		printf("Unable to open a314.device\n");
+		goto fail_out1;
+	}
+
+	A314Base = &(cmsg->a314_Request.io_Device->dd_Library);
+
+	rmsg = (struct A314_IORequest *)CreateExtIO(mp, sizeof(struct A314_IORequest));
+	wmsg = (struct A314_IORequest *)CreateExtIO(mp, sizeof(struct A314_IORequest));
+	memcpy(rmsg, cmsg, sizeof(struct A314_IORequest));
+	memcpy(wmsg, cmsg, sizeof(struct A314_IORequest));
+	wmsg->a314_Request.io_Message.mn_ReplyPort = wmp;
+
+	if (a314_connect("awsproxy") != A314_CONNECT_OK)
+	{
+		printf("Unable to connect to awsproxy\n");
+		goto fail_out2;
+	}
+
+	start_a314_read();
+
+	ULONG mp_sig = 1 << mp->mp_SigBit;
+	ULONG wmp_sig = 1 << wmp->mp_SigBit;
+
+	ULONG vblank_sigbit = AllocSignal(-1);
+	ULONG vblank_sig = 1 << vblank_sigbit;
+
+	vblank_data.task = FindTask(NULL);
+	vblank_data.signal = vblank_sig;
+
+	vblank_interrupt.is_Node.ln_Type = NT_INTERRUPT;
+	vblank_interrupt.is_Node.ln_Pri = 0;
+	vblank_interrupt.is_Node.ln_Name = "aws";
+	vblank_interrupt.is_Data = (APTR)&vblank_data;
+	vblank_interrupt.is_Code = VBlankServer;
+	AddIntServer(INTB_VERTB, &vblank_interrupt);
+
+	printf("Press ctrl-c to exit...\n");
+
+	while (TRUE)
+	{
+		ULONG signal = Wait(mp_sig | wmp_sig | vblank_sig | SIGBREAKF_CTRL_C);
+
+		if (signal & vblank_sig)
+			handle_vblank();
+
+		if (signal & wmp_sig)
+		{
+			struct Message *msg = GetMsg(wmp);
+			if (msg)
+				pending_a314_write = FALSE;
+		}
+
+		if (signal & mp_sig)
+		{
+			struct Message *msg;
+			while (msg = GetMsg(mp))
+			{
+				if (msg == (struct Message *)rmsg)
+					handle_a314_read_completed();
+				else if (msg == (struct Message *)cmsg)
+					pending_a314_reset = FALSE;
+				else
+					handle_intui_message((struct IntuiMessage *)msg);
+			}
+		}
+
+		if (signal & SIGBREAKF_CTRL_C)
+		{
+			start_a314_reset();
+			stream_closed = TRUE;
+		}
+
+		if (stream_closed && !pending_a314_read && !pending_a314_write && !pending_a314_reset)
+			break;
+	}
+
+	while (windows_head)
+		close_window(windows_head);
+
+	RemIntServer(INTB_VERTB, &vblank_interrupt);
+	FreeSignal(vblank_sigbit);
+
+fail_out2:
+	DeleteExtIO((struct IORequest *)wmsg);
+	DeleteExtIO((struct IORequest *)rmsg);
+	CloseDevice((struct IORequest *)cmsg);
+fail_out1:
+	DeleteExtIO((struct IORequest *)cmsg);
+	DeletePort(wmp);
+	DeletePort(mp);
+	CloseLibrary((struct Library *)IntuitionBase);
+	CloseLibrary((struct Library *)GfxBase);
+	SetTaskPri(FindTask(NULL), old_priority);
+	return 0;
+}
diff --git a/Software/aws/awslib.py b/Software/aws/awslib.py
new file mode 100644
index 0000000..89f4d55
--- /dev/null
+++ b/Software/aws/awslib.py
@@ -0,0 +1,158 @@
+#!/usr/bin/python3
+# -*- coding: utf-8 -*-
+
+# Copyright (c) 2021 Niklas Ekström
+
+import logging
+import os
+import select
+import socket
+import struct
+import sys
+import time
+import random
+import string
+import threading
+import queue
+
+logging.basicConfig(format = '%(levelname)s, %(asctime)s, %(name)s, line %(lineno)d: %(message)s')
+logger = logging.getLogger(__name__)
+logger.setLevel(logging.INFO)
+
+AWS_CLIENT_REQ_OPEN_WINDOW = 1
+AWS_CLIENT_RES_OPEN_WINDOW_FAIL = 2
+AWS_CLIENT_RES_OPEN_WINDOW_SUCCESS = 3
+AWS_CLIENT_REQ_CLOSE_WINDOW = 4
+AWS_CLIENT_REQ_COPY_FLIP_BUFFER = 5
+AWS_CLIENT_REQ_WB_SCREEN_INFO = 6
+AWS_CLIENT_RES_WB_SCREEN_INFO = 7
+AWS_CLIENT_EVENT_CLOSE_WINDOW = 8
+AWS_CLIENT_EVENT_FLIP_DONE = 9
+
+class Window(object):
+    def __init__(self, wid):
+        self.wid = wid
+        self.width = None
+        self.height = None
+        self.depth = None
+
+class Connection(threading.Thread):
+    def __init__(self, sock, callbacks):
+        super().__init__()
+        self.sock = sock
+        self.callbacks = callbacks
+        self.is_open = True
+        self.next_wid = 0
+        self.windows = {}
+        self.rbuf = None
+        self.sync_queue = queue.Queue()
+
+    def run(self):
+        while True:
+            rl, _, _ = select.select([self.sock], [], [])
+            if self.sock not in rl:
+                continue
+            if not self.handle_readable():
+                self.is_open = False
+                self.callbacks.connection_closed(self)
+                self.sync_queue.put(None)
+                self.sock.close()
+                break
+
+    def send(self, data):
+        data = struct.pack('=I', len(data)) + data
+        self.sock.sendall(data)
+
+    def close(self):
+        self.sock.shutdown(socket.SHUT_RDWR)
+        self.join(2.0)
+
+    def process_msg(self, msg):
+        cmd = msg[0]
+        if cmd in [AWS_CLIENT_RES_OPEN_WINDOW_FAIL, AWS_CLIENT_RES_OPEN_WINDOW_SUCCESS, AWS_CLIENT_RES_WB_SCREEN_INFO]:
+            self.sync_queue.put(msg)
+        elif cmd == AWS_CLIENT_EVENT_CLOSE_WINDOW:
+            wid = struct.unpack('=H', msg[1:3])[0]
+            self.callbacks.event_close_window(self, wid)
+        elif cmd == AWS_CLIENT_EVENT_FLIP_DONE:
+            wid = struct.unpack('=H', msg[1:3])[0]
+            self.callbacks.event_flip_done(self, wid)
+        else:
+            logger.error('Received unknown command %d, shutting down', cmd)
+            exit(-1)
+
+    def handle_readable(self):
+        buf = self.sock.recv(128)
+        if not buf:
+            self.sock.shutdown(socket.SHUT_RDWR)
+            return False
+
+        self.rbuf = self.rbuf + buf if self.rbuf else buf
+
+        while self.rbuf:
+            blen = len(self.rbuf)
+            if blen < 4:
+                break
+            plen = struct.unpack('=I', self.rbuf[:4])[0]
+            if blen < plen + 4:
+                break
+            msg = self.rbuf[4:plen + 4]
+            self.rbuf = None if blen == plen + 4 else self.rbuf[plen + 4:]
+            self.process_msg(msg)
+
+        return True
+
+    def get_wb_screen_info(self):
+        self.send(bytes([AWS_CLIENT_REQ_WB_SCREEN_INFO]))
+        msg = self.sync_queue.get()
+        if msg is None:
+            raise RuntimeError('Connection failed')
+        w, h, d = struct.unpack('=HHH', msg[1:7])
+        pal = msg[7:]
+        pal = [struct.unpack('=H', pal[2*i:2*(i+1)])[0] for i in range(len(pal) // 2)]
+        return (w, h, d, pal)
+
+    def open_window(self, left, top, width, height, title):
+        if not self.is_open:
+            return None, None
+
+        wid = self.next_wid
+        while wid in self.windows:
+            wid = (wid + 1) % 65536
+        self.next_wid = (wid + 1) % 65536
+        self.windows[wid] = Window(wid)
+        self.send(struct.pack('=BHHHHH', AWS_CLIENT_REQ_OPEN_WINDOW, wid, left, top, width, height) + title.encode('latin-1'))
+        msg = self.sync_queue.get()
+        if not msg:
+            raise RuntimeError('Connection failed')
+
+        cmd = msg[0]
+        if cmd == AWS_CLIENT_RES_OPEN_WINDOW_FAIL:
+            #wid = struct.unpack('=H', msg[1:3])[0]
+            del self.windows[wid]
+            return None, None
+        elif cmd == AWS_CLIENT_RES_OPEN_WINDOW_SUCCESS:
+            w = self.windows[wid]
+            _, w.width, w.height, w.depth = struct.unpack('=HHHH', msg[1:9])
+            return w.wid, (w.width, w.height, w.depth)
+        else:
+            raise RuntimeError('Invalid response')
+
+    def close_window(self, wid):
+        if not self.is_open or wid not in self.windows:
+            return
+        self.send(struct.pack('=BH', AWS_CLIENT_REQ_CLOSE_WINDOW, wid))
+        del self.windows[wid]
+
+    def copy_flip_window(self, wid, buffer):
+        if not self.is_open or wid not in self.windows:
+            return
+        self.send(struct.pack('=BH', AWS_CLIENT_REQ_COPY_FLIP_BUFFER, wid) + buffer)
+
+def connect(callbacks):
+    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+    sock.connect(('localhost', 18377))
+    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
+    conn = Connection(sock, callbacks)
+    conn.start()
+    return conn
diff --git a/Software/aws/awsproxy.py b/Software/aws/awsproxy.py
new file mode 100644
index 0000000..4b73608
--- /dev/null
+++ b/Software/aws/awsproxy.py
@@ -0,0 +1,374 @@
+#!/usr/bin/python3
+# -*- coding: utf-8 -*-
+
+# Copyright (c) 2021 Niklas Ekström
+
+import logging
+import os
+import select
+import socket
+import struct
+import sys
+import time
+
+logging.basicConfig(format = '%(levelname)s, %(asctime)s, %(name)s, line %(lineno)d: %(message)s')
+logger = logging.getLogger(__name__)
+logger.setLevel(logging.INFO)
+
+MSG_REGISTER_REQ        = 1
+MSG_REGISTER_RES        = 2
+MSG_DEREGISTER_REQ      = 3
+MSG_DEREGISTER_RES      = 4
+MSG_READ_MEM_REQ        = 5
+MSG_READ_MEM_RES        = 6
+MSG_WRITE_MEM_REQ       = 7
+MSG_WRITE_MEM_RES       = 8
+MSG_CONNECT             = 9
+MSG_CONNECT_RESPONSE    = 10
+MSG_DATA                = 11
+MSG_EOS                 = 12
+MSG_RESET               = 13
+
+def wait_for_msg(drv):
+    header = b''
+    while len(header) < 9:
+        data = drv.recv(9 - len(header))
+        if not data:
+            logger.error('Connection to a314d was closed, terminating.')
+            exit(-1)
+        header += data
+    (plen, stream_id, ptype) = struct.unpack('=IIB', header)
+    payload = b''
+    while len(payload) < plen:
+        data = drv.recv(plen - len(payload))
+        if not data:
+            logger.error('Connection to a314d was closed, terminating.')
+            exit(-1)
+        payload += data
+    return (stream_id, ptype, payload)
+
+def send_register_req(drv, name):
+    m = struct.pack('=IIB', len(name), 0, MSG_REGISTER_REQ) + name
+    drv.sendall(m)
+
+def send_read_mem_req(drv, address, length):
+    m = struct.pack('=IIBII', 8, 0, MSG_READ_MEM_REQ, address, length)
+    drv.sendall(m)
+
+def read_mem(drv, address, length):
+    send_read_mem_req(drv, address, length)
+    _, ptype, payload = wait_for_msg(drv)
+    if ptype != MSG_READ_MEM_RES:
+        logger.error('Expected MSG_READ_MEM_RES but got %s. Shutting down.', ptype)
+        exit(-1)
+    return payload
+
+def send_write_mem_req(drv, address, data):
+    m = struct.pack('=IIBI', 4 + len(data), 0, MSG_WRITE_MEM_REQ, address) + data
+    drv.sendall(m)
+
+def write_mem(drv, address, data):
+    send_write_mem_req(drv, address, data)
+    _, ptype, _ = wait_for_msg(drv)
+    if ptype != MSG_WRITE_MEM_RES:
+        logger.error('Expected MSG_WRITE_MEM_RES but got %s. Shutting down.', ptype)
+        exit(-1)
+
+def send_connect_response(drv, stream_id, result):
+    m = struct.pack('=IIBB', 1, stream_id, MSG_CONNECT_RESPONSE, result)
+    drv.sendall(m)
+
+def send_data(drv, stream_id, data):
+    m = struct.pack('=IIB', len(data), stream_id, MSG_DATA) + data
+    drv.sendall(m)
+
+def send_eos(drv, stream_id):
+    m = struct.pack('=IIB', 0, stream_id, MSG_EOS)
+    drv.sendall(m)
+
+def send_reset(drv, stream_id):
+    m = struct.pack('=IIB', 0, stream_id, MSG_RESET)
+    drv.sendall(m)
+
+### A314 communication routines above. Actual driver below.
+
+class Window(object):
+    def __init__(self, wid, cwid, c):
+        self.wid = wid
+        self.cwid = cwid
+        self.client = c
+        self.buffer_address = None
+
+class Client(object):
+    def __init__(self, sock):
+        self.sock = sock
+        self.rbuf = None
+        self.windows = {} # cwid -> window object.
+        self.waiting_for_wb_screen_info = False
+
+    def send(self, data):
+        data = struct.pack('=I', len(data)) + data
+        self.sock.sendall(data)
+
+    def fileno(self):
+        return self.sock.fileno()
+
+clients = []
+
+# wid -> window object.
+windows = {}
+
+next_window_id = 0
+
+def get_next_wid():
+    global next_window_id
+    wid = next_window_id
+    while wid in windows:
+        wid = (wid + 1) % 256
+    next_window_id = (wid + 1) % 256
+    return wid
+
+current_stream_id = None
+done = False
+rbuf = b''
+
+write_mem_reqs = []
+
+SERVICE_NAME = b'awsproxy'
+
+AWS_REQ_OPEN_WINDOW = 1
+AWS_RES_OPEN_WINDOW_FAIL = 2
+AWS_RES_OPEN_WINDOW_SUCCESS = 3
+AWS_REQ_CLOSE_WINDOW = 4
+AWS_REQ_FLIP_BUFFER = 5
+AWS_REQ_WB_SCREEN_INFO = 6
+AWS_RES_WB_SCREEN_INFO = 7
+AWS_EVENT_CLOSE_WINDOW = 8
+AWS_EVENT_FLIP_DONE = 9
+
+AWS_CLIENT_REQ_OPEN_WINDOW = 1
+AWS_CLIENT_RES_OPEN_WINDOW_FAIL = 2
+AWS_CLIENT_RES_OPEN_WINDOW_SUCCESS = 3
+AWS_CLIENT_REQ_CLOSE_WINDOW = 4
+AWS_CLIENT_REQ_COPY_FLIP_BUFFER = 5
+AWS_CLIENT_REQ_WB_SCREEN_INFO = 6
+AWS_CLIENT_RES_WB_SCREEN_INFO = 7
+AWS_CLIENT_EVENT_CLOSE_WINDOW = 8
+AWS_CLIENT_EVENT_FLIP_DONE = 9
+
+def process_drv_data(msg):
+    cmd = msg[0]
+    if cmd == AWS_RES_OPEN_WINDOW_FAIL:
+        wid = msg[1]
+        if wid in windows:
+            w = windows[wid]
+            c = w.client
+            c.send(struct.pack('=BH', AWS_CLIENT_RES_OPEN_WINDOW_FAIL, w.cwid))
+            del c.windows[w.cwid]
+            del windows[w.wid]
+    elif cmd == AWS_RES_OPEN_WINDOW_SUCCESS:
+        wid = msg[1]
+        if wid in windows:
+            w = windows[wid]
+            ba, width, height, depth = struct.unpack('>IHHH', msg[2:12])
+            w.buffer_address = ba
+            c = w.client
+            c.send(struct.pack('=BHHHH', AWS_CLIENT_RES_OPEN_WINDOW_SUCCESS, w.cwid, width, height, depth))
+    elif cmd == AWS_EVENT_CLOSE_WINDOW:
+        wid = msg[1]
+        if wid in windows:
+            w = windows[wid]
+            c = w.client
+            c.send(struct.pack('=BH', AWS_CLIENT_EVENT_CLOSE_WINDOW, w.cwid))
+    elif cmd == AWS_EVENT_FLIP_DONE:
+        wid = msg[1]
+        if wid in windows:
+            w = windows[wid]
+            c = w.client
+            c.send(struct.pack('=BH', AWS_CLIENT_EVENT_FLIP_DONE, w.cwid))
+    elif cmd == AWS_RES_WB_SCREEN_INFO:
+        width, height, depth = struct.unpack('>HHH', msg[2:8])
+        pal = list(msg[8:])
+        for i in range(len(pal) // 2):
+            pal[2*i], pal[2*i + 1] = pal[2*i + 1], pal[2*i]
+        pal = bytes(pal)
+        for c in clients:
+            if c.waiting_for_wb_screen_info:
+                c.send(struct.pack('=BHHH', AWS_CLIENT_RES_WB_SCREEN_INFO, width, height, depth) + pal)
+                c.waiting_for_wb_screen_info = False
+
+def process_write_mem_res():
+    wid = write_mem_reqs.pop(0)
+    if wid in windows:
+        send_data(drv, current_stream_id, struct.pack('>BB', AWS_REQ_FLIP_BUFFER, wid))
+
+def process_client_msg(c, msg):
+    cmd = msg[0]
+    if cmd == AWS_CLIENT_REQ_OPEN_WINDOW:
+        cwid, left, top, width, height = struct.unpack('=HHHHH', msg[1:11])
+        title = msg[11:]
+        w = Window(get_next_wid(), cwid, c)
+        c.windows[w.cwid] = w
+        windows[w.wid] = w
+        send_data(drv, current_stream_id, struct.pack('>BBHHHH', AWS_REQ_OPEN_WINDOW, w.wid, left, top, width, height) + title)
+    elif cmd == AWS_CLIENT_REQ_CLOSE_WINDOW:
+        cwid = struct.unpack('=H', msg[1:3])[0]
+        # TODO: Probably close connection to client if receives an invalid request?
+        if cwid in c.windows:
+            w = c.windows[cwid]
+            send_data(drv, current_stream_id, struct.pack('>BB', AWS_REQ_CLOSE_WINDOW, w.wid))
+            del c.windows[w.cwid]
+            del windows[w.wid]
+    elif cmd == AWS_CLIENT_REQ_COPY_FLIP_BUFFER:
+        cwid = struct.unpack('=H', msg[1:3])[0]
+        if cwid in c.windows:
+            w = c.windows[cwid]
+            write_mem_reqs.append(w.wid)
+            send_write_mem_req(drv, w.buffer_address, msg[3:])
+    elif cmd == AWS_CLIENT_REQ_WB_SCREEN_INFO:
+        c.waiting_for_wb_screen_info = True
+        send_data(drv, current_stream_id, bytes([AWS_REQ_WB_SCREEN_INFO]))
+
+def process_client_readable(c):
+    buf = c.sock.recv(128*1024)
+    if not buf:
+        logger.info('Client disconnected')
+        for w in c.windows.values():
+            send_data(drv, current_stream_id, struct.pack('>BB', AWS_REQ_CLOSE_WINDOW, w.wid))
+            del windows[w.wid]
+
+        c.sock.shutdown(socket.SHUT_RDWR)
+        c.sock.close()
+        clients.remove(c)
+        return
+
+    c.rbuf = c.rbuf + buf if c.rbuf else buf
+
+    while c.rbuf:
+        blen = len(c.rbuf)
+        if blen < 4:
+            break
+
+        plen = struct.unpack('=I', c.rbuf[:4])[0]
+        if blen < 4 + plen:
+            break
+
+        payload = c.rbuf[4:4+plen]
+        c.rbuf = None if blen == 4+plen else c.rbuf[4+plen:]
+
+        process_client_msg(c, payload)
+
+def process_incoming_connection():
+    sock, _ = server_socket.accept()
+    if current_stream_id is None:
+        logger.info('Rejected client connection since Amiga is not connected')
+        sock.close()
+    else:
+        logger.info('Accepted client connection')
+        sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
+        clients.append(Client(sock))
+
+def process_drv_msg(stream_id, ptype, payload):
+    global current_stream_id
+
+    if ptype == MSG_CONNECT:
+        if payload == SERVICE_NAME and current_stream_id is None:
+            logger.info('Amiga connected')
+            current_stream_id = stream_id
+            send_connect_response(drv, stream_id, 0)
+        else:
+            send_connect_response(drv, stream_id, 3)
+    elif ptype == MSG_WRITE_MEM_RES:
+        process_write_mem_res()
+    elif current_stream_id == stream_id:
+        if ptype == MSG_DATA:
+            process_drv_data(payload)
+        elif ptype == MSG_RESET:
+            current_stream_id = None
+            logger.info('Amiga disconnected')
+
+def process_drv_readable():
+    global done, rbuf
+
+    buf = drv.recv(1024)
+    if not buf:
+        done = True
+        return
+
+    rbuf += buf
+    while True:
+        if len(rbuf) < 9:
+            break
+
+        (plen, stream_id, ptype) = struct.unpack('=IIB', rbuf[:9])
+        if len(rbuf) < 9 + plen:
+            break
+
+        payload = rbuf[9:9+plen]
+        rbuf = rbuf[9+plen:]
+
+        process_drv_msg(stream_id, ptype, payload)
+
+try:
+    idx = sys.argv.index('-ondemand')
+except ValueError:
+    idx = -1
+
+if idx != -1:
+    fd = int(sys.argv[idx + 1])
+    drv = socket.socket(fileno=fd)
+else:
+    drv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+    drv.connect(('localhost', 7110))
+    drv.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
+
+    send_register_req(drv, SERVICE_NAME)
+    _, _, payload = wait_for_msg(drv)
+    if payload[0] != 1:
+        logger.error("Unable to register 'aws' with a314d, shutting down")
+        done = True
+
+if not done:
+    try:
+        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+        server_socket.bind(('localhost', 18377))
+        server_socket.listen()
+    except:
+        logger.error('Unable to bind server socket to TCP port localhost:18377')
+        done = True
+
+if not done:
+    logger.info('awsproxy is running')
+
+while not done:
+    try:
+        rl = [drv, server_socket] + clients
+        rl, _, _ = select.select(rl, [], [], 10.0)
+    except KeyboardInterrupt:
+        rl = []
+        done = True
+
+    for sock in rl:
+        if sock == drv:
+            process_drv_readable()
+        elif sock == server_socket:
+            process_incoming_connection()
+        else:
+            process_client_readable(sock)
+
+for c in clients:
+    # No need to close windows, as they will all be closed when stream is reset.
+    c.sock.shutdown(socket.SHUT_RDWR)
+    c.sock.close()
+
+if server_socket:
+    server_socket.close()
+    server_socket = None
+
+if drv:
+    if current_stream_id is not None:
+        send_reset(drv, current_stream_id)
+    drv.close()
+    drv = None
+
+logger.info('awsproxy stopped')
diff --git a/Software/aws/build.bat b/Software/aws/build.bat
new file mode 100644
index 0000000..1a638a0
--- /dev/null
+++ b/Software/aws/build.bat
@@ -0,0 +1 @@
+vc aws.c vblank_server.asm -O3 -lamiga -o aws
diff --git a/Software/aws/vblank_server.asm b/Software/aws/vblank_server.asm
new file mode 100644
index 0000000..14a0c24
--- /dev/null
+++ b/Software/aws/vblank_server.asm
@@ -0,0 +1,18 @@
+
+	XDEF	_VBlankServer
+	CODE
+
+;struct VBlankData
+;{
+;	struct Task *task;
+;	ULONG signal;
+;};
+
+	; a1 points to VBlankData structure
+_VBlankServer:
+	move.l	$4.w,a6
+	move.l	4(a1),d0	; signal
+	move.l	0(a1),a1	; task
+	jsr	-324(a6)
+	moveq	#0,d0
+	rts
