From e7b2c12501c9a2e258ee9654eced85f07e239bfb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Niklas=20Ekstr=C3=B6m?= <mail@niklasekstrom.nu>
Date: Tue, 5 Jan 2021 14:22:55 +0100
Subject: [PATCH 1/6] Add Amiga Window Server (AWS)


diff --git a/Software/Makefile b/Software/Makefile
index fd0e3a4..e93fba8 100644
--- a/Software/Makefile
+++ b/Software/Makefile
@@ -3,7 +3,7 @@
 CPP=g++
 VC=vc
 
-all: bin_dir bin/a314d bin/a314.device bin/a314fs bin/pi bin/piaudio bin/remotewb bin/remote-mouse bin/videoplayer bin/diag bin/a314eth.device
+all: bin_dir bin/a314d bin/a314.device bin/a314fs bin/pi bin/piaudio bin/remotewb bin/remote-mouse bin/videoplayer bin/diag bin/a314eth.device bin/aws
 
 bin_dir:
 	mkdir -p bin
@@ -42,6 +42,9 @@ bin/diag: diag/diag.c
 bin/a314eth.device: a314device/a314.h a314device/proto_a314.h ethernet/romtag.asm ethernet/device.c ethernet/sana2.h ethernet/tagitem.h
 	${VC} ethernet/romtag.asm ethernet/device.c -O3 -nostdlib -o bin/a314eth.device -lamiga
 
+bin/aws: aws/aws.c
+	${VC} aws/aws.c -O3 -lamiga -o bin/aws
+
 install: all
 	mkdir -p /opt/a314
 	cp bin/a314d /opt/a314
@@ -52,6 +55,7 @@ install: all
 	cp remote-mouse/remote-mouse.py /opt/a314
 	cp videoplayer/videoplayer.py /opt/a314
 	cp ethernet/ethernet.py /opt/a314
+	cp aws/awsproxy.py /opt/a314
 	mkdir -p /etc/opt/a314
 	cp a314d/a314d.conf /etc/opt/a314
 	cp a314fs/a314fs.conf /etc/opt/a314
diff --git a/Software/a314d/a314d.conf b/Software/a314d/a314d.conf
index 03f2bb9..0048a1b 100644
--- a/Software/a314d/a314d.conf
+++ b/Software/a314d/a314d.conf
@@ -5,3 +5,4 @@ remotewb	python3	/opt/a314/remotewb.py
 remote-mouse	python3	/opt/a314/remote-mouse.py
 videoplayer	python3	/opt/a314/videoplayer.py
 ethernet	python3	/opt/a314/ethernet.py
+awsproxy	python3	/opt/a314/awsproxy.py
diff --git a/Software/aws/app.py b/Software/aws/app.py
new file mode 100644
index 0000000..d9c4afc
--- /dev/null
+++ b/Software/aws/app.py
@@ -0,0 +1,85 @@
+#!/usr/bin/python3
+# -*- coding: utf-8 -*-
+
+# Copyright (c) 2021 Niklas Ekström
+
+import awslib
+import random
+import select
+import socket
+import sys
+
+window_sizes = {}
+
+class ConnectionCallbacks(object):
+    def open_window_fail(self, conn, wid):
+        print('Window {} failed to open'.format(wid))
+
+    def open_window_success(self, conn, wid, width, height, depth):
+        print('Window {} opened successfully with size {}x{}x{}'.format(wid, width, height, depth))
+        window_sizes[wid] = (width, height, depth)
+
+    def event_close_window(self, conn, wid):
+        print('Close button clicked for window {}'.format(wid))
+
+conn = awslib.connect(ConnectionCallbacks())
+if conn is None:
+    print("Failed to connect to AWS")
+    exit(-1)
+
+def print_help():
+    print("Possible commands:")
+    print("  open <x> <y> <w> <h> <title>")
+    print("  close <wid>")
+    print("  flip <wid>")
+    print("  help")
+    print("  quit")
+
+print("Connected to AWS")
+print("Enter command (open/close/flip/help/quit):")
+
+while True:
+    rl = [sys.stdin, conn]
+    try:
+        rl, _, _ = select.select(rl, [], [])
+    except KeyboardInterrupt:
+        conn.close()
+        break
+
+    if conn in rl:
+        conn.handle_readable()
+
+    if sys.stdin in rl:
+        arr = sys.stdin.readline().strip().split()
+        try:
+            if arr[0] == 'quit':
+                conn.close()
+                break
+            elif arr[0] == 'help':
+                print_help()
+            elif arr[0] == 'open':
+                x, y, w, h = int(arr[1]), int(arr[2]), int(arr[3]), int(arr[4])
+                title = ' '.join(arr[5:])
+                wid = conn.open_window(x, y, w, h, title)
+                print('open_window returned wid {}'.format(wid))
+            elif arr[0] == 'close':
+                wid = int(arr[1])
+                if wid not in window_sizes:
+                    print('Unknown wid {}'.format(wid))
+                else:
+                    conn.close_window(wid)
+                    del window_sizes[wid]
+            elif arr[0] == 'flip':
+                wid = int(arr[1])
+                if wid not in window_sizes:
+                    print('Unknown wid {}'.format(wid))
+                else:
+                    w, h, d = window_sizes[wid]
+                    w = (w + 15) & ~15
+                    pixels = w * h * d
+                    buffer = bytes([random.randint(0, 255) for _ in range(pixels // 8)])
+                    conn.copy_flip_window(wid, buffer)
+            else:
+                print('Unknown command: {}'.format(arr[0]))
+        except Exception as e:
+            print('Caught exception:', e)
diff --git a/Software/aws/aws.c b/Software/aws/aws.c
new file mode 100644
index 0000000..c9203c3
--- /dev/null
+++ b/Software/aws/aws.c
@@ -0,0 +1,443 @@
+/*
+ * Copyright (c) 2021 Niklas Ekström
+ */
+
+#include <exec/types.h>
+#include <exec/ports.h>
+#include <exec/tasks.h>
+#include <exec/nodes.h>
+#include <exec/lists.h>
+#include <exec/execbase.h>
+#include <exec/memory.h>
+
+#include <libraries/dos.h>
+#include <intuition/intuition.h>
+#include <graphics/gfx.h>
+
+#include <proto/exec.h>
+#include <proto/intuition.h>
+#include <proto/graphics.h>
+
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+
+#include "../a314device/a314.h"
+#include "../a314device/proto_a314.h"
+
+#define AWS_REQ_OPEN_WINDOW 1
+#define AWS_REQ_CLOSE_WINDOW 2
+#define AWS_REQ_FLIP_BUFFER 3
+#define AWS_RES_OPEN_WINDOW_FAIL 4
+#define AWS_RES_OPEN_WINDOW_SUCCESS 5
+#define AWS_EVENT_CLOSE_WINDOW 6
+
+struct WindowInfo
+{
+	struct WindowInfo *next;
+	struct WindowInfo *prev;
+	struct Window *window;
+	struct BitMap bm;
+	UBYTE *buffer;
+	UWORD buf_width;
+	UWORD buf_height;
+	UBYTE buf_depth;
+	UBYTE wid;
+	char title[128];
+};
+
+struct WindowInfo *windows_head = NULL;
+struct WindowInfo *windows_tail = NULL;
+
+struct MsgPort *mp;
+struct MsgPort *wmp;
+
+ULONG socket;
+
+struct Library *A314Base;
+struct IntuitionBase *IntuitionBase;
+struct GfxBase *GfxBase;
+
+struct A314_IORequest *cmsg;
+struct A314_IORequest *rmsg;
+struct A314_IORequest *wmsg;
+
+UBYTE arbuf[256];
+UBYTE awbuf[256];
+
+BOOL pending_a314_read = FALSE;
+BOOL pending_a314_write = FALSE;
+BOOL pending_a314_reset = FALSE;
+
+BOOL stream_closed = FALSE;
+
+void start_a314_cmd(struct A314_IORequest *msg, UWORD command, char *buffer, int length)
+{
+	msg->a314_Request.io_Command = command;
+	msg->a314_Request.io_Error = 0;
+
+	msg->a314_Socket = socket;
+	msg->a314_Buffer = buffer;
+	msg->a314_Length = length;
+
+	SendIO((struct IORequest *)msg);
+}
+
+LONG a314_connect(char *name)
+{
+	socket = time(NULL);
+	start_a314_cmd(cmsg, A314_CONNECT, name, strlen(name));
+	return WaitIO((struct IORequest *)cmsg);
+}
+
+void start_a314_read()
+{
+	start_a314_cmd(rmsg, A314_READ, arbuf, 255);
+	pending_a314_read = TRUE;
+}
+
+void wait_a314_write_complete()
+{
+	if (pending_a314_write)
+	{
+		WaitIO((struct IORequest *)wmsg);
+		pending_a314_write = FALSE;
+	}
+}
+
+void start_a314_write(int length)
+{
+	start_a314_cmd(wmsg, A314_WRITE, awbuf, length);
+	pending_a314_write = TRUE;
+}
+
+LONG sync_a314_write(int length)
+{
+	start_a314_write(length);
+	pending_a314_write = FALSE;
+	return WaitIO((struct IORequest *)wmsg);
+}
+
+void start_a314_reset()
+{
+	start_a314_cmd(cmsg, A314_RESET, NULL, 0);
+	pending_a314_reset = TRUE;
+}
+
+LONG sync_a314_reset()
+{
+	start_a314_reset();
+	pending_a314_reset = FALSE;
+	return WaitIO((struct IORequest *)cmsg);
+}
+
+struct WindowInfo *find_window_by_id(ULONG wid)
+{
+	struct WindowInfo *wi = windows_head;
+	while (wi)
+	{
+		if (wi->wid == wid)
+			return wi;
+		wi = wi->next;
+	}
+	return wi;
+}
+
+struct WindowInfo *find_window(struct Window *w)
+{
+	struct WindowInfo *wi = windows_head;
+	while (wi)
+	{
+		if (wi->window == w)
+			return wi;
+		wi = wi->next;
+	}
+	return wi;
+}
+
+void append_window(struct WindowInfo *wi)
+{
+	wi->next = NULL;
+	wi->prev = windows_tail;
+	if (windows_tail)
+		windows_tail->next = wi;
+	else
+		windows_head = wi;
+	windows_tail = wi;
+}
+
+void remove_window(struct WindowInfo *wi)
+{
+	if (wi->prev)
+		wi->prev->next = wi->next;
+	else
+		windows_head = wi->next;
+
+	if (wi->next)
+		wi->next->prev = wi->prev;
+	else
+		windows_tail = wi->prev;
+
+	wi->prev = NULL;
+	wi->next = NULL;
+}
+
+void handle_req_open_window()
+{
+	struct WindowInfo *wi = (struct WindowInfo *)AllocMem(sizeof(struct WindowInfo), MEMF_CLEAR);
+
+	UBYTE wid = arbuf[1];
+	UWORD left = *(UWORD *)&arbuf[2];
+	UWORD top = *(UWORD *)&arbuf[4];
+	UWORD width = *(UWORD *)&arbuf[6];
+	UWORD height = *(UWORD *)&arbuf[8];
+	memcpy(wi->title, &arbuf[10], rmsg->a314_Length - 10);
+
+	struct NewWindow nw =
+	{
+		left, top,
+		width, height,
+		0, 1,
+		0,
+		WINDOWCLOSE | ACTIVATE | WINDOWDEPTH | WINDOWDRAG | SIMPLE_REFRESH,
+		NULL, NULL,
+		wi->title,
+		NULL, NULL,
+		0, 0,
+		0, 0,
+		WBENCHSCREEN
+	};
+
+	struct Window *w = OpenWindow(&nw);
+	if (w)
+	{
+		w->UserPort = mp;
+		ModifyIDCMP(w, CLOSEWINDOW | REFRESHWINDOW);
+
+		UWORD bw = w->Width - (w->BorderLeft + w->BorderRight);
+		UWORD bh = w->Height - (w->BorderTop + w->BorderBottom);
+		UWORD bd = w->WScreen->BitMap.Depth;
+
+		ULONG bpr = ((bw + 15) & ~15) >> 3;
+		void *buffer = AllocMem(bpr * bh * bd, MEMF_A314 | MEMF_CHIP);
+		if (!buffer)
+			CloseWindow(w);
+		else
+		{
+			wi->window = w;
+			wi->buffer = buffer;
+			wi->buf_width = bw;
+			wi->buf_height = bh;
+			wi->buf_depth = bd;
+			wi->wid = wid;
+
+			wi->bm.BytesPerRow = bpr;
+			wi->bm.Rows = bh;
+			wi->bm.Depth = bd;
+			for (int i = 0; i < bd; i++)
+				wi->bm.Planes[i] = wi->buffer + bpr * bh * i;
+
+			append_window(wi);
+
+			wait_a314_write_complete();
+
+			awbuf[0] = AWS_RES_OPEN_WINDOW_SUCCESS;
+			awbuf[1] = wid;
+			*(ULONG *)&awbuf[2] = TranslateAddressA314(buffer);
+			*(UWORD *)&awbuf[6] = bw;
+			*(UWORD *)&awbuf[8] = bh;
+			*(UWORD *)&awbuf[10] = bd;
+			start_a314_write(12);
+			return;
+		}
+	}
+
+	FreeMem(wi, sizeof(struct WindowInfo));
+
+	wait_a314_write_complete();
+
+	awbuf[0] = AWS_RES_OPEN_WINDOW_FAIL;
+	awbuf[1] = wid;
+	start_a314_write(2);
+}
+
+void handle_req_close_window()
+{
+	UBYTE wid = arbuf[1];
+	struct WindowInfo *wi = find_window_by_id(wid);
+	if (!wi)
+		return;
+
+	remove_window(wi);
+
+	ULONG pixels = wi->buf_width;
+	pixels = (pixels + 15) & ~15;
+	pixels = pixels * wi->buf_height * wi->buf_depth;
+	FreeMem(wi->buffer, pixels >> 3);
+
+	wi->window->UserPort = NULL;
+	CloseWindow(wi->window);
+
+	FreeMem(wi, sizeof(struct WindowInfo));
+}
+
+void redraw_window(struct WindowInfo *wi)
+{
+	struct RastPort rp;
+	rp.Layer = NULL;
+	rp.BitMap = &wi->bm;
+	struct Window *w = wi->window;
+	ClipBlit(&rp, 0, 0, w->RPort, w->BorderLeft, w->BorderTop, wi->buf_width, wi->buf_height, 0xc0);
+}
+
+void handle_req_flip_buffer()
+{
+	UBYTE wid = arbuf[1];
+	struct WindowInfo *wi = find_window_by_id(wid);
+	if (wi)
+		redraw_window(wi);
+}
+
+void handle_intui_message(struct IntuiMessage *im)
+{
+	ULONG class = im->Class;
+	struct WindowInfo *wi = find_window(im->IDCMPWindow);
+	ReplyMsg((struct Message *)im);
+
+	switch (class)
+	{
+		case CLOSEWINDOW:
+			wait_a314_write_complete();
+			awbuf[0] = AWS_EVENT_CLOSE_WINDOW;
+			awbuf[1] = wi->wid;
+			start_a314_write(2);
+			break;
+
+		case REFRESHWINDOW:
+			BeginRefresh(wi->window);
+			redraw_window(wi);
+			EndRefresh(wi->window, TRUE);
+			break;
+	}
+}
+
+void handle_a314_read_completed()
+{
+	pending_a314_read = FALSE;
+
+	if (stream_closed)
+		return;
+
+	int res = rmsg->a314_Request.io_Error;
+	if (res == A314_READ_OK)
+	{
+		switch (arbuf[0])
+		{
+			case AWS_REQ_OPEN_WINDOW:
+				handle_req_open_window();
+				break;
+			case AWS_REQ_CLOSE_WINDOW:
+				handle_req_close_window();
+				break;
+			case AWS_REQ_FLIP_BUFFER:
+				handle_req_flip_buffer();
+				break;
+		}
+
+		start_a314_read();
+	}
+	else if (res == A314_READ_EOS)
+	{
+		start_a314_reset();
+		stream_closed = TRUE;
+	}
+	else if (res == A314_READ_RESET)
+		stream_closed = TRUE;
+}
+
+int main()
+{
+	LONG old_priority = SetTaskPri(FindTask(NULL), 20);
+
+	GfxBase = (struct GfxBase *)OpenLibrary("graphics.library", 0);
+	IntuitionBase = (struct IntuitionBase *)OpenLibrary("intuition.library", 0);
+
+	mp = CreatePort(NULL, 0);
+	wmp = CreatePort(NULL, 0);
+	cmsg = (struct A314_IORequest *)CreateExtIO(mp, sizeof(struct A314_IORequest));
+
+	if (OpenDevice(A314_NAME, 0, (struct IORequest *)cmsg, 0) != 0)
+	{
+		printf("Unable to open a314.device\n");
+		goto fail_out1;
+	}
+
+	A314Base = &(cmsg->a314_Request.io_Device->dd_Library);
+
+	rmsg = (struct A314_IORequest *)CreateExtIO(mp, sizeof(struct A314_IORequest));
+	wmsg = (struct A314_IORequest *)CreateExtIO(mp, sizeof(struct A314_IORequest));
+	memcpy(rmsg, cmsg, sizeof(struct A314_IORequest));
+	memcpy(wmsg, cmsg, sizeof(struct A314_IORequest));
+	wmsg->a314_Request.io_Message.mn_ReplyPort = wmp;
+
+	if (a314_connect("awsproxy") != A314_CONNECT_OK)
+	{
+		printf("Unable to connect to awsproxy\n");
+		goto fail_out2;
+	}
+
+	start_a314_read();
+
+	ULONG mp_sig = 1 << mp->mp_SigBit;
+	ULONG wmp_sig = 1 << wmp->mp_SigBit;
+
+	printf("Press ctrl-c to exit...\n");
+
+	while (TRUE)
+	{
+		ULONG signal = Wait(mp_sig | wmp_sig | SIGBREAKF_CTRL_C);
+
+		if (signal & wmp_sig)
+		{
+			struct Message *msg = GetMsg(wmp);
+			if (msg)
+				pending_a314_write = FALSE;
+		}
+
+		if (signal & mp_sig)
+		{
+			struct Message *msg;
+			while (msg = GetMsg(mp))
+			{
+				if (msg == (struct Message *)rmsg)
+					handle_a314_read_completed();
+				else if (msg == (struct Message *)cmsg)
+					pending_a314_reset = FALSE;
+				else
+					handle_intui_message((struct IntuiMessage *)msg);
+			}
+		}
+
+		if (signal & SIGBREAKF_CTRL_C)
+		{
+			start_a314_reset();
+			stream_closed = TRUE;
+		}
+
+		if (stream_closed && !pending_a314_read && !pending_a314_write && !pending_a314_reset)
+			break;
+	}
+
+fail_out2:
+	DeleteExtIO((struct IORequest *)wmsg);
+	DeleteExtIO((struct IORequest *)rmsg);
+	CloseDevice((struct IORequest *)cmsg);
+fail_out1:
+	DeleteExtIO((struct IORequest *)cmsg);
+	DeletePort(wmp);
+	DeletePort(mp);
+	CloseLibrary((struct Library *)IntuitionBase);
+	CloseLibrary((struct Library *)GfxBase);
+	SetTaskPri(FindTask(NULL), old_priority);
+	return 0;
+}
diff --git a/Software/aws/awslib.py b/Software/aws/awslib.py
new file mode 100644
index 0000000..406ec2a
--- /dev/null
+++ b/Software/aws/awslib.py
@@ -0,0 +1,117 @@
+#!/usr/bin/python3
+# -*- coding: utf-8 -*-
+
+# Copyright (c) 2021 Niklas Ekström
+
+import logging
+import os
+import select
+import socket
+import struct
+import sys
+import time
+import random
+import string
+
+logging.basicConfig(format = '%(levelname)s, %(asctime)s, %(name)s, line %(lineno)d: %(message)s')
+logger = logging.getLogger(__name__)
+logger.setLevel(logging.INFO)
+
+AWS_CLIENT_REQ_OPEN_WINDOW = 1
+AWS_CLIENT_REQ_CLOSE_WINDOW = 2
+AWS_CLIENT_REQ_COPY_FLIP_BUFFER = 3
+AWS_CLIENT_RES_OPEN_WINDOW_FAIL = 4
+AWS_CLIENT_RES_OPEN_WINDOW_SUCCESS = 5
+AWS_CLIENT_EVENT_CLOSE_WINDOW = 6
+
+class Window(object):
+    def __init__(self, wid):
+        self.wid = wid
+        self.width = None
+        self.height = None
+        self.depth = None
+
+class Connection(object):
+    def __init__(self, sock, callbacks):
+        self.sock = sock
+        self.callbacks = callbacks
+        self.next_wid = 0
+        self.windows = {}
+        self.rbuf = None
+
+    def fileno(self):
+        return self.sock.fileno()
+
+    def send(self, data):
+        data = struct.pack('=I', len(data)) + data
+        self.sock.sendall(data)
+
+    def close(self):
+        self.sock.shutdown(socket.SHUT_RDWR)
+        self.sock.close()
+
+    def open_window(self, left, top, width, height, title):
+        wid = self.next_wid
+        while wid in self.windows:
+            wid = (wid + 1) % 65536
+        self.next_wid = (wid + 1) % 65536
+        self.windows[wid] = Window(wid)
+        self.send(struct.pack('=BHHHHH', AWS_CLIENT_REQ_OPEN_WINDOW, wid, left, top, width, height) + title.encode('latin-1'))
+        return wid
+
+    def close_window(self, wid):
+        if wid in self.windows:
+            self.send(struct.pack('=BH', AWS_CLIENT_REQ_CLOSE_WINDOW, wid))
+            del self.windows[wid]
+
+    def copy_flip_window(self, wid, buffer):
+        if wid in self.windows:
+            self.send(struct.pack('=BH', AWS_CLIENT_REQ_COPY_FLIP_BUFFER, wid) + buffer)
+
+    def process_msg(self, msg):
+        cmd = msg[0]
+        if cmd == AWS_CLIENT_RES_OPEN_WINDOW_FAIL:
+            wid = struct.unpack('=H', msg[1:3])[0]
+            if wid in self.windows:
+                self.callbacks.open_window_fail(self, wid)
+                del self.windows[wid]
+        elif cmd == AWS_CLIENT_RES_OPEN_WINDOW_SUCCESS:
+            wid, width, height, depth = struct.unpack('=HHHH', msg[1:9])
+            if wid in self.windows:
+                w = self.windows[wid]
+                w.width = width
+                w.height = height
+                w.depth = depth
+                self.callbacks.open_window_success(self, wid, width, height, depth)
+        elif cmd == AWS_CLIENT_EVENT_CLOSE_WINDOW:
+            wid = struct.unpack('=H', msg[1:3])[0]
+            if wid in self.windows:
+                self.callbacks.event_close_window(self, wid)
+
+    def handle_readable(self):
+        buf = self.sock.recv(128)
+        if not buf:
+            self.sock.shutdown(socket.SHUT_RDWR)
+            self.sock.close()
+            self.sock = None
+            self.callbacks.connection_closed(self)
+            return
+
+        self.rbuf = self.rbuf + buf if self.rbuf else buf
+
+        while self.rbuf:
+            blen = len(self.rbuf)
+            if blen < 4:
+                break
+            plen = struct.unpack('=I', self.rbuf[:4])[0]
+            if blen < plen + 4:
+                break
+            msg = self.rbuf[4:plen + 4]
+            self.rbuf = None if blen == plen + 4 else self.rbuf[plen + 4:]
+            self.process_msg(msg)
+
+def connect(callbacks):
+    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+    sock.connect(('localhost', 18377))
+    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
+    return Connection(sock, callbacks)
diff --git a/Software/aws/awsproxy.py b/Software/aws/awsproxy.py
new file mode 100644
index 0000000..680b814
--- /dev/null
+++ b/Software/aws/awsproxy.py
@@ -0,0 +1,349 @@
+#!/usr/bin/python3
+# -*- coding: utf-8 -*-
+
+# Copyright (c) 2021 Niklas Ekström
+
+import logging
+import os
+import select
+import socket
+import struct
+import sys
+import time
+
+logging.basicConfig(format = '%(levelname)s, %(asctime)s, %(name)s, line %(lineno)d: %(message)s')
+logger = logging.getLogger(__name__)
+logger.setLevel(logging.INFO)
+
+MSG_REGISTER_REQ        = 1
+MSG_REGISTER_RES        = 2
+MSG_DEREGISTER_REQ      = 3
+MSG_DEREGISTER_RES      = 4
+MSG_READ_MEM_REQ        = 5
+MSG_READ_MEM_RES        = 6
+MSG_WRITE_MEM_REQ       = 7
+MSG_WRITE_MEM_RES       = 8
+MSG_CONNECT             = 9
+MSG_CONNECT_RESPONSE    = 10
+MSG_DATA                = 11
+MSG_EOS                 = 12
+MSG_RESET               = 13
+
+def wait_for_msg(drv):
+    header = b''
+    while len(header) < 9:
+        data = drv.recv(9 - len(header))
+        if not data:
+            logger.error('Connection to a314d was closed, terminating.')
+            exit(-1)
+        header += data
+    (plen, stream_id, ptype) = struct.unpack('=IIB', header)
+    payload = b''
+    while len(payload) < plen:
+        data = drv.recv(plen - len(payload))
+        if not data:
+            logger.error('Connection to a314d was closed, terminating.')
+            exit(-1)
+        payload += data
+    return (stream_id, ptype, payload)
+
+def send_register_req(drv, name):
+    m = struct.pack('=IIB', len(name), 0, MSG_REGISTER_REQ) + name
+    drv.sendall(m)
+
+def send_read_mem_req(drv, address, length):
+    m = struct.pack('=IIBII', 8, 0, MSG_READ_MEM_REQ, address, length)
+    drv.sendall(m)
+
+def read_mem(drv, address, length):
+    send_read_mem_req(drv, address, length)
+    _, ptype, payload = wait_for_msg(drv)
+    if ptype != MSG_READ_MEM_RES:
+        logger.error('Expected MSG_READ_MEM_RES but got %s. Shutting down.', ptype)
+        exit(-1)
+    return payload
+
+def send_write_mem_req(drv, address, data):
+    m = struct.pack('=IIBI', 4 + len(data), 0, MSG_WRITE_MEM_REQ, address) + data
+    drv.sendall(m)
+
+def write_mem(drv, address, data):
+    send_write_mem_req(drv, address, data)
+    _, ptype, _ = wait_for_msg(drv)
+    if ptype != MSG_WRITE_MEM_RES:
+        logger.error('Expected MSG_WRITE_MEM_RES but got %s. Shutting down.', ptype)
+        exit(-1)
+
+def send_connect_response(drv, stream_id, result):
+    m = struct.pack('=IIBB', 1, stream_id, MSG_CONNECT_RESPONSE, result)
+    drv.sendall(m)
+
+def send_data(drv, stream_id, data):
+    m = struct.pack('=IIB', len(data), stream_id, MSG_DATA) + data
+    drv.sendall(m)
+
+def send_eos(drv, stream_id):
+    m = struct.pack('=IIB', 0, stream_id, MSG_EOS)
+    drv.sendall(m)
+
+def send_reset(drv, stream_id):
+    m = struct.pack('=IIB', 0, stream_id, MSG_RESET)
+    drv.sendall(m)
+
+### A314 communication routines above. Actual driver below.
+
+class Window(object):
+    def __init__(self, wid, cwid, c):
+        self.wid = wid
+        self.cwid = cwid
+        self.client = c
+        self.buffer_address = None
+
+class Client(object):
+    def __init__(self, sock):
+        self.sock = sock
+        self.rbuf = None
+        self.windows = {} # cwid -> window object.
+
+    def send(self, data):
+        data = struct.pack('=I', len(data)) + data
+        self.sock.sendall(data)
+
+    def fileno(self):
+        return self.sock.fileno()
+
+clients = []
+
+# wid -> window object.
+windows = {}
+
+next_window_id = 0
+
+def get_next_wid():
+    global next_window_id
+    wid = next_window_id
+    while wid in windows:
+        wid = (wid + 1) % 256
+    next_window_id = (wid + 1) % 256
+    return wid
+
+current_stream_id = None
+done = False
+rbuf = b''
+
+write_mem_reqs = []
+
+SERVICE_NAME = b'awsproxy'
+
+AWS_REQ_OPEN_WINDOW = 1
+AWS_REQ_CLOSE_WINDOW = 2
+AWS_REQ_FLIP_BUFFER = 3
+AWS_RES_OPEN_WINDOW_FAIL = 4
+AWS_RES_OPEN_WINDOW_SUCCESS = 5
+AWS_EVENT_CLOSE_WINDOW = 6
+
+# Definiera de olika meddelandena som går mellan klient och awsproxy.
+AWS_CLIENT_REQ_OPEN_WINDOW = 1
+AWS_CLIENT_REQ_CLOSE_WINDOW = 2
+AWS_CLIENT_REQ_COPY_FLIP_BUFFER = 3
+AWS_CLIENT_RES_OPEN_WINDOW_FAIL = 4
+AWS_CLIENT_RES_OPEN_WINDOW_SUCCESS = 5
+AWS_CLIENT_EVENT_CLOSE_WINDOW = 6
+
+# Kan stänga klientanslutningen när som helst, vilket resettar allt state.
+
+def process_drv_data(msg):
+    cmd = msg[0]
+    if cmd == AWS_RES_OPEN_WINDOW_FAIL:
+        wid = msg[1]
+        if wid in windows:
+            w = windows[wid]
+            c = w.client
+            c.send(struct.pack('=BH', AWS_CLIENT_RES_OPEN_WINDOW_FAIL, w.cwid))
+            del c.windows[w.cwid]
+            del windows[w.wid]
+    elif cmd == AWS_RES_OPEN_WINDOW_SUCCESS:
+        wid = msg[1]
+        if wid in windows:
+            w = windows[wid]
+            ba, width, height, depth = struct.unpack('>IHHH', msg[2:12])
+            w.buffer_address = ba
+            c = w.client
+            c.send(struct.pack('=BHHHH', AWS_CLIENT_RES_OPEN_WINDOW_SUCCESS, w.cwid, width, height, depth))
+    elif cmd == AWS_EVENT_CLOSE_WINDOW:
+        wid = msg[1]
+        if wid in windows:
+            w = windows[wid]
+            c = w.client
+            c.send(struct.pack('=BH', AWS_CLIENT_EVENT_CLOSE_WINDOW, w.cwid))
+
+def process_write_mem_res():
+    wid = write_mem_reqs.pop(0)
+    if wid in windows:
+        send_data(drv, current_stream_id, struct.pack('>BB', AWS_REQ_FLIP_BUFFER, wid))
+
+def process_client_msg(c, msg):
+    cmd = msg[0]
+    if cmd == AWS_CLIENT_REQ_OPEN_WINDOW:
+        cwid, left, top, width, height = struct.unpack('=HHHHH', msg[1:11])
+        title = msg[11:]
+        w = Window(get_next_wid(), cwid, c)
+        c.windows[w.cwid] = w
+        windows[w.wid] = w
+        send_data(drv, current_stream_id, struct.pack('>BBHHHH', AWS_REQ_OPEN_WINDOW, w.wid, left, top, width, height) + title)
+    elif cmd == AWS_CLIENT_REQ_CLOSE_WINDOW:
+        cwid = struct.unpack('=H', msg[1:3])[0]
+        # TODO: Probably close connection to client if receives an invalid request?
+        if cwid in c.windows:
+            w = c.windows[cwid]
+            send_data(drv, current_stream_id, struct.pack('>BB', AWS_REQ_CLOSE_WINDOW, w.wid))
+            del c.windows[w.cwid]
+            del windows[w.wid]
+    elif cmd == AWS_CLIENT_REQ_COPY_FLIP_BUFFER:
+        cwid = struct.unpack('=H', msg[1:3])[0]
+        if cwid in c.windows:
+            w = c.windows[cwid]
+            write_mem_reqs.append(w.wid)
+            send_write_mem_req(drv, w.buffer_address, msg[3:])
+
+def process_client_readable(c):
+    buf = c.sock.recv(128*1024)
+    if not buf:
+        logger.info('Client disconnected')
+        for w in c.windows.values():
+            send_data(drv, current_stream_id, struct.pack('>BB', AWS_REQ_CLOSE_WINDOW, w.wid))
+            del windows[w.wid]
+
+        c.sock.shutdown(socket.SHUT_RDWR)
+        c.sock.close()
+        clients.remove(c)
+        return
+
+    c.rbuf = c.rbuf + buf if c.rbuf else buf
+
+    while c.rbuf:
+        blen = len(c.rbuf)
+        if blen < 4:
+            break
+
+        plen = struct.unpack('=I', c.rbuf[:4])[0]
+        if blen < 4 + plen:
+            break
+
+        payload = c.rbuf[4:4+plen]
+        c.rbuf = None if blen == 4+plen else c.rbuf[4+plen:]
+
+        process_client_msg(c, payload)
+
+def process_incoming_connection():
+    sock, _ = server_socket.accept()
+    logger.info('Accepted client connection')
+    if current_stream_id is None:
+        sock.close()
+    else:
+        clients.append(Client(sock))
+
+def process_drv_msg(stream_id, ptype, payload):
+    global current_stream_id
+
+    if ptype == MSG_CONNECT:
+        if payload == SERVICE_NAME and current_stream_id is None:
+            logger.info('Amiga connected')
+            current_stream_id = stream_id
+            send_connect_response(drv, stream_id, 0)
+        else:
+            send_connect_response(drv, stream_id, 3)
+    elif ptype == MSG_WRITE_MEM_RES:
+        process_write_mem_res()
+    elif current_stream_id == stream_id:
+        if ptype == MSG_DATA:
+            process_drv_data(payload)
+        elif ptype == MSG_RESET:
+            current_stream_id = None
+            logger.info('Amiga disconnected')
+
+def process_drv_readable():
+    global done, rbuf
+
+    buf = drv.recv(1024)
+    if not buf:
+        done = True
+        return
+
+    rbuf += buf
+    while True:
+        if len(rbuf) < 9:
+            break
+
+        (plen, stream_id, ptype) = struct.unpack('=IIB', rbuf[:9])
+        if len(rbuf) < 9 + plen:
+            break
+
+        payload = rbuf[9:9+plen]
+        rbuf = rbuf[9+plen:]
+
+        process_drv_msg(stream_id, ptype, payload)
+
+try:
+    idx = sys.argv.index('-ondemand')
+except ValueError:
+    idx = -1
+
+if idx != -1:
+    fd = int(sys.argv[idx + 1])
+    drv = socket.socket(fileno=fd)
+else:
+    drv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+    drv.connect(('localhost', 7110))
+    drv.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
+
+    send_register_req(drv, SERVICE_NAME)
+    _, _, payload = wait_for_msg(drv)
+    if payload[0] != 1:
+        logger.error("Unable to register 'aws' with a314d, shutting down")
+        done = True
+
+if not done:
+    try:
+        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+        server_socket.bind(('localhost', 18377))
+        server_socket.listen()
+    except:
+        logger.error('Unable to bind server socket to TCP port localhost:18377')
+        done = True
+
+if not done:
+    logger.info('awsproxy is running')
+
+while not done:
+    try:
+        rl = [drv, server_socket] + clients
+        rl, _, _ = select.select(rl, [], [], 10.0)
+    except KeyboardInterrupt:
+        rl = []
+        done = True
+
+    for sock in rl:
+        if sock == drv:
+            process_drv_readable()
+        elif sock == server_socket:
+            process_incoming_connection()
+        else:
+            process_client_readable(sock)
+
+for c in clients:
+    # No need to close windows, as they will all be closed when stream is reset.
+    c.sock.shutdown(socket.SHUT_RDWR)
+    c.sock.close()
+
+if server_socket:
+    server_socket.close()
+    server_socket = None
+
+if drv:
+    if current_stream_id is not None:
+        send_reset(drv, current_stream_id)
+    drv.close()
+    drv = None
+
+logger.info('awsproxy stopped')
diff --git a/Software/aws/build.bat b/Software/aws/build.bat
new file mode 100644
index 0000000..d1fefbd
--- /dev/null
+++ b/Software/aws/build.bat
@@ -0,0 +1 @@
+vc aws.c -O3 -lamiga -o aws
-- 
2.47.3

