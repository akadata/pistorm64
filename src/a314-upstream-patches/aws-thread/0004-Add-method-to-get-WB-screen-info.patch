From 4f64b357a74b2107ea30a8fbfc747d86737f7da7 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Niklas=20Ekstr=C3=B6m?= <mail@niklasekstrom.nu>
Date: Thu, 7 Jan 2021 11:24:14 +0100
Subject: [PATCH 4/6] Add method to get WB screen info

Currently the width, height, depth and palette is returned.

diff --git a/Software/aws/app.py b/Software/aws/app.py
index 219c144..2493b4b 100644
--- a/Software/aws/app.py
+++ b/Software/aws/app.py
@@ -13,12 +13,17 @@ window_sizes = {}
 
 class ConnectionCallbacks(object):
     # Take care as these callbacks are executed in a separate thread!
+
+    # There is currently no synchronization in awslib,
+    # so you should not invoke connection methods on this thread.
+
     # An option is to forward the notification to the main thread through a queue or socketpair.
     def connection_closed(self, conn):
         print('Connection closed')
 
     def event_close_window(self, conn, wid):
         print('Close button clicked for window {}'.format(wid))
+        # TODO: Close window, but not on this thread.
 
 conn = awslib.connect(ConnectionCallbacks())
 if conn is None:
@@ -27,6 +32,7 @@ if conn is None:
 
 def print_help():
     print("Possible commands:")
+    print("  info")
     print("  open <x> <y> <w> <h> <title>")
     print("  close <wid>")
     print("  flip <wid>")
@@ -34,7 +40,7 @@ def print_help():
     print("  quit")
 
 print("Connected to AWS")
-print("Enter command (open/close/flip/help/quit):")
+print("Enter command (info/open/close/flip/help/quit):")
 
 while True:
     arr = sys.stdin.readline().strip().split()
@@ -44,6 +50,11 @@ while True:
             break
         elif arr[0] == 'help':
             print_help()
+        elif arr[0] == 'info':
+            w, h, d, pal = conn.get_wb_screen_info()
+            print('Screen info:')
+            print('  width={}, height={}, depth={}'.format(w, h, d))
+            print('  palette={}'.format([('%04x' % c) for c in pal]))
         elif arr[0] == 'open':
             x, y, w, h = int(arr[1]), int(arr[2]), int(arr[3]), int(arr[4])
             title = ' '.join(arr[5:])
diff --git a/Software/aws/aws.c b/Software/aws/aws.c
index 4c00e8e..c315421 100644
--- a/Software/aws/aws.c
+++ b/Software/aws/aws.c
@@ -31,6 +31,8 @@
 #define AWS_RES_OPEN_WINDOW_FAIL 4
 #define AWS_RES_OPEN_WINDOW_SUCCESS 5
 #define AWS_EVENT_CLOSE_WINDOW 6
+#define AWS_REQ_WB_SCREEN_INFO 7
+#define AWS_RES_WB_SCREEN_INFO 8
 
 struct WindowInfo
 {
@@ -288,6 +290,42 @@ static void handle_req_flip_buffer()
 		redraw_window(wi);
 }
 
+static struct Screen *find_wb_screen()
+{
+	struct Screen *screen = IntuitionBase->FirstScreen;
+	while (screen)
+	{
+		if ((screen->Flags & SCREENTYPE) == WBENCHSCREEN)
+			return screen;
+		screen = screen->NextScreen;
+	}
+	return NULL;
+}
+
+static void handle_req_wb_screen_info()
+{
+	struct Screen *screen = find_wb_screen();
+
+	wait_a314_write_complete();
+
+	awbuf[0] = AWS_RES_WB_SCREEN_INFO;
+	awbuf[1] = 0;
+
+	UWORD *p = (UWORD *)&awbuf[2];
+	*p++ = screen->Width;
+	*p++ = screen->Height;
+	*p++ = screen->BitMap.Depth;
+
+	struct ColorMap *cm = screen->ViewPort.ColorMap;
+	int n = 1 << screen->BitMap.Depth;
+	if (n > cm->Count)
+		n = cm->Count;
+	for (int i = 0; i < n; i++)
+		*p++ = ((UWORD *)cm->ColorTable)[i] & 0xfff;
+
+	start_a314_write((UBYTE *)p - awbuf);
+}
+
 static void handle_intui_message(struct IntuiMessage *im)
 {
 	ULONG class = im->Class;
@@ -332,6 +370,9 @@ static void handle_a314_read_completed()
 			case AWS_REQ_FLIP_BUFFER:
 				handle_req_flip_buffer();
 				break;
+			case AWS_REQ_WB_SCREEN_INFO:
+				handle_req_wb_screen_info();
+				break;
 		}
 
 		start_a314_read();
diff --git a/Software/aws/awslib.py b/Software/aws/awslib.py
index df90b6b..598b75b 100644
--- a/Software/aws/awslib.py
+++ b/Software/aws/awslib.py
@@ -25,6 +25,8 @@ AWS_CLIENT_REQ_COPY_FLIP_BUFFER = 3
 AWS_CLIENT_RES_OPEN_WINDOW_FAIL = 4
 AWS_CLIENT_RES_OPEN_WINDOW_SUCCESS = 5
 AWS_CLIENT_EVENT_CLOSE_WINDOW = 6
+AWS_CLIENT_REQ_WB_SCREEN_INFO = 7
+AWS_CLIENT_RES_WB_SCREEN_INFO = 8
 
 class Window(object):
     def __init__(self, wid):
@@ -66,12 +68,8 @@ class Connection(threading.Thread):
 
     def process_msg(self, msg):
         cmd = msg[0]
-        if cmd == AWS_CLIENT_RES_OPEN_WINDOW_FAIL:
-            wid = struct.unpack('=H', msg[1:3])[0]
-            self.sync_queue.put(None)
-        elif cmd == AWS_CLIENT_RES_OPEN_WINDOW_SUCCESS:
-            wid, width, height, depth = struct.unpack('=HHHH', msg[1:9])
-            self.sync_queue.put((width, height, depth))
+        if cmd in [AWS_CLIENT_RES_OPEN_WINDOW_FAIL, AWS_CLIENT_RES_OPEN_WINDOW_SUCCESS, AWS_CLIENT_RES_WB_SCREEN_INFO]:
+            self.sync_queue.put(msg)
         elif cmd == AWS_CLIENT_EVENT_CLOSE_WINDOW:
             wid = struct.unpack('=H', msg[1:3])[0]
             self.callbacks.event_close_window(self, wid)
@@ -97,6 +95,16 @@ class Connection(threading.Thread):
 
         return True
 
+    def get_wb_screen_info(self):
+        self.send(bytes([AWS_CLIENT_REQ_WB_SCREEN_INFO]))
+        msg = self.sync_queue.get()
+        if msg is None:
+            raise RuntimeError('Connection failed')
+        w, h, d = struct.unpack('=HHH', msg[1:7])
+        pal = msg[7:]
+        pal = [struct.unpack('=H', pal[2*i:2*(i+1)])[0] for i in range(len(pal) // 2)]
+        return (w, h, d, pal)
+
     def open_window(self, left, top, width, height, title):
         if not self.is_open:
             return None, None
@@ -107,14 +115,21 @@ class Connection(threading.Thread):
         self.next_wid = (wid + 1) % 65536
         self.windows[wid] = Window(wid)
         self.send(struct.pack('=BHHHHH', AWS_CLIENT_REQ_OPEN_WINDOW, wid, left, top, width, height) + title.encode('latin-1'))
-        size = self.sync_queue.get()
-        if not size:
+        msg = self.sync_queue.get()
+        if not msg:
+            raise RuntimeError('Connection failed')
+
+        cmd = msg[0]
+        if cmd == AWS_CLIENT_RES_OPEN_WINDOW_FAIL:
+            #wid = struct.unpack('=H', msg[1:3])[0]
             del self.windows[wid]
             return None, None
-        else:
+        elif cmd == AWS_CLIENT_RES_OPEN_WINDOW_SUCCESS:
             w = self.windows[wid]
-            w.width, w.height, w.depth = size
-            return wid, size
+            _, w.width, w.height, w.depth = struct.unpack('=HHHH', msg[1:9])
+            return w.wid, (w.width, w.height, w.depth)
+        else:
+            raise RuntimeError('Invalid response')
 
     def close_window(self, wid):
         if not self.is_open or wid not in self.windows:
diff --git a/Software/aws/awsproxy.py b/Software/aws/awsproxy.py
index 80e8ca2..ef29809 100644
--- a/Software/aws/awsproxy.py
+++ b/Software/aws/awsproxy.py
@@ -104,6 +104,7 @@ class Client(object):
         self.sock = sock
         self.rbuf = None
         self.windows = {} # cwid -> window object.
+        self.waiting_for_wb_screen_info = False
 
     def send(self, data):
         data = struct.pack('=I', len(data)) + data
@@ -141,6 +142,8 @@ AWS_REQ_FLIP_BUFFER = 3
 AWS_RES_OPEN_WINDOW_FAIL = 4
 AWS_RES_OPEN_WINDOW_SUCCESS = 5
 AWS_EVENT_CLOSE_WINDOW = 6
+AWS_REQ_WB_SCREEN_INFO = 7
+AWS_RES_WB_SCREEN_INFO = 8
 
 # Definiera de olika meddelandena som går mellan klient och awsproxy.
 AWS_CLIENT_REQ_OPEN_WINDOW = 1
@@ -149,6 +152,8 @@ AWS_CLIENT_REQ_COPY_FLIP_BUFFER = 3
 AWS_CLIENT_RES_OPEN_WINDOW_FAIL = 4
 AWS_CLIENT_RES_OPEN_WINDOW_SUCCESS = 5
 AWS_CLIENT_EVENT_CLOSE_WINDOW = 6
+AWS_CLIENT_REQ_WB_SCREEN_INFO = 7
+AWS_CLIENT_RES_WB_SCREEN_INFO = 8
 
 # Kan stänga klientanslutningen när som helst, vilket resettar allt state.
 
@@ -176,6 +181,16 @@ def process_drv_data(msg):
             w = windows[wid]
             c = w.client
             c.send(struct.pack('=BH', AWS_CLIENT_EVENT_CLOSE_WINDOW, w.cwid))
+    elif cmd == AWS_RES_WB_SCREEN_INFO:
+        width, height, depth = struct.unpack('>HHH', msg[2:8])
+        pal = list(msg[8:])
+        for i in range(len(pal) // 2):
+            pal[2*i], pal[2*i + 1] = pal[2*i + 1], pal[2*i]
+        pal = bytes(pal)
+        for c in clients:
+            if c.waiting_for_wb_screen_info:
+                c.send(struct.pack('=BHHH', AWS_CLIENT_RES_WB_SCREEN_INFO, width, height, depth) + pal)
+                c.waiting_for_wb_screen_info = False
 
 def process_write_mem_res():
     wid = write_mem_reqs.pop(0)
@@ -205,6 +220,9 @@ def process_client_msg(c, msg):
             w = c.windows[cwid]
             write_mem_reqs.append(w.wid)
             send_write_mem_req(drv, w.buffer_address, msg[3:])
+    elif cmd == AWS_CLIENT_REQ_WB_SCREEN_INFO:
+        c.waiting_for_wb_screen_info = True
+        send_data(drv, current_stream_id, bytes([AWS_REQ_WB_SCREEN_INFO]))
 
 def process_client_readable(c):
     buf = c.sock.recv(128*1024)
-- 
2.47.3

